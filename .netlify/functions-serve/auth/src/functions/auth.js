var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/depd/lib/compat/callsite-tostring.js
var require_callsite_tostring = __commonJS({
  "node_modules/depd/lib/compat/callsite-tostring.js"(exports2, module2) {
    "use strict";
    module2.exports = callSiteToString2;
    function callSiteFileLocation(callSite) {
      var fileName;
      var fileLocation = "";
      if (callSite.isNative()) {
        fileLocation = "native";
      } else if (callSite.isEval()) {
        fileName = callSite.getScriptNameOrSourceURL();
        if (!fileName) {
          fileLocation = callSite.getEvalOrigin();
        }
      } else {
        fileName = callSite.getFileName();
      }
      if (fileName) {
        fileLocation += fileName;
        var lineNumber = callSite.getLineNumber();
        if (lineNumber != null) {
          fileLocation += ":" + lineNumber;
          var columnNumber = callSite.getColumnNumber();
          if (columnNumber) {
            fileLocation += ":" + columnNumber;
          }
        }
      }
      return fileLocation || "unknown source";
    }
    function callSiteToString2(callSite) {
      var addSuffix = true;
      var fileLocation = callSiteFileLocation(callSite);
      var functionName = callSite.getFunctionName();
      var isConstructor = callSite.isConstructor();
      var isMethodCall = !(callSite.isToplevel() || isConstructor);
      var line = "";
      if (isMethodCall) {
        var methodName = callSite.getMethodName();
        var typeName = getConstructorName(callSite);
        if (functionName) {
          if (typeName && functionName.indexOf(typeName) !== 0) {
            line += typeName + ".";
          }
          line += functionName;
          if (methodName && functionName.lastIndexOf("." + methodName) !== functionName.length - methodName.length - 1) {
            line += " [as " + methodName + "]";
          }
        } else {
          line += typeName + "." + (methodName || "<anonymous>");
        }
      } else if (isConstructor) {
        line += "new " + (functionName || "<anonymous>");
      } else if (functionName) {
        line += functionName;
      } else {
        addSuffix = false;
        line += fileLocation;
      }
      if (addSuffix) {
        line += " (" + fileLocation + ")";
      }
      return line;
    }
    function getConstructorName(obj) {
      var receiver = obj.receiver;
      return receiver.constructor && receiver.constructor.name || null;
    }
  }
});

// node_modules/depd/lib/compat/event-listener-count.js
var require_event_listener_count = __commonJS({
  "node_modules/depd/lib/compat/event-listener-count.js"(exports2, module2) {
    "use strict";
    module2.exports = eventListenerCount2;
    function eventListenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    }
  }
});

// node_modules/depd/lib/compat/index.js
var require_compat = __commonJS({
  "node_modules/depd/lib/compat/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    lazyProperty(module2.exports, "callSiteToString", function callSiteToString2() {
      var limit = Error.stackTraceLimit;
      var obj = {};
      var prep = Error.prepareStackTrace;
      function prepareObjectStackTrace2(obj2, stack2) {
        return stack2;
      }
      Error.prepareStackTrace = prepareObjectStackTrace2;
      Error.stackTraceLimit = 2;
      Error.captureStackTrace(obj);
      var stack = obj.stack.slice();
      Error.prepareStackTrace = prep;
      Error.stackTraceLimit = limit;
      return stack[0].toString ? toString : require_callsite_tostring();
    });
    lazyProperty(module2.exports, "eventListenerCount", function eventListenerCount2() {
      return EventEmitter.listenerCount || require_event_listener_count();
    });
    function lazyProperty(obj, prop, getter) {
      function get() {
        var val = getter();
        Object.defineProperty(obj, prop, {
          configurable: true,
          enumerable: true,
          value: val
        });
        return val;
      }
      Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: true,
        get
      });
    }
    function toString(obj) {
      return obj.toString();
    }
  }
});

// node_modules/depd/index.js
var require_depd = __commonJS({
  "node_modules/depd/index.js"(exports, module) {
    var callSiteToString = require_compat().callSiteToString;
    var eventListenerCount = require_compat().eventListenerCount;
    var relative = require("path").relative;
    module.exports = depd;
    var basePath = process.cwd();
    function containsNamespace(str, namespace) {
      var vals = str.split(/[ ,]+/);
      var ns = String(namespace).toLowerCase();
      for (var i = 0; i < vals.length; i++) {
        var val = vals[i];
        if (val && (val === "*" || val.toLowerCase() === ns)) {
          return true;
        }
      }
      return false;
    }
    function convertDataDescriptorToAccessor(obj, prop, message) {
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      var value = descriptor.value;
      descriptor.get = function getter() {
        return value;
      };
      if (descriptor.writable) {
        descriptor.set = function setter(val) {
          return value = val;
        };
      }
      delete descriptor.value;
      delete descriptor.writable;
      Object.defineProperty(obj, prop, descriptor);
      return descriptor;
    }
    function createArgumentsString(arity) {
      var str = "";
      for (var i = 0; i < arity; i++) {
        str += ", arg" + i;
      }
      return str.substr(2);
    }
    function createStackString(stack) {
      var str = this.name + ": " + this.namespace;
      if (this.message) {
        str += " deprecated " + this.message;
      }
      for (var i = 0; i < stack.length; i++) {
        str += "\n    at " + callSiteToString(stack[i]);
      }
      return str;
    }
    function depd(namespace) {
      if (!namespace) {
        throw new TypeError("argument namespace is required");
      }
      var stack = getStack();
      var site = callSiteLocation(stack[1]);
      var file = site[0];
      function deprecate(message) {
        log.call(deprecate, message);
      }
      deprecate._file = file;
      deprecate._ignored = isignored(namespace);
      deprecate._namespace = namespace;
      deprecate._traced = istraced(namespace);
      deprecate._warned = Object.create(null);
      deprecate.function = wrapfunction;
      deprecate.property = wrapproperty;
      return deprecate;
    }
    function isignored(namespace) {
      if (process.noDeprecation) {
        return true;
      }
      var str = process.env.NO_DEPRECATION || "";
      return containsNamespace(str, namespace);
    }
    function istraced(namespace) {
      if (process.traceDeprecation) {
        return true;
      }
      var str = process.env.TRACE_DEPRECATION || "";
      return containsNamespace(str, namespace);
    }
    function log(message, site) {
      var haslisteners = eventListenerCount(process, "deprecation") !== 0;
      if (!haslisteners && this._ignored) {
        return;
      }
      var caller;
      var callFile;
      var callSite;
      var depSite;
      var i = 0;
      var seen = false;
      var stack = getStack();
      var file = this._file;
      if (site) {
        depSite = site;
        callSite = callSiteLocation(stack[1]);
        callSite.name = depSite.name;
        file = callSite[0];
      } else {
        i = 2;
        depSite = callSiteLocation(stack[i]);
        callSite = depSite;
      }
      for (; i < stack.length; i++) {
        caller = callSiteLocation(stack[i]);
        callFile = caller[0];
        if (callFile === file) {
          seen = true;
        } else if (callFile === this._file) {
          file = this._file;
        } else if (seen) {
          break;
        }
      }
      var key = caller ? depSite.join(":") + "__" + caller.join(":") : void 0;
      if (key !== void 0 && key in this._warned) {
        return;
      }
      this._warned[key] = true;
      var msg = message;
      if (!msg) {
        msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
      }
      if (haslisteners) {
        var err = DeprecationError(this._namespace, msg, stack.slice(i));
        process.emit("deprecation", err);
        return;
      }
      var format = process.stderr.isTTY ? formatColor : formatPlain;
      var output = format.call(this, msg, caller, stack.slice(i));
      process.stderr.write(output + "\n", "utf8");
    }
    function callSiteLocation(callSite) {
      var file = callSite.getFileName() || "<anonymous>";
      var line = callSite.getLineNumber();
      var colm = callSite.getColumnNumber();
      if (callSite.isEval()) {
        file = callSite.getEvalOrigin() + ", " + file;
      }
      var site = [file, line, colm];
      site.callSite = callSite;
      site.name = callSite.getFunctionName();
      return site;
    }
    function defaultMessage(site) {
      var callSite = site.callSite;
      var funcName = site.name;
      if (!funcName) {
        funcName = "<anonymous@" + formatLocation(site) + ">";
      }
      var context = callSite.getThis();
      var typeName = context && callSite.getTypeName();
      if (typeName === "Object") {
        typeName = void 0;
      }
      if (typeName === "Function") {
        typeName = context.name || typeName;
      }
      return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
    }
    function formatPlain(msg, caller, stack) {
      var timestamp = new Date().toUTCString();
      var formatted = timestamp + " " + this._namespace + " deprecated " + msg;
      if (this._traced) {
        for (var i = 0; i < stack.length; i++) {
          formatted += "\n    at " + callSiteToString(stack[i]);
        }
        return formatted;
      }
      if (caller) {
        formatted += " at " + formatLocation(caller);
      }
      return formatted;
    }
    function formatColor(msg, caller, stack) {
      var formatted = "[36;1m" + this._namespace + "[22;39m [33;1mdeprecated[22;39m [0m" + msg + "[39m";
      if (this._traced) {
        for (var i = 0; i < stack.length; i++) {
          formatted += "\n    [36mat " + callSiteToString(stack[i]) + "[39m";
        }
        return formatted;
      }
      if (caller) {
        formatted += " [36m" + formatLocation(caller) + "[39m";
      }
      return formatted;
    }
    function formatLocation(callSite) {
      return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
    }
    function getStack() {
      var limit = Error.stackTraceLimit;
      var obj = {};
      var prep = Error.prepareStackTrace;
      Error.prepareStackTrace = prepareObjectStackTrace;
      Error.stackTraceLimit = Math.max(10, limit);
      Error.captureStackTrace(obj);
      var stack = obj.stack.slice(1);
      Error.prepareStackTrace = prep;
      Error.stackTraceLimit = limit;
      return stack;
    }
    function prepareObjectStackTrace(obj, stack) {
      return stack;
    }
    function wrapfunction(fn, message) {
      if (typeof fn !== "function") {
        throw new TypeError("argument fn must be a function");
      }
      var args = createArgumentsString(fn.length);
      var deprecate = this;
      var stack = getStack();
      var site = callSiteLocation(stack[1]);
      site.name = fn.name;
      var deprecatedfn = eval("(function (" + args + ') {\n"use strict"\nlog.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n})');
      return deprecatedfn;
    }
    function wrapproperty(obj, prop, message) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("argument obj must be object");
      }
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      if (!descriptor) {
        throw new TypeError("must call property on owner object");
      }
      if (!descriptor.configurable) {
        throw new TypeError("property must be configurable");
      }
      var deprecate = this;
      var stack = getStack();
      var site = callSiteLocation(stack[1]);
      site.name = prop;
      if ("value" in descriptor) {
        descriptor = convertDataDescriptorToAccessor(obj, prop, message);
      }
      var get = descriptor.get;
      var set = descriptor.set;
      if (typeof get === "function") {
        descriptor.get = function getter() {
          log.call(deprecate, message, site);
          return get.apply(this, arguments);
        };
      }
      if (typeof set === "function") {
        descriptor.set = function setter() {
          log.call(deprecate, message, site);
          return set.apply(this, arguments);
        };
      }
      Object.defineProperty(obj, prop, descriptor);
    }
    function DeprecationError(namespace, message, stack) {
      var error = new Error();
      var stackString;
      Object.defineProperty(error, "constructor", {
        value: DeprecationError
      });
      Object.defineProperty(error, "message", {
        configurable: true,
        enumerable: false,
        value: message,
        writable: true
      });
      Object.defineProperty(error, "name", {
        enumerable: false,
        configurable: true,
        value: "DeprecationError",
        writable: true
      });
      Object.defineProperty(error, "namespace", {
        configurable: true,
        enumerable: false,
        value: namespace,
        writable: true
      });
      Object.defineProperty(error, "stack", {
        configurable: true,
        enumerable: false,
        get: function() {
          if (stackString !== void 0) {
            return stackString;
          }
          return stackString = createStackString.call(this, stack);
        },
        set: function setter(val) {
          stackString = val;
        }
      });
      return error;
    }
  }
});

// node_modules/bytes/index.js
var require_bytes = __commonJS({
  "node_modules/bytes/index.js"(exports2, module2) {
    "use strict";
    module2.exports = bytes;
    module2.exports.format = format;
    module2.exports.parse = parse;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes(value, options) {
      if (typeof value === "string") {
        return parse(value);
      }
      if (typeof value === "number") {
        return format(value, options);
      }
      return null;
    }
    function format(value, options) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.pb) {
          unit = "PB";
        } else if (mag >= map.tb) {
          unit = "TB";
        } else if (mag >= map.gb) {
          unit = "GB";
        } else if (mag >= map.mb) {
          unit = "MB";
        } else if (mag >= map.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.replace(formatThousandsRegExp, thousandsSeparator);
      }
      return str + unitSeparator + unit;
    }
    function parse(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      return Math.floor(map[unit] * floatValue);
    }
  }
});

// node_modules/content-type/index.js
var require_content_type = __commonJS({
  "node_modules/content-type/index.js"(exports2) {
    "use strict";
    var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
    var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    exports2.format = format;
    exports2.parse = parse;
    function format(obj) {
      if (!obj || typeof obj !== "object") {
        throw new TypeError("argument obj is required");
      }
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || !TYPE_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string = type;
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          if (!TOKEN_REGEXP.test(param)) {
            throw new TypeError("invalid parameter name");
          }
          string += "; " + param + "=" + qstring(parameters[param]);
        }
      }
      return string;
    }
    function parse(string) {
      if (!string) {
        throw new TypeError("argument string is required");
      }
      var header = typeof string === "object" ? getcontenttype(string) : string;
      if (typeof header !== "string") {
        throw new TypeError("argument string is required to be a string");
      }
      var index = header.indexOf(";");
      var type = index !== -1 ? header.substr(0, index).trim() : header.trim();
      if (!TYPE_REGEXP.test(type)) {
        throw new TypeError("invalid media type");
      }
      var obj = new ContentType(type.toLowerCase());
      if (index !== -1) {
        var key;
        var match;
        var value;
        PARAM_REGEXP.lastIndex = index;
        while (match = PARAM_REGEXP.exec(header)) {
          if (match.index !== index) {
            throw new TypeError("invalid parameter format");
          }
          index += match[0].length;
          key = match[1].toLowerCase();
          value = match[2];
          if (value[0] === '"') {
            value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
          }
          obj.parameters[key] = value;
        }
        if (index !== header.length) {
          throw new TypeError("invalid parameter format");
        }
      }
      return obj;
    }
    function getcontenttype(obj) {
      var header;
      if (typeof obj.getHeader === "function") {
        header = obj.getHeader("content-type");
      } else if (typeof obj.headers === "object") {
        header = obj.headers && obj.headers["content-type"];
      }
      if (typeof header !== "string") {
        throw new TypeError("content-type header is missing from object");
      }
      return header;
    }
    function qstring(val) {
      var str = String(val);
      if (TOKEN_REGEXP.test(str)) {
        return str;
      }
      if (str.length > 0 && !TEXT_REGEXP.test(str)) {
        throw new TypeError("invalid parameter value");
      }
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ContentType(type) {
      this.parameters = Object.create(null);
      this.type = type;
    }
  }
});

// node_modules/setprototypeof/index.js
var require_setprototypeof = __commonJS({
  "node_modules/setprototypeof/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
    function setProtoOf(obj, proto) {
      obj.__proto__ = proto;
      return obj;
    }
    function mixinProperties(obj, proto) {
      for (var prop in proto) {
        if (!obj.hasOwnProperty(prop)) {
          obj[prop] = proto[prop];
        }
      }
      return obj;
    }
  }
});

// node_modules/statuses/codes.json
var require_codes = __commonJS({
  "node_modules/statuses/codes.json"(exports2, module2) {
    module2.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "306": "(Unused)",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Unordered Collection",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// node_modules/statuses/index.js
var require_statuses = __commonJS({
  "node_modules/statuses/index.js"(exports2, module2) {
    "use strict";
    var codes = require_codes();
    module2.exports = status;
    status.STATUS_CODES = codes;
    status.codes = populateStatusesMap(status, codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    function populateStatusesMap(statuses, codes2) {
      var arr = [];
      Object.keys(codes2).forEach(function forEachCode(code) {
        var message = codes2[code];
        var status2 = Number(code);
        statuses[status2] = message;
        statuses[message] = status2;
        statuses[message.toLowerCase()] = status2;
        arr.push(status2);
      });
      return arr;
    }
    function status(code) {
      if (typeof code === "number") {
        if (!status[code])
          throw new Error("invalid status code: " + code);
        return code;
      }
      if (typeof code !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n = parseInt(code, 10);
      if (!isNaN(n)) {
        if (!status[n])
          throw new Error("invalid status code: " + n);
        return n;
      }
      n = status[code.toLowerCase()];
      if (!n)
        throw new Error('invalid status message: "' + code + '"');
      return n;
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      module2.exports = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/toidentifier/index.js
var require_toidentifier = __commonJS({
  "node_modules/toidentifier/index.js"(exports2, module2) {
    module2.exports = toIdentifier;
    function toIdentifier(str) {
      return str.split(" ").map(function(token) {
        return token.slice(0, 1).toUpperCase() + token.slice(1);
      }).join("").replace(/[^ _0-9a-z]/gi, "");
    }
  }
});

// node_modules/http-errors/index.js
var require_http_errors = __commonJS({
  "node_modules/http-errors/index.js"(exports2, module2) {
    "use strict";
    var deprecate = require_depd()("http-errors");
    var setPrototypeOf = require_setprototypeof();
    var statuses = require_statuses();
    var inherits2 = require_inherits();
    var toIdentifier = require_toidentifier();
    module2.exports = createError;
    module2.exports.HttpError = createHttpErrorConstructor();
    populateConstructorExports(module2.exports, statuses.codes, module2.exports.HttpError);
    function codeClass(status) {
      return Number(String(status).charAt(0) + "00");
    }
    function createError() {
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
          continue;
        }
        switch (typeof arg) {
          case "string":
            msg = arg;
            break;
          case "number":
            status = arg;
            if (i !== 0) {
              deprecate("non-first-argument status code; replace with createError(" + arg + ", ...)");
            }
            break;
          case "object":
            props = arg;
            break;
        }
      }
      if (typeof status === "number" && (status < 400 || status >= 600)) {
        deprecate("non-error status code; use only 4xx or 5xx status codes");
      }
      if (typeof status !== "number" || !statuses[status] && (status < 400 || status >= 600)) {
        status = 500;
      }
      var HttpError = createError[status] || createError[codeClass(status)];
      if (!err) {
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses[status]);
        Error.captureStackTrace(err, createError);
      }
      if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        err.expose = status < 500;
        err.status = err.statusCode = status;
      }
      for (var key in props) {
        if (key !== "status" && key !== "statusCode") {
          err[key] = props[key];
        }
      }
      return err;
    }
    function createHttpErrorConstructor() {
      function HttpError() {
        throw new TypeError("cannot construct abstract class");
      }
      inherits2(HttpError, Error);
      return HttpError;
    }
    function createClientErrorConstructor(HttpError, name, code) {
      var className = name.match(/Error$/) ? name : name + "Error";
      function ClientError(message) {
        var msg = message != null ? message : statuses[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ClientError);
        setPrototypeOf(err, ClientError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits2(ClientError, HttpError);
      nameFunc(ClientError, className);
      ClientError.prototype.status = code;
      ClientError.prototype.statusCode = code;
      ClientError.prototype.expose = true;
      return ClientError;
    }
    function createServerErrorConstructor(HttpError, name, code) {
      var className = name.match(/Error$/) ? name : name + "Error";
      function ServerError(message) {
        var msg = message != null ? message : statuses[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ServerError);
        setPrototypeOf(err, ServerError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits2(ServerError, HttpError);
      nameFunc(ServerError, className);
      ServerError.prototype.status = code;
      ServerError.prototype.statusCode = code;
      ServerError.prototype.expose = false;
      return ServerError;
    }
    function nameFunc(func, name) {
      var desc = Object.getOwnPropertyDescriptor(func, "name");
      if (desc && desc.configurable) {
        desc.value = name;
        Object.defineProperty(func, "name", desc);
      }
    }
    function populateConstructorExports(exports3, codes, HttpError) {
      codes.forEach(function forEachCode(code) {
        var CodeError;
        var name = toIdentifier(statuses[code]);
        switch (codeClass(code)) {
          case 400:
            CodeError = createClientErrorConstructor(HttpError, name, code);
            break;
          case 500:
            CodeError = createServerErrorConstructor(HttpError, name, code);
            break;
        }
        if (CodeError) {
          exports3[code] = CodeError;
          exports3[name] = CodeError;
        }
      });
      exports3["I'mateapot"] = deprecate.function(exports3.ImATeapot, `"I'mateapot"; use "ImATeapot" instead`);
    }
  }
});

// node_modules/body-parser/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/body-parser/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/body-parser/node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/body-parser/node_modules/debug/src/debug.js"(exports2, module2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if (typeof formatter === "function") {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if (typeof exports2.init === "function") {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/body-parser/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/body-parser/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2 = module2.exports = require_debug();
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log2() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/body-parser/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/body-parser/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2 = module2.exports = require_debug();
    exports2.init = init;
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (fd !== 1 && fd !== 2) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  [3" + c + ";1m" + name + " [0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("[3" + c + "m+" + exports2.humanize(this.diff) + "[0m");
      } else {
        args[0] = new Date().toUTCString() + " " + name + " " + args[0];
      }
    }
    function log2() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (namespaces == null) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs = require("fs");
          stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require("net");
          stream2 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    exports2.enable(load());
  }
});

// node_modules/body-parser/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/body-parser/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports2, module2) {
    "use strict";
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key))
        continue;
      if (key === "SlowBuffer" || key === "Buffer")
        continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer2) {
      if (!Buffer2.hasOwnProperty(key))
        continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow")
        continue;
      Safer[key] = Buffer2[key];
    }
    safer.Buffer.prototype = Buffer2.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer2(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer2(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module2.exports = safer;
  }
});

// node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS({
  "node_modules/iconv-lite/lib/bom-handling.js"(exports2) {
    "use strict";
    var BOMChar = "\uFEFF";
    exports2.PrependBOM = PrependBOMWrapper;
    function PrependBOMWrapper(encoder, options) {
      this.encoder = encoder;
      this.addBOM = true;
    }
    PrependBOMWrapper.prototype.write = function(str) {
      if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
      }
      return this.encoder.write(str);
    };
    PrependBOMWrapper.prototype.end = function() {
      return this.encoder.end();
    };
    exports2.StripBOM = StripBOMWrapper;
    function StripBOMWrapper(decoder, options) {
      this.decoder = decoder;
      this.pass = false;
      this.options = options || {};
    }
    StripBOMWrapper.prototype.write = function(buf) {
      var res = this.decoder.write(buf);
      if (this.pass || !res)
        return res;
      if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === "function")
          this.options.stripBOM();
      }
      this.pass = true;
      return res;
    };
    StripBOMWrapper.prototype.end = function() {
      return this.decoder.end();
    };
  }
});

// node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS({
  "node_modules/iconv-lite/encodings/internal.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    module2.exports = {
      utf8: { type: "_internal", bomAware: true },
      cesu8: { type: "_internal", bomAware: true },
      unicode11utf8: "utf8",
      ucs2: { type: "_internal", bomAware: true },
      utf16le: "ucs2",
      binary: { type: "_internal" },
      base64: { type: "_internal" },
      hex: { type: "_internal" },
      _internal: InternalCodec
    };
    function InternalCodec(codecOptions, iconv) {
      this.enc = codecOptions.encodingName;
      this.bomAware = codecOptions.bomAware;
      if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
      else if (this.enc === "cesu8") {
        this.enc = "utf8";
        this.encoder = InternalEncoderCesu8;
        if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "\u{1F4A9}") {
          this.decoder = InternalDecoderCesu8;
          this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
      }
    }
    InternalCodec.prototype.encoder = InternalEncoder;
    InternalCodec.prototype.decoder = InternalDecoder;
    var StringDecoder = require("string_decoder").StringDecoder;
    if (!StringDecoder.prototype.end)
      StringDecoder.prototype.end = function() {
      };
    function InternalDecoder(options, codec) {
      StringDecoder.call(this, codec.enc);
    }
    InternalDecoder.prototype = StringDecoder.prototype;
    function InternalEncoder(options, codec) {
      this.enc = codec.enc;
    }
    InternalEncoder.prototype.write = function(str) {
      return Buffer2.from(str, this.enc);
    };
    InternalEncoder.prototype.end = function() {
    };
    function InternalEncoderBase64(options, codec) {
      this.prevStr = "";
    }
    InternalEncoderBase64.prototype.write = function(str) {
      str = this.prevStr + str;
      var completeQuads = str.length - str.length % 4;
      this.prevStr = str.slice(completeQuads);
      str = str.slice(0, completeQuads);
      return Buffer2.from(str, "base64");
    };
    InternalEncoderBase64.prototype.end = function() {
      return Buffer2.from(this.prevStr, "base64");
    };
    function InternalEncoderCesu8(options, codec) {
    }
    InternalEncoderCesu8.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
      for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (charCode < 128)
          buf[bufIdx++] = charCode;
        else if (charCode < 2048) {
          buf[bufIdx++] = 192 + (charCode >>> 6);
          buf[bufIdx++] = 128 + (charCode & 63);
        } else {
          buf[bufIdx++] = 224 + (charCode >>> 12);
          buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
          buf[bufIdx++] = 128 + (charCode & 63);
        }
      }
      return buf.slice(0, bufIdx);
    };
    InternalEncoderCesu8.prototype.end = function() {
    };
    function InternalDecoderCesu8(options, codec) {
      this.acc = 0;
      this.contBytes = 0;
      this.accBytes = 0;
      this.defaultCharUnicode = codec.defaultCharUnicode;
    }
    InternalDecoderCesu8.prototype.write = function(buf) {
      var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
      for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 192) !== 128) {
          if (contBytes > 0) {
            res += this.defaultCharUnicode;
            contBytes = 0;
          }
          if (curByte < 128) {
            res += String.fromCharCode(curByte);
          } else if (curByte < 224) {
            acc = curByte & 31;
            contBytes = 1;
            accBytes = 1;
          } else if (curByte < 240) {
            acc = curByte & 15;
            contBytes = 2;
            accBytes = 1;
          } else {
            res += this.defaultCharUnicode;
          }
        } else {
          if (contBytes > 0) {
            acc = acc << 6 | curByte & 63;
            contBytes--;
            accBytes++;
            if (contBytes === 0) {
              if (accBytes === 2 && acc < 128 && acc > 0)
                res += this.defaultCharUnicode;
              else if (accBytes === 3 && acc < 2048)
                res += this.defaultCharUnicode;
              else
                res += String.fromCharCode(acc);
            }
          } else {
            res += this.defaultCharUnicode;
          }
        }
      }
      this.acc = acc;
      this.contBytes = contBytes;
      this.accBytes = accBytes;
      return res;
    };
    InternalDecoderCesu8.prototype.end = function() {
      var res = 0;
      if (this.contBytes > 0)
        res += this.defaultCharUnicode;
      return res;
    };
  }
});

// node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS({
  "node_modules/iconv-lite/encodings/utf16.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2.utf16be = Utf16BECodec;
    function Utf16BECodec() {
    }
    Utf16BECodec.prototype.encoder = Utf16BEEncoder;
    Utf16BECodec.prototype.decoder = Utf16BEDecoder;
    Utf16BECodec.prototype.bomAware = true;
    function Utf16BEEncoder() {
    }
    Utf16BEEncoder.prototype.write = function(str) {
      var buf = Buffer2.from(str, "ucs2");
      for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i];
        buf[i] = buf[i + 1];
        buf[i + 1] = tmp;
      }
      return buf;
    };
    Utf16BEEncoder.prototype.end = function() {
    };
    function Utf16BEDecoder() {
      this.overflowByte = -1;
    }
    Utf16BEDecoder.prototype.write = function(buf) {
      if (buf.length == 0)
        return "";
      var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
      if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1;
        j = 2;
      }
      for (; i < buf.length - 1; i += 2, j += 2) {
        buf2[j] = buf[i + 1];
        buf2[j + 1] = buf[i];
      }
      this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
      return buf2.slice(0, j).toString("ucs2");
    };
    Utf16BEDecoder.prototype.end = function() {
    };
    exports2.utf16 = Utf16Codec;
    function Utf16Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf16Codec.prototype.encoder = Utf16Encoder;
    Utf16Codec.prototype.decoder = Utf16Decoder;
    function Utf16Encoder(options, codec) {
      options = options || {};
      if (options.addBOM === void 0)
        options.addBOM = true;
      this.encoder = codec.iconv.getEncoder("utf-16le", options);
    }
    Utf16Encoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf16Encoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf16Decoder(options, codec) {
      this.decoder = null;
      this.initialBytes = [];
      this.initialBytesLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf16Decoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;
        if (this.initialBytesLen < 16)
          return "";
        var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        this.initialBytes.length = this.initialBytesLen = 0;
      }
      return this.decoder.write(buf);
    };
    Utf16Decoder.prototype.end = function() {
      if (!this.decoder) {
        var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var res = this.decoder.write(buf), trail = this.decoder.end();
        return trail ? res + trail : res;
      }
      return this.decoder.end();
    };
    function detectEncoding(buf, defaultEncoding) {
      var enc = defaultEncoding || "utf-16le";
      if (buf.length >= 2) {
        if (buf[0] == 254 && buf[1] == 255)
          enc = "utf-16be";
        else if (buf[0] == 255 && buf[1] == 254)
          enc = "utf-16le";
        else {
          var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
          for (var i = 0; i < _len; i += 2) {
            if (buf[i] === 0 && buf[i + 1] !== 0)
              asciiCharsBE++;
            if (buf[i] !== 0 && buf[i + 1] === 0)
              asciiCharsLE++;
          }
          if (asciiCharsBE > asciiCharsLE)
            enc = "utf-16be";
          else if (asciiCharsBE < asciiCharsLE)
            enc = "utf-16le";
        }
      }
      return enc;
    }
  }
});

// node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS({
  "node_modules/iconv-lite/encodings/utf7.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2.utf7 = Utf7Codec;
    exports2.unicode11utf7 = "utf7";
    function Utf7Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7Codec.prototype.encoder = Utf7Encoder;
    Utf7Codec.prototype.decoder = Utf7Decoder;
    Utf7Codec.prototype.bomAware = true;
    var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
    function Utf7Encoder(options, codec) {
      this.iconv = codec.iconv;
    }
    Utf7Encoder.prototype.write = function(str) {
      return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
      }.bind(this)));
    };
    Utf7Encoder.prototype.end = function() {
    };
    function Utf7Decoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64Regex = /[A-Za-z0-9\/+]/;
    var base64Chars = [];
    for (var i = 0; i < 256; i++)
      base64Chars[i] = base64Regex.test(String.fromCharCode(i));
    var plusChar = "+".charCodeAt(0);
    var minusChar = "-".charCodeAt(0);
    var andChar = "&".charCodeAt(0);
    Utf7Decoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == plusChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64Chars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "+";
            } else {
              var b64str = base64Accum + buf.slice(lastI, i2).toString();
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + buf.slice(lastI).toString();
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7Decoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
    exports2.utf7imap = Utf7IMAPCodec;
    function Utf7IMAPCodec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
    Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
    Utf7IMAPCodec.prototype.bomAware = true;
    function Utf7IMAPEncoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = Buffer2.alloc(6);
      this.base64AccumIdx = 0;
    }
    Utf7IMAPEncoder.prototype.write = function(str) {
      var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
      for (var i2 = 0; i2 < str.length; i2++) {
        var uChar = str.charCodeAt(i2);
        if (32 <= uChar && uChar <= 126) {
          if (inBase64) {
            if (base64AccumIdx > 0) {
              bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
              base64AccumIdx = 0;
            }
            buf[bufIdx++] = minusChar;
            inBase64 = false;
          }
          if (!inBase64) {
            buf[bufIdx++] = uChar;
            if (uChar === andChar)
              buf[bufIdx++] = minusChar;
          }
        } else {
          if (!inBase64) {
            buf[bufIdx++] = andChar;
            inBase64 = true;
          }
          if (inBase64) {
            base64Accum[base64AccumIdx++] = uChar >> 8;
            base64Accum[base64AccumIdx++] = uChar & 255;
            if (base64AccumIdx == base64Accum.length) {
              bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
              base64AccumIdx = 0;
            }
          }
        }
      }
      this.inBase64 = inBase64;
      this.base64AccumIdx = base64AccumIdx;
      return buf.slice(0, bufIdx);
    };
    Utf7IMAPEncoder.prototype.end = function() {
      var buf = Buffer2.alloc(10), bufIdx = 0;
      if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
          bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
          this.base64AccumIdx = 0;
        }
        buf[bufIdx++] = minusChar;
        this.inBase64 = false;
      }
      return buf.slice(0, bufIdx);
    };
    function Utf7IMAPDecoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64IMAPChars = base64Chars.slice();
    base64IMAPChars[",".charCodeAt(0)] = true;
    Utf7IMAPDecoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == andChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64IMAPChars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "&";
            } else {
              var b64str = base64Accum + buf.slice(lastI, i2).toString().replace(/,/g, "/");
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7IMAPDecoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
  }
});

// node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS({
  "node_modules/iconv-lite/encodings/sbcs-codec.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2._sbcs = SBCSCodec;
    function SBCSCodec(codecOptions, iconv) {
      if (!codecOptions)
        throw new Error("SBCS codec is called without the data.");
      if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
        throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
      if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
          asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
      }
      this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
      var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
      for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
      this.encodeBuf = encodeBuf;
    }
    SBCSCodec.prototype.encoder = SBCSEncoder;
    SBCSCodec.prototype.decoder = SBCSDecoder;
    function SBCSEncoder(options, codec) {
      this.encodeBuf = codec.encodeBuf;
    }
    SBCSEncoder.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length);
      for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
      return buf;
    };
    SBCSEncoder.prototype.end = function() {
    };
    function SBCSDecoder(options, codec) {
      this.decodeBuf = codec.decodeBuf;
    }
    SBCSDecoder.prototype.write = function(buf) {
      var decodeBuf = this.decodeBuf;
      var newBuf = Buffer2.alloc(buf.length * 2);
      var idx1 = 0, idx2 = 0;
      for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i] * 2;
        idx2 = i * 2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
      }
      return newBuf.toString("ucs2");
    };
    SBCSDecoder.prototype.end = function() {
    };
  }
});

// node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS({
  "node_modules/iconv-lite/encodings/sbcs-data.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "10029": "maccenteuro",
      "maccenteuro": {
        "type": "_sbcs",
        "chars": "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7"
      },
      "808": "cp808",
      "ibm808": "cp808",
      "cp808": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\u20AC\u25A0\xA0"
      },
      "mik": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2514\u2534\u252C\u251C\u2500\u253C\u2563\u2551\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2510\u2591\u2592\u2593\u2502\u2524\u2116\xA7\u2557\u255D\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ascii8bit": "ascii",
      "usascii": "ascii",
      "ansix34": "ascii",
      "ansix341968": "ascii",
      "ansix341986": "ascii",
      "csascii": "ascii",
      "cp367": "ascii",
      "ibm367": "ascii",
      "isoir6": "ascii",
      "iso646us": "ascii",
      "iso646irv": "ascii",
      "us": "ascii",
      "latin1": "iso88591",
      "latin2": "iso88592",
      "latin3": "iso88593",
      "latin4": "iso88594",
      "latin5": "iso88599",
      "latin6": "iso885910",
      "latin7": "iso885913",
      "latin8": "iso885914",
      "latin9": "iso885915",
      "latin10": "iso885916",
      "csisolatin1": "iso88591",
      "csisolatin2": "iso88592",
      "csisolatin3": "iso88593",
      "csisolatin4": "iso88594",
      "csisolatincyrillic": "iso88595",
      "csisolatinarabic": "iso88596",
      "csisolatingreek": "iso88597",
      "csisolatinhebrew": "iso88598",
      "csisolatin5": "iso88599",
      "csisolatin6": "iso885910",
      "l1": "iso88591",
      "l2": "iso88592",
      "l3": "iso88593",
      "l4": "iso88594",
      "l5": "iso88599",
      "l6": "iso885910",
      "l7": "iso885913",
      "l8": "iso885914",
      "l9": "iso885915",
      "l10": "iso885916",
      "isoir14": "iso646jp",
      "isoir57": "iso646cn",
      "isoir100": "iso88591",
      "isoir101": "iso88592",
      "isoir109": "iso88593",
      "isoir110": "iso88594",
      "isoir144": "iso88595",
      "isoir127": "iso88596",
      "isoir126": "iso88597",
      "isoir138": "iso88598",
      "isoir148": "iso88599",
      "isoir157": "iso885910",
      "isoir166": "tis620",
      "isoir179": "iso885913",
      "isoir199": "iso885914",
      "isoir203": "iso885915",
      "isoir226": "iso885916",
      "cp819": "iso88591",
      "ibm819": "iso88591",
      "cyrillic": "iso88595",
      "arabic": "iso88596",
      "arabic8": "iso88596",
      "ecma114": "iso88596",
      "asmo708": "iso88596",
      "greek": "iso88597",
      "greek8": "iso88597",
      "ecma118": "iso88597",
      "elot928": "iso88597",
      "hebrew": "iso88598",
      "hebrew8": "iso88598",
      "turkish": "iso88599",
      "turkish8": "iso88599",
      "thai": "iso885911",
      "thai8": "iso885911",
      "celtic": "iso885914",
      "celtic8": "iso885914",
      "isoceltic": "iso885914",
      "tis6200": "tis620",
      "tis62025291": "tis620",
      "tis62025330": "tis620",
      "10000": "macroman",
      "10006": "macgreek",
      "10007": "maccyrillic",
      "10079": "maciceland",
      "10081": "macturkish",
      "cspc8codepage437": "cp437",
      "cspc775baltic": "cp775",
      "cspc850multilingual": "cp850",
      "cspcp852": "cp852",
      "cspc862latinhebrew": "cp862",
      "cpgr": "cp869",
      "msee": "cp1250",
      "mscyrl": "cp1251",
      "msansi": "cp1252",
      "msgreek": "cp1253",
      "msturk": "cp1254",
      "mshebr": "cp1255",
      "msarab": "cp1256",
      "winbaltrim": "cp1257",
      "cp20866": "koi8r",
      "20866": "koi8r",
      "ibm878": "koi8r",
      "cskoi8r": "koi8r",
      "cp21866": "koi8u",
      "21866": "koi8u",
      "ibm1168": "koi8u",
      "strk10482002": "rk1048",
      "tcvn5712": "tcvn",
      "tcvn57121": "tcvn",
      "gb198880": "iso646cn",
      "cn": "iso646cn",
      "csiso14jisc6220ro": "iso646jp",
      "jisc62201969ro": "iso646jp",
      "jp": "iso646jp",
      "cshproman8": "hproman8",
      "r8": "hproman8",
      "roman8": "hproman8",
      "xroman8": "hproman8",
      "ibm1051": "hproman8",
      "mac": "macintosh",
      "csmacintosh": "macintosh"
    };
  }
});

// node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS({
  "node_modules/iconv-lite/encodings/sbcs-data-generated.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "437": "cp437",
      "737": "cp737",
      "775": "cp775",
      "850": "cp850",
      "852": "cp852",
      "855": "cp855",
      "856": "cp856",
      "857": "cp857",
      "858": "cp858",
      "860": "cp860",
      "861": "cp861",
      "862": "cp862",
      "863": "cp863",
      "864": "cp864",
      "865": "cp865",
      "866": "cp866",
      "869": "cp869",
      "874": "windows874",
      "922": "cp922",
      "1046": "cp1046",
      "1124": "cp1124",
      "1125": "cp1125",
      "1129": "cp1129",
      "1133": "cp1133",
      "1161": "cp1161",
      "1162": "cp1162",
      "1163": "cp1163",
      "1250": "windows1250",
      "1251": "windows1251",
      "1252": "windows1252",
      "1253": "windows1253",
      "1254": "windows1254",
      "1255": "windows1255",
      "1256": "windows1256",
      "1257": "windows1257",
      "1258": "windows1258",
      "28591": "iso88591",
      "28592": "iso88592",
      "28593": "iso88593",
      "28594": "iso88594",
      "28595": "iso88595",
      "28596": "iso88596",
      "28597": "iso88597",
      "28598": "iso88598",
      "28599": "iso88599",
      "28600": "iso885910",
      "28601": "iso885911",
      "28603": "iso885913",
      "28604": "iso885914",
      "28605": "iso885915",
      "28606": "iso885916",
      "windows874": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\uFFFD\uFFFD\uFFFD\u2026\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "win874": "windows874",
      "cp874": "windows874",
      "windows1250": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\u0160\u2039\u015A\u0164\u017D\u0179\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0161\u203A\u015B\u0165\u017E\u017A\xA0\u02C7\u02D8\u0141\xA4\u0104\xA6\xA7\xA8\xA9\u015E\xAB\xAC\xAD\xAE\u017B\xB0\xB1\u02DB\u0142\xB4\xB5\xB6\xB7\xB8\u0105\u015F\xBB\u013D\u02DD\u013E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
      },
      "win1250": "windows1250",
      "cp1250": "windows1250",
      "windows1251": {
        "type": "_sbcs",
        "chars": "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u040C\u040B\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u045C\u045B\u045F\xA0\u040E\u045E\u0408\xA4\u0490\xA6\xA7\u0401\xA9\u0404\xAB\xAC\xAD\xAE\u0407\xB0\xB1\u0406\u0456\u0491\xB5\xB6\xB7\u0451\u2116\u0454\xBB\u0458\u0405\u0455\u0457\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
      },
      "win1251": "windows1251",
      "cp1251": "windows1251",
      "windows1252": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\u017D\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\u017E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "win1252": "windows1252",
      "cp1252": "windows1252",
      "windows1253": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0385\u0386\xA3\xA4\xA5\xA6\xA7\xA8\xA9\uFFFD\xAB\xAC\xAD\xAE\u2015\xB0\xB1\xB2\xB3\u0384\xB5\xB6\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
      },
      "win1253": "windows1253",
      "cp1253": "windows1253",
      "windows1254": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
      },
      "win1254": "windows1254",
      "cp1254": "windows1254",
      "windows1255": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\xA1\xA2\xA3\u20AA\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\xBF\u05B0\u05B1\u05B2\u05B3\u05B4\u05B5\u05B6\u05B7\u05B8\u05B9\u05BA\u05BB\u05BC\u05BD\u05BE\u05BF\u05C0\u05C1\u05C2\u05C3\u05F0\u05F1\u05F2\u05F3\u05F4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
      },
      "win1255": "windows1255",
      "cp1255": "windows1255",
      "windows1256": {
        "type": "_sbcs",
        "chars": "\u20AC\u067E\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0679\u2039\u0152\u0686\u0698\u0688\u06AF\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u06A9\u2122\u0691\u203A\u0153\u200C\u200D\u06BA\xA0\u060C\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\u06BE\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\u061B\xBB\xBC\xBD\xBE\u061F\u06C1\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\xD7\u0637\u0638\u0639\u063A\u0640\u0641\u0642\u0643\xE0\u0644\xE2\u0645\u0646\u0647\u0648\xE7\xE8\xE9\xEA\xEB\u0649\u064A\xEE\xEF\u064B\u064C\u064D\u064E\xF4\u064F\u0650\xF7\u0651\xF9\u0652\xFB\xFC\u200E\u200F\u06D2"
      },
      "win1256": "windows1256",
      "cp1256": "windows1256",
      "windows1257": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\xA8\u02C7\xB8\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\xAF\u02DB\uFFFD\xA0\uFFFD\xA2\xA3\xA4\uFFFD\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u02D9"
      },
      "win1257": "windows1257",
      "cp1257": "windows1257",
      "windows1258": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
      },
      "win1258": "windows1258",
      "cp1258": "windows1258",
      "iso88591": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "cp28591": "iso88591",
      "iso88592": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u02D8\u0141\xA4\u013D\u015A\xA7\xA8\u0160\u015E\u0164\u0179\xAD\u017D\u017B\xB0\u0105\u02DB\u0142\xB4\u013E\u015B\u02C7\xB8\u0161\u015F\u0165\u017A\u02DD\u017E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
      },
      "cp28592": "iso88592",
      "iso88593": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0126\u02D8\xA3\xA4\uFFFD\u0124\xA7\xA8\u0130\u015E\u011E\u0134\xAD\uFFFD\u017B\xB0\u0127\xB2\xB3\xB4\xB5\u0125\xB7\xB8\u0131\u015F\u011F\u0135\xBD\uFFFD\u017C\xC0\xC1\xC2\uFFFD\xC4\u010A\u0108\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\uFFFD\xD1\xD2\xD3\xD4\u0120\xD6\xD7\u011C\xD9\xDA\xDB\xDC\u016C\u015C\xDF\xE0\xE1\xE2\uFFFD\xE4\u010B\u0109\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\uFFFD\xF1\xF2\xF3\xF4\u0121\xF6\xF7\u011D\xF9\xFA\xFB\xFC\u016D\u015D\u02D9"
      },
      "cp28593": "iso88593",
      "iso88594": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0138\u0156\xA4\u0128\u013B\xA7\xA8\u0160\u0112\u0122\u0166\xAD\u017D\xAF\xB0\u0105\u02DB\u0157\xB4\u0129\u013C\u02C7\xB8\u0161\u0113\u0123\u0167\u014A\u017E\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\u012A\u0110\u0145\u014C\u0136\xD4\xD5\xD6\xD7\xD8\u0172\xDA\xDB\xDC\u0168\u016A\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\u012B\u0111\u0146\u014D\u0137\xF4\xF5\xF6\xF7\xF8\u0173\xFA\xFB\xFC\u0169\u016B\u02D9"
      },
      "cp28594": "iso88594",
      "iso88595": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0403\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0453\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
      },
      "cp28595": "iso88595",
      "iso88596": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\uFFFD\uFFFD\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u060C\xAD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u061B\uFFFD\uFFFD\uFFFD\u061F\uFFFD\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "cp28596": "iso88596",
      "iso88597": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u2018\u2019\xA3\u20AC\u20AF\xA6\xA7\xA8\xA9\u037A\xAB\xAC\xAD\uFFFD\u2015\xB0\xB1\xB2\xB3\u0384\u0385\u0386\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
      },
      "cp28597": "iso88597",
      "iso88598": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2017\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
      },
      "cp28598": "iso88598",
      "iso88599": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
      },
      "cp28599": "iso88599",
      "iso885910": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0112\u0122\u012A\u0128\u0136\xA7\u013B\u0110\u0160\u0166\u017D\xAD\u016A\u014A\xB0\u0105\u0113\u0123\u012B\u0129\u0137\xB7\u013C\u0111\u0161\u0167\u017E\u2015\u016B\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\xCF\xD0\u0145\u014C\xD3\xD4\xD5\xD6\u0168\xD8\u0172\xDA\xDB\xDC\xDD\xDE\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\xEF\xF0\u0146\u014D\xF3\xF4\xF5\xF6\u0169\xF8\u0173\xFA\xFB\xFC\xFD\xFE\u0138"
      },
      "cp28600": "iso885910",
      "iso885911": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "cp28601": "iso885911",
      "iso885913": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u201D\xA2\xA3\xA4\u201E\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\u201C\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u2019"
      },
      "cp28603": "iso885913",
      "iso885914": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u1E02\u1E03\xA3\u010A\u010B\u1E0A\xA7\u1E80\xA9\u1E82\u1E0B\u1EF2\xAD\xAE\u0178\u1E1E\u1E1F\u0120\u0121\u1E40\u1E41\xB6\u1E56\u1E81\u1E57\u1E83\u1E60\u1EF3\u1E84\u1E85\u1E61\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0174\xD1\xD2\xD3\xD4\xD5\xD6\u1E6A\xD8\xD9\xDA\xDB\xDC\xDD\u0176\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0175\xF1\xF2\xF3\xF4\xF5\xF6\u1E6B\xF8\xF9\xFA\xFB\xFC\xFD\u0177\xFF"
      },
      "cp28604": "iso885914",
      "iso885915": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\u0160\xA7\u0161\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u017D\xB5\xB6\xB7\u017E\xB9\xBA\xBB\u0152\u0153\u0178\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "cp28605": "iso885915",
      "iso885916": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0105\u0141\u20AC\u201E\u0160\xA7\u0161\xA9\u0218\xAB\u0179\xAD\u017A\u017B\xB0\xB1\u010C\u0142\u017D\u201D\xB6\xB7\u017E\u010D\u0219\xBB\u0152\u0153\u0178\u017C\xC0\xC1\xC2\u0102\xC4\u0106\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0110\u0143\xD2\xD3\xD4\u0150\xD6\u015A\u0170\xD9\xDA\xDB\xDC\u0118\u021A\xDF\xE0\xE1\xE2\u0103\xE4\u0107\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0111\u0144\xF2\xF3\xF4\u0151\xF6\u015B\u0171\xF9\xFA\xFB\xFC\u0119\u021B\xFF"
      },
      "cp28606": "iso885916",
      "cp437": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm437": "cp437",
      "csibm437": "cp437",
      "cp737": {
        "type": "_sbcs",
        "chars": "\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u03C5\u03C6\u03C7\u03C8\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03C9\u03AC\u03AD\u03AE\u03CA\u03AF\u03CC\u03CD\u03CB\u03CE\u0386\u0388\u0389\u038A\u038C\u038E\u038F\xB1\u2265\u2264\u03AA\u03AB\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm737": "cp737",
      "csibm737": "cp737",
      "cp775": {
        "type": "_sbcs",
        "chars": "\u0106\xFC\xE9\u0101\xE4\u0123\xE5\u0107\u0142\u0113\u0156\u0157\u012B\u0179\xC4\xC5\xC9\xE6\xC6\u014D\xF6\u0122\xA2\u015A\u015B\xD6\xDC\xF8\xA3\xD8\xD7\xA4\u0100\u012A\xF3\u017B\u017C\u017A\u201D\xA6\xA9\xAE\xAC\xBD\xBC\u0141\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0104\u010C\u0118\u0116\u2563\u2551\u2557\u255D\u012E\u0160\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0172\u016A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u017D\u0105\u010D\u0119\u0117\u012F\u0161\u0173\u016B\u017E\u2518\u250C\u2588\u2584\u258C\u2590\u2580\xD3\xDF\u014C\u0143\xF5\xD5\xB5\u0144\u0136\u0137\u013B\u013C\u0146\u0112\u0145\u2019\xAD\xB1\u201C\xBE\xB6\xA7\xF7\u201E\xB0\u2219\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm775": "cp775",
      "csibm775": "cp775",
      "cp850": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u0131\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm850": "cp850",
      "csibm850": "cp850",
      "cp852": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\u016F\u0107\xE7\u0142\xEB\u0150\u0151\xEE\u0179\xC4\u0106\xC9\u0139\u013A\xF4\xF6\u013D\u013E\u015A\u015B\xD6\xDC\u0164\u0165\u0141\xD7\u010D\xE1\xED\xF3\xFA\u0104\u0105\u017D\u017E\u0118\u0119\xAC\u017A\u010C\u015F\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\u011A\u015E\u2563\u2551\u2557\u255D\u017B\u017C\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0102\u0103\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u0111\u0110\u010E\xCB\u010F\u0147\xCD\xCE\u011B\u2518\u250C\u2588\u2584\u0162\u016E\u2580\xD3\xDF\xD4\u0143\u0144\u0148\u0160\u0161\u0154\xDA\u0155\u0170\xFD\xDD\u0163\xB4\xAD\u02DD\u02DB\u02C7\u02D8\xA7\xF7\xB8\xB0\xA8\u02D9\u0171\u0158\u0159\u25A0\xA0"
      },
      "ibm852": "cp852",
      "csibm852": "cp852",
      "cp855": {
        "type": "_sbcs",
        "chars": "\u0452\u0402\u0453\u0403\u0451\u0401\u0454\u0404\u0455\u0405\u0456\u0406\u0457\u0407\u0458\u0408\u0459\u0409\u045A\u040A\u045B\u040B\u045C\u040C\u045E\u040E\u045F\u040F\u044E\u042E\u044A\u042A\u0430\u0410\u0431\u0411\u0446\u0426\u0434\u0414\u0435\u0415\u0444\u0424\u0433\u0413\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0445\u0425\u0438\u0418\u2563\u2551\u2557\u255D\u0439\u0419\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u043A\u041A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u043B\u041B\u043C\u041C\u043D\u041D\u043E\u041E\u043F\u2518\u250C\u2588\u2584\u041F\u044F\u2580\u042F\u0440\u0420\u0441\u0421\u0442\u0422\u0443\u0423\u0436\u0416\u0432\u0412\u044C\u042C\u2116\xAD\u044B\u042B\u0437\u0417\u0448\u0428\u044D\u042D\u0449\u0429\u0447\u0427\xA7\u25A0\xA0"
      },
      "ibm855": "cp855",
      "csibm855": "cp855",
      "cp856": {
        "type": "_sbcs",
        "chars": "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\xA3\uFFFD\xD7\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAE\xAC\xBD\xBC\uFFFD\xAB\xBB\u2591\u2592\u2593\u2502\u2524\uFFFD\uFFFD\uFFFD\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\uFFFD\uFFFD\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2518\u250C\u2588\u2584\xA6\uFFFD\u2580\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xB5\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm856": "cp856",
      "csibm856": "cp856",
      "cp857": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\u0131\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\u0130\xD6\xDC\xF8\xA3\xD8\u015E\u015F\xE1\xED\xF3\xFA\xF1\xD1\u011E\u011F\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xBA\xAA\xCA\xCB\xC8\uFFFD\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\uFFFD\xD7\xDA\xDB\xD9\xEC\xFF\xAF\xB4\xAD\xB1\uFFFD\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm857": "cp857",
      "csibm857": "cp857",
      "cp858": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u20AC\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm858": "cp858",
      "csibm858": "cp858",
      "cp860": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE3\xE0\xC1\xE7\xEA\xCA\xE8\xCD\xD4\xEC\xC3\xC2\xC9\xC0\xC8\xF4\xF5\xF2\xDA\xF9\xCC\xD5\xDC\xA2\xA3\xD9\u20A7\xD3\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xD2\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm860": "cp860",
      "csibm860": "cp860",
      "cp861": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xD0\xF0\xDE\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xFE\xFB\xDD\xFD\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xC1\xCD\xD3\xDA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm861": "cp861",
      "csibm861": "cp861",
      "cp862": {
        "type": "_sbcs",
        "chars": "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm862": "cp862",
      "csibm862": "cp862",
      "cp863": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xC2\xE0\xB6\xE7\xEA\xEB\xE8\xEF\xEE\u2017\xC0\xA7\xC9\xC8\xCA\xF4\xCB\xCF\xFB\xF9\xA4\xD4\xDC\xA2\xA3\xD9\xDB\u0192\xA6\xB4\xF3\xFA\xA8\xB8\xB3\xAF\xCE\u2310\xAC\xBD\xBC\xBE\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm863": "cp863",
      "csibm863": "cp863",
      "cp864": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r !\"#$\u066A&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xB0\xB7\u2219\u221A\u2592\u2500\u2502\u253C\u2524\u252C\u251C\u2534\u2510\u250C\u2514\u2518\u03B2\u221E\u03C6\xB1\xBD\xBC\u2248\xAB\xBB\uFEF7\uFEF8\uFFFD\uFFFD\uFEFB\uFEFC\uFFFD\xA0\xAD\uFE82\xA3\xA4\uFE84\uFFFD\uFFFD\uFE8E\uFE8F\uFE95\uFE99\u060C\uFE9D\uFEA1\uFEA5\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFED1\u061B\uFEB1\uFEB5\uFEB9\u061F\xA2\uFE80\uFE81\uFE83\uFE85\uFECA\uFE8B\uFE8D\uFE91\uFE93\uFE97\uFE9B\uFE9F\uFEA3\uFEA7\uFEA9\uFEAB\uFEAD\uFEAF\uFEB3\uFEB7\uFEBB\uFEBF\uFEC1\uFEC5\uFECB\uFECF\xA6\xAC\xF7\xD7\uFEC9\u0640\uFED3\uFED7\uFEDB\uFEDF\uFEE3\uFEE7\uFEEB\uFEED\uFEEF\uFEF3\uFEBD\uFECC\uFECE\uFECD\uFEE1\uFE7D\u0651\uFEE5\uFEE9\uFEEC\uFEF0\uFEF2\uFED0\uFED5\uFEF5\uFEF6\uFEDD\uFED9\uFEF1\u25A0\uFFFD"
      },
      "ibm864": "cp864",
      "csibm864": "cp864",
      "cp865": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xA4\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm865": "cp865",
      "csibm865": "cp865",
      "cp866": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\xA4\u25A0\xA0"
      },
      "ibm866": "cp866",
      "csibm866": "cp866",
      "cp869": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0386\uFFFD\xB7\xAC\xA6\u2018\u2019\u0388\u2015\u0389\u038A\u03AA\u038C\uFFFD\uFFFD\u038E\u03AB\xA9\u038F\xB2\xB3\u03AC\xA3\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03CD\u0391\u0392\u0393\u0394\u0395\u0396\u0397\xBD\u0398\u0399\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u039A\u039B\u039C\u039D\u2563\u2551\u2557\u255D\u039E\u039F\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u03A0\u03A1\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u2518\u250C\u2588\u2584\u03B4\u03B5\u2580\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u0384\xAD\xB1\u03C5\u03C6\u03C7\xA7\u03C8\u0385\xB0\xA8\u03C9\u03CB\u03B0\u03CE\u25A0\xA0"
      },
      "ibm869": "cp869",
      "csibm869": "cp869",
      "cp922": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\u203E\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0160\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\u017D\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0161\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\u017E\xFF"
      },
      "ibm922": "cp922",
      "csibm922": "cp922",
      "cp1046": {
        "type": "_sbcs",
        "chars": "\uFE88\xD7\xF7\uF8F6\uF8F5\uF8F4\uF8F7\uFE71\x88\u25A0\u2502\u2500\u2510\u250C\u2514\u2518\uFE79\uFE7B\uFE7D\uFE7F\uFE77\uFE8A\uFEF0\uFEF3\uFEF2\uFECE\uFECF\uFED0\uFEF6\uFEF8\uFEFA\uFEFC\xA0\uF8FA\uF8F9\uF8F8\xA4\uF8FB\uFE8B\uFE91\uFE97\uFE9B\uFE9F\uFEA3\u060C\xAD\uFEA7\uFEB3\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFEB7\u061B\uFEBB\uFEBF\uFECA\u061F\uFECB\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\uFEC7\u0639\u063A\uFECC\uFE82\uFE84\uFE8E\uFED3\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFED7\uFEDB\uFEDF\uF8FC\uFEF5\uFEF7\uFEF9\uFEFB\uFEE3\uFEE7\uFEEC\uFEE9\uFFFD"
      },
      "ibm1046": "cp1046",
      "csibm1046": "cp1046",
      "cp1124": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0490\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0491\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
      },
      "ibm1124": "cp1124",
      "csibm1124": "cp1124",
      "cp1125": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0490\u0491\u0404\u0454\u0406\u0456\u0407\u0457\xB7\u221A\u2116\xA4\u25A0\xA0"
      },
      "ibm1125": "cp1125",
      "csibm1125": "cp1125",
      "cp1129": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
      },
      "ibm1129": "cp1129",
      "csibm1129": "cp1129",
      "cp1133": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E81\u0E82\u0E84\u0E87\u0E88\u0EAA\u0E8A\u0E8D\u0E94\u0E95\u0E96\u0E97\u0E99\u0E9A\u0E9B\u0E9C\u0E9D\u0E9E\u0E9F\u0EA1\u0EA2\u0EA3\u0EA5\u0EA7\u0EAB\u0EAD\u0EAE\uFFFD\uFFFD\uFFFD\u0EAF\u0EB0\u0EB2\u0EB3\u0EB4\u0EB5\u0EB6\u0EB7\u0EB8\u0EB9\u0EBC\u0EB1\u0EBB\u0EBD\uFFFD\uFFFD\uFFFD\u0EC0\u0EC1\u0EC2\u0EC3\u0EC4\u0EC8\u0EC9\u0ECA\u0ECB\u0ECC\u0ECD\u0EC6\uFFFD\u0EDC\u0EDD\u20AD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0ED0\u0ED1\u0ED2\u0ED3\u0ED4\u0ED5\u0ED6\u0ED7\u0ED8\u0ED9\uFFFD\uFFFD\xA2\xAC\xA6\uFFFD"
      },
      "ibm1133": "cp1133",
      "csibm1133": "cp1133",
      "cp1161": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E48\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\u0E49\u0E4A\u0E4B\u20AC\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\xA2\xAC\xA6\xA0"
      },
      "ibm1161": "cp1161",
      "csibm1161": "cp1161",
      "cp1162": {
        "type": "_sbcs",
        "chars": "\u20AC\x81\x82\x83\x84\u2026\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "ibm1162": "cp1162",
      "csibm1162": "cp1162",
      "cp1163": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
      },
      "ibm1163": "cp1163",
      "csibm1163": "cp1163",
      "maccroatian": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u2126\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uFFFD\xA9\u2044\xA4\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7"
      },
      "maccyrillic": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\xA2\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u2202\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
      },
      "macgreek": {
        "type": "_sbcs",
        "chars": "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\xAD\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\u0387\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\uFFFD"
      },
      "maciceland": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macroman": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macromania": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u015E\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\u0103\u015F\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\u0162\u0163\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macthai": {
        "type": "_sbcs",
        "chars": "\xAB\xBB\u2026\uF88C\uF88F\uF892\uF895\uF898\uF88B\uF88E\uF891\uF894\uF897\u201C\u201D\uF899\uFFFD\u2022\uF884\uF889\uF885\uF886\uF887\uF888\uF88A\uF88D\uF890\uF893\uF896\u2018\u2019\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFEFF\u200B\u2013\u2014\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u2122\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\xAE\xA9\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "macturkish": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\uFFFD\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macukraine": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
      },
      "koi8r": {
        "type": "_sbcs",
        "chars": "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u2553\u2554\u2555\u2556\u2557\u2558\u2559\u255A\u255B\u255C\u255D\u255E\u255F\u2560\u2561\u0401\u2562\u2563\u2564\u2565\u2566\u2567\u2568\u2569\u256A\u256B\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "koi8u": {
        "type": "_sbcs",
        "chars": "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u255D\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "koi8ru": {
        "type": "_sbcs",
        "chars": "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u045E\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u040E\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "koi8t": {
        "type": "_sbcs",
        "chars": "\u049B\u0493\u201A\u0492\u201E\u2026\u2020\u2021\uFFFD\u2030\u04B3\u2039\u04B2\u04B7\u04B6\uFFFD\u049A\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u04EF\u04EE\u0451\xA4\u04E3\xA6\xA7\uFFFD\uFFFD\uFFFD\xAB\xAC\xAD\xAE\uFFFD\xB0\xB1\xB2\u0401\uFFFD\u04E2\xB6\xB7\uFFFD\u2116\uFFFD\xBB\uFFFD\uFFFD\uFFFD\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "armscii8": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\u0587\u0589)(\xBB\xAB\u2014.\u055D,-\u058A\u2026\u055C\u055B\u055E\u0531\u0561\u0532\u0562\u0533\u0563\u0534\u0564\u0535\u0565\u0536\u0566\u0537\u0567\u0538\u0568\u0539\u0569\u053A\u056A\u053B\u056B\u053C\u056C\u053D\u056D\u053E\u056E\u053F\u056F\u0540\u0570\u0541\u0571\u0542\u0572\u0543\u0573\u0544\u0574\u0545\u0575\u0546\u0576\u0547\u0577\u0548\u0578\u0549\u0579\u054A\u057A\u054B\u057B\u054C\u057C\u054D\u057D\u054E\u057E\u054F\u057F\u0550\u0580\u0551\u0581\u0552\u0582\u0553\u0583\u0554\u0584\u0555\u0585\u0556\u0586\u055A\uFFFD"
      },
      "rk1048": {
        "type": "_sbcs",
        "chars": "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u049A\u04BA\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u049B\u04BB\u045F\xA0\u04B0\u04B1\u04D8\xA4\u04E8\xA6\xA7\u0401\xA9\u0492\xAB\xAC\xAD\xAE\u04AE\xB0\xB1\u0406\u0456\u04E9\xB5\xB6\xB7\u0451\u2116\u0493\xBB\u04D9\u04A2\u04A3\u04AF\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
      },
      "tcvn": {
        "type": "_sbcs",
        "chars": "\0\xDA\u1EE4\u1EEA\u1EEC\u1EEE\x07\b	\n\v\f\r\u1EE8\u1EF0\u1EF2\u1EF6\u1EF8\xDD\u1EF4 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xC0\u1EA2\xC3\xC1\u1EA0\u1EB6\u1EAC\xC8\u1EBA\u1EBC\xC9\u1EB8\u1EC6\xCC\u1EC8\u0128\xCD\u1ECA\xD2\u1ECE\xD5\xD3\u1ECC\u1ED8\u1EDC\u1EDE\u1EE0\u1EDA\u1EE2\xD9\u1EE6\u0168\xA0\u0102\xC2\xCA\xD4\u01A0\u01AF\u0110\u0103\xE2\xEA\xF4\u01A1\u01B0\u0111\u1EB0\u0300\u0309\u0303\u0301\u0323\xE0\u1EA3\xE3\xE1\u1EA1\u1EB2\u1EB1\u1EB3\u1EB5\u1EAF\u1EB4\u1EAE\u1EA6\u1EA8\u1EAA\u1EA4\u1EC0\u1EB7\u1EA7\u1EA9\u1EAB\u1EA5\u1EAD\xE8\u1EC2\u1EBB\u1EBD\xE9\u1EB9\u1EC1\u1EC3\u1EC5\u1EBF\u1EC7\xEC\u1EC9\u1EC4\u1EBE\u1ED2\u0129\xED\u1ECB\xF2\u1ED4\u1ECF\xF5\xF3\u1ECD\u1ED3\u1ED5\u1ED7\u1ED1\u1ED9\u1EDD\u1EDF\u1EE1\u1EDB\u1EE3\xF9\u1ED6\u1EE7\u0169\xFA\u1EE5\u1EEB\u1EED\u1EEF\u1EE9\u1EF1\u1EF3\u1EF7\u1EF9\xFD\u1EF5\u1ED0"
      },
      "georgianacademy": {
        "type": "_sbcs",
        "chars": "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10EF\u10F0\u10F1\u10F2\u10F3\u10F4\u10F5\u10F6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "georgianps": {
        "type": "_sbcs",
        "chars": "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10F1\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10F2\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10F3\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10F4\u10EF\u10F0\u10F5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "pt154": {
        "type": "_sbcs",
        "chars": "\u0496\u0492\u04EE\u0493\u201E\u2026\u04B6\u04AE\u04B2\u04AF\u04A0\u04E2\u04A2\u049A\u04BA\u04B8\u0497\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u04B3\u04B7\u04A1\u04E3\u04A3\u049B\u04BB\u04B9\xA0\u040E\u045E\u0408\u04E8\u0498\u04B0\xA7\u0401\xA9\u04D8\xAB\xAC\u04EF\xAE\u049C\xB0\u04B1\u0406\u0456\u0499\u04E9\xB6\xB7\u0451\u2116\u04D9\xBB\u0458\u04AA\u04AB\u049D\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
      },
      "viscii": {
        "type": "_sbcs",
        "chars": "\0\u1EB2\u1EB4\u1EAA\x07\b	\n\v\f\r\u1EF6\u1EF8\u1EF4 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\u1EA0\u1EAE\u1EB0\u1EB6\u1EA4\u1EA6\u1EA8\u1EAC\u1EBC\u1EB8\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EE2\u1EDA\u1EDC\u1EDE\u1ECA\u1ECE\u1ECC\u1EC8\u1EE6\u0168\u1EE4\u1EF2\xD5\u1EAF\u1EB1\u1EB7\u1EA5\u1EA7\u1EA9\u1EAD\u1EBD\u1EB9\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1ED1\u1ED3\u1ED5\u1ED7\u1EE0\u01A0\u1ED9\u1EDD\u1EDF\u1ECB\u1EF0\u1EE8\u1EEA\u1EEC\u01A1\u1EDB\u01AF\xC0\xC1\xC2\xC3\u1EA2\u0102\u1EB3\u1EB5\xC8\xC9\xCA\u1EBA\xCC\xCD\u0128\u1EF3\u0110\u1EE9\xD2\xD3\xD4\u1EA1\u1EF7\u1EEB\u1EED\xD9\xDA\u1EF9\u1EF5\xDD\u1EE1\u01B0\xE0\xE1\xE2\xE3\u1EA3\u0103\u1EEF\u1EAB\xE8\xE9\xEA\u1EBB\xEC\xED\u0129\u1EC9\u0111\u1EF1\xF2\xF3\xF4\xF5\u1ECF\u1ECD\u1EE5\xF9\xFA\u0169\u1EE7\xFD\u1EE3\u1EEE"
      },
      "iso646cn": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r !\"#\xA5%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "iso646jp": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\xA5]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "hproman8": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xC0\xC2\xC8\xCA\xCB\xCE\xCF\xB4\u02CB\u02C6\xA8\u02DC\xD9\xDB\u20A4\xAF\xDD\xFD\xB0\xC7\xE7\xD1\xF1\xA1\xBF\xA4\xA3\xA5\xA7\u0192\xA2\xE2\xEA\xF4\xFB\xE1\xE9\xF3\xFA\xE0\xE8\xF2\xF9\xE4\xEB\xF6\xFC\xC5\xEE\xD8\xC6\xE5\xED\xF8\xE6\xC4\xEC\xD6\xDC\xC9\xEF\xDF\xD4\xC1\xC3\xE3\xD0\xF0\xCD\xCC\xD3\xD2\xD5\xF5\u0160\u0161\xDA\u0178\xFF\xDE\xFE\xB7\xB5\xB6\xBE\u2014\xBC\xBD\xAA\xBA\xAB\u25A0\xBB\xB1\uFFFD"
      },
      "macintosh": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "ascii": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "tis620": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      }
    };
  }
});

// node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS({
  "node_modules/iconv-lite/encodings/dbcs-codec.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2._dbcs = DBCSCodec;
    var UNASSIGNED = -1;
    var GB18030_CODE = -2;
    var SEQ_START = -10;
    var NODE_START = -1e3;
    var UNASSIGNED_NODE = new Array(256);
    var DEF_CHAR = -1;
    for (var i = 0; i < 256; i++)
      UNASSIGNED_NODE[i] = UNASSIGNED;
    function DBCSCodec(codecOptions, iconv) {
      this.encodingName = codecOptions.encodingName;
      if (!codecOptions)
        throw new Error("DBCS codec is called without the data.");
      if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");
      var mappingTable = codecOptions.table();
      this.decodeTables = [];
      this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
      this.decodeTableSeq = [];
      for (var i2 = 0; i2 < mappingTable.length; i2++)
        this._addDecodeChunk(mappingTable[i2]);
      this.defaultCharUnicode = iconv.defaultCharUnicode;
      this.encodeTable = [];
      this.encodeTableSeq = [];
      var skipEncodeChars = {};
      if (codecOptions.encodeSkipVals)
        for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
          var val = codecOptions.encodeSkipVals[i2];
          if (typeof val === "number")
            skipEncodeChars[val] = true;
          else
            for (var j = val.from; j <= val.to; j++)
              skipEncodeChars[j] = true;
        }
      this._fillEncodeTable(0, 0, skipEncodeChars);
      if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
          if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
            this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
      }
      this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
      if (this.defCharSB === UNASSIGNED)
        this.defCharSB = this.encodeTable[0]["?"];
      if (this.defCharSB === UNASSIGNED)
        this.defCharSB = "?".charCodeAt(0);
      if (typeof codecOptions.gb18030 === "function") {
        this.gb18030 = codecOptions.gb18030();
        var thirdByteNodeIdx = this.decodeTables.length;
        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
        var fourthByteNodeIdx = this.decodeTables.length;
        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
        for (var i2 = 129; i2 <= 254; i2++) {
          var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2];
          var secondByteNode = this.decodeTables[secondByteNodeIdx];
          for (var j = 48; j <= 57; j++)
            secondByteNode[j] = NODE_START - thirdByteNodeIdx;
        }
        for (var i2 = 129; i2 <= 254; i2++)
          thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
        for (var i2 = 48; i2 <= 57; i2++)
          fourthByteNode[i2] = GB18030_CODE;
      }
    }
    DBCSCodec.prototype.encoder = DBCSEncoder;
    DBCSCodec.prototype.decoder = DBCSDecoder;
    DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
      var bytes = [];
      for (; addr > 0; addr >>= 8)
        bytes.push(addr & 255);
      if (bytes.length == 0)
        bytes.push(0);
      var node = this.decodeTables[0];
      for (var i2 = bytes.length - 1; i2 > 0; i2--) {
        var val = node[bytes[i2]];
        if (val == UNASSIGNED) {
          node[bytes[i2]] = NODE_START - this.decodeTables.length;
          this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        } else if (val <= NODE_START) {
          node = this.decodeTables[NODE_START - val];
        } else
          throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
      }
      return node;
    };
    DBCSCodec.prototype._addDecodeChunk = function(chunk) {
      var curAddr = parseInt(chunk[0], 16);
      var writeTable = this._getDecodeTrieNode(curAddr);
      curAddr = curAddr & 255;
      for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") {
          for (var l = 0; l < part.length; ) {
            var code = part.charCodeAt(l++);
            if (55296 <= code && code < 56320) {
              var codeTrail = part.charCodeAt(l++);
              if (56320 <= codeTrail && codeTrail < 57344)
                writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
              else
                throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
            } else if (4080 < code && code <= 4095) {
              var len = 4095 - code + 2;
              var seq = [];
              for (var m = 0; m < len; m++)
                seq.push(part.charCodeAt(l++));
              writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
              this.decodeTableSeq.push(seq);
            } else
              writeTable[curAddr++] = code;
          }
        } else if (typeof part === "number") {
          var charCode = writeTable[curAddr - 1] + 1;
          for (var l = 0; l < part; l++)
            writeTable[curAddr++] = charCode++;
        } else
          throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
      }
      if (curAddr > 255)
        throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    };
    DBCSCodec.prototype._getEncodeBucket = function(uCode) {
      var high = uCode >> 8;
      if (this.encodeTable[high] === void 0)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
      return this.encodeTable[high];
    };
    DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
      else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
    };
    DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
      var uCode = seq[0];
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      var node;
      if (bucket[low] <= SEQ_START) {
        node = this.encodeTableSeq[SEQ_START - bucket[low]];
      } else {
        node = {};
        if (bucket[low] !== UNASSIGNED)
          node[DEF_CHAR] = bucket[low];
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
      }
      for (var j = 1; j < seq.length - 1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === "object")
          node = oldVal;
        else {
          node = node[uCode] = {};
          if (oldVal !== void 0)
            node[DEF_CHAR] = oldVal;
        }
      }
      uCode = seq[seq.length - 1];
      node[uCode] = dbcsCode;
    };
    DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
      var node = this.decodeTables[nodeIdx];
      for (var i2 = 0; i2 < 256; i2++) {
        var uCode = node[i2];
        var mbCode = prefix + i2;
        if (skipEncodeChars[mbCode])
          continue;
        if (uCode >= 0)
          this._setEncodeChar(uCode, mbCode);
        else if (uCode <= NODE_START)
          this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
        else if (uCode <= SEQ_START)
          this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
      }
    };
    function DBCSEncoder(options, codec) {
      this.leadSurrogate = -1;
      this.seqObj = void 0;
      this.encodeTable = codec.encodeTable;
      this.encodeTableSeq = codec.encodeTableSeq;
      this.defaultCharSingleByte = codec.defCharSB;
      this.gb18030 = codec.gb18030;
    }
    DBCSEncoder.prototype.write = function(str) {
      var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
      while (true) {
        if (nextChar === -1) {
          if (i2 == str.length)
            break;
          var uCode = str.charCodeAt(i2++);
        } else {
          var uCode = nextChar;
          nextChar = -1;
        }
        if (55296 <= uCode && uCode < 57344) {
          if (uCode < 56320) {
            if (leadSurrogate === -1) {
              leadSurrogate = uCode;
              continue;
            } else {
              leadSurrogate = uCode;
              uCode = UNASSIGNED;
            }
          } else {
            if (leadSurrogate !== -1) {
              uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
              leadSurrogate = -1;
            } else {
              uCode = UNASSIGNED;
            }
          }
        } else if (leadSurrogate !== -1) {
          nextChar = uCode;
          uCode = UNASSIGNED;
          leadSurrogate = -1;
        }
        var dbcsCode = UNASSIGNED;
        if (seqObj !== void 0 && uCode != UNASSIGNED) {
          var resCode = seqObj[uCode];
          if (typeof resCode === "object") {
            seqObj = resCode;
            continue;
          } else if (typeof resCode == "number") {
            dbcsCode = resCode;
          } else if (resCode == void 0) {
            resCode = seqObj[DEF_CHAR];
            if (resCode !== void 0) {
              dbcsCode = resCode;
              nextChar = uCode;
            } else {
            }
          }
          seqObj = void 0;
        } else if (uCode >= 0) {
          var subtable = this.encodeTable[uCode >> 8];
          if (subtable !== void 0)
            dbcsCode = subtable[uCode & 255];
          if (dbcsCode <= SEQ_START) {
            seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
            continue;
          }
          if (dbcsCode == UNASSIGNED && this.gb18030) {
            var idx = findIdx(this.gb18030.uChars, uCode);
            if (idx != -1) {
              var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
              newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
              dbcsCode = dbcsCode % 12600;
              newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
              dbcsCode = dbcsCode % 1260;
              newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
              dbcsCode = dbcsCode % 10;
              newBuf[j++] = 48 + dbcsCode;
              continue;
            }
          }
        }
        if (dbcsCode === UNASSIGNED)
          dbcsCode = this.defaultCharSingleByte;
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else if (dbcsCode < 65536) {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        } else {
          newBuf[j++] = dbcsCode >> 16;
          newBuf[j++] = dbcsCode >> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = seqObj;
      this.leadSurrogate = leadSurrogate;
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.end = function() {
      if (this.leadSurrogate === -1 && this.seqObj === void 0)
        return;
      var newBuf = Buffer2.alloc(10), j = 0;
      if (this.seqObj) {
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== void 0) {
          if (dbcsCode < 256) {
            newBuf[j++] = dbcsCode;
          } else {
            newBuf[j++] = dbcsCode >> 8;
            newBuf[j++] = dbcsCode & 255;
          }
        } else {
        }
        this.seqObj = void 0;
      }
      if (this.leadSurrogate !== -1) {
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
      }
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.findIdx = findIdx;
    function DBCSDecoder(options, codec) {
      this.nodeIdx = 0;
      this.prevBuf = Buffer2.alloc(0);
      this.decodeTables = codec.decodeTables;
      this.decodeTableSeq = codec.decodeTableSeq;
      this.defaultCharUnicode = codec.defaultCharUnicode;
      this.gb18030 = codec.gb18030;
    }
    DBCSDecoder.prototype.write = function(buf) {
      var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
      if (prevBufOffset > 0)
        prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]);
      for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
        var curByte = i2 >= 0 ? buf[i2] : prevBuf[i2 + prevBufOffset];
        var uCode = this.decodeTables[nodeIdx][curByte];
        if (uCode >= 0) {
        } else if (uCode === UNASSIGNED) {
          i2 = seqStart;
          uCode = this.defaultCharUnicode.charCodeAt(0);
        } else if (uCode === GB18030_CODE) {
          var curSeq = seqStart >= 0 ? buf.slice(seqStart, i2 + 1) : prevBuf.slice(seqStart + prevBufOffset, i2 + 1 + prevBufOffset);
          var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
          var idx = findIdx(this.gb18030.gbChars, ptr);
          uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        } else if (uCode <= NODE_START) {
          nodeIdx = NODE_START - uCode;
          continue;
        } else if (uCode <= SEQ_START) {
          var seq = this.decodeTableSeq[SEQ_START - uCode];
          for (var k = 0; k < seq.length - 1; k++) {
            uCode = seq[k];
            newBuf[j++] = uCode & 255;
            newBuf[j++] = uCode >> 8;
          }
          uCode = seq[seq.length - 1];
        } else
          throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
        if (uCode > 65535) {
          uCode -= 65536;
          var uCodeLead = 55296 + Math.floor(uCode / 1024);
          newBuf[j++] = uCodeLead & 255;
          newBuf[j++] = uCodeLead >> 8;
          uCode = 56320 + uCode % 1024;
        }
        newBuf[j++] = uCode & 255;
        newBuf[j++] = uCode >> 8;
        nodeIdx = 0;
        seqStart = i2 + 1;
      }
      this.nodeIdx = nodeIdx;
      this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
      return newBuf.slice(0, j).toString("ucs2");
    };
    DBCSDecoder.prototype.end = function() {
      var ret2 = "";
      while (this.prevBuf.length > 0) {
        ret2 += this.defaultCharUnicode;
        var buf = this.prevBuf.slice(1);
        this.prevBuf = Buffer2.alloc(0);
        this.nodeIdx = 0;
        if (buf.length > 0)
          ret2 += this.write(buf);
      }
      this.nodeIdx = 0;
      return ret2;
    };
    function findIdx(table, val) {
      if (table[0] > val)
        return -1;
      var l = 0, r = table.length;
      while (l < r - 1) {
        var mid = l + Math.floor((r - l + 1) / 2);
        if (table[mid] <= val)
          l = mid;
        else
          r = mid;
      }
      return l;
    }
  }
});

// node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS({
  "node_modules/iconv-lite/encodings/tables/shiftjis.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 128],
      ["a1", "\uFF61", 62],
      ["8140", "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008", 9, "\uFF0B\uFF0D\xB1\xD7"],
      ["8180", "\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"],
      ["81b8", "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"],
      ["81c8", "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"],
      ["81da", "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"],
      ["81f0", "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"],
      ["81fc", "\u25EF"],
      ["824f", "\uFF10", 9],
      ["8260", "\uFF21", 25],
      ["8281", "\uFF41", 25],
      ["829f", "\u3041", 82],
      ["8340", "\u30A1", 62],
      ["8380", "\u30E0", 22],
      ["839f", "\u0391", 16, "\u03A3", 6],
      ["83bf", "\u03B1", 16, "\u03C3", 6],
      ["8440", "\u0410", 5, "\u0401\u0416", 25],
      ["8470", "\u0430", 5, "\u0451\u0436", 7],
      ["8480", "\u043E", 17],
      ["849f", "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"],
      ["8740", "\u2460", 19, "\u2160", 9],
      ["875f", "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"],
      ["877e", "\u337B"],
      ["8780", "\u301D\u301F\u2116\u33CD\u2121\u32A4", 4, "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"],
      ["889f", "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"],
      ["8940", "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186"],
      ["8980", "\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"],
      ["8a40", "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B"],
      ["8a80", "\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"],
      ["8b40", "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551"],
      ["8b80", "\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"],
      ["8c40", "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8"],
      ["8c80", "\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"],
      ["8d40", "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D"],
      ["8d80", "\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"],
      ["8e40", "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62"],
      ["8e80", "\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"],
      ["8f40", "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3"],
      ["8f80", "\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"],
      ["9040", "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8"],
      ["9080", "\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"],
      ["9140", "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB"],
      ["9180", "\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"],
      ["9240", "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4"],
      ["9280", "\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"],
      ["9340", "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC"],
      ["9380", "\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"],
      ["9440", "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885"],
      ["9480", "\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"],
      ["9540", "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577"],
      ["9580", "\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"],
      ["9640", "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6"],
      ["9680", "\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"],
      ["9740", "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32"],
      ["9780", "\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"],
      ["9840", "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"],
      ["989f", "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"],
      ["9940", "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED"],
      ["9980", "\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"],
      ["9a40", "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638"],
      ["9a80", "\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"],
      ["9b40", "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80"],
      ["9b80", "\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"],
      ["9c40", "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060"],
      ["9c80", "\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"],
      ["9d40", "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B"],
      ["9d80", "\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"],
      ["9e40", "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E"],
      ["9e80", "\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"],
      ["9f40", "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF"],
      ["9f80", "\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"],
      ["e040", "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD"],
      ["e080", "\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"],
      ["e140", "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF"],
      ["e180", "\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"],
      ["e240", "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0"],
      ["e280", "\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"],
      ["e340", "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37"],
      ["e380", "\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"],
      ["e440", "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264"],
      ["e480", "\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"],
      ["e540", "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC"],
      ["e580", "\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"],
      ["e640", "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7"],
      ["e680", "\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"],
      ["e740", "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C"],
      ["e780", "\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"],
      ["e840", "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599"],
      ["e880", "\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"],
      ["e940", "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43"],
      ["e980", "\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"],
      ["ea40", "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF"],
      ["ea80", "\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0\u582F\u69C7\u9059\u7464\u51DC\u7199"],
      ["ed40", "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F"],
      ["ed80", "\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"],
      ["ee40", "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559"],
      ["ee80", "\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"],
      ["eeef", "\u2170", 9, "\uFFE2\uFFE4\uFF07\uFF02"],
      ["f040", "\uE000", 62],
      ["f080", "\uE03F", 124],
      ["f140", "\uE0BC", 62],
      ["f180", "\uE0FB", 124],
      ["f240", "\uE178", 62],
      ["f280", "\uE1B7", 124],
      ["f340", "\uE234", 62],
      ["f380", "\uE273", 124],
      ["f440", "\uE2F0", 62],
      ["f480", "\uE32F", 124],
      ["f540", "\uE3AC", 62],
      ["f580", "\uE3EB", 124],
      ["f640", "\uE468", 62],
      ["f680", "\uE4A7", 124],
      ["f740", "\uE524", 62],
      ["f780", "\uE563", 124],
      ["f840", "\uE5E0", 62],
      ["f880", "\uE61F", 124],
      ["f940", "\uE69C"],
      ["fa40", "\u2170", 9, "\u2160", 9, "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u2235\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A"],
      ["fa80", "\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F"],
      ["fb40", "\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19"],
      ["fb80", "\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9"],
      ["fc40", "\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS({
  "node_modules/iconv-lite/encodings/tables/eucjp.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["8ea1", "\uFF61", 62],
      ["a1a1", "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008", 9, "\uFF0B\uFF0D\xB1\xD7\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7"],
      ["a2a1", "\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"],
      ["a2ba", "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"],
      ["a2ca", "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"],
      ["a2dc", "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"],
      ["a2f2", "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"],
      ["a2fe", "\u25EF"],
      ["a3b0", "\uFF10", 9],
      ["a3c1", "\uFF21", 25],
      ["a3e1", "\uFF41", 25],
      ["a4a1", "\u3041", 82],
      ["a5a1", "\u30A1", 85],
      ["a6a1", "\u0391", 16, "\u03A3", 6],
      ["a6c1", "\u03B1", 16, "\u03C3", 6],
      ["a7a1", "\u0410", 5, "\u0401\u0416", 25],
      ["a7d1", "\u0430", 5, "\u0451\u0436", 25],
      ["a8a1", "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"],
      ["ada1", "\u2460", 19, "\u2160", 9],
      ["adc0", "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"],
      ["addf", "\u337B\u301D\u301F\u2116\u33CD\u2121\u32A4", 4, "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"],
      ["b0a1", "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"],
      ["b1a1", "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC"],
      ["b2a1", "\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"],
      ["b3a1", "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431"],
      ["b4a1", "\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"],
      ["b5a1", "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC"],
      ["b6a1", "\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"],
      ["b7a1", "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372"],
      ["b8a1", "\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"],
      ["b9a1", "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC"],
      ["baa1", "\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"],
      ["bba1", "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642"],
      ["bca1", "\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"],
      ["bda1", "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F"],
      ["bea1", "\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"],
      ["bfa1", "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE"],
      ["c0a1", "\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"],
      ["c1a1", "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E"],
      ["c2a1", "\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"],
      ["c3a1", "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5"],
      ["c4a1", "\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"],
      ["c5a1", "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230"],
      ["c6a1", "\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"],
      ["c7a1", "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6"],
      ["c8a1", "\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"],
      ["c9a1", "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D"],
      ["caa1", "\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"],
      ["cba1", "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80"],
      ["cca1", "\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"],
      ["cda1", "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483"],
      ["cea1", "\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"],
      ["cfa1", "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"],
      ["d0a1", "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"],
      ["d1a1", "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8"],
      ["d2a1", "\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"],
      ["d3a1", "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709"],
      ["d4a1", "\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"],
      ["d5a1", "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53"],
      ["d6a1", "\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"],
      ["d7a1", "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A"],
      ["d8a1", "\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"],
      ["d9a1", "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC"],
      ["daa1", "\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"],
      ["dba1", "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD"],
      ["dca1", "\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"],
      ["dda1", "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE"],
      ["dea1", "\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"],
      ["dfa1", "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC"],
      ["e0a1", "\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"],
      ["e1a1", "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670"],
      ["e2a1", "\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"],
      ["e3a1", "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50"],
      ["e4a1", "\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"],
      ["e5a1", "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A"],
      ["e6a1", "\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"],
      ["e7a1", "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9"],
      ["e8a1", "\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"],
      ["e9a1", "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759"],
      ["eaa1", "\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"],
      ["eba1", "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B"],
      ["eca1", "\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"],
      ["eda1", "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8"],
      ["eea1", "\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"],
      ["efa1", "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E"],
      ["f0a1", "\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"],
      ["f1a1", "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7"],
      ["f2a1", "\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"],
      ["f3a1", "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0"],
      ["f4a1", "\u582F\u69C7\u9059\u7464\u51DC\u7199"],
      ["f9a1", "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7"],
      ["faa1", "\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"],
      ["fba1", "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA"],
      ["fca1", "\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"],
      ["fcf1", "\u2170", 9, "\uFFE2\uFFE4\uFF07\uFF02"],
      ["8fa2af", "\u02D8\u02C7\xB8\u02D9\u02DD\xAF\u02DB\u02DA\uFF5E\u0384\u0385"],
      ["8fa2c2", "\xA1\xA6\xBF"],
      ["8fa2eb", "\xBA\xAA\xA9\xAE\u2122\xA4\u2116"],
      ["8fa6e1", "\u0386\u0388\u0389\u038A\u03AA"],
      ["8fa6e7", "\u038C"],
      ["8fa6e9", "\u038E\u03AB"],
      ["8fa6ec", "\u038F"],
      ["8fa6f1", "\u03AC\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03C2\u03CD\u03CB\u03B0\u03CE"],
      ["8fa7c2", "\u0402", 10, "\u040E\u040F"],
      ["8fa7f2", "\u0452", 10, "\u045E\u045F"],
      ["8fa9a1", "\xC6\u0110"],
      ["8fa9a4", "\u0126"],
      ["8fa9a6", "\u0132"],
      ["8fa9a8", "\u0141\u013F"],
      ["8fa9ab", "\u014A\xD8\u0152"],
      ["8fa9af", "\u0166\xDE"],
      ["8fa9c1", "\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0142\u0140\u0149\u014B\xF8\u0153\xDF\u0167\xFE"],
      ["8faaa1", "\xC1\xC0\xC4\xC2\u0102\u01CD\u0100\u0104\xC5\xC3\u0106\u0108\u010C\xC7\u010A\u010E\xC9\xC8\xCB\xCA\u011A\u0116\u0112\u0118"],
      ["8faaba", "\u011C\u011E\u0122\u0120\u0124\xCD\xCC\xCF\xCE\u01CF\u0130\u012A\u012E\u0128\u0134\u0136\u0139\u013D\u013B\u0143\u0147\u0145\xD1\xD3\xD2\xD6\xD4\u01D1\u0150\u014C\xD5\u0154\u0158\u0156\u015A\u015C\u0160\u015E\u0164\u0162\xDA\xD9\xDC\xDB\u016C\u01D3\u0170\u016A\u0172\u016E\u0168\u01D7\u01DB\u01D9\u01D5\u0174\xDD\u0178\u0176\u0179\u017D\u017B"],
      ["8faba1", "\xE1\xE0\xE4\xE2\u0103\u01CE\u0101\u0105\xE5\xE3\u0107\u0109\u010D\xE7\u010B\u010F\xE9\xE8\xEB\xEA\u011B\u0117\u0113\u0119\u01F5\u011D\u011F"],
      ["8fabbd", "\u0121\u0125\xED\xEC\xEF\xEE\u01D0"],
      ["8fabc5", "\u012B\u012F\u0129\u0135\u0137\u013A\u013E\u013C\u0144\u0148\u0146\xF1\xF3\xF2\xF6\xF4\u01D2\u0151\u014D\xF5\u0155\u0159\u0157\u015B\u015D\u0161\u015F\u0165\u0163\xFA\xF9\xFC\xFB\u016D\u01D4\u0171\u016B\u0173\u016F\u0169\u01D8\u01DC\u01DA\u01D6\u0175\xFD\xFF\u0177\u017A\u017E\u017C"],
      ["8fb0a1", "\u4E02\u4E04\u4E05\u4E0C\u4E12\u4E1F\u4E23\u4E24\u4E28\u4E2B\u4E2E\u4E2F\u4E30\u4E35\u4E40\u4E41\u4E44\u4E47\u4E51\u4E5A\u4E5C\u4E63\u4E68\u4E69\u4E74\u4E75\u4E79\u4E7F\u4E8D\u4E96\u4E97\u4E9D\u4EAF\u4EB9\u4EC3\u4ED0\u4EDA\u4EDB\u4EE0\u4EE1\u4EE2\u4EE8\u4EEF\u4EF1\u4EF3\u4EF5\u4EFD\u4EFE\u4EFF\u4F00\u4F02\u4F03\u4F08\u4F0B\u4F0C\u4F12\u4F15\u4F16\u4F17\u4F19\u4F2E\u4F31\u4F60\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E\u4F40\u4F42\u4F48\u4F49\u4F4B\u4F4C\u4F52\u4F54\u4F56\u4F58\u4F5F\u4F63\u4F6A\u4F6C\u4F6E\u4F71\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F7E\u4F81\u4F82\u4F84"],
      ["8fb1a1", "\u4F85\u4F89\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F94\u4F97\u4F99\u4F9A\u4F9E\u4F9F\u4FB2\u4FB7\u4FB9\u4FBB\u4FBC\u4FBD\u4FBE\u4FC0\u4FC1\u4FC5\u4FC6\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FCF\u4FD2\u4FDC\u4FE0\u4FE2\u4FF0\u4FF2\u4FFC\u4FFD\u4FFF\u5000\u5001\u5004\u5007\u500A\u500C\u500E\u5010\u5013\u5017\u5018\u501B\u501C\u501D\u501E\u5022\u5027\u502E\u5030\u5032\u5033\u5035\u5040\u5041\u5042\u5045\u5046\u504A\u504C\u504E\u5051\u5052\u5053\u5057\u5059\u505F\u5060\u5062\u5063\u5066\u5067\u506A\u506D\u5070\u5071\u503B\u5081\u5083\u5084\u5086\u508A\u508E\u508F\u5090"],
      ["8fb2a1", "\u5092\u5093\u5094\u5096\u509B\u509C\u509E", 4, "\u50AA\u50AF\u50B0\u50B9\u50BA\u50BD\u50C0\u50C3\u50C4\u50C7\u50CC\u50CE\u50D0\u50D3\u50D4\u50D8\u50DC\u50DD\u50DF\u50E2\u50E4\u50E6\u50E8\u50E9\u50EF\u50F1\u50F6\u50FA\u50FE\u5103\u5106\u5107\u5108\u510B\u510C\u510D\u510E\u50F2\u5110\u5117\u5119\u511B\u511C\u511D\u511E\u5123\u5127\u5128\u512C\u512D\u512F\u5131\u5133\u5134\u5135\u5138\u5139\u5142\u514A\u514F\u5153\u5155\u5157\u5158\u515F\u5164\u5166\u517E\u5183\u5184\u518B\u518E\u5198\u519D\u51A1\u51A3\u51AD\u51B8\u51BA\u51BC\u51BE\u51BF\u51C2"],
      ["8fb3a1", "\u51C8\u51CF\u51D1\u51D2\u51D3\u51D5\u51D8\u51DE\u51E2\u51E5\u51EE\u51F2\u51F3\u51F4\u51F7\u5201\u5202\u5205\u5212\u5213\u5215\u5216\u5218\u5222\u5228\u5231\u5232\u5235\u523C\u5245\u5249\u5255\u5257\u5258\u525A\u525C\u525F\u5260\u5261\u5266\u526E\u5277\u5278\u5279\u5280\u5282\u5285\u528A\u528C\u5293\u5295\u5296\u5297\u5298\u529A\u529C\u52A4\u52A5\u52A6\u52A7\u52AF\u52B0\u52B6\u52B7\u52B8\u52BA\u52BB\u52BD\u52C0\u52C4\u52C6\u52C8\u52CC\u52CF\u52D1\u52D4\u52D6\u52DB\u52DC\u52E1\u52E5\u52E8\u52E9\u52EA\u52EC\u52F0\u52F1\u52F4\u52F6\u52F7\u5300\u5303\u530A\u530B"],
      ["8fb4a1", "\u530C\u5311\u5313\u5318\u531B\u531C\u531E\u531F\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u5330\u5332\u5335\u533C\u533D\u533E\u5342\u534C\u534B\u5359\u535B\u5361\u5363\u5365\u536C\u536D\u5372\u5379\u537E\u5383\u5387\u5388\u538E\u5393\u5394\u5399\u539D\u53A1\u53A4\u53AA\u53AB\u53AF\u53B2\u53B4\u53B5\u53B7\u53B8\u53BA\u53BD\u53C0\u53C5\u53CF\u53D2\u53D3\u53D5\u53DA\u53DD\u53DE\u53E0\u53E6\u53E7\u53F5\u5402\u5413\u541A\u5421\u5427\u5428\u542A\u542F\u5431\u5434\u5435\u5443\u5444\u5447\u544D\u544F\u545E\u5462\u5464\u5466\u5467\u5469\u546B\u546D\u546E\u5474\u547F"],
      ["8fb5a1", "\u5481\u5483\u5485\u5488\u5489\u548D\u5491\u5495\u5496\u549C\u549F\u54A1\u54A6\u54A7\u54A9\u54AA\u54AD\u54AE\u54B1\u54B7\u54B9\u54BA\u54BB\u54BF\u54C6\u54CA\u54CD\u54CE\u54E0\u54EA\u54EC\u54EF\u54F6\u54FC\u54FE\u54FF\u5500\u5501\u5505\u5508\u5509\u550C\u550D\u550E\u5515\u552A\u552B\u5532\u5535\u5536\u553B\u553C\u553D\u5541\u5547\u5549\u554A\u554D\u5550\u5551\u5558\u555A\u555B\u555E\u5560\u5561\u5564\u5566\u557F\u5581\u5582\u5586\u5588\u558E\u558F\u5591\u5592\u5593\u5594\u5597\u55A3\u55A4\u55AD\u55B2\u55BF\u55C1\u55C3\u55C6\u55C9\u55CB\u55CC\u55CE\u55D1\u55D2"],
      ["8fb6a1", "\u55D3\u55D7\u55D8\u55DB\u55DE\u55E2\u55E9\u55F6\u55FF\u5605\u5608\u560A\u560D", 5, "\u5619\u562C\u5630\u5633\u5635\u5637\u5639\u563B\u563C\u563D\u563F\u5640\u5641\u5643\u5644\u5646\u5649\u564B\u564D\u564F\u5654\u565E\u5660\u5661\u5662\u5663\u5666\u5669\u566D\u566F\u5671\u5672\u5675\u5684\u5685\u5688\u568B\u568C\u5695\u5699\u569A\u569D\u569E\u569F\u56A6\u56A7\u56A8\u56A9\u56AB\u56AC\u56AD\u56B1\u56B3\u56B7\u56BE\u56C5\u56C9\u56CA\u56CB\u56CF\u56D0\u56CC\u56CD\u56D9\u56DC\u56DD\u56DF\u56E1\u56E4", 4, "\u56F1\u56EB\u56ED"],
      ["8fb7a1", "\u56F6\u56F7\u5701\u5702\u5707\u570A\u570C\u5711\u5715\u571A\u571B\u571D\u5720\u5722\u5723\u5724\u5725\u5729\u572A\u572C\u572E\u572F\u5733\u5734\u573D\u573E\u573F\u5745\u5746\u574C\u574D\u5752\u5762\u5765\u5767\u5768\u576B\u576D", 4, "\u5773\u5774\u5775\u5777\u5779\u577A\u577B\u577C\u577E\u5781\u5783\u578C\u5794\u5797\u5799\u579A\u579C\u579D\u579E\u579F\u57A1\u5795\u57A7\u57A8\u57A9\u57AC\u57B8\u57BD\u57C7\u57C8\u57CC\u57CF\u57D5\u57DD\u57DE\u57E4\u57E6\u57E7\u57E9\u57ED\u57F0\u57F5\u57F6\u57F8\u57FD\u57FE\u57FF\u5803\u5804\u5808\u5809\u57E1"],
      ["8fb8a1", "\u580C\u580D\u581B\u581E\u581F\u5820\u5826\u5827\u582D\u5832\u5839\u583F\u5849\u584C\u584D\u584F\u5850\u5855\u585F\u5861\u5864\u5867\u5868\u5878\u587C\u587F\u5880\u5881\u5887\u5888\u5889\u588A\u588C\u588D\u588F\u5890\u5894\u5896\u589D\u58A0\u58A1\u58A2\u58A6\u58A9\u58B1\u58B2\u58C4\u58BC\u58C2\u58C8\u58CD\u58CE\u58D0\u58D2\u58D4\u58D6\u58DA\u58DD\u58E1\u58E2\u58E9\u58F3\u5905\u5906\u590B\u590C\u5912\u5913\u5914\u8641\u591D\u5921\u5923\u5924\u5928\u592F\u5930\u5933\u5935\u5936\u593F\u5943\u5946\u5952\u5953\u5959\u595B\u595D\u595E\u595F\u5961\u5963\u596B\u596D"],
      ["8fb9a1", "\u596F\u5972\u5975\u5976\u5979\u597B\u597C\u598B\u598C\u598E\u5992\u5995\u5997\u599F\u59A4\u59A7\u59AD\u59AE\u59AF\u59B0\u59B3\u59B7\u59BA\u59BC\u59C1\u59C3\u59C4\u59C8\u59CA\u59CD\u59D2\u59DD\u59DE\u59DF\u59E3\u59E4\u59E7\u59EE\u59EF\u59F1\u59F2\u59F4\u59F7\u5A00\u5A04\u5A0C\u5A0D\u5A0E\u5A12\u5A13\u5A1E\u5A23\u5A24\u5A27\u5A28\u5A2A\u5A2D\u5A30\u5A44\u5A45\u5A47\u5A48\u5A4C\u5A50\u5A55\u5A5E\u5A63\u5A65\u5A67\u5A6D\u5A77\u5A7A\u5A7B\u5A7E\u5A8B\u5A90\u5A93\u5A96\u5A99\u5A9C\u5A9E\u5A9F\u5AA0\u5AA2\u5AA7\u5AAC\u5AB1\u5AB2\u5AB3\u5AB5\u5AB8\u5ABA\u5ABB\u5ABF"],
      ["8fbaa1", "\u5AC4\u5AC6\u5AC8\u5ACF\u5ADA\u5ADC\u5AE0\u5AE5\u5AEA\u5AEE\u5AF5\u5AF6\u5AFD\u5B00\u5B01\u5B08\u5B17\u5B34\u5B19\u5B1B\u5B1D\u5B21\u5B25\u5B2D\u5B38\u5B41\u5B4B\u5B4C\u5B52\u5B56\u5B5E\u5B68\u5B6E\u5B6F\u5B7C\u5B7D\u5B7E\u5B7F\u5B81\u5B84\u5B86\u5B8A\u5B8E\u5B90\u5B91\u5B93\u5B94\u5B96\u5BA8\u5BA9\u5BAC\u5BAD\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBC\u5BC0\u5BC1\u5BCD\u5BCF\u5BD6", 4, "\u5BE0\u5BEF\u5BF1\u5BF4\u5BFD\u5C0C\u5C17\u5C1E\u5C1F\u5C23\u5C26\u5C29\u5C2B\u5C2C\u5C2E\u5C30\u5C32\u5C35\u5C36\u5C59\u5C5A\u5C5C\u5C62\u5C63\u5C67\u5C68\u5C69"],
      ["8fbba1", "\u5C6D\u5C70\u5C74\u5C75\u5C7A\u5C7B\u5C7C\u5C7D\u5C87\u5C88\u5C8A\u5C8F\u5C92\u5C9D\u5C9F\u5CA0\u5CA2\u5CA3\u5CA6\u5CAA\u5CB2\u5CB4\u5CB5\u5CBA\u5CC9\u5CCB\u5CD2\u5CDD\u5CD7\u5CEE\u5CF1\u5CF2\u5CF4\u5D01\u5D06\u5D0D\u5D12\u5D2B\u5D23\u5D24\u5D26\u5D27\u5D31\u5D34\u5D39\u5D3D\u5D3F\u5D42\u5D43\u5D46\u5D48\u5D55\u5D51\u5D59\u5D4A\u5D5F\u5D60\u5D61\u5D62\u5D64\u5D6A\u5D6D\u5D70\u5D79\u5D7A\u5D7E\u5D7F\u5D81\u5D83\u5D88\u5D8A\u5D92\u5D93\u5D94\u5D95\u5D99\u5D9B\u5D9F\u5DA0\u5DA7\u5DAB\u5DB0\u5DB4\u5DB8\u5DB9\u5DC3\u5DC7\u5DCB\u5DD0\u5DCE\u5DD8\u5DD9\u5DE0\u5DE4"],
      ["8fbca1", "\u5DE9\u5DF8\u5DF9\u5E00\u5E07\u5E0D\u5E12\u5E14\u5E15\u5E18\u5E1F\u5E20\u5E2E\u5E28\u5E32\u5E35\u5E3E\u5E4B\u5E50\u5E49\u5E51\u5E56\u5E58\u5E5B\u5E5C\u5E5E\u5E68\u5E6A", 4, "\u5E70\u5E80\u5E8B\u5E8E\u5EA2\u5EA4\u5EA5\u5EA8\u5EAA\u5EAC\u5EB1\u5EB3\u5EBD\u5EBE\u5EBF\u5EC6\u5ECC\u5ECB\u5ECE\u5ED1\u5ED2\u5ED4\u5ED5\u5EDC\u5EDE\u5EE5\u5EEB\u5F02\u5F06\u5F07\u5F08\u5F0E\u5F19\u5F1C\u5F1D\u5F21\u5F22\u5F23\u5F24\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F34\u5F36\u5F3B\u5F3D\u5F3F\u5F40\u5F44\u5F45\u5F47\u5F4D\u5F50\u5F54\u5F58\u5F5B\u5F60\u5F63\u5F64\u5F67"],
      ["8fbda1", "\u5F6F\u5F72\u5F74\u5F75\u5F78\u5F7A\u5F7D\u5F7E\u5F89\u5F8D\u5F8F\u5F96\u5F9C\u5F9D\u5FA2\u5FA7\u5FAB\u5FA4\u5FAC\u5FAF\u5FB0\u5FB1\u5FB8\u5FC4\u5FC7\u5FC8\u5FC9\u5FCB\u5FD0", 4, "\u5FDE\u5FE1\u5FE2\u5FE8\u5FE9\u5FEA\u5FEC\u5FED\u5FEE\u5FEF\u5FF2\u5FF3\u5FF6\u5FFA\u5FFC\u6007\u600A\u600D\u6013\u6014\u6017\u6018\u601A\u601F\u6024\u602D\u6033\u6035\u6040\u6047\u6048\u6049\u604C\u6051\u6054\u6056\u6057\u605D\u6061\u6067\u6071\u607E\u607F\u6082\u6086\u6088\u608A\u608E\u6091\u6093\u6095\u6098\u609D\u609E\u60A2\u60A4\u60A5\u60A8\u60B0\u60B1\u60B7"],
      ["8fbea1", "\u60BB\u60BE\u60C2\u60C4\u60C8\u60C9\u60CA\u60CB\u60CE\u60CF\u60D4\u60D5\u60D9\u60DB\u60DD\u60DE\u60E2\u60E5\u60F2\u60F5\u60F8\u60FC\u60FD\u6102\u6107\u610A\u610C\u6110", 4, "\u6116\u6117\u6119\u611C\u611E\u6122\u612A\u612B\u6130\u6131\u6135\u6136\u6137\u6139\u6141\u6145\u6146\u6149\u615E\u6160\u616C\u6172\u6178\u617B\u617C\u617F\u6180\u6181\u6183\u6184\u618B\u618D\u6192\u6193\u6197\u6198\u619C\u619D\u619F\u61A0\u61A5\u61A8\u61AA\u61AD\u61B8\u61B9\u61BC\u61C0\u61C1\u61C2\u61CE\u61CF\u61D5\u61DC\u61DD\u61DE\u61DF\u61E1\u61E2\u61E7\u61E9\u61E5"],
      ["8fbfa1", "\u61EC\u61ED\u61EF\u6201\u6203\u6204\u6207\u6213\u6215\u621C\u6220\u6222\u6223\u6227\u6229\u622B\u6239\u623D\u6242\u6243\u6244\u6246\u624C\u6250\u6251\u6252\u6254\u6256\u625A\u625C\u6264\u626D\u626F\u6273\u627A\u627D\u628D\u628E\u628F\u6290\u62A6\u62A8\u62B3\u62B6\u62B7\u62BA\u62BE\u62BF\u62C4\u62CE\u62D5\u62D6\u62DA\u62EA\u62F2\u62F4\u62FC\u62FD\u6303\u6304\u630A\u630B\u630D\u6310\u6313\u6316\u6318\u6329\u632A\u632D\u6335\u6336\u6339\u633C\u6341\u6342\u6343\u6344\u6346\u634A\u634B\u634E\u6352\u6353\u6354\u6358\u635B\u6365\u6366\u636C\u636D\u6371\u6374\u6375"],
      ["8fc0a1", "\u6378\u637C\u637D\u637F\u6382\u6384\u6387\u638A\u6390\u6394\u6395\u6399\u639A\u639E\u63A4\u63A6\u63AD\u63AE\u63AF\u63BD\u63C1\u63C5\u63C8\u63CE\u63D1\u63D3\u63D4\u63D5\u63DC\u63E0\u63E5\u63EA\u63EC\u63F2\u63F3\u63F5\u63F8\u63F9\u6409\u640A\u6410\u6412\u6414\u6418\u641E\u6420\u6422\u6424\u6425\u6429\u642A\u642F\u6430\u6435\u643D\u643F\u644B\u644F\u6451\u6452\u6453\u6454\u645A\u645B\u645C\u645D\u645F\u6460\u6461\u6463\u646D\u6473\u6474\u647B\u647D\u6485\u6487\u648F\u6490\u6491\u6498\u6499\u649B\u649D\u649F\u64A1\u64A3\u64A6\u64A8\u64AC\u64B3\u64BD\u64BE\u64BF"],
      ["8fc1a1", "\u64C4\u64C9\u64CA\u64CB\u64CC\u64CE\u64D0\u64D1\u64D5\u64D7\u64E4\u64E5\u64E9\u64EA\u64ED\u64F0\u64F5\u64F7\u64FB\u64FF\u6501\u6504\u6508\u6509\u650A\u650F\u6513\u6514\u6516\u6519\u651B\u651E\u651F\u6522\u6526\u6529\u652E\u6531\u653A\u653C\u653D\u6543\u6547\u6549\u6550\u6552\u6554\u655F\u6560\u6567\u656B\u657A\u657D\u6581\u6585\u658A\u6592\u6595\u6598\u659D\u65A0\u65A3\u65A6\u65AE\u65B2\u65B3\u65B4\u65BF\u65C2\u65C8\u65C9\u65CE\u65D0\u65D4\u65D6\u65D8\u65DF\u65F0\u65F2\u65F4\u65F5\u65F9\u65FE\u65FF\u6600\u6604\u6608\u6609\u660D\u6611\u6612\u6615\u6616\u661D"],
      ["8fc2a1", "\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6631\u6633\u6639\u6637\u6640\u6645\u6646\u664A\u664C\u6651\u664E\u6657\u6658\u6659\u665B\u665C\u6660\u6661\u66FB\u666A\u666B\u666C\u667E\u6673\u6675\u667F\u6677\u6678\u6679\u667B\u6680\u667C\u668B\u668C\u668D\u6690\u6692\u6699\u669A\u669B\u669C\u669F\u66A0\u66A4\u66AD\u66B1\u66B2\u66B5\u66BB\u66BF\u66C0\u66C2\u66C3\u66C8\u66CC\u66CE\u66CF\u66D4\u66DB\u66DF\u66E8\u66EB\u66EC\u66EE\u66FA\u6705\u6707\u670E\u6713\u6719\u671C\u6720\u6722\u6733\u673E\u6745\u6747\u6748\u674C\u6754\u6755\u675D"],
      ["8fc3a1", "\u6766\u676C\u676E\u6774\u6776\u677B\u6781\u6784\u678E\u678F\u6791\u6793\u6796\u6798\u6799\u679B\u67B0\u67B1\u67B2\u67B5\u67BB\u67BC\u67BD\u67F9\u67C0\u67C2\u67C3\u67C5\u67C8\u67C9\u67D2\u67D7\u67D9\u67DC\u67E1\u67E6\u67F0\u67F2\u67F6\u67F7\u6852\u6814\u6819\u681D\u681F\u6828\u6827\u682C\u682D\u682F\u6830\u6831\u6833\u683B\u683F\u6844\u6845\u684A\u684C\u6855\u6857\u6858\u685B\u686B\u686E", 4, "\u6875\u6879\u687A\u687B\u687C\u6882\u6884\u6886\u6888\u6896\u6898\u689A\u689C\u68A1\u68A3\u68A5\u68A9\u68AA\u68AE\u68B2\u68BB\u68C5\u68C8\u68CC\u68CF"],
      ["8fc4a1", "\u68D0\u68D1\u68D3\u68D6\u68D9\u68DC\u68DD\u68E5\u68E8\u68EA\u68EB\u68EC\u68ED\u68F0\u68F1\u68F5\u68F6\u68FB\u68FC\u68FD\u6906\u6909\u690A\u6910\u6911\u6913\u6916\u6917\u6931\u6933\u6935\u6938\u693B\u6942\u6945\u6949\u694E\u6957\u695B\u6963\u6964\u6965\u6966\u6968\u6969\u696C\u6970\u6971\u6972\u697A\u697B\u697F\u6980\u698D\u6992\u6996\u6998\u69A1\u69A5\u69A6\u69A8\u69AB\u69AD\u69AF\u69B7\u69B8\u69BA\u69BC\u69C5\u69C8\u69D1\u69D6\u69D7\u69E2\u69E5\u69EE\u69EF\u69F1\u69F3\u69F5\u69FE\u6A00\u6A01\u6A03\u6A0F\u6A11\u6A15\u6A1A\u6A1D\u6A20\u6A24\u6A28\u6A30\u6A32"],
      ["8fc5a1", "\u6A34\u6A37\u6A3B\u6A3E\u6A3F\u6A45\u6A46\u6A49\u6A4A\u6A4E\u6A50\u6A51\u6A52\u6A55\u6A56\u6A5B\u6A64\u6A67\u6A6A\u6A71\u6A73\u6A7E\u6A81\u6A83\u6A86\u6A87\u6A89\u6A8B\u6A91\u6A9B\u6A9D\u6A9E\u6A9F\u6AA5\u6AAB\u6AAF\u6AB0\u6AB1\u6AB4\u6ABD\u6ABE\u6ABF\u6AC6\u6AC9\u6AC8\u6ACC\u6AD0\u6AD4\u6AD5\u6AD6\u6ADC\u6ADD\u6AE4\u6AE7\u6AEC\u6AF0\u6AF1\u6AF2\u6AFC\u6AFD\u6B02\u6B03\u6B06\u6B07\u6B09\u6B0F\u6B10\u6B11\u6B17\u6B1B\u6B1E\u6B24\u6B28\u6B2B\u6B2C\u6B2F\u6B35\u6B36\u6B3B\u6B3F\u6B46\u6B4A\u6B4D\u6B52\u6B56\u6B58\u6B5D\u6B60\u6B67\u6B6B\u6B6E\u6B70\u6B75\u6B7D"],
      ["8fc6a1", "\u6B7E\u6B82\u6B85\u6B97\u6B9B\u6B9F\u6BA0\u6BA2\u6BA3\u6BA8\u6BA9\u6BAC\u6BAD\u6BAE\u6BB0\u6BB8\u6BB9\u6BBD\u6BBE\u6BC3\u6BC4\u6BC9\u6BCC\u6BD6\u6BDA\u6BE1\u6BE3\u6BE6\u6BE7\u6BEE\u6BF1\u6BF7\u6BF9\u6BFF\u6C02\u6C04\u6C05\u6C09\u6C0D\u6C0E\u6C10\u6C12\u6C19\u6C1F\u6C26\u6C27\u6C28\u6C2C\u6C2E\u6C33\u6C35\u6C36\u6C3A\u6C3B\u6C3F\u6C4A\u6C4B\u6C4D\u6C4F\u6C52\u6C54\u6C59\u6C5B\u6C5C\u6C6B\u6C6D\u6C6F\u6C74\u6C76\u6C78\u6C79\u6C7B\u6C85\u6C86\u6C87\u6C89\u6C94\u6C95\u6C97\u6C98\u6C9C\u6C9F\u6CB0\u6CB2\u6CB4\u6CC2\u6CC6\u6CCD\u6CCF\u6CD0\u6CD1\u6CD2\u6CD4\u6CD6"],
      ["8fc7a1", "\u6CDA\u6CDC\u6CE0\u6CE7\u6CE9\u6CEB\u6CEC\u6CEE\u6CF2\u6CF4\u6D04\u6D07\u6D0A\u6D0E\u6D0F\u6D11\u6D13\u6D1A\u6D26\u6D27\u6D28\u6C67\u6D2E\u6D2F\u6D31\u6D39\u6D3C\u6D3F\u6D57\u6D5E\u6D5F\u6D61\u6D65\u6D67\u6D6F\u6D70\u6D7C\u6D82\u6D87\u6D91\u6D92\u6D94\u6D96\u6D97\u6D98\u6DAA\u6DAC\u6DB4\u6DB7\u6DB9\u6DBD\u6DBF\u6DC4\u6DC8\u6DCA\u6DCE\u6DCF\u6DD6\u6DDB\u6DDD\u6DDF\u6DE0\u6DE2\u6DE5\u6DE9\u6DEF\u6DF0\u6DF4\u6DF6\u6DFC\u6E00\u6E04\u6E1E\u6E22\u6E27\u6E32\u6E36\u6E39\u6E3B\u6E3C\u6E44\u6E45\u6E48\u6E49\u6E4B\u6E4F\u6E51\u6E52\u6E53\u6E54\u6E57\u6E5C\u6E5D\u6E5E"],
      ["8fc8a1", "\u6E62\u6E63\u6E68\u6E73\u6E7B\u6E7D\u6E8D\u6E93\u6E99\u6EA0\u6EA7\u6EAD\u6EAE\u6EB1\u6EB3\u6EBB\u6EBF\u6EC0\u6EC1\u6EC3\u6EC7\u6EC8\u6ECA\u6ECD\u6ECE\u6ECF\u6EEB\u6EED\u6EEE\u6EF9\u6EFB\u6EFD\u6F04\u6F08\u6F0A\u6F0C\u6F0D\u6F16\u6F18\u6F1A\u6F1B\u6F26\u6F29\u6F2A\u6F2F\u6F30\u6F33\u6F36\u6F3B\u6F3C\u6F2D\u6F4F\u6F51\u6F52\u6F53\u6F57\u6F59\u6F5A\u6F5D\u6F5E\u6F61\u6F62\u6F68\u6F6C\u6F7D\u6F7E\u6F83\u6F87\u6F88\u6F8B\u6F8C\u6F8D\u6F90\u6F92\u6F93\u6F94\u6F96\u6F9A\u6F9F\u6FA0\u6FA5\u6FA6\u6FA7\u6FA8\u6FAE\u6FAF\u6FB0\u6FB5\u6FB6\u6FBC\u6FC5\u6FC7\u6FC8\u6FCA"],
      ["8fc9a1", "\u6FDA\u6FDE\u6FE8\u6FE9\u6FF0\u6FF5\u6FF9\u6FFC\u6FFD\u7000\u7005\u7006\u7007\u700D\u7017\u7020\u7023\u702F\u7034\u7037\u7039\u703C\u7043\u7044\u7048\u7049\u704A\u704B\u7054\u7055\u705D\u705E\u704E\u7064\u7065\u706C\u706E\u7075\u7076\u707E\u7081\u7085\u7086\u7094", 4, "\u709B\u70A4\u70AB\u70B0\u70B1\u70B4\u70B7\u70CA\u70D1\u70D3\u70D4\u70D5\u70D6\u70D8\u70DC\u70E4\u70FA\u7103", 4, "\u710B\u710C\u710F\u711E\u7120\u712B\u712D\u712F\u7130\u7131\u7138\u7141\u7145\u7146\u7147\u714A\u714B\u7150\u7152\u7157\u715A\u715C\u715E\u7160"],
      ["8fcaa1", "\u7168\u7179\u7180\u7185\u7187\u718C\u7192\u719A\u719B\u71A0\u71A2\u71AF\u71B0\u71B2\u71B3\u71BA\u71BF\u71C0\u71C1\u71C4\u71CB\u71CC\u71D3\u71D6\u71D9\u71DA\u71DC\u71F8\u71FE\u7200\u7207\u7208\u7209\u7213\u7217\u721A\u721D\u721F\u7224\u722B\u722F\u7234\u7238\u7239\u7241\u7242\u7243\u7245\u724E\u724F\u7250\u7253\u7255\u7256\u725A\u725C\u725E\u7260\u7263\u7268\u726B\u726E\u726F\u7271\u7277\u7278\u727B\u727C\u727F\u7284\u7289\u728D\u728E\u7293\u729B\u72A8\u72AD\u72AE\u72B1\u72B4\u72BE\u72C1\u72C7\u72C9\u72CC\u72D5\u72D6\u72D8\u72DF\u72E5\u72F3\u72F4\u72FA\u72FB"],
      ["8fcba1", "\u72FE\u7302\u7304\u7305\u7307\u730B\u730D\u7312\u7313\u7318\u7319\u731E\u7322\u7324\u7327\u7328\u732C\u7331\u7332\u7335\u733A\u733B\u733D\u7343\u734D\u7350\u7352\u7356\u7358\u735D\u735E\u735F\u7360\u7366\u7367\u7369\u736B\u736C\u736E\u736F\u7371\u7377\u7379\u737C\u7380\u7381\u7383\u7385\u7386\u738E\u7390\u7393\u7395\u7397\u7398\u739C\u739E\u739F\u73A0\u73A2\u73A5\u73A6\u73AA\u73AB\u73AD\u73B5\u73B7\u73B9\u73BC\u73BD\u73BF\u73C5\u73C6\u73C9\u73CB\u73CC\u73CF\u73D2\u73D3\u73D6\u73D9\u73DD\u73E1\u73E3\u73E6\u73E7\u73E9\u73F4\u73F5\u73F7\u73F9\u73FA\u73FB\u73FD"],
      ["8fcca1", "\u73FF\u7400\u7401\u7404\u7407\u740A\u7411\u741A\u741B\u7424\u7426\u7428", 9, "\u7439\u7440\u7443\u7444\u7446\u7447\u744B\u744D\u7451\u7452\u7457\u745D\u7462\u7466\u7467\u7468\u746B\u746D\u746E\u7471\u7472\u7480\u7481\u7485\u7486\u7487\u7489\u748F\u7490\u7491\u7492\u7498\u7499\u749A\u749C\u749F\u74A0\u74A1\u74A3\u74A6\u74A8\u74A9\u74AA\u74AB\u74AE\u74AF\u74B1\u74B2\u74B5\u74B9\u74BB\u74BF\u74C8\u74C9\u74CC\u74D0\u74D3\u74D8\u74DA\u74DB\u74DE\u74DF\u74E4\u74E8\u74EA\u74EB\u74EF\u74F4\u74FA\u74FB\u74FC\u74FF\u7506"],
      ["8fcda1", "\u7512\u7516\u7517\u7520\u7521\u7524\u7527\u7529\u752A\u752F\u7536\u7539\u753D\u753E\u753F\u7540\u7543\u7547\u7548\u754E\u7550\u7552\u7557\u755E\u755F\u7561\u756F\u7571\u7579", 5, "\u7581\u7585\u7590\u7592\u7593\u7595\u7599\u759C\u75A2\u75A4\u75B4\u75BA\u75BF\u75C0\u75C1\u75C4\u75C6\u75CC\u75CE\u75CF\u75D7\u75DC\u75DF\u75E0\u75E1\u75E4\u75E7\u75EC\u75EE\u75EF\u75F1\u75F9\u7600\u7602\u7603\u7604\u7607\u7608\u760A\u760C\u760F\u7612\u7613\u7615\u7616\u7619\u761B\u761C\u761D\u761E\u7623\u7625\u7626\u7629\u762D\u7632\u7633\u7635\u7638\u7639"],
      ["8fcea1", "\u763A\u763C\u764A\u7640\u7641\u7643\u7644\u7645\u7649\u764B\u7655\u7659\u765F\u7664\u7665\u766D\u766E\u766F\u7671\u7674\u7681\u7685\u768C\u768D\u7695\u769B\u769C\u769D\u769F\u76A0\u76A2", 6, "\u76AA\u76AD\u76BD\u76C1\u76C5\u76C9\u76CB\u76CC\u76CE\u76D4\u76D9\u76E0\u76E6\u76E8\u76EC\u76F0\u76F1\u76F6\u76F9\u76FC\u7700\u7706\u770A\u770E\u7712\u7714\u7715\u7717\u7719\u771A\u771C\u7722\u7728\u772D\u772E\u772F\u7734\u7735\u7736\u7739\u773D\u773E\u7742\u7745\u7746\u774A\u774D\u774E\u774F\u7752\u7756\u7757\u775C\u775E\u775F\u7760\u7762"],
      ["8fcfa1", "\u7764\u7767\u776A\u776C\u7770\u7772\u7773\u7774\u777A\u777D\u7780\u7784\u778C\u778D\u7794\u7795\u7796\u779A\u779F\u77A2\u77A7\u77AA\u77AE\u77AF\u77B1\u77B5\u77BE\u77C3\u77C9\u77D1\u77D2\u77D5\u77D9\u77DE\u77DF\u77E0\u77E4\u77E6\u77EA\u77EC\u77F0\u77F1\u77F4\u77F8\u77FB\u7805\u7806\u7809\u780D\u780E\u7811\u781D\u7821\u7822\u7823\u782D\u782E\u7830\u7835\u7837\u7843\u7844\u7847\u7848\u784C\u784E\u7852\u785C\u785E\u7860\u7861\u7863\u7864\u7868\u786A\u786E\u787A\u787E\u788A\u788F\u7894\u7898\u78A1\u789D\u789E\u789F\u78A4\u78A8\u78AC\u78AD\u78B0\u78B1\u78B2\u78B3"],
      ["8fd0a1", "\u78BB\u78BD\u78BF\u78C7\u78C8\u78C9\u78CC\u78CE\u78D2\u78D3\u78D5\u78D6\u78E4\u78DB\u78DF\u78E0\u78E1\u78E6\u78EA\u78F2\u78F3\u7900\u78F6\u78F7\u78FA\u78FB\u78FF\u7906\u790C\u7910\u791A\u791C\u791E\u791F\u7920\u7925\u7927\u7929\u792D\u7931\u7934\u7935\u793B\u793D\u793F\u7944\u7945\u7946\u794A\u794B\u794F\u7951\u7954\u7958\u795B\u795C\u7967\u7969\u796B\u7972\u7979\u797B\u797C\u797E\u798B\u798C\u7991\u7993\u7994\u7995\u7996\u7998\u799B\u799C\u79A1\u79A8\u79A9\u79AB\u79AF\u79B1\u79B4\u79B8\u79BB\u79C2\u79C4\u79C7\u79C8\u79CA\u79CF\u79D4\u79D6\u79DA\u79DD\u79DE"],
      ["8fd1a1", "\u79E0\u79E2\u79E5\u79EA\u79EB\u79ED\u79F1\u79F8\u79FC\u7A02\u7A03\u7A07\u7A09\u7A0A\u7A0C\u7A11\u7A15\u7A1B\u7A1E\u7A21\u7A27\u7A2B\u7A2D\u7A2F\u7A30\u7A34\u7A35\u7A38\u7A39\u7A3A\u7A44\u7A45\u7A47\u7A48\u7A4C\u7A55\u7A56\u7A59\u7A5C\u7A5D\u7A5F\u7A60\u7A65\u7A67\u7A6A\u7A6D\u7A75\u7A78\u7A7E\u7A80\u7A82\u7A85\u7A86\u7A8A\u7A8B\u7A90\u7A91\u7A94\u7A9E\u7AA0\u7AA3\u7AAC\u7AB3\u7AB5\u7AB9\u7ABB\u7ABC\u7AC6\u7AC9\u7ACC\u7ACE\u7AD1\u7ADB\u7AE8\u7AE9\u7AEB\u7AEC\u7AF1\u7AF4\u7AFB\u7AFD\u7AFE\u7B07\u7B14\u7B1F\u7B23\u7B27\u7B29\u7B2A\u7B2B\u7B2D\u7B2E\u7B2F\u7B30"],
      ["8fd2a1", "\u7B31\u7B34\u7B3D\u7B3F\u7B40\u7B41\u7B47\u7B4E\u7B55\u7B60\u7B64\u7B66\u7B69\u7B6A\u7B6D\u7B6F\u7B72\u7B73\u7B77\u7B84\u7B89\u7B8E\u7B90\u7B91\u7B96\u7B9B\u7B9E\u7BA0\u7BA5\u7BAC\u7BAF\u7BB0\u7BB2\u7BB5\u7BB6\u7BBA\u7BBB\u7BBC\u7BBD\u7BC2\u7BC5\u7BC8\u7BCA\u7BD4\u7BD6\u7BD7\u7BD9\u7BDA\u7BDB\u7BE8\u7BEA\u7BF2\u7BF4\u7BF5\u7BF8\u7BF9\u7BFA\u7BFC\u7BFE\u7C01\u7C02\u7C03\u7C04\u7C06\u7C09\u7C0B\u7C0C\u7C0E\u7C0F\u7C19\u7C1B\u7C20\u7C25\u7C26\u7C28\u7C2C\u7C31\u7C33\u7C34\u7C36\u7C39\u7C3A\u7C46\u7C4A\u7C55\u7C51\u7C52\u7C53\u7C59", 5],
      ["8fd3a1", "\u7C61\u7C63\u7C67\u7C69\u7C6D\u7C6E\u7C70\u7C72\u7C79\u7C7C\u7C7D\u7C86\u7C87\u7C8F\u7C94\u7C9E\u7CA0\u7CA6\u7CB0\u7CB6\u7CB7\u7CBA\u7CBB\u7CBC\u7CBF\u7CC4\u7CC7\u7CC8\u7CC9\u7CCD\u7CCF\u7CD3\u7CD4\u7CD5\u7CD7\u7CD9\u7CDA\u7CDD\u7CE6\u7CE9\u7CEB\u7CF5\u7D03\u7D07\u7D08\u7D09\u7D0F\u7D11\u7D12\u7D13\u7D16\u7D1D\u7D1E\u7D23\u7D26\u7D2A\u7D2D\u7D31\u7D3C\u7D3D\u7D3E\u7D40\u7D41\u7D47\u7D48\u7D4D\u7D51\u7D53\u7D57\u7D59\u7D5A\u7D5C\u7D5D\u7D65\u7D67\u7D6A\u7D70\u7D78\u7D7A\u7D7B\u7D7F\u7D81\u7D82\u7D83\u7D85\u7D86\u7D88\u7D8B\u7D8C\u7D8D\u7D91\u7D96\u7D97\u7D9D"],
      ["8fd4a1", "\u7D9E\u7DA6\u7DA7\u7DAA\u7DB3\u7DB6\u7DB7\u7DB9\u7DC2", 4, "\u7DCC\u7DCD\u7DCE\u7DD7\u7DD9\u7E00\u7DE2\u7DE5\u7DE6\u7DEA\u7DEB\u7DED\u7DF1\u7DF5\u7DF6\u7DF9\u7DFA\u7E08\u7E10\u7E11\u7E15\u7E17\u7E1C\u7E1D\u7E20\u7E27\u7E28\u7E2C\u7E2D\u7E2F\u7E33\u7E36\u7E3F\u7E44\u7E45\u7E47\u7E4E\u7E50\u7E52\u7E58\u7E5F\u7E61\u7E62\u7E65\u7E6B\u7E6E\u7E6F\u7E73\u7E78\u7E7E\u7E81\u7E86\u7E87\u7E8A\u7E8D\u7E91\u7E95\u7E98\u7E9A\u7E9D\u7E9E\u7F3C\u7F3B\u7F3D\u7F3E\u7F3F\u7F43\u7F44\u7F47\u7F4F\u7F52\u7F53\u7F5B\u7F5C\u7F5D\u7F61\u7F63\u7F64\u7F65\u7F66\u7F6D"],
      ["8fd5a1", "\u7F71\u7F7D\u7F7E\u7F7F\u7F80\u7F8B\u7F8D\u7F8F\u7F90\u7F91\u7F96\u7F97\u7F9C\u7FA1\u7FA2\u7FA6\u7FAA\u7FAD\u7FB4\u7FBC\u7FBF\u7FC0\u7FC3\u7FC8\u7FCE\u7FCF\u7FDB\u7FDF\u7FE3\u7FE5\u7FE8\u7FEC\u7FEE\u7FEF\u7FF2\u7FFA\u7FFD\u7FFE\u7FFF\u8007\u8008\u800A\u800D\u800E\u800F\u8011\u8013\u8014\u8016\u801D\u801E\u801F\u8020\u8024\u8026\u802C\u802E\u8030\u8034\u8035\u8037\u8039\u803A\u803C\u803E\u8040\u8044\u8060\u8064\u8066\u806D\u8071\u8075\u8081\u8088\u808E\u809C\u809E\u80A6\u80A7\u80AB\u80B8\u80B9\u80C8\u80CD\u80CF\u80D2\u80D4\u80D5\u80D7\u80D8\u80E0\u80ED\u80EE"],
      ["8fd6a1", "\u80F0\u80F2\u80F3\u80F6\u80F9\u80FA\u80FE\u8103\u810B\u8116\u8117\u8118\u811C\u811E\u8120\u8124\u8127\u812C\u8130\u8135\u813A\u813C\u8145\u8147\u814A\u814C\u8152\u8157\u8160\u8161\u8167\u8168\u8169\u816D\u816F\u8177\u8181\u8190\u8184\u8185\u8186\u818B\u818E\u8196\u8198\u819B\u819E\u81A2\u81AE\u81B2\u81B4\u81BB\u81CB\u81C3\u81C5\u81CA\u81CE\u81CF\u81D5\u81D7\u81DB\u81DD\u81DE\u81E1\u81E4\u81EB\u81EC\u81F0\u81F1\u81F2\u81F5\u81F6\u81F8\u81F9\u81FD\u81FF\u8200\u8203\u820F\u8213\u8214\u8219\u821A\u821D\u8221\u8222\u8228\u8232\u8234\u823A\u8243\u8244\u8245\u8246"],
      ["8fd7a1", "\u824B\u824E\u824F\u8251\u8256\u825C\u8260\u8263\u8267\u826D\u8274\u827B\u827D\u827F\u8280\u8281\u8283\u8284\u8287\u8289\u828A\u828E\u8291\u8294\u8296\u8298\u829A\u829B\u82A0\u82A1\u82A3\u82A4\u82A7\u82A8\u82A9\u82AA\u82AE\u82B0\u82B2\u82B4\u82B7\u82BA\u82BC\u82BE\u82BF\u82C6\u82D0\u82D5\u82DA\u82E0\u82E2\u82E4\u82E8\u82EA\u82ED\u82EF\u82F6\u82F7\u82FD\u82FE\u8300\u8301\u8307\u8308\u830A\u830B\u8354\u831B\u831D\u831E\u831F\u8321\u8322\u832C\u832D\u832E\u8330\u8333\u8337\u833A\u833C\u833D\u8342\u8343\u8344\u8347\u834D\u834E\u8351\u8355\u8356\u8357\u8370\u8378"],
      ["8fd8a1", "\u837D\u837F\u8380\u8382\u8384\u8386\u838D\u8392\u8394\u8395\u8398\u8399\u839B\u839C\u839D\u83A6\u83A7\u83A9\u83AC\u83BE\u83BF\u83C0\u83C7\u83C9\u83CF\u83D0\u83D1\u83D4\u83DD\u8353\u83E8\u83EA\u83F6\u83F8\u83F9\u83FC\u8401\u8406\u840A\u840F\u8411\u8415\u8419\u83AD\u842F\u8439\u8445\u8447\u8448\u844A\u844D\u844F\u8451\u8452\u8456\u8458\u8459\u845A\u845C\u8460\u8464\u8465\u8467\u846A\u8470\u8473\u8474\u8476\u8478\u847C\u847D\u8481\u8485\u8492\u8493\u8495\u849E\u84A6\u84A8\u84A9\u84AA\u84AF\u84B1\u84B4\u84BA\u84BD\u84BE\u84C0\u84C2\u84C7\u84C8\u84CC\u84CF\u84D3"],
      ["8fd9a1", "\u84DC\u84E7\u84EA\u84EF\u84F0\u84F1\u84F2\u84F7\u8532\u84FA\u84FB\u84FD\u8502\u8503\u8507\u850C\u850E\u8510\u851C\u851E\u8522\u8523\u8524\u8525\u8527\u852A\u852B\u852F\u8533\u8534\u8536\u853F\u8546\u854F", 4, "\u8556\u8559\u855C", 6, "\u8564\u856B\u856F\u8579\u857A\u857B\u857D\u857F\u8581\u8585\u8586\u8589\u858B\u858C\u858F\u8593\u8598\u859D\u859F\u85A0\u85A2\u85A5\u85A7\u85B4\u85B6\u85B7\u85B8\u85BC\u85BD\u85BE\u85BF\u85C2\u85C7\u85CA\u85CB\u85CE\u85AD\u85D8\u85DA\u85DF\u85E0\u85E6\u85E8\u85ED\u85F3\u85F6\u85FC"],
      ["8fdaa1", "\u85FF\u8600\u8604\u8605\u860D\u860E\u8610\u8611\u8612\u8618\u8619\u861B\u861E\u8621\u8627\u8629\u8636\u8638\u863A\u863C\u863D\u8640\u8642\u8646\u8652\u8653\u8656\u8657\u8658\u8659\u865D\u8660", 4, "\u8669\u866C\u866F\u8675\u8676\u8677\u867A\u868D\u8691\u8696\u8698\u869A\u869C\u86A1\u86A6\u86A7\u86A8\u86AD\u86B1\u86B3\u86B4\u86B5\u86B7\u86B8\u86B9\u86BF\u86C0\u86C1\u86C3\u86C5\u86D1\u86D2\u86D5\u86D7\u86DA\u86DC\u86E0\u86E3\u86E5\u86E7\u8688\u86FA\u86FC\u86FD\u8704\u8705\u8707\u870B\u870E\u870F\u8710\u8713\u8714\u8719\u871E\u871F\u8721\u8723"],
      ["8fdba1", "\u8728\u872E\u872F\u8731\u8732\u8739\u873A\u873C\u873D\u873E\u8740\u8743\u8745\u874D\u8758\u875D\u8761\u8764\u8765\u876F\u8771\u8772\u877B\u8783", 6, "\u878B\u878C\u8790\u8793\u8795\u8797\u8798\u8799\u879E\u87A0\u87A3\u87A7\u87AC\u87AD\u87AE\u87B1\u87B5\u87BE\u87BF\u87C1\u87C8\u87C9\u87CA\u87CE\u87D5\u87D6\u87D9\u87DA\u87DC\u87DF\u87E2\u87E3\u87E4\u87EA\u87EB\u87ED\u87F1\u87F3\u87F8\u87FA\u87FF\u8801\u8803\u8806\u8809\u880A\u880B\u8810\u8819\u8812\u8813\u8814\u8818\u881A\u881B\u881C\u881E\u881F\u8828\u882D\u882E\u8830\u8832\u8835"],
      ["8fdca1", "\u883A\u883C\u8841\u8843\u8845\u8848\u8849\u884A\u884B\u884E\u8851\u8855\u8856\u8858\u885A\u885C\u885F\u8860\u8864\u8869\u8871\u8879\u887B\u8880\u8898\u889A\u889B\u889C\u889F\u88A0\u88A8\u88AA\u88BA\u88BD\u88BE\u88C0\u88CA", 4, "\u88D1\u88D2\u88D3\u88DB\u88DE\u88E7\u88EF\u88F0\u88F1\u88F5\u88F7\u8901\u8906\u890D\u890E\u890F\u8915\u8916\u8918\u8919\u891A\u891C\u8920\u8926\u8927\u8928\u8930\u8931\u8932\u8935\u8939\u893A\u893E\u8940\u8942\u8945\u8946\u8949\u894F\u8952\u8957\u895A\u895B\u895C\u8961\u8962\u8963\u896B\u896E\u8970\u8973\u8975\u897A"],
      ["8fdda1", "\u897B\u897C\u897D\u8989\u898D\u8990\u8994\u8995\u899B\u899C\u899F\u89A0\u89A5\u89B0\u89B4\u89B5\u89B6\u89B7\u89BC\u89D4", 4, "\u89E5\u89E9\u89EB\u89ED\u89F1\u89F3\u89F6\u89F9\u89FD\u89FF\u8A04\u8A05\u8A07\u8A0F\u8A11\u8A12\u8A14\u8A15\u8A1E\u8A20\u8A22\u8A24\u8A26\u8A2B\u8A2C\u8A2F\u8A35\u8A37\u8A3D\u8A3E\u8A40\u8A43\u8A45\u8A47\u8A49\u8A4D\u8A4E\u8A53\u8A56\u8A57\u8A58\u8A5C\u8A5D\u8A61\u8A65\u8A67\u8A75\u8A76\u8A77\u8A79\u8A7A\u8A7B\u8A7E\u8A7F\u8A80\u8A83\u8A86\u8A8B\u8A8F\u8A90\u8A92\u8A96\u8A97\u8A99\u8A9F\u8AA7\u8AA9\u8AAE\u8AAF\u8AB3"],
      ["8fdea1", "\u8AB6\u8AB7\u8ABB\u8ABE\u8AC3\u8AC6\u8AC8\u8AC9\u8ACA\u8AD1\u8AD3\u8AD4\u8AD5\u8AD7\u8ADD\u8ADF\u8AEC\u8AF0\u8AF4\u8AF5\u8AF6\u8AFC\u8AFF\u8B05\u8B06\u8B0B\u8B11\u8B1C\u8B1E\u8B1F\u8B0A\u8B2D\u8B30\u8B37\u8B3C\u8B42", 4, "\u8B48\u8B52\u8B53\u8B54\u8B59\u8B4D\u8B5E\u8B63\u8B6D\u8B76\u8B78\u8B79\u8B7C\u8B7E\u8B81\u8B84\u8B85\u8B8B\u8B8D\u8B8F\u8B94\u8B95\u8B9C\u8B9E\u8B9F\u8C38\u8C39\u8C3D\u8C3E\u8C45\u8C47\u8C49\u8C4B\u8C4F\u8C51\u8C53\u8C54\u8C57\u8C58\u8C5B\u8C5D\u8C59\u8C63\u8C64\u8C66\u8C68\u8C69\u8C6D\u8C73\u8C75\u8C76\u8C7B\u8C7E\u8C86"],
      ["8fdfa1", "\u8C87\u8C8B\u8C90\u8C92\u8C93\u8C99\u8C9B\u8C9C\u8CA4\u8CB9\u8CBA\u8CC5\u8CC6\u8CC9\u8CCB\u8CCF\u8CD6\u8CD5\u8CD9\u8CDD\u8CE1\u8CE8\u8CEC\u8CEF\u8CF0\u8CF2\u8CF5\u8CF7\u8CF8\u8CFE\u8CFF\u8D01\u8D03\u8D09\u8D12\u8D17\u8D1B\u8D65\u8D69\u8D6C\u8D6E\u8D7F\u8D82\u8D84\u8D88\u8D8D\u8D90\u8D91\u8D95\u8D9E\u8D9F\u8DA0\u8DA6\u8DAB\u8DAC\u8DAF\u8DB2\u8DB5\u8DB7\u8DB9\u8DBB\u8DC0\u8DC5\u8DC6\u8DC7\u8DC8\u8DCA\u8DCE\u8DD1\u8DD4\u8DD5\u8DD7\u8DD9\u8DE4\u8DE5\u8DE7\u8DEC\u8DF0\u8DBC\u8DF1\u8DF2\u8DF4\u8DFD\u8E01\u8E04\u8E05\u8E06\u8E0B\u8E11\u8E14\u8E16\u8E20\u8E21\u8E22"],
      ["8fe0a1", "\u8E23\u8E26\u8E27\u8E31\u8E33\u8E36\u8E37\u8E38\u8E39\u8E3D\u8E40\u8E41\u8E4B\u8E4D\u8E4E\u8E4F\u8E54\u8E5B\u8E5C\u8E5D\u8E5E\u8E61\u8E62\u8E69\u8E6C\u8E6D\u8E6F\u8E70\u8E71\u8E79\u8E7A\u8E7B\u8E82\u8E83\u8E89\u8E90\u8E92\u8E95\u8E9A\u8E9B\u8E9D\u8E9E\u8EA2\u8EA7\u8EA9\u8EAD\u8EAE\u8EB3\u8EB5\u8EBA\u8EBB\u8EC0\u8EC1\u8EC3\u8EC4\u8EC7\u8ECF\u8ED1\u8ED4\u8EDC\u8EE8\u8EEE\u8EF0\u8EF1\u8EF7\u8EF9\u8EFA\u8EED\u8F00\u8F02\u8F07\u8F08\u8F0F\u8F10\u8F16\u8F17\u8F18\u8F1E\u8F20\u8F21\u8F23\u8F25\u8F27\u8F28\u8F2C\u8F2D\u8F2E\u8F34\u8F35\u8F36\u8F37\u8F3A\u8F40\u8F41"],
      ["8fe1a1", "\u8F43\u8F47\u8F4F\u8F51", 4, "\u8F58\u8F5D\u8F5E\u8F65\u8F9D\u8FA0\u8FA1\u8FA4\u8FA5\u8FA6\u8FB5\u8FB6\u8FB8\u8FBE\u8FC0\u8FC1\u8FC6\u8FCA\u8FCB\u8FCD\u8FD0\u8FD2\u8FD3\u8FD5\u8FE0\u8FE3\u8FE4\u8FE8\u8FEE\u8FF1\u8FF5\u8FF6\u8FFB\u8FFE\u9002\u9004\u9008\u900C\u9018\u901B\u9028\u9029\u902F\u902A\u902C\u902D\u9033\u9034\u9037\u903F\u9043\u9044\u904C\u905B\u905D\u9062\u9066\u9067\u906C\u9070\u9074\u9079\u9085\u9088\u908B\u908C\u908E\u9090\u9095\u9097\u9098\u9099\u909B\u90A0\u90A1\u90A2\u90A5\u90B0\u90B2\u90B3\u90B4\u90B6\u90BD\u90CC\u90BE\u90C3"],
      ["8fe2a1", "\u90C4\u90C5\u90C7\u90C8\u90D5\u90D7\u90D8\u90D9\u90DC\u90DD\u90DF\u90E5\u90D2\u90F6\u90EB\u90EF\u90F0\u90F4\u90FE\u90FF\u9100\u9104\u9105\u9106\u9108\u910D\u9110\u9114\u9116\u9117\u9118\u911A\u911C\u911E\u9120\u9125\u9122\u9123\u9127\u9129\u912E\u912F\u9131\u9134\u9136\u9137\u9139\u913A\u913C\u913D\u9143\u9147\u9148\u914F\u9153\u9157\u9159\u915A\u915B\u9161\u9164\u9167\u916D\u9174\u9179\u917A\u917B\u9181\u9183\u9185\u9186\u918A\u918E\u9191\u9193\u9194\u9195\u9198\u919E\u91A1\u91A6\u91A8\u91AC\u91AD\u91AE\u91B0\u91B1\u91B2\u91B3\u91B6\u91BB\u91BC\u91BD\u91BF"],
      ["8fe3a1", "\u91C2\u91C3\u91C5\u91D3\u91D4\u91D7\u91D9\u91DA\u91DE\u91E4\u91E5\u91E9\u91EA\u91EC", 5, "\u91F7\u91F9\u91FB\u91FD\u9200\u9201\u9204\u9205\u9206\u9207\u9209\u920A\u920C\u9210\u9212\u9213\u9216\u9218\u921C\u921D\u9223\u9224\u9225\u9226\u9228\u922E\u922F\u9230\u9233\u9235\u9236\u9238\u9239\u923A\u923C\u923E\u9240\u9242\u9243\u9246\u9247\u924A\u924D\u924E\u924F\u9251\u9258\u9259\u925C\u925D\u9260\u9261\u9265\u9267\u9268\u9269\u926E\u926F\u9270\u9275", 4, "\u927B\u927C\u927D\u927F\u9288\u9289\u928A\u928D\u928E\u9292\u9297"],
      ["8fe4a1", "\u9299\u929F\u92A0\u92A4\u92A5\u92A7\u92A8\u92AB\u92AF\u92B2\u92B6\u92B8\u92BA\u92BB\u92BC\u92BD\u92BF", 4, "\u92C5\u92C6\u92C7\u92C8\u92CB\u92CC\u92CD\u92CE\u92D0\u92D3\u92D5\u92D7\u92D8\u92D9\u92DC\u92DD\u92DF\u92E0\u92E1\u92E3\u92E5\u92E7\u92E8\u92EC\u92EE\u92F0\u92F9\u92FB\u92FF\u9300\u9302\u9308\u930D\u9311\u9314\u9315\u931C\u931D\u931E\u931F\u9321\u9324\u9325\u9327\u9329\u932A\u9333\u9334\u9336\u9337\u9347\u9348\u9349\u9350\u9351\u9352\u9355\u9357\u9358\u935A\u935E\u9364\u9365\u9367\u9369\u936A\u936D\u936F\u9370\u9371\u9373\u9374\u9376"],
      ["8fe5a1", "\u937A\u937D\u937F\u9380\u9381\u9382\u9388\u938A\u938B\u938D\u938F\u9392\u9395\u9398\u939B\u939E\u93A1\u93A3\u93A4\u93A6\u93A8\u93AB\u93B4\u93B5\u93B6\u93BA\u93A9\u93C1\u93C4\u93C5\u93C6\u93C7\u93C9", 4, "\u93D3\u93D9\u93DC\u93DE\u93DF\u93E2\u93E6\u93E7\u93F9\u93F7\u93F8\u93FA\u93FB\u93FD\u9401\u9402\u9404\u9408\u9409\u940D\u940E\u940F\u9415\u9416\u9417\u941F\u942E\u942F\u9431\u9432\u9433\u9434\u943B\u943F\u943D\u9443\u9445\u9448\u944A\u944C\u9455\u9459\u945C\u945F\u9461\u9463\u9468\u946B\u946D\u946E\u946F\u9471\u9472\u9484\u9483\u9578\u9579"],
      ["8fe6a1", "\u957E\u9584\u9588\u958C\u958D\u958E\u959D\u959E\u959F\u95A1\u95A6\u95A9\u95AB\u95AC\u95B4\u95B6\u95BA\u95BD\u95BF\u95C6\u95C8\u95C9\u95CB\u95D0\u95D1\u95D2\u95D3\u95D9\u95DA\u95DD\u95DE\u95DF\u95E0\u95E4\u95E6\u961D\u961E\u9622\u9624\u9625\u9626\u962C\u9631\u9633\u9637\u9638\u9639\u963A\u963C\u963D\u9641\u9652\u9654\u9656\u9657\u9658\u9661\u966E\u9674\u967B\u967C\u967E\u967F\u9681\u9682\u9683\u9684\u9689\u9691\u9696\u969A\u969D\u969F\u96A4\u96A5\u96A6\u96A9\u96AE\u96AF\u96B3\u96BA\u96CA\u96D2\u5DB2\u96D8\u96DA\u96DD\u96DE\u96DF\u96E9\u96EF\u96F1\u96FA\u9702"],
      ["8fe7a1", "\u9703\u9705\u9709\u971A\u971B\u971D\u9721\u9722\u9723\u9728\u9731\u9733\u9741\u9743\u974A\u974E\u974F\u9755\u9757\u9758\u975A\u975B\u9763\u9767\u976A\u976E\u9773\u9776\u9777\u9778\u977B\u977D\u977F\u9780\u9789\u9795\u9796\u9797\u9799\u979A\u979E\u979F\u97A2\u97AC\u97AE\u97B1\u97B2\u97B5\u97B6\u97B8\u97B9\u97BA\u97BC\u97BE\u97BF\u97C1\u97C4\u97C5\u97C7\u97C9\u97CA\u97CC\u97CD\u97CE\u97D0\u97D1\u97D4\u97D7\u97D8\u97D9\u97DD\u97DE\u97E0\u97DB\u97E1\u97E4\u97EF\u97F1\u97F4\u97F7\u97F8\u97FA\u9807\u980A\u9819\u980D\u980E\u9814\u9816\u981C\u981E\u9820\u9823\u9826"],
      ["8fe8a1", "\u982B\u982E\u982F\u9830\u9832\u9833\u9835\u9825\u983E\u9844\u9847\u984A\u9851\u9852\u9853\u9856\u9857\u9859\u985A\u9862\u9863\u9865\u9866\u986A\u986C\u98AB\u98AD\u98AE\u98B0\u98B4\u98B7\u98B8\u98BA\u98BB\u98BF\u98C2\u98C5\u98C8\u98CC\u98E1\u98E3\u98E5\u98E6\u98E7\u98EA\u98F3\u98F6\u9902\u9907\u9908\u9911\u9915\u9916\u9917\u991A\u991B\u991C\u991F\u9922\u9926\u9927\u992B\u9931", 4, "\u9939\u993A\u993B\u993C\u9940\u9941\u9946\u9947\u9948\u994D\u994E\u9954\u9958\u9959\u995B\u995C\u995E\u995F\u9960\u999B\u999D\u999F\u99A6\u99B0\u99B1\u99B2\u99B5"],
      ["8fe9a1", "\u99B9\u99BA\u99BD\u99BF\u99C3\u99C9\u99D3\u99D4\u99D9\u99DA\u99DC\u99DE\u99E7\u99EA\u99EB\u99EC\u99F0\u99F4\u99F5\u99F9\u99FD\u99FE\u9A02\u9A03\u9A04\u9A0B\u9A0C\u9A10\u9A11\u9A16\u9A1E\u9A20\u9A22\u9A23\u9A24\u9A27\u9A2D\u9A2E\u9A33\u9A35\u9A36\u9A38\u9A47\u9A41\u9A44\u9A4A\u9A4B\u9A4C\u9A4E\u9A51\u9A54\u9A56\u9A5D\u9AAA\u9AAC\u9AAE\u9AAF\u9AB2\u9AB4\u9AB5\u9AB6\u9AB9\u9ABB\u9ABE\u9ABF\u9AC1\u9AC3\u9AC6\u9AC8\u9ACE\u9AD0\u9AD2\u9AD5\u9AD6\u9AD7\u9ADB\u9ADC\u9AE0\u9AE4\u9AE5\u9AE7\u9AE9\u9AEC\u9AF2\u9AF3\u9AF5\u9AF9\u9AFA\u9AFD\u9AFF", 4],
      ["8feaa1", "\u9B04\u9B05\u9B08\u9B09\u9B0B\u9B0C\u9B0D\u9B0E\u9B10\u9B12\u9B16\u9B19\u9B1B\u9B1C\u9B20\u9B26\u9B2B\u9B2D\u9B33\u9B34\u9B35\u9B37\u9B39\u9B3A\u9B3D\u9B48\u9B4B\u9B4C\u9B55\u9B56\u9B57\u9B5B\u9B5E\u9B61\u9B63\u9B65\u9B66\u9B68\u9B6A", 4, "\u9B73\u9B75\u9B77\u9B78\u9B79\u9B7F\u9B80\u9B84\u9B85\u9B86\u9B87\u9B89\u9B8A\u9B8B\u9B8D\u9B8F\u9B90\u9B94\u9B9A\u9B9D\u9B9E\u9BA6\u9BA7\u9BA9\u9BAC\u9BB0\u9BB1\u9BB2\u9BB7\u9BB8\u9BBB\u9BBC\u9BBE\u9BBF\u9BC1\u9BC7\u9BC8\u9BCE\u9BD0\u9BD7\u9BD8\u9BDD\u9BDF\u9BE5\u9BE7\u9BEA\u9BEB\u9BEF\u9BF3\u9BF7\u9BF8"],
      ["8feba1", "\u9BF9\u9BFA\u9BFD\u9BFF\u9C00\u9C02\u9C0B\u9C0F\u9C11\u9C16\u9C18\u9C19\u9C1A\u9C1C\u9C1E\u9C22\u9C23\u9C26", 4, "\u9C31\u9C35\u9C36\u9C37\u9C3D\u9C41\u9C43\u9C44\u9C45\u9C49\u9C4A\u9C4E\u9C4F\u9C50\u9C53\u9C54\u9C56\u9C58\u9C5B\u9C5D\u9C5E\u9C5F\u9C63\u9C69\u9C6A\u9C5C\u9C6B\u9C68\u9C6E\u9C70\u9C72\u9C75\u9C77\u9C7B\u9CE6\u9CF2\u9CF7\u9CF9\u9D0B\u9D02\u9D11\u9D17\u9D18\u9D1C\u9D1D\u9D1E\u9D2F\u9D30\u9D32\u9D33\u9D34\u9D3A\u9D3C\u9D45\u9D3D\u9D42\u9D43\u9D47\u9D4A\u9D53\u9D54\u9D5F\u9D63\u9D62\u9D65\u9D69\u9D6A\u9D6B\u9D70\u9D76\u9D77\u9D7B"],
      ["8feca1", "\u9D7C\u9D7E\u9D83\u9D84\u9D86\u9D8A\u9D8D\u9D8E\u9D92\u9D93\u9D95\u9D96\u9D97\u9D98\u9DA1\u9DAA\u9DAC\u9DAE\u9DB1\u9DB5\u9DB9\u9DBC\u9DBF\u9DC3\u9DC7\u9DC9\u9DCA\u9DD4\u9DD5\u9DD6\u9DD7\u9DDA\u9DDE\u9DDF\u9DE0\u9DE5\u9DE7\u9DE9\u9DEB\u9DEE\u9DF0\u9DF3\u9DF4\u9DFE\u9E0A\u9E02\u9E07\u9E0E\u9E10\u9E11\u9E12\u9E15\u9E16\u9E19\u9E1C\u9E1D\u9E7A\u9E7B\u9E7C\u9E80\u9E82\u9E83\u9E84\u9E85\u9E87\u9E8E\u9E8F\u9E96\u9E98\u9E9B\u9E9E\u9EA4\u9EA8\u9EAC\u9EAE\u9EAF\u9EB0\u9EB3\u9EB4\u9EB5\u9EC6\u9EC8\u9ECB\u9ED5\u9EDF\u9EE4\u9EE7\u9EEC\u9EED\u9EEE\u9EF0\u9EF1\u9EF2\u9EF5"],
      ["8feda1", "\u9EF8\u9EFF\u9F02\u9F03\u9F09\u9F0F\u9F10\u9F11\u9F12\u9F14\u9F16\u9F17\u9F19\u9F1A\u9F1B\u9F1F\u9F22\u9F26\u9F2A\u9F2B\u9F2F\u9F31\u9F32\u9F34\u9F37\u9F39\u9F3A\u9F3C\u9F3D\u9F3F\u9F41\u9F43", 4, "\u9F53\u9F55\u9F56\u9F57\u9F58\u9F5A\u9F5D\u9F5E\u9F68\u9F69\u9F6D", 4, "\u9F73\u9F75\u9F7A\u9F7D\u9F8F\u9F90\u9F91\u9F92\u9F94\u9F96\u9F97\u9F9E\u9FA1\u9FA2\u9FA3\u9FA5"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS({
  "node_modules/iconv-lite/encodings/tables/cp936.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127, "\u20AC"],
      ["8140", "\u4E02\u4E04\u4E05\u4E06\u4E0F\u4E12\u4E17\u4E1F\u4E20\u4E21\u4E23\u4E26\u4E29\u4E2E\u4E2F\u4E31\u4E33\u4E35\u4E37\u4E3C\u4E40\u4E41\u4E42\u4E44\u4E46\u4E4A\u4E51\u4E55\u4E57\u4E5A\u4E5B\u4E62\u4E63\u4E64\u4E65\u4E67\u4E68\u4E6A", 5, "\u4E72\u4E74", 9, "\u4E7F", 6, "\u4E87\u4E8A"],
      ["8180", "\u4E90\u4E96\u4E97\u4E99\u4E9C\u4E9D\u4E9E\u4EA3\u4EAA\u4EAF\u4EB0\u4EB1\u4EB4\u4EB6\u4EB7\u4EB8\u4EB9\u4EBC\u4EBD\u4EBE\u4EC8\u4ECC\u4ECF\u4ED0\u4ED2\u4EDA\u4EDB\u4EDC\u4EE0\u4EE2\u4EE6\u4EE7\u4EE9\u4EED\u4EEE\u4EEF\u4EF1\u4EF4\u4EF8\u4EF9\u4EFA\u4EFC\u4EFE\u4F00\u4F02", 6, "\u4F0B\u4F0C\u4F12", 4, "\u4F1C\u4F1D\u4F21\u4F23\u4F28\u4F29\u4F2C\u4F2D\u4F2E\u4F31\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E", 4, "\u4F44\u4F45\u4F47", 5, "\u4F52\u4F54\u4F56\u4F61\u4F62\u4F66\u4F68\u4F6A\u4F6B\u4F6D\u4F6E\u4F71\u4F72\u4F75\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F80\u4F81\u4F82\u4F85\u4F86\u4F87\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F95\u4F96\u4F98\u4F99\u4F9A\u4F9C\u4F9E\u4F9F\u4FA1\u4FA2"],
      ["8240", "\u4FA4\u4FAB\u4FAD\u4FB0", 4, "\u4FB6", 8, "\u4FC0\u4FC1\u4FC2\u4FC6\u4FC7\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FD2", 4, "\u4FD9\u4FDB\u4FE0\u4FE2\u4FE4\u4FE5\u4FE7\u4FEB\u4FEC\u4FF0\u4FF2\u4FF4\u4FF5\u4FF6\u4FF7\u4FF9\u4FFB\u4FFC\u4FFD\u4FFF", 11],
      ["8280", "\u500B\u500E\u5010\u5011\u5013\u5015\u5016\u5017\u501B\u501D\u501E\u5020\u5022\u5023\u5024\u5027\u502B\u502F", 10, "\u503B\u503D\u503F\u5040\u5041\u5042\u5044\u5045\u5046\u5049\u504A\u504B\u504D\u5050", 4, "\u5056\u5057\u5058\u5059\u505B\u505D", 7, "\u5066", 5, "\u506D", 8, "\u5078\u5079\u507A\u507C\u507D\u5081\u5082\u5083\u5084\u5086\u5087\u5089\u508A\u508B\u508C\u508E", 20, "\u50A4\u50A6\u50AA\u50AB\u50AD", 4, "\u50B3", 6, "\u50BC"],
      ["8340", "\u50BD", 17, "\u50D0", 5, "\u50D7\u50D8\u50D9\u50DB", 10, "\u50E8\u50E9\u50EA\u50EB\u50EF\u50F0\u50F1\u50F2\u50F4\u50F6", 4, "\u50FC", 9, "\u5108"],
      ["8380", "\u5109\u510A\u510C", 5, "\u5113", 13, "\u5122", 28, "\u5142\u5147\u514A\u514C\u514E\u514F\u5150\u5152\u5153\u5157\u5158\u5159\u515B\u515D", 4, "\u5163\u5164\u5166\u5167\u5169\u516A\u516F\u5172\u517A\u517E\u517F\u5183\u5184\u5186\u5187\u518A\u518B\u518E\u518F\u5190\u5191\u5193\u5194\u5198\u519A\u519D\u519E\u519F\u51A1\u51A3\u51A6", 4, "\u51AD\u51AE\u51B4\u51B8\u51B9\u51BA\u51BE\u51BF\u51C1\u51C2\u51C3\u51C5\u51C8\u51CA\u51CD\u51CE\u51D0\u51D2", 5],
      ["8440", "\u51D8\u51D9\u51DA\u51DC\u51DE\u51DF\u51E2\u51E3\u51E5", 5, "\u51EC\u51EE\u51F1\u51F2\u51F4\u51F7\u51FE\u5204\u5205\u5209\u520B\u520C\u520F\u5210\u5213\u5214\u5215\u521C\u521E\u521F\u5221\u5222\u5223\u5225\u5226\u5227\u522A\u522C\u522F\u5231\u5232\u5234\u5235\u523C\u523E\u5244", 5, "\u524B\u524E\u524F\u5252\u5253\u5255\u5257\u5258"],
      ["8480", "\u5259\u525A\u525B\u525D\u525F\u5260\u5262\u5263\u5264\u5266\u5268\u526B\u526C\u526D\u526E\u5270\u5271\u5273", 9, "\u527E\u5280\u5283", 4, "\u5289", 6, "\u5291\u5292\u5294", 6, "\u529C\u52A4\u52A5\u52A6\u52A7\u52AE\u52AF\u52B0\u52B4", 9, "\u52C0\u52C1\u52C2\u52C4\u52C5\u52C6\u52C8\u52CA\u52CC\u52CD\u52CE\u52CF\u52D1\u52D3\u52D4\u52D5\u52D7\u52D9", 5, "\u52E0\u52E1\u52E2\u52E3\u52E5", 10, "\u52F1", 7, "\u52FB\u52FC\u52FD\u5301\u5302\u5303\u5304\u5307\u5309\u530A\u530B\u530C\u530E"],
      ["8540", "\u5311\u5312\u5313\u5314\u5318\u531B\u531C\u531E\u531F\u5322\u5324\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u532F", 9, "\u533C\u533D\u5340\u5342\u5344\u5346\u534B\u534C\u534D\u5350\u5354\u5358\u5359\u535B\u535D\u5365\u5368\u536A\u536C\u536D\u5372\u5376\u5379\u537B\u537C\u537D\u537E\u5380\u5381\u5383\u5387\u5388\u538A\u538E\u538F"],
      ["8580", "\u5390", 4, "\u5396\u5397\u5399\u539B\u539C\u539E\u53A0\u53A1\u53A4\u53A7\u53AA\u53AB\u53AC\u53AD\u53AF", 6, "\u53B7\u53B8\u53B9\u53BA\u53BC\u53BD\u53BE\u53C0\u53C3", 4, "\u53CE\u53CF\u53D0\u53D2\u53D3\u53D5\u53DA\u53DC\u53DD\u53DE\u53E1\u53E2\u53E7\u53F4\u53FA\u53FE\u53FF\u5400\u5402\u5405\u5407\u540B\u5414\u5418\u5419\u541A\u541C\u5422\u5424\u5425\u542A\u5430\u5433\u5436\u5437\u543A\u543D\u543F\u5441\u5442\u5444\u5445\u5447\u5449\u544C\u544D\u544E\u544F\u5451\u545A\u545D", 4, "\u5463\u5465\u5467\u5469", 7, "\u5474\u5479\u547A\u547E\u547F\u5481\u5483\u5485\u5487\u5488\u5489\u548A\u548D\u5491\u5493\u5497\u5498\u549C\u549E\u549F\u54A0\u54A1"],
      ["8640", "\u54A2\u54A5\u54AE\u54B0\u54B2\u54B5\u54B6\u54B7\u54B9\u54BA\u54BC\u54BE\u54C3\u54C5\u54CA\u54CB\u54D6\u54D8\u54DB\u54E0", 4, "\u54EB\u54EC\u54EF\u54F0\u54F1\u54F4", 5, "\u54FB\u54FE\u5500\u5502\u5503\u5504\u5505\u5508\u550A", 4, "\u5512\u5513\u5515", 5, "\u551C\u551D\u551E\u551F\u5521\u5525\u5526"],
      ["8680", "\u5528\u5529\u552B\u552D\u5532\u5534\u5535\u5536\u5538\u5539\u553A\u553B\u553D\u5540\u5542\u5545\u5547\u5548\u554B", 4, "\u5551\u5552\u5553\u5554\u5557", 4, "\u555D\u555E\u555F\u5560\u5562\u5563\u5568\u5569\u556B\u556F", 5, "\u5579\u557A\u557D\u557F\u5585\u5586\u558C\u558D\u558E\u5590\u5592\u5593\u5595\u5596\u5597\u559A\u559B\u559E\u55A0", 6, "\u55A8", 8, "\u55B2\u55B4\u55B6\u55B8\u55BA\u55BC\u55BF", 4, "\u55C6\u55C7\u55C8\u55CA\u55CB\u55CE\u55CF\u55D0\u55D5\u55D7", 4, "\u55DE\u55E0\u55E2\u55E7\u55E9\u55ED\u55EE\u55F0\u55F1\u55F4\u55F6\u55F8", 4, "\u55FF\u5602\u5603\u5604\u5605"],
      ["8740", "\u5606\u5607\u560A\u560B\u560D\u5610", 7, "\u5619\u561A\u561C\u561D\u5620\u5621\u5622\u5625\u5626\u5628\u5629\u562A\u562B\u562E\u562F\u5630\u5633\u5635\u5637\u5638\u563A\u563C\u563D\u563E\u5640", 11, "\u564F", 4, "\u5655\u5656\u565A\u565B\u565D", 4],
      ["8780", "\u5663\u5665\u5666\u5667\u566D\u566E\u566F\u5670\u5672\u5673\u5674\u5675\u5677\u5678\u5679\u567A\u567D", 7, "\u5687", 6, "\u5690\u5691\u5692\u5694", 14, "\u56A4", 10, "\u56B0", 6, "\u56B8\u56B9\u56BA\u56BB\u56BD", 12, "\u56CB", 8, "\u56D5\u56D6\u56D8\u56D9\u56DC\u56E3\u56E5", 5, "\u56EC\u56EE\u56EF\u56F2\u56F3\u56F6\u56F7\u56F8\u56FB\u56FC\u5700\u5701\u5702\u5705\u5707\u570B", 6],
      ["8840", "\u5712", 9, "\u571D\u571E\u5720\u5721\u5722\u5724\u5725\u5726\u5727\u572B\u5731\u5732\u5734", 4, "\u573C\u573D\u573F\u5741\u5743\u5744\u5745\u5746\u5748\u5749\u574B\u5752", 4, "\u5758\u5759\u5762\u5763\u5765\u5767\u576C\u576E\u5770\u5771\u5772\u5774\u5775\u5778\u5779\u577A\u577D\u577E\u577F\u5780"],
      ["8880", "\u5781\u5787\u5788\u5789\u578A\u578D", 4, "\u5794", 6, "\u579C\u579D\u579E\u579F\u57A5\u57A8\u57AA\u57AC\u57AF\u57B0\u57B1\u57B3\u57B5\u57B6\u57B7\u57B9", 8, "\u57C4", 6, "\u57CC\u57CD\u57D0\u57D1\u57D3\u57D6\u57D7\u57DB\u57DC\u57DE\u57E1\u57E2\u57E3\u57E5", 7, "\u57EE\u57F0\u57F1\u57F2\u57F3\u57F5\u57F6\u57F7\u57FB\u57FC\u57FE\u57FF\u5801\u5803\u5804\u5805\u5808\u5809\u580A\u580C\u580E\u580F\u5810\u5812\u5813\u5814\u5816\u5817\u5818\u581A\u581B\u581C\u581D\u581F\u5822\u5823\u5825", 4, "\u582B", 4, "\u5831\u5832\u5833\u5834\u5836", 7],
      ["8940", "\u583E", 5, "\u5845", 6, "\u584E\u584F\u5850\u5852\u5853\u5855\u5856\u5857\u5859", 4, "\u585F", 5, "\u5866", 4, "\u586D", 16, "\u587F\u5882\u5884\u5886\u5887\u5888\u588A\u588B\u588C"],
      ["8980", "\u588D", 4, "\u5894", 4, "\u589B\u589C\u589D\u58A0", 7, "\u58AA", 17, "\u58BD\u58BE\u58BF\u58C0\u58C2\u58C3\u58C4\u58C6", 10, "\u58D2\u58D3\u58D4\u58D6", 13, "\u58E5", 5, "\u58ED\u58EF\u58F1\u58F2\u58F4\u58F5\u58F7\u58F8\u58FA", 7, "\u5903\u5905\u5906\u5908", 4, "\u590E\u5910\u5911\u5912\u5913\u5917\u5918\u591B\u591D\u591E\u5920\u5921\u5922\u5923\u5926\u5928\u592C\u5930\u5932\u5933\u5935\u5936\u593B"],
      ["8a40", "\u593D\u593E\u593F\u5940\u5943\u5945\u5946\u594A\u594C\u594D\u5950\u5952\u5953\u5959\u595B", 4, "\u5961\u5963\u5964\u5966", 12, "\u5975\u5977\u597A\u597B\u597C\u597E\u597F\u5980\u5985\u5989\u598B\u598C\u598E\u598F\u5990\u5991\u5994\u5995\u5998\u599A\u599B\u599C\u599D\u599F\u59A0\u59A1\u59A2\u59A6"],
      ["8a80", "\u59A7\u59AC\u59AD\u59B0\u59B1\u59B3", 5, "\u59BA\u59BC\u59BD\u59BF", 6, "\u59C7\u59C8\u59C9\u59CC\u59CD\u59CE\u59CF\u59D5\u59D6\u59D9\u59DB\u59DE", 4, "\u59E4\u59E6\u59E7\u59E9\u59EA\u59EB\u59ED", 11, "\u59FA\u59FC\u59FD\u59FE\u5A00\u5A02\u5A0A\u5A0B\u5A0D\u5A0E\u5A0F\u5A10\u5A12\u5A14\u5A15\u5A16\u5A17\u5A19\u5A1A\u5A1B\u5A1D\u5A1E\u5A21\u5A22\u5A24\u5A26\u5A27\u5A28\u5A2A", 6, "\u5A33\u5A35\u5A37", 4, "\u5A3D\u5A3E\u5A3F\u5A41", 4, "\u5A47\u5A48\u5A4B", 9, "\u5A56\u5A57\u5A58\u5A59\u5A5B", 5],
      ["8b40", "\u5A61\u5A63\u5A64\u5A65\u5A66\u5A68\u5A69\u5A6B", 8, "\u5A78\u5A79\u5A7B\u5A7C\u5A7D\u5A7E\u5A80", 17, "\u5A93", 6, "\u5A9C", 13, "\u5AAB\u5AAC"],
      ["8b80", "\u5AAD", 4, "\u5AB4\u5AB6\u5AB7\u5AB9", 4, "\u5ABF\u5AC0\u5AC3", 5, "\u5ACA\u5ACB\u5ACD", 4, "\u5AD3\u5AD5\u5AD7\u5AD9\u5ADA\u5ADB\u5ADD\u5ADE\u5ADF\u5AE2\u5AE4\u5AE5\u5AE7\u5AE8\u5AEA\u5AEC", 4, "\u5AF2", 22, "\u5B0A", 11, "\u5B18", 25, "\u5B33\u5B35\u5B36\u5B38", 7, "\u5B41", 6],
      ["8c40", "\u5B48", 7, "\u5B52\u5B56\u5B5E\u5B60\u5B61\u5B67\u5B68\u5B6B\u5B6D\u5B6E\u5B6F\u5B72\u5B74\u5B76\u5B77\u5B78\u5B79\u5B7B\u5B7C\u5B7E\u5B7F\u5B82\u5B86\u5B8A\u5B8D\u5B8E\u5B90\u5B91\u5B92\u5B94\u5B96\u5B9F\u5BA7\u5BA8\u5BA9\u5BAC\u5BAD\u5BAE\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBB\u5BBC\u5BC0\u5BC1\u5BC3\u5BC8\u5BC9\u5BCA\u5BCB\u5BCD\u5BCE\u5BCF"],
      ["8c80", "\u5BD1\u5BD4", 8, "\u5BE0\u5BE2\u5BE3\u5BE6\u5BE7\u5BE9", 4, "\u5BEF\u5BF1", 6, "\u5BFD\u5BFE\u5C00\u5C02\u5C03\u5C05\u5C07\u5C08\u5C0B\u5C0C\u5C0D\u5C0E\u5C10\u5C12\u5C13\u5C17\u5C19\u5C1B\u5C1E\u5C1F\u5C20\u5C21\u5C23\u5C26\u5C28\u5C29\u5C2A\u5C2B\u5C2D\u5C2E\u5C2F\u5C30\u5C32\u5C33\u5C35\u5C36\u5C37\u5C43\u5C44\u5C46\u5C47\u5C4C\u5C4D\u5C52\u5C53\u5C54\u5C56\u5C57\u5C58\u5C5A\u5C5B\u5C5C\u5C5D\u5C5F\u5C62\u5C64\u5C67", 6, "\u5C70\u5C72", 6, "\u5C7B\u5C7C\u5C7D\u5C7E\u5C80\u5C83", 4, "\u5C89\u5C8A\u5C8B\u5C8E\u5C8F\u5C92\u5C93\u5C95\u5C9D", 4, "\u5CA4", 4],
      ["8d40", "\u5CAA\u5CAE\u5CAF\u5CB0\u5CB2\u5CB4\u5CB6\u5CB9\u5CBA\u5CBB\u5CBC\u5CBE\u5CC0\u5CC2\u5CC3\u5CC5", 5, "\u5CCC", 5, "\u5CD3", 5, "\u5CDA", 6, "\u5CE2\u5CE3\u5CE7\u5CE9\u5CEB\u5CEC\u5CEE\u5CEF\u5CF1", 9, "\u5CFC", 4],
      ["8d80", "\u5D01\u5D04\u5D05\u5D08", 5, "\u5D0F", 4, "\u5D15\u5D17\u5D18\u5D19\u5D1A\u5D1C\u5D1D\u5D1F", 4, "\u5D25\u5D28\u5D2A\u5D2B\u5D2C\u5D2F", 4, "\u5D35", 7, "\u5D3F", 7, "\u5D48\u5D49\u5D4D", 10, "\u5D59\u5D5A\u5D5C\u5D5E", 10, "\u5D6A\u5D6D\u5D6E\u5D70\u5D71\u5D72\u5D73\u5D75", 12, "\u5D83", 21, "\u5D9A\u5D9B\u5D9C\u5D9E\u5D9F\u5DA0"],
      ["8e40", "\u5DA1", 21, "\u5DB8", 12, "\u5DC6", 6, "\u5DCE", 12, "\u5DDC\u5DDF\u5DE0\u5DE3\u5DE4\u5DEA\u5DEC\u5DED"],
      ["8e80", "\u5DF0\u5DF5\u5DF6\u5DF8", 4, "\u5DFF\u5E00\u5E04\u5E07\u5E09\u5E0A\u5E0B\u5E0D\u5E0E\u5E12\u5E13\u5E17\u5E1E", 7, "\u5E28", 4, "\u5E2F\u5E30\u5E32", 4, "\u5E39\u5E3A\u5E3E\u5E3F\u5E40\u5E41\u5E43\u5E46", 5, "\u5E4D", 6, "\u5E56", 4, "\u5E5C\u5E5D\u5E5F\u5E60\u5E63", 14, "\u5E75\u5E77\u5E79\u5E7E\u5E81\u5E82\u5E83\u5E85\u5E88\u5E89\u5E8C\u5E8D\u5E8E\u5E92\u5E98\u5E9B\u5E9D\u5EA1\u5EA2\u5EA3\u5EA4\u5EA8", 4, "\u5EAE", 4, "\u5EB4\u5EBA\u5EBB\u5EBC\u5EBD\u5EBF", 6],
      ["8f40", "\u5EC6\u5EC7\u5EC8\u5ECB", 5, "\u5ED4\u5ED5\u5ED7\u5ED8\u5ED9\u5EDA\u5EDC", 11, "\u5EE9\u5EEB", 8, "\u5EF5\u5EF8\u5EF9\u5EFB\u5EFC\u5EFD\u5F05\u5F06\u5F07\u5F09\u5F0C\u5F0D\u5F0E\u5F10\u5F12\u5F14\u5F16\u5F19\u5F1A\u5F1C\u5F1D\u5F1E\u5F21\u5F22\u5F23\u5F24"],
      ["8f80", "\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F32", 6, "\u5F3B\u5F3D\u5F3E\u5F3F\u5F41", 14, "\u5F51\u5F54\u5F59\u5F5A\u5F5B\u5F5C\u5F5E\u5F5F\u5F60\u5F63\u5F65\u5F67\u5F68\u5F6B\u5F6E\u5F6F\u5F72\u5F74\u5F75\u5F76\u5F78\u5F7A\u5F7D\u5F7E\u5F7F\u5F83\u5F86\u5F8D\u5F8E\u5F8F\u5F91\u5F93\u5F94\u5F96\u5F9A\u5F9B\u5F9D\u5F9E\u5F9F\u5FA0\u5FA2", 5, "\u5FA9\u5FAB\u5FAC\u5FAF", 5, "\u5FB6\u5FB8\u5FB9\u5FBA\u5FBB\u5FBE", 4, "\u5FC7\u5FC8\u5FCA\u5FCB\u5FCE\u5FD3\u5FD4\u5FD5\u5FDA\u5FDB\u5FDC\u5FDE\u5FDF\u5FE2\u5FE3\u5FE5\u5FE6\u5FE8\u5FE9\u5FEC\u5FEF\u5FF0\u5FF2\u5FF3\u5FF4\u5FF6\u5FF7\u5FF9\u5FFA\u5FFC\u6007"],
      ["9040", "\u6008\u6009\u600B\u600C\u6010\u6011\u6013\u6017\u6018\u601A\u601E\u601F\u6022\u6023\u6024\u602C\u602D\u602E\u6030", 4, "\u6036", 4, "\u603D\u603E\u6040\u6044", 6, "\u604C\u604E\u604F\u6051\u6053\u6054\u6056\u6057\u6058\u605B\u605C\u605E\u605F\u6060\u6061\u6065\u6066\u606E\u6071\u6072\u6074\u6075\u6077\u607E\u6080"],
      ["9080", "\u6081\u6082\u6085\u6086\u6087\u6088\u608A\u608B\u608E\u608F\u6090\u6091\u6093\u6095\u6097\u6098\u6099\u609C\u609E\u60A1\u60A2\u60A4\u60A5\u60A7\u60A9\u60AA\u60AE\u60B0\u60B3\u60B5\u60B6\u60B7\u60B9\u60BA\u60BD", 7, "\u60C7\u60C8\u60C9\u60CC", 4, "\u60D2\u60D3\u60D4\u60D6\u60D7\u60D9\u60DB\u60DE\u60E1", 4, "\u60EA\u60F1\u60F2\u60F5\u60F7\u60F8\u60FB", 4, "\u6102\u6103\u6104\u6105\u6107\u610A\u610B\u610C\u6110", 4, "\u6116\u6117\u6118\u6119\u611B\u611C\u611D\u611E\u6121\u6122\u6125\u6128\u6129\u612A\u612C", 18, "\u6140", 6],
      ["9140", "\u6147\u6149\u614B\u614D\u614F\u6150\u6152\u6153\u6154\u6156", 6, "\u615E\u615F\u6160\u6161\u6163\u6164\u6165\u6166\u6169", 6, "\u6171\u6172\u6173\u6174\u6176\u6178", 18, "\u618C\u618D\u618F", 4, "\u6195"],
      ["9180", "\u6196", 6, "\u619E", 8, "\u61AA\u61AB\u61AD", 9, "\u61B8", 5, "\u61BF\u61C0\u61C1\u61C3", 4, "\u61C9\u61CC", 4, "\u61D3\u61D5", 16, "\u61E7", 13, "\u61F6", 8, "\u6200", 5, "\u6207\u6209\u6213\u6214\u6219\u621C\u621D\u621E\u6220\u6223\u6226\u6227\u6228\u6229\u622B\u622D\u622F\u6230\u6231\u6232\u6235\u6236\u6238", 4, "\u6242\u6244\u6245\u6246\u624A"],
      ["9240", "\u624F\u6250\u6255\u6256\u6257\u6259\u625A\u625C", 6, "\u6264\u6265\u6268\u6271\u6272\u6274\u6275\u6277\u6278\u627A\u627B\u627D\u6281\u6282\u6283\u6285\u6286\u6287\u6288\u628B", 5, "\u6294\u6299\u629C\u629D\u629E\u62A3\u62A6\u62A7\u62A9\u62AA\u62AD\u62AE\u62AF\u62B0\u62B2\u62B3\u62B4\u62B6\u62B7\u62B8\u62BA\u62BE\u62C0\u62C1"],
      ["9280", "\u62C3\u62CB\u62CF\u62D1\u62D5\u62DD\u62DE\u62E0\u62E1\u62E4\u62EA\u62EB\u62F0\u62F2\u62F5\u62F8\u62F9\u62FA\u62FB\u6300\u6303\u6304\u6305\u6306\u630A\u630B\u630C\u630D\u630F\u6310\u6312\u6313\u6314\u6315\u6317\u6318\u6319\u631C\u6326\u6327\u6329\u632C\u632D\u632E\u6330\u6331\u6333", 5, "\u633B\u633C\u633E\u633F\u6340\u6341\u6344\u6347\u6348\u634A\u6351\u6352\u6353\u6354\u6356", 7, "\u6360\u6364\u6365\u6366\u6368\u636A\u636B\u636C\u636F\u6370\u6372\u6373\u6374\u6375\u6378\u6379\u637C\u637D\u637E\u637F\u6381\u6383\u6384\u6385\u6386\u638B\u638D\u6391\u6393\u6394\u6395\u6397\u6399", 6, "\u63A1\u63A4\u63A6\u63AB\u63AF\u63B1\u63B2\u63B5\u63B6\u63B9\u63BB\u63BD\u63BF\u63C0"],
      ["9340", "\u63C1\u63C2\u63C3\u63C5\u63C7\u63C8\u63CA\u63CB\u63CC\u63D1\u63D3\u63D4\u63D5\u63D7", 6, "\u63DF\u63E2\u63E4", 4, "\u63EB\u63EC\u63EE\u63EF\u63F0\u63F1\u63F3\u63F5\u63F7\u63F9\u63FA\u63FB\u63FC\u63FE\u6403\u6404\u6406", 4, "\u640D\u640E\u6411\u6412\u6415", 5, "\u641D\u641F\u6422\u6423\u6424"],
      ["9380", "\u6425\u6427\u6428\u6429\u642B\u642E", 5, "\u6435", 4, "\u643B\u643C\u643E\u6440\u6442\u6443\u6449\u644B", 6, "\u6453\u6455\u6456\u6457\u6459", 4, "\u645F", 7, "\u6468\u646A\u646B\u646C\u646E", 9, "\u647B", 6, "\u6483\u6486\u6488", 8, "\u6493\u6494\u6497\u6498\u649A\u649B\u649C\u649D\u649F", 4, "\u64A5\u64A6\u64A7\u64A8\u64AA\u64AB\u64AF\u64B1\u64B2\u64B3\u64B4\u64B6\u64B9\u64BB\u64BD\u64BE\u64BF\u64C1\u64C3\u64C4\u64C6", 6, "\u64CF\u64D1\u64D3\u64D4\u64D5\u64D6\u64D9\u64DA"],
      ["9440", "\u64DB\u64DC\u64DD\u64DF\u64E0\u64E1\u64E3\u64E5\u64E7", 24, "\u6501", 7, "\u650A", 7, "\u6513", 4, "\u6519", 8],
      ["9480", "\u6522\u6523\u6524\u6526", 4, "\u652C\u652D\u6530\u6531\u6532\u6533\u6537\u653A\u653C\u653D\u6540", 4, "\u6546\u6547\u654A\u654B\u654D\u654E\u6550\u6552\u6553\u6554\u6557\u6558\u655A\u655C\u655F\u6560\u6561\u6564\u6565\u6567\u6568\u6569\u656A\u656D\u656E\u656F\u6571\u6573\u6575\u6576\u6578", 14, "\u6588\u6589\u658A\u658D\u658E\u658F\u6592\u6594\u6595\u6596\u6598\u659A\u659D\u659E\u65A0\u65A2\u65A3\u65A6\u65A8\u65AA\u65AC\u65AE\u65B1", 7, "\u65BA\u65BB\u65BE\u65BF\u65C0\u65C2\u65C7\u65C8\u65C9\u65CA\u65CD\u65D0\u65D1\u65D3\u65D4\u65D5\u65D8", 7, "\u65E1\u65E3\u65E4\u65EA\u65EB"],
      ["9540", "\u65F2\u65F3\u65F4\u65F5\u65F8\u65F9\u65FB", 4, "\u6601\u6604\u6605\u6607\u6608\u6609\u660B\u660D\u6610\u6611\u6612\u6616\u6617\u6618\u661A\u661B\u661C\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6632\u6633\u6637", 4, "\u663D\u663F\u6640\u6642\u6644", 6, "\u664D\u664E\u6650\u6651\u6658"],
      ["9580", "\u6659\u665B\u665C\u665D\u665E\u6660\u6662\u6663\u6665\u6667\u6669", 4, "\u6671\u6672\u6673\u6675\u6678\u6679\u667B\u667C\u667D\u667F\u6680\u6681\u6683\u6685\u6686\u6688\u6689\u668A\u668B\u668D\u668E\u668F\u6690\u6692\u6693\u6694\u6695\u6698", 4, "\u669E", 8, "\u66A9", 4, "\u66AF", 4, "\u66B5\u66B6\u66B7\u66B8\u66BA\u66BB\u66BC\u66BD\u66BF", 25, "\u66DA\u66DE", 7, "\u66E7\u66E8\u66EA", 5, "\u66F1\u66F5\u66F6\u66F8\u66FA\u66FB\u66FD\u6701\u6702\u6703"],
      ["9640", "\u6704\u6705\u6706\u6707\u670C\u670E\u670F\u6711\u6712\u6713\u6716\u6718\u6719\u671A\u671C\u671E\u6720", 5, "\u6727\u6729\u672E\u6730\u6732\u6733\u6736\u6737\u6738\u6739\u673B\u673C\u673E\u673F\u6741\u6744\u6745\u6747\u674A\u674B\u674D\u6752\u6754\u6755\u6757", 4, "\u675D\u6762\u6763\u6764\u6766\u6767\u676B\u676C\u676E\u6771\u6774\u6776"],
      ["9680", "\u6778\u6779\u677A\u677B\u677D\u6780\u6782\u6783\u6785\u6786\u6788\u678A\u678C\u678D\u678E\u678F\u6791\u6792\u6793\u6794\u6796\u6799\u679B\u679F\u67A0\u67A1\u67A4\u67A6\u67A9\u67AC\u67AE\u67B1\u67B2\u67B4\u67B9", 7, "\u67C2\u67C5", 9, "\u67D5\u67D6\u67D7\u67DB\u67DF\u67E1\u67E3\u67E4\u67E6\u67E7\u67E8\u67EA\u67EB\u67ED\u67EE\u67F2\u67F5", 7, "\u67FE\u6801\u6802\u6803\u6804\u6806\u680D\u6810\u6812\u6814\u6815\u6818", 4, "\u681E\u681F\u6820\u6822", 6, "\u682B", 6, "\u6834\u6835\u6836\u683A\u683B\u683F\u6847\u684B\u684D\u684F\u6852\u6856", 5],
      ["9740", "\u685C\u685D\u685E\u685F\u686A\u686C", 7, "\u6875\u6878", 8, "\u6882\u6884\u6887", 7, "\u6890\u6891\u6892\u6894\u6895\u6896\u6898", 9, "\u68A3\u68A4\u68A5\u68A9\u68AA\u68AB\u68AC\u68AE\u68B1\u68B2\u68B4\u68B6\u68B7\u68B8"],
      ["9780", "\u68B9", 6, "\u68C1\u68C3", 5, "\u68CA\u68CC\u68CE\u68CF\u68D0\u68D1\u68D3\u68D4\u68D6\u68D7\u68D9\u68DB", 4, "\u68E1\u68E2\u68E4", 9, "\u68EF\u68F2\u68F3\u68F4\u68F6\u68F7\u68F8\u68FB\u68FD\u68FE\u68FF\u6900\u6902\u6903\u6904\u6906", 4, "\u690C\u690F\u6911\u6913", 11, "\u6921\u6922\u6923\u6925", 7, "\u692E\u692F\u6931\u6932\u6933\u6935\u6936\u6937\u6938\u693A\u693B\u693C\u693E\u6940\u6941\u6943", 16, "\u6955\u6956\u6958\u6959\u695B\u695C\u695F"],
      ["9840", "\u6961\u6962\u6964\u6965\u6967\u6968\u6969\u696A\u696C\u696D\u696F\u6970\u6972", 4, "\u697A\u697B\u697D\u697E\u697F\u6981\u6983\u6985\u698A\u698B\u698C\u698E", 5, "\u6996\u6997\u6999\u699A\u699D", 9, "\u69A9\u69AA\u69AC\u69AE\u69AF\u69B0\u69B2\u69B3\u69B5\u69B6\u69B8\u69B9\u69BA\u69BC\u69BD"],
      ["9880", "\u69BE\u69BF\u69C0\u69C2", 7, "\u69CB\u69CD\u69CF\u69D1\u69D2\u69D3\u69D5", 5, "\u69DC\u69DD\u69DE\u69E1", 11, "\u69EE\u69EF\u69F0\u69F1\u69F3", 9, "\u69FE\u6A00", 9, "\u6A0B", 11, "\u6A19", 5, "\u6A20\u6A22", 5, "\u6A29\u6A2B\u6A2C\u6A2D\u6A2E\u6A30\u6A32\u6A33\u6A34\u6A36", 6, "\u6A3F", 4, "\u6A45\u6A46\u6A48", 7, "\u6A51", 6, "\u6A5A"],
      ["9940", "\u6A5C", 4, "\u6A62\u6A63\u6A64\u6A66", 10, "\u6A72", 6, "\u6A7A\u6A7B\u6A7D\u6A7E\u6A7F\u6A81\u6A82\u6A83\u6A85", 8, "\u6A8F\u6A92", 4, "\u6A98", 7, "\u6AA1", 5],
      ["9980", "\u6AA7\u6AA8\u6AAA\u6AAD", 114, "\u6B25\u6B26\u6B28", 6],
      ["9a40", "\u6B2F\u6B30\u6B31\u6B33\u6B34\u6B35\u6B36\u6B38\u6B3B\u6B3C\u6B3D\u6B3F\u6B40\u6B41\u6B42\u6B44\u6B45\u6B48\u6B4A\u6B4B\u6B4D", 11, "\u6B5A", 7, "\u6B68\u6B69\u6B6B", 13, "\u6B7A\u6B7D\u6B7E\u6B7F\u6B80\u6B85\u6B88"],
      ["9a80", "\u6B8C\u6B8E\u6B8F\u6B90\u6B91\u6B94\u6B95\u6B97\u6B98\u6B99\u6B9C", 4, "\u6BA2", 7, "\u6BAB", 7, "\u6BB6\u6BB8", 6, "\u6BC0\u6BC3\u6BC4\u6BC6", 4, "\u6BCC\u6BCE\u6BD0\u6BD1\u6BD8\u6BDA\u6BDC", 4, "\u6BE2", 7, "\u6BEC\u6BED\u6BEE\u6BF0\u6BF1\u6BF2\u6BF4\u6BF6\u6BF7\u6BF8\u6BFA\u6BFB\u6BFC\u6BFE", 6, "\u6C08", 4, "\u6C0E\u6C12\u6C17\u6C1C\u6C1D\u6C1E\u6C20\u6C23\u6C25\u6C2B\u6C2C\u6C2D\u6C31\u6C33\u6C36\u6C37\u6C39\u6C3A\u6C3B\u6C3C\u6C3E\u6C3F\u6C43\u6C44\u6C45\u6C48\u6C4B", 4, "\u6C51\u6C52\u6C53\u6C56\u6C58"],
      ["9b40", "\u6C59\u6C5A\u6C62\u6C63\u6C65\u6C66\u6C67\u6C6B", 4, "\u6C71\u6C73\u6C75\u6C77\u6C78\u6C7A\u6C7B\u6C7C\u6C7F\u6C80\u6C84\u6C87\u6C8A\u6C8B\u6C8D\u6C8E\u6C91\u6C92\u6C95\u6C96\u6C97\u6C98\u6C9A\u6C9C\u6C9D\u6C9E\u6CA0\u6CA2\u6CA8\u6CAC\u6CAF\u6CB0\u6CB4\u6CB5\u6CB6\u6CB7\u6CBA\u6CC0\u6CC1\u6CC2\u6CC3\u6CC6\u6CC7\u6CC8\u6CCB\u6CCD\u6CCE\u6CCF\u6CD1\u6CD2\u6CD8"],
      ["9b80", "\u6CD9\u6CDA\u6CDC\u6CDD\u6CDF\u6CE4\u6CE6\u6CE7\u6CE9\u6CEC\u6CED\u6CF2\u6CF4\u6CF9\u6CFF\u6D00\u6D02\u6D03\u6D05\u6D06\u6D08\u6D09\u6D0A\u6D0D\u6D0F\u6D10\u6D11\u6D13\u6D14\u6D15\u6D16\u6D18\u6D1C\u6D1D\u6D1F", 5, "\u6D26\u6D28\u6D29\u6D2C\u6D2D\u6D2F\u6D30\u6D34\u6D36\u6D37\u6D38\u6D3A\u6D3F\u6D40\u6D42\u6D44\u6D49\u6D4C\u6D50\u6D55\u6D56\u6D57\u6D58\u6D5B\u6D5D\u6D5F\u6D61\u6D62\u6D64\u6D65\u6D67\u6D68\u6D6B\u6D6C\u6D6D\u6D70\u6D71\u6D72\u6D73\u6D75\u6D76\u6D79\u6D7A\u6D7B\u6D7D", 4, "\u6D83\u6D84\u6D86\u6D87\u6D8A\u6D8B\u6D8D\u6D8F\u6D90\u6D92\u6D96", 4, "\u6D9C\u6DA2\u6DA5\u6DAC\u6DAD\u6DB0\u6DB1\u6DB3\u6DB4\u6DB6\u6DB7\u6DB9", 5, "\u6DC1\u6DC2\u6DC3\u6DC8\u6DC9\u6DCA"],
      ["9c40", "\u6DCD\u6DCE\u6DCF\u6DD0\u6DD2\u6DD3\u6DD4\u6DD5\u6DD7\u6DDA\u6DDB\u6DDC\u6DDF\u6DE2\u6DE3\u6DE5\u6DE7\u6DE8\u6DE9\u6DEA\u6DED\u6DEF\u6DF0\u6DF2\u6DF4\u6DF5\u6DF6\u6DF8\u6DFA\u6DFD", 7, "\u6E06\u6E07\u6E08\u6E09\u6E0B\u6E0F\u6E12\u6E13\u6E15\u6E18\u6E19\u6E1B\u6E1C\u6E1E\u6E1F\u6E22\u6E26\u6E27\u6E28\u6E2A\u6E2C\u6E2E\u6E30\u6E31\u6E33\u6E35"],
      ["9c80", "\u6E36\u6E37\u6E39\u6E3B", 7, "\u6E45", 7, "\u6E4F\u6E50\u6E51\u6E52\u6E55\u6E57\u6E59\u6E5A\u6E5C\u6E5D\u6E5E\u6E60", 10, "\u6E6C\u6E6D\u6E6F", 14, "\u6E80\u6E81\u6E82\u6E84\u6E87\u6E88\u6E8A", 4, "\u6E91", 6, "\u6E99\u6E9A\u6E9B\u6E9D\u6E9E\u6EA0\u6EA1\u6EA3\u6EA4\u6EA6\u6EA8\u6EA9\u6EAB\u6EAC\u6EAD\u6EAE\u6EB0\u6EB3\u6EB5\u6EB8\u6EB9\u6EBC\u6EBE\u6EBF\u6EC0\u6EC3\u6EC4\u6EC5\u6EC6\u6EC8\u6EC9\u6ECA\u6ECC\u6ECD\u6ECE\u6ED0\u6ED2\u6ED6\u6ED8\u6ED9\u6EDB\u6EDC\u6EDD\u6EE3\u6EE7\u6EEA", 5],
      ["9d40", "\u6EF0\u6EF1\u6EF2\u6EF3\u6EF5\u6EF6\u6EF7\u6EF8\u6EFA", 7, "\u6F03\u6F04\u6F05\u6F07\u6F08\u6F0A", 4, "\u6F10\u6F11\u6F12\u6F16", 9, "\u6F21\u6F22\u6F23\u6F25\u6F26\u6F27\u6F28\u6F2C\u6F2E\u6F30\u6F32\u6F34\u6F35\u6F37", 6, "\u6F3F\u6F40\u6F41\u6F42"],
      ["9d80", "\u6F43\u6F44\u6F45\u6F48\u6F49\u6F4A\u6F4C\u6F4E", 9, "\u6F59\u6F5A\u6F5B\u6F5D\u6F5F\u6F60\u6F61\u6F63\u6F64\u6F65\u6F67", 5, "\u6F6F\u6F70\u6F71\u6F73\u6F75\u6F76\u6F77\u6F79\u6F7B\u6F7D", 6, "\u6F85\u6F86\u6F87\u6F8A\u6F8B\u6F8F", 12, "\u6F9D\u6F9E\u6F9F\u6FA0\u6FA2", 4, "\u6FA8", 10, "\u6FB4\u6FB5\u6FB7\u6FB8\u6FBA", 5, "\u6FC1\u6FC3", 5, "\u6FCA", 6, "\u6FD3", 10, "\u6FDF\u6FE2\u6FE3\u6FE4\u6FE5"],
      ["9e40", "\u6FE6", 7, "\u6FF0", 32, "\u7012", 7, "\u701C", 6, "\u7024", 6],
      ["9e80", "\u702B", 9, "\u7036\u7037\u7038\u703A", 17, "\u704D\u704E\u7050", 13, "\u705F", 11, "\u706E\u7071\u7072\u7073\u7074\u7077\u7079\u707A\u707B\u707D\u7081\u7082\u7083\u7084\u7086\u7087\u7088\u708B\u708C\u708D\u708F\u7090\u7091\u7093\u7097\u7098\u709A\u709B\u709E", 12, "\u70B0\u70B2\u70B4\u70B5\u70B6\u70BA\u70BE\u70BF\u70C4\u70C5\u70C6\u70C7\u70C9\u70CB", 12, "\u70DA"],
      ["9f40", "\u70DC\u70DD\u70DE\u70E0\u70E1\u70E2\u70E3\u70E5\u70EA\u70EE\u70F0", 6, "\u70F8\u70FA\u70FB\u70FC\u70FE", 10, "\u710B", 4, "\u7111\u7112\u7114\u7117\u711B", 10, "\u7127", 7, "\u7132\u7133\u7134"],
      ["9f80", "\u7135\u7137", 13, "\u7146\u7147\u7148\u7149\u714B\u714D\u714F", 12, "\u715D\u715F", 4, "\u7165\u7169", 4, "\u716F\u7170\u7171\u7174\u7175\u7176\u7177\u7179\u717B\u717C\u717E", 5, "\u7185", 4, "\u718B\u718C\u718D\u718E\u7190\u7191\u7192\u7193\u7195\u7196\u7197\u719A", 4, "\u71A1", 6, "\u71A9\u71AA\u71AB\u71AD", 5, "\u71B4\u71B6\u71B7\u71B8\u71BA", 8, "\u71C4", 9, "\u71CF", 4],
      ["a040", "\u71D6", 9, "\u71E1\u71E2\u71E3\u71E4\u71E6\u71E8", 5, "\u71EF", 9, "\u71FA", 11, "\u7207", 19],
      ["a080", "\u721B\u721C\u721E", 9, "\u7229\u722B\u722D\u722E\u722F\u7232\u7233\u7234\u723A\u723C\u723E\u7240", 6, "\u7249\u724A\u724B\u724E\u724F\u7250\u7251\u7253\u7254\u7255\u7257\u7258\u725A\u725C\u725E\u7260\u7263\u7264\u7265\u7268\u726A\u726B\u726C\u726D\u7270\u7271\u7273\u7274\u7276\u7277\u7278\u727B\u727C\u727D\u7282\u7283\u7285", 4, "\u728C\u728E\u7290\u7291\u7293", 11, "\u72A0", 11, "\u72AE\u72B1\u72B2\u72B3\u72B5\u72BA", 6, "\u72C5\u72C6\u72C7\u72C9\u72CA\u72CB\u72CC\u72CF\u72D1\u72D3\u72D4\u72D5\u72D6\u72D8\u72DA\u72DB"],
      ["a1a1", "\u3000\u3001\u3002\xB7\u02C9\u02C7\xA8\u3003\u3005\u2014\uFF5E\u2016\u2026\u2018\u2019\u201C\u201D\u3014\u3015\u3008", 7, "\u3016\u3017\u3010\u3011\xB1\xD7\xF7\u2236\u2227\u2228\u2211\u220F\u222A\u2229\u2208\u2237\u221A\u22A5\u2225\u2220\u2312\u2299\u222B\u222E\u2261\u224C\u2248\u223D\u221D\u2260\u226E\u226F\u2264\u2265\u221E\u2235\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFF04\xA4\uFFE0\uFFE1\u2030\xA7\u2116\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u203B\u2192\u2190\u2191\u2193\u3013"],
      ["a2a1", "\u2170", 9],
      ["a2b1", "\u2488", 19, "\u2474", 19, "\u2460", 9],
      ["a2e5", "\u3220", 9],
      ["a2f1", "\u2160", 11],
      ["a3a1", "\uFF01\uFF02\uFF03\uFFE5\uFF05", 88, "\uFFE3"],
      ["a4a1", "\u3041", 82],
      ["a5a1", "\u30A1", 85],
      ["a6a1", "\u0391", 16, "\u03A3", 6],
      ["a6c1", "\u03B1", 16, "\u03C3", 6],
      ["a6e0", "\uFE35\uFE36\uFE39\uFE3A\uFE3F\uFE40\uFE3D\uFE3E\uFE41\uFE42\uFE43\uFE44"],
      ["a6ee", "\uFE3B\uFE3C\uFE37\uFE38\uFE31"],
      ["a6f4", "\uFE33\uFE34"],
      ["a7a1", "\u0410", 5, "\u0401\u0416", 25],
      ["a7d1", "\u0430", 5, "\u0451\u0436", 25],
      ["a840", "\u02CA\u02CB\u02D9\u2013\u2015\u2025\u2035\u2105\u2109\u2196\u2197\u2198\u2199\u2215\u221F\u2223\u2252\u2266\u2267\u22BF\u2550", 35, "\u2581", 6],
      ["a880", "\u2588", 7, "\u2593\u2594\u2595\u25BC\u25BD\u25E2\u25E3\u25E4\u25E5\u2609\u2295\u3012\u301D\u301E"],
      ["a8a1", "\u0101\xE1\u01CE\xE0\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA\u01DC\xFC\xEA\u0251"],
      ["a8bd", "\u0144\u0148"],
      ["a8c0", "\u0261"],
      ["a8c5", "\u3105", 36],
      ["a940", "\u3021", 8, "\u32A3\u338E\u338F\u339C\u339D\u339E\u33A1\u33C4\u33CE\u33D1\u33D2\u33D5\uFE30\uFFE2\uFFE4"],
      ["a959", "\u2121\u3231"],
      ["a95c", "\u2010"],
      ["a960", "\u30FC\u309B\u309C\u30FD\u30FE\u3006\u309D\u309E\uFE49", 9, "\uFE54\uFE55\uFE56\uFE57\uFE59", 8],
      ["a980", "\uFE62", 4, "\uFE68\uFE69\uFE6A\uFE6B"],
      ["a996", "\u3007"],
      ["a9a4", "\u2500", 75],
      ["aa40", "\u72DC\u72DD\u72DF\u72E2", 5, "\u72EA\u72EB\u72F5\u72F6\u72F9\u72FD\u72FE\u72FF\u7300\u7302\u7304", 5, "\u730B\u730C\u730D\u730F\u7310\u7311\u7312\u7314\u7318\u7319\u731A\u731F\u7320\u7323\u7324\u7326\u7327\u7328\u732D\u732F\u7330\u7332\u7333\u7335\u7336\u733A\u733B\u733C\u733D\u7340", 8],
      ["aa80", "\u7349\u734A\u734B\u734C\u734E\u734F\u7351\u7353\u7354\u7355\u7356\u7358", 7, "\u7361", 10, "\u736E\u7370\u7371"],
      ["ab40", "\u7372", 11, "\u737F", 4, "\u7385\u7386\u7388\u738A\u738C\u738D\u738F\u7390\u7392\u7393\u7394\u7395\u7397\u7398\u7399\u739A\u739C\u739D\u739E\u73A0\u73A1\u73A3", 5, "\u73AA\u73AC\u73AD\u73B1\u73B4\u73B5\u73B6\u73B8\u73B9\u73BC\u73BD\u73BE\u73BF\u73C1\u73C3", 4],
      ["ab80", "\u73CB\u73CC\u73CE\u73D2", 6, "\u73DA\u73DB\u73DC\u73DD\u73DF\u73E1\u73E2\u73E3\u73E4\u73E6\u73E8\u73EA\u73EB\u73EC\u73EE\u73EF\u73F0\u73F1\u73F3", 4],
      ["ac40", "\u73F8", 10, "\u7404\u7407\u7408\u740B\u740C\u740D\u740E\u7411", 8, "\u741C", 5, "\u7423\u7424\u7427\u7429\u742B\u742D\u742F\u7431\u7432\u7437", 4, "\u743D\u743E\u743F\u7440\u7442", 11],
      ["ac80", "\u744E", 6, "\u7456\u7458\u745D\u7460", 12, "\u746E\u746F\u7471", 4, "\u7478\u7479\u747A"],
      ["ad40", "\u747B\u747C\u747D\u747F\u7482\u7484\u7485\u7486\u7488\u7489\u748A\u748C\u748D\u748F\u7491", 10, "\u749D\u749F", 7, "\u74AA", 15, "\u74BB", 12],
      ["ad80", "\u74C8", 9, "\u74D3", 8, "\u74DD\u74DF\u74E1\u74E5\u74E7", 6, "\u74F0\u74F1\u74F2"],
      ["ae40", "\u74F3\u74F5\u74F8", 6, "\u7500\u7501\u7502\u7503\u7505", 7, "\u750E\u7510\u7512\u7514\u7515\u7516\u7517\u751B\u751D\u751E\u7520", 4, "\u7526\u7527\u752A\u752E\u7534\u7536\u7539\u753C\u753D\u753F\u7541\u7542\u7543\u7544\u7546\u7547\u7549\u754A\u754D\u7550\u7551\u7552\u7553\u7555\u7556\u7557\u7558"],
      ["ae80", "\u755D", 7, "\u7567\u7568\u7569\u756B", 6, "\u7573\u7575\u7576\u7577\u757A", 4, "\u7580\u7581\u7582\u7584\u7585\u7587"],
      ["af40", "\u7588\u7589\u758A\u758C\u758D\u758E\u7590\u7593\u7595\u7598\u759B\u759C\u759E\u75A2\u75A6", 4, "\u75AD\u75B6\u75B7\u75BA\u75BB\u75BF\u75C0\u75C1\u75C6\u75CB\u75CC\u75CE\u75CF\u75D0\u75D1\u75D3\u75D7\u75D9\u75DA\u75DC\u75DD\u75DF\u75E0\u75E1\u75E5\u75E9\u75EC\u75ED\u75EE\u75EF\u75F2\u75F3\u75F5\u75F6\u75F7\u75F8\u75FA\u75FB\u75FD\u75FE\u7602\u7604\u7606\u7607"],
      ["af80", "\u7608\u7609\u760B\u760D\u760E\u760F\u7611\u7612\u7613\u7614\u7616\u761A\u761C\u761D\u761E\u7621\u7623\u7627\u7628\u762C\u762E\u762F\u7631\u7632\u7636\u7637\u7639\u763A\u763B\u763D\u7641\u7642\u7644"],
      ["b040", "\u7645", 6, "\u764E", 5, "\u7655\u7657", 4, "\u765D\u765F\u7660\u7661\u7662\u7664", 6, "\u766C\u766D\u766E\u7670", 7, "\u7679\u767A\u767C\u767F\u7680\u7681\u7683\u7685\u7689\u768A\u768C\u768D\u768F\u7690\u7692\u7694\u7695\u7697\u7698\u769A\u769B"],
      ["b080", "\u769C", 7, "\u76A5", 8, "\u76AF\u76B0\u76B3\u76B5", 9, "\u76C0\u76C1\u76C3\u554A\u963F\u57C3\u6328\u54CE\u5509\u54C0\u7691\u764C\u853C\u77EE\u827E\u788D\u7231\u9698\u978D\u6C28\u5B89\u4FFA\u6309\u6697\u5CB8\u80FA\u6848\u80AE\u6602\u76CE\u51F9\u6556\u71AC\u7FF1\u8884\u50B2\u5965\u61CA\u6FB3\u82AD\u634C\u6252\u53ED\u5427\u7B06\u516B\u75A4\u5DF4\u62D4\u8DCB\u9776\u628A\u8019\u575D\u9738\u7F62\u7238\u767D\u67CF\u767E\u6446\u4F70\u8D25\u62DC\u7A17\u6591\u73ED\u642C\u6273\u822C\u9881\u677F\u7248\u626E\u62CC\u4F34\u74E3\u534A\u529E\u7ECA\u90A6\u5E2E\u6886\u699C\u8180\u7ED1\u68D2\u78C5\u868C\u9551\u508D\u8C24\u82DE\u80DE\u5305\u8912\u5265"],
      ["b140", "\u76C4\u76C7\u76C9\u76CB\u76CC\u76D3\u76D5\u76D9\u76DA\u76DC\u76DD\u76DE\u76E0", 4, "\u76E6", 7, "\u76F0\u76F3\u76F5\u76F6\u76F7\u76FA\u76FB\u76FD\u76FF\u7700\u7702\u7703\u7705\u7706\u770A\u770C\u770E", 10, "\u771B\u771C\u771D\u771E\u7721\u7723\u7724\u7725\u7727\u772A\u772B"],
      ["b180", "\u772C\u772E\u7730", 4, "\u7739\u773B\u773D\u773E\u773F\u7742\u7744\u7745\u7746\u7748", 7, "\u7752", 7, "\u775C\u8584\u96F9\u4FDD\u5821\u9971\u5B9D\u62B1\u62A5\u66B4\u8C79\u9C8D\u7206\u676F\u7891\u60B2\u5351\u5317\u8F88\u80CC\u8D1D\u94A1\u500D\u72C8\u5907\u60EB\u7119\u88AB\u5954\u82EF\u672C\u7B28\u5D29\u7EF7\u752D\u6CF5\u8E66\u8FF8\u903C\u9F3B\u6BD4\u9119\u7B14\u5F7C\u78A7\u84D6\u853D\u6BD5\u6BD9\u6BD6\u5E01\u5E87\u75F9\u95ED\u655D\u5F0A\u5FC5\u8F9F\u58C1\u81C2\u907F\u965B\u97AD\u8FB9\u7F16\u8D2C\u6241\u4FBF\u53D8\u535E\u8FA8\u8FA9\u8FAB\u904D\u6807\u5F6A\u8198\u8868\u9CD6\u618B\u522B\u762A\u5F6C\u658C\u6FD2\u6EE8\u5BBE\u6448\u5175\u51B0\u67C4\u4E19\u79C9\u997C\u70B3"],
      ["b240", "\u775D\u775E\u775F\u7760\u7764\u7767\u7769\u776A\u776D", 11, "\u777A\u777B\u777C\u7781\u7782\u7783\u7786", 5, "\u778F\u7790\u7793", 11, "\u77A1\u77A3\u77A4\u77A6\u77A8\u77AB\u77AD\u77AE\u77AF\u77B1\u77B2\u77B4\u77B6", 4],
      ["b280", "\u77BC\u77BE\u77C0", 12, "\u77CE", 8, "\u77D8\u77D9\u77DA\u77DD", 4, "\u77E4\u75C5\u5E76\u73BB\u83E0\u64AD\u62E8\u94B5\u6CE2\u535A\u52C3\u640F\u94C2\u7B94\u4F2F\u5E1B\u8236\u8116\u818A\u6E24\u6CCA\u9A73\u6355\u535C\u54FA\u8865\u57E0\u4E0D\u5E03\u6B65\u7C3F\u90E8\u6016\u64E6\u731C\u88C1\u6750\u624D\u8D22\u776C\u8E29\u91C7\u5F69\u83DC\u8521\u9910\u53C2\u8695\u6B8B\u60ED\u60E8\u707F\u82CD\u8231\u4ED3\u6CA7\u85CF\u64CD\u7CD9\u69FD\u66F9\u8349\u5395\u7B56\u4FA7\u518C\u6D4B\u5C42\u8E6D\u63D2\u53C9\u832C\u8336\u67E5\u78B4\u643D\u5BDF\u5C94\u5DEE\u8BE7\u62C6\u67F4\u8C7A\u6400\u63BA\u8749\u998B\u8C17\u7F20\u94F2\u4EA7\u9610\u98A4\u660C\u7316"],
      ["b340", "\u77E6\u77E8\u77EA\u77EF\u77F0\u77F1\u77F2\u77F4\u77F5\u77F7\u77F9\u77FA\u77FB\u77FC\u7803", 5, "\u780A\u780B\u780E\u780F\u7810\u7813\u7815\u7819\u781B\u781E\u7820\u7821\u7822\u7824\u7828\u782A\u782B\u782E\u782F\u7831\u7832\u7833\u7835\u7836\u783D\u783F\u7841\u7842\u7843\u7844\u7846\u7848\u7849\u784A\u784B\u784D\u784F\u7851\u7853\u7854\u7858\u7859\u785A"],
      ["b380", "\u785B\u785C\u785E", 11, "\u786F", 7, "\u7878\u7879\u787A\u787B\u787D", 6, "\u573A\u5C1D\u5E38\u957F\u507F\u80A0\u5382\u655E\u7545\u5531\u5021\u8D85\u6284\u949E\u671D\u5632\u6F6E\u5DE2\u5435\u7092\u8F66\u626F\u64A4\u63A3\u5F7B\u6F88\u90F4\u81E3\u8FB0\u5C18\u6668\u5FF1\u6C89\u9648\u8D81\u886C\u6491\u79F0\u57CE\u6A59\u6210\u5448\u4E58\u7A0B\u60E9\u6F84\u8BDA\u627F\u901E\u9A8B\u79E4\u5403\u75F4\u6301\u5319\u6C60\u8FDF\u5F1B\u9A70\u803B\u9F7F\u4F88\u5C3A\u8D64\u7FC5\u65A5\u70BD\u5145\u51B2\u866B\u5D07\u5BA0\u62BD\u916C\u7574\u8E0C\u7A20\u6101\u7B79\u4EC7\u7EF8\u7785\u4E11\u81ED\u521D\u51FA\u6A71\u53A8\u8E87\u9504\u96CF\u6EC1\u9664\u695A"],
      ["b440", "\u7884\u7885\u7886\u7888\u788A\u788B\u788F\u7890\u7892\u7894\u7895\u7896\u7899\u789D\u789E\u78A0\u78A2\u78A4\u78A6\u78A8", 7, "\u78B5\u78B6\u78B7\u78B8\u78BA\u78BB\u78BC\u78BD\u78BF\u78C0\u78C2\u78C3\u78C4\u78C6\u78C7\u78C8\u78CC\u78CD\u78CE\u78CF\u78D1\u78D2\u78D3\u78D6\u78D7\u78D8\u78DA", 9],
      ["b480", "\u78E4\u78E5\u78E6\u78E7\u78E9\u78EA\u78EB\u78ED", 4, "\u78F3\u78F5\u78F6\u78F8\u78F9\u78FB", 5, "\u7902\u7903\u7904\u7906", 6, "\u7840\u50A8\u77D7\u6410\u89E6\u5904\u63E3\u5DDD\u7A7F\u693D\u4F20\u8239\u5598\u4E32\u75AE\u7A97\u5E62\u5E8A\u95EF\u521B\u5439\u708A\u6376\u9524\u5782\u6625\u693F\u9187\u5507\u6DF3\u7EAF\u8822\u6233\u7EF0\u75B5\u8328\u78C1\u96CC\u8F9E\u6148\u74F7\u8BCD\u6B64\u523A\u8D50\u6B21\u806A\u8471\u56F1\u5306\u4ECE\u4E1B\u51D1\u7C97\u918B\u7C07\u4FC3\u8E7F\u7BE1\u7A9C\u6467\u5D14\u50AC\u8106\u7601\u7CB9\u6DEC\u7FE0\u6751\u5B58\u5BF8\u78CB\u64AE\u6413\u63AA\u632B\u9519\u642D\u8FBE\u7B54\u7629\u6253\u5927\u5446\u6B79\u50A3\u6234\u5E26\u6B86\u4EE3\u8D37\u888B\u5F85\u902E"],
      ["b540", "\u790D", 5, "\u7914", 9, "\u791F", 4, "\u7925", 14, "\u7935", 4, "\u793D\u793F\u7942\u7943\u7944\u7945\u7947\u794A", 8, "\u7954\u7955\u7958\u7959\u7961\u7963"],
      ["b580", "\u7964\u7966\u7969\u796A\u796B\u796C\u796E\u7970", 6, "\u7979\u797B", 4, "\u7982\u7983\u7986\u7987\u7988\u7989\u798B\u798C\u798D\u798E\u7990\u7991\u7992\u6020\u803D\u62C5\u4E39\u5355\u90F8\u63B8\u80C6\u65E6\u6C2E\u4F46\u60EE\u6DE1\u8BDE\u5F39\u86CB\u5F53\u6321\u515A\u8361\u6863\u5200\u6363\u8E48\u5012\u5C9B\u7977\u5BFC\u5230\u7A3B\u60BC\u9053\u76D7\u5FB7\u5F97\u7684\u8E6C\u706F\u767B\u7B49\u77AA\u51F3\u9093\u5824\u4F4E\u6EF4\u8FEA\u654C\u7B1B\u72C4\u6DA4\u7FDF\u5AE1\u62B5\u5E95\u5730\u8482\u7B2C\u5E1D\u5F1F\u9012\u7F14\u98A0\u6382\u6EC7\u7898\u70B9\u5178\u975B\u57AB\u7535\u4F43\u7538\u5E97\u60E6\u5960\u6DC0\u6BBF\u7889\u53FC\u96D5\u51CB\u5201\u6389\u540A\u9493\u8C03\u8DCC\u7239\u789F\u8776\u8FED\u8C0D\u53E0"],
      ["b640", "\u7993", 6, "\u799B", 11, "\u79A8", 10, "\u79B4", 4, "\u79BC\u79BF\u79C2\u79C4\u79C5\u79C7\u79C8\u79CA\u79CC\u79CE\u79CF\u79D0\u79D3\u79D4\u79D6\u79D7\u79D9", 5, "\u79E0\u79E1\u79E2\u79E5\u79E8\u79EA"],
      ["b680", "\u79EC\u79EE\u79F1", 6, "\u79F9\u79FA\u79FC\u79FE\u79FF\u7A01\u7A04\u7A05\u7A07\u7A08\u7A09\u7A0A\u7A0C\u7A0F", 4, "\u7A15\u7A16\u7A18\u7A19\u7A1B\u7A1C\u4E01\u76EF\u53EE\u9489\u9876\u9F0E\u952D\u5B9A\u8BA2\u4E22\u4E1C\u51AC\u8463\u61C2\u52A8\u680B\u4F97\u606B\u51BB\u6D1E\u515C\u6296\u6597\u9661\u8C46\u9017\u75D8\u90FD\u7763\u6BD2\u728A\u72EC\u8BFB\u5835\u7779\u8D4C\u675C\u9540\u809A\u5EA6\u6E21\u5992\u7AEF\u77ED\u953B\u6BB5\u65AD\u7F0E\u5806\u5151\u961F\u5BF9\u58A9\u5428\u8E72\u6566\u987F\u56E4\u949D\u76FE\u9041\u6387\u54C6\u591A\u593A\u579B\u8EB2\u6735\u8DFA\u8235\u5241\u60F0\u5815\u86FE\u5CE8\u9E45\u4FC4\u989D\u8BB9\u5A25\u6076\u5384\u627C\u904F\u9102\u997F\u6069\u800C\u513F\u8033\u5C14\u9975\u6D31\u4E8C"],
      ["b740", "\u7A1D\u7A1F\u7A21\u7A22\u7A24", 14, "\u7A34\u7A35\u7A36\u7A38\u7A3A\u7A3E\u7A40", 5, "\u7A47", 9, "\u7A52", 4, "\u7A58", 16],
      ["b780", "\u7A69", 6, "\u7A71\u7A72\u7A73\u7A75\u7A7B\u7A7C\u7A7D\u7A7E\u7A82\u7A85\u7A87\u7A89\u7A8A\u7A8B\u7A8C\u7A8E\u7A8F\u7A90\u7A93\u7A94\u7A99\u7A9A\u7A9B\u7A9E\u7AA1\u7AA2\u8D30\u53D1\u7F5A\u7B4F\u4F10\u4E4F\u9600\u6CD5\u73D0\u85E9\u5E06\u756A\u7FFB\u6A0A\u77FE\u9492\u7E41\u51E1\u70E6\u53CD\u8FD4\u8303\u8D29\u72AF\u996D\u6CDB\u574A\u82B3\u65B9\u80AA\u623F\u9632\u59A8\u4EFF\u8BBF\u7EBA\u653E\u83F2\u975E\u5561\u98DE\u80A5\u532A\u8BFD\u5420\u80BA\u5E9F\u6CB8\u8D39\u82AC\u915A\u5429\u6C1B\u5206\u7EB7\u575F\u711A\u6C7E\u7C89\u594B\u4EFD\u5FFF\u6124\u7CAA\u4E30\u5C01\u67AB\u8702\u5CF0\u950B\u98CE\u75AF\u70FD\u9022\u51AF\u7F1D\u8BBD\u5949\u51E4\u4F5B\u5426\u592B\u6577\u80A4\u5B75\u6276\u62C2\u8F90\u5E45\u6C1F\u7B26\u4F0F\u4FD8\u670D"],
      ["b840", "\u7AA3\u7AA4\u7AA7\u7AA9\u7AAA\u7AAB\u7AAE", 4, "\u7AB4", 10, "\u7AC0", 10, "\u7ACC", 9, "\u7AD7\u7AD8\u7ADA\u7ADB\u7ADC\u7ADD\u7AE1\u7AE2\u7AE4\u7AE7", 5, "\u7AEE\u7AF0\u7AF1\u7AF2\u7AF3"],
      ["b880", "\u7AF4", 4, "\u7AFB\u7AFC\u7AFE\u7B00\u7B01\u7B02\u7B05\u7B07\u7B09\u7B0C\u7B0D\u7B0E\u7B10\u7B12\u7B13\u7B16\u7B17\u7B18\u7B1A\u7B1C\u7B1D\u7B1F\u7B21\u7B22\u7B23\u7B27\u7B29\u7B2D\u6D6E\u6DAA\u798F\u88B1\u5F17\u752B\u629A\u8F85\u4FEF\u91DC\u65A7\u812F\u8151\u5E9C\u8150\u8D74\u526F\u8986\u8D4B\u590D\u5085\u4ED8\u961C\u7236\u8179\u8D1F\u5BCC\u8BA3\u9644\u5987\u7F1A\u5490\u5676\u560E\u8BE5\u6539\u6982\u9499\u76D6\u6E89\u5E72\u7518\u6746\u67D1\u7AFF\u809D\u8D76\u611F\u79C6\u6562\u8D63\u5188\u521A\u94A2\u7F38\u809B\u7EB2\u5C97\u6E2F\u6760\u7BD9\u768B\u9AD8\u818F\u7F94\u7CD5\u641E\u9550\u7A3F\u544A\u54E5\u6B4C\u6401\u6208\u9E3D\u80F3\u7599\u5272\u9769\u845B\u683C\u86E4\u9601\u9694\u94EC\u4E2A\u5404\u7ED9\u6839\u8DDF\u8015\u66F4\u5E9A\u7FB9"],
      ["b940", "\u7B2F\u7B30\u7B32\u7B34\u7B35\u7B36\u7B37\u7B39\u7B3B\u7B3D\u7B3F", 5, "\u7B46\u7B48\u7B4A\u7B4D\u7B4E\u7B53\u7B55\u7B57\u7B59\u7B5C\u7B5E\u7B5F\u7B61\u7B63", 10, "\u7B6F\u7B70\u7B73\u7B74\u7B76\u7B78\u7B7A\u7B7C\u7B7D\u7B7F\u7B81\u7B82\u7B83\u7B84\u7B86", 6, "\u7B8E\u7B8F"],
      ["b980", "\u7B91\u7B92\u7B93\u7B96\u7B98\u7B99\u7B9A\u7B9B\u7B9E\u7B9F\u7BA0\u7BA3\u7BA4\u7BA5\u7BAE\u7BAF\u7BB0\u7BB2\u7BB3\u7BB5\u7BB6\u7BB7\u7BB9", 7, "\u7BC2\u7BC3\u7BC4\u57C2\u803F\u6897\u5DE5\u653B\u529F\u606D\u9F9A\u4F9B\u8EAC\u516C\u5BAB\u5F13\u5DE9\u6C5E\u62F1\u8D21\u5171\u94A9\u52FE\u6C9F\u82DF\u72D7\u57A2\u6784\u8D2D\u591F\u8F9C\u83C7\u5495\u7B8D\u4F30\u6CBD\u5B64\u59D1\u9F13\u53E4\u86CA\u9AA8\u8C37\u80A1\u6545\u987E\u56FA\u96C7\u522E\u74DC\u5250\u5BE1\u6302\u8902\u4E56\u62D0\u602A\u68FA\u5173\u5B98\u51A0\u89C2\u7BA1\u9986\u7F50\u60EF\u704C\u8D2F\u5149\u5E7F\u901B\u7470\u89C4\u572D\u7845\u5F52\u9F9F\u95FA\u8F68\u9B3C\u8BE1\u7678\u6842\u67DC\u8DEA\u8D35\u523D\u8F8A\u6EDA\u68CD\u9505\u90ED\u56FD\u679C\u88F9\u8FC7\u54C8"],
      ["ba40", "\u7BC5\u7BC8\u7BC9\u7BCA\u7BCB\u7BCD\u7BCE\u7BCF\u7BD0\u7BD2\u7BD4", 4, "\u7BDB\u7BDC\u7BDE\u7BDF\u7BE0\u7BE2\u7BE3\u7BE4\u7BE7\u7BE8\u7BE9\u7BEB\u7BEC\u7BED\u7BEF\u7BF0\u7BF2", 4, "\u7BF8\u7BF9\u7BFA\u7BFB\u7BFD\u7BFF", 7, "\u7C08\u7C09\u7C0A\u7C0D\u7C0E\u7C10", 5, "\u7C17\u7C18\u7C19"],
      ["ba80", "\u7C1A", 4, "\u7C20", 5, "\u7C28\u7C29\u7C2B", 12, "\u7C39", 5, "\u7C42\u9AB8\u5B69\u6D77\u6C26\u4EA5\u5BB3\u9A87\u9163\u61A8\u90AF\u97E9\u542B\u6DB5\u5BD2\u51FD\u558A\u7F55\u7FF0\u64BC\u634D\u65F1\u61BE\u608D\u710A\u6C57\u6C49\u592F\u676D\u822A\u58D5\u568E\u8C6A\u6BEB\u90DD\u597D\u8017\u53F7\u6D69\u5475\u559D\u8377\u83CF\u6838\u79BE\u548C\u4F55\u5408\u76D2\u8C89\u9602\u6CB3\u6DB8\u8D6B\u8910\u9E64\u8D3A\u563F\u9ED1\u75D5\u5F88\u72E0\u6068\u54FC\u4EA8\u6A2A\u8861\u6052\u8F70\u54C4\u70D8\u8679\u9E3F\u6D2A\u5B8F\u5F18\u7EA2\u5589\u4FAF\u7334\u543C\u539A\u5019\u540E\u547C\u4E4E\u5FFD\u745A\u58F6\u846B\u80E1\u8774\u72D0\u7CCA\u6E56"],
      ["bb40", "\u7C43", 9, "\u7C4E", 36, "\u7C75", 5, "\u7C7E", 9],
      ["bb80", "\u7C88\u7C8A", 6, "\u7C93\u7C94\u7C96\u7C99\u7C9A\u7C9B\u7CA0\u7CA1\u7CA3\u7CA6\u7CA7\u7CA8\u7CA9\u7CAB\u7CAC\u7CAD\u7CAF\u7CB0\u7CB4", 4, "\u7CBA\u7CBB\u5F27\u864E\u552C\u62A4\u4E92\u6CAA\u6237\u82B1\u54D7\u534E\u733E\u6ED1\u753B\u5212\u5316\u8BDD\u69D0\u5F8A\u6000\u6DEE\u574F\u6B22\u73AF\u6853\u8FD8\u7F13\u6362\u60A3\u5524\u75EA\u8C62\u7115\u6DA3\u5BA6\u5E7B\u8352\u614C\u9EC4\u78FA\u8757\u7C27\u7687\u51F0\u60F6\u714C\u6643\u5E4C\u604D\u8C0E\u7070\u6325\u8F89\u5FBD\u6062\u86D4\u56DE\u6BC1\u6094\u6167\u5349\u60E0\u6666\u8D3F\u79FD\u4F1A\u70E9\u6C47\u8BB3\u8BF2\u7ED8\u8364\u660F\u5A5A\u9B42\u6D51\u6DF7\u8C41\u6D3B\u4F19\u706B\u83B7\u6216\u60D1\u970D\u8D27\u7978\u51FB\u573E\u57FA\u673A\u7578\u7A3D\u79EF\u7B95"],
      ["bc40", "\u7CBF\u7CC0\u7CC2\u7CC3\u7CC4\u7CC6\u7CC9\u7CCB\u7CCE", 6, "\u7CD8\u7CDA\u7CDB\u7CDD\u7CDE\u7CE1", 6, "\u7CE9", 5, "\u7CF0", 7, "\u7CF9\u7CFA\u7CFC", 13, "\u7D0B", 5],
      ["bc80", "\u7D11", 14, "\u7D21\u7D23\u7D24\u7D25\u7D26\u7D28\u7D29\u7D2A\u7D2C\u7D2D\u7D2E\u7D30", 6, "\u808C\u9965\u8FF9\u6FC0\u8BA5\u9E21\u59EC\u7EE9\u7F09\u5409\u6781\u68D8\u8F91\u7C4D\u96C6\u53CA\u6025\u75BE\u6C72\u5373\u5AC9\u7EA7\u6324\u51E0\u810A\u5DF1\u84DF\u6280\u5180\u5B63\u4F0E\u796D\u5242\u60B8\u6D4E\u5BC4\u5BC2\u8BA1\u8BB0\u65E2\u5FCC\u9645\u5993\u7EE7\u7EAA\u5609\u67B7\u5939\u4F73\u5BB6\u52A0\u835A\u988A\u8D3E\u7532\u94BE\u5047\u7A3C\u4EF7\u67B6\u9A7E\u5AC1\u6B7C\u76D1\u575A\u5C16\u7B3A\u95F4\u714E\u517C\u80A9\u8270\u5978\u7F04\u8327\u68C0\u67EC\u78B1\u7877\u62E3\u6361\u7B80\u4FED\u526A\u51CF\u8350\u69DB\u9274\u8DF5\u8D31\u89C1\u952E\u7BAD\u4EF6"],
      ["bd40", "\u7D37", 54, "\u7D6F", 7],
      ["bd80", "\u7D78", 32, "\u5065\u8230\u5251\u996F\u6E10\u6E85\u6DA7\u5EFA\u50F5\u59DC\u5C06\u6D46\u6C5F\u7586\u848B\u6868\u5956\u8BB2\u5320\u9171\u964D\u8549\u6912\u7901\u7126\u80F6\u4EA4\u90CA\u6D47\u9A84\u5A07\u56BC\u6405\u94F0\u77EB\u4FA5\u811A\u72E1\u89D2\u997A\u7F34\u7EDE\u527F\u6559\u9175\u8F7F\u8F83\u53EB\u7A96\u63ED\u63A5\u7686\u79F8\u8857\u9636\u622A\u52AB\u8282\u6854\u6770\u6377\u776B\u7AED\u6D01\u7ED3\u89E3\u59D0\u6212\u85C9\u82A5\u754C\u501F\u4ECB\u75A5\u8BEB\u5C4A\u5DFE\u7B4B\u65A4\u91D1\u4ECA\u6D25\u895F\u7D27\u9526\u4EC5\u8C28\u8FDB\u9773\u664B\u7981\u8FD1\u70EC\u6D78"],
      ["be40", "\u7D99", 12, "\u7DA7", 6, "\u7DAF", 42],
      ["be80", "\u7DDA", 32, "\u5C3D\u52B2\u8346\u5162\u830E\u775B\u6676\u9CB8\u4EAC\u60CA\u7CBE\u7CB3\u7ECF\u4E95\u8B66\u666F\u9888\u9759\u5883\u656C\u955C\u5F84\u75C9\u9756\u7ADF\u7ADE\u51C0\u70AF\u7A98\u63EA\u7A76\u7EA0\u7396\u97ED\u4E45\u7078\u4E5D\u9152\u53A9\u6551\u65E7\u81FC\u8205\u548E\u5C31\u759A\u97A0\u62D8\u72D9\u75BD\u5C45\u9A79\u83CA\u5C40\u5480\u77E9\u4E3E\u6CAE\u805A\u62D2\u636E\u5DE8\u5177\u8DDD\u8E1E\u952F\u4FF1\u53E5\u60E7\u70AC\u5267\u6350\u9E43\u5A1F\u5026\u7737\u5377\u7EE2\u6485\u652B\u6289\u6398\u5014\u7235\u89C9\u51B3\u8BC0\u7EDD\u5747\u83CC\u94A7\u519B\u541B\u5CFB"],
      ["bf40", "\u7DFB", 62],
      ["bf80", "\u7E3A\u7E3C", 4, "\u7E42", 4, "\u7E48", 21, "\u4FCA\u7AE3\u6D5A\u90E1\u9A8F\u5580\u5496\u5361\u54AF\u5F00\u63E9\u6977\u51EF\u6168\u520A\u582A\u52D8\u574E\u780D\u770B\u5EB7\u6177\u7CE0\u625B\u6297\u4EA2\u7095\u8003\u62F7\u70E4\u9760\u5777\u82DB\u67EF\u68F5\u78D5\u9897\u79D1\u58F3\u54B3\u53EF\u6E34\u514B\u523B\u5BA2\u8BFE\u80AF\u5543\u57A6\u6073\u5751\u542D\u7A7A\u6050\u5B54\u63A7\u62A0\u53E3\u6263\u5BC7\u67AF\u54ED\u7A9F\u82E6\u9177\u5E93\u88E4\u5938\u57AE\u630E\u8DE8\u80EF\u5757\u7B77\u4FA9\u5FEB\u5BBD\u6B3E\u5321\u7B50\u72C2\u6846\u77FF\u7736\u65F7\u51B5\u4E8F\u76D4\u5CBF\u7AA5\u8475\u594E\u9B41\u5080"],
      ["c040", "\u7E5E", 35, "\u7E83", 23, "\u7E9C\u7E9D\u7E9E"],
      ["c080", "\u7EAE\u7EB4\u7EBB\u7EBC\u7ED6\u7EE4\u7EEC\u7EF9\u7F0A\u7F10\u7F1E\u7F37\u7F39\u7F3B", 6, "\u7F43\u7F46", 9, "\u7F52\u7F53\u9988\u6127\u6E83\u5764\u6606\u6346\u56F0\u62EC\u6269\u5ED3\u9614\u5783\u62C9\u5587\u8721\u814A\u8FA3\u5566\u83B1\u6765\u8D56\u84DD\u5A6A\u680F\u62E6\u7BEE\u9611\u5170\u6F9C\u8C30\u63FD\u89C8\u61D2\u7F06\u70C2\u6EE5\u7405\u6994\u72FC\u5ECA\u90CE\u6717\u6D6A\u635E\u52B3\u7262\u8001\u4F6C\u59E5\u916A\u70D9\u6D9D\u52D2\u4E50\u96F7\u956D\u857E\u78CA\u7D2F\u5121\u5792\u64C2\u808B\u7C7B\u6CEA\u68F1\u695E\u51B7\u5398\u68A8\u7281\u9ECE\u7BF1\u72F8\u79BB\u6F13\u7406\u674E\u91CC\u9CA4\u793C\u8389\u8354\u540F\u6817\u4E3D\u5389\u52B1\u783E\u5386\u5229\u5088\u4F8B\u4FD0"],
      ["c140", "\u7F56\u7F59\u7F5B\u7F5C\u7F5D\u7F5E\u7F60\u7F63", 4, "\u7F6B\u7F6C\u7F6D\u7F6F\u7F70\u7F73\u7F75\u7F76\u7F77\u7F78\u7F7A\u7F7B\u7F7C\u7F7D\u7F7F\u7F80\u7F82", 7, "\u7F8B\u7F8D\u7F8F", 4, "\u7F95", 4, "\u7F9B\u7F9C\u7FA0\u7FA2\u7FA3\u7FA5\u7FA6\u7FA8", 6, "\u7FB1"],
      ["c180", "\u7FB3", 4, "\u7FBA\u7FBB\u7FBE\u7FC0\u7FC2\u7FC3\u7FC4\u7FC6\u7FC7\u7FC8\u7FC9\u7FCB\u7FCD\u7FCF", 4, "\u7FD6\u7FD7\u7FD9", 5, "\u7FE2\u7FE3\u75E2\u7ACB\u7C92\u6CA5\u96B6\u529B\u7483\u54E9\u4FE9\u8054\u83B2\u8FDE\u9570\u5EC9\u601C\u6D9F\u5E18\u655B\u8138\u94FE\u604B\u70BC\u7EC3\u7CAE\u51C9\u6881\u7CB1\u826F\u4E24\u8F86\u91CF\u667E\u4EAE\u8C05\u64A9\u804A\u50DA\u7597\u71CE\u5BE5\u8FBD\u6F66\u4E86\u6482\u9563\u5ED6\u6599\u5217\u88C2\u70C8\u52A3\u730E\u7433\u6797\u78F7\u9716\u4E34\u90BB\u9CDE\u6DCB\u51DB\u8D41\u541D\u62CE\u73B2\u83F1\u96F6\u9F84\u94C3\u4F36\u7F9A\u51CC\u7075\u9675\u5CAD\u9886\u53E6\u4EE4\u6E9C\u7409\u69B4\u786B\u998F\u7559\u5218\u7624\u6D41\u67F3\u516D\u9F99\u804B\u5499\u7B3C\u7ABF"],
      ["c240", "\u7FE4\u7FE7\u7FE8\u7FEA\u7FEB\u7FEC\u7FED\u7FEF\u7FF2\u7FF4", 6, "\u7FFD\u7FFE\u7FFF\u8002\u8007\u8008\u8009\u800A\u800E\u800F\u8011\u8013\u801A\u801B\u801D\u801E\u801F\u8021\u8023\u8024\u802B", 5, "\u8032\u8034\u8039\u803A\u803C\u803E\u8040\u8041\u8044\u8045\u8047\u8048\u8049\u804E\u804F\u8050\u8051\u8053\u8055\u8056\u8057"],
      ["c280", "\u8059\u805B", 13, "\u806B", 5, "\u8072", 11, "\u9686\u5784\u62E2\u9647\u697C\u5A04\u6402\u7BD3\u6F0F\u964B\u82A6\u5362\u9885\u5E90\u7089\u63B3\u5364\u864F\u9C81\u9E93\u788C\u9732\u8DEF\u8D42\u9E7F\u6F5E\u7984\u5F55\u9646\u622E\u9A74\u5415\u94DD\u4FA3\u65C5\u5C65\u5C61\u7F15\u8651\u6C2F\u5F8B\u7387\u6EE4\u7EFF\u5CE6\u631B\u5B6A\u6EE6\u5375\u4E71\u63A0\u7565\u62A1\u8F6E\u4F26\u4ED1\u6CA6\u7EB6\u8BBA\u841D\u87BA\u7F57\u903B\u9523\u7BA9\u9AA1\u88F8\u843D\u6D1B\u9A86\u7EDC\u5988\u9EBB\u739B\u7801\u8682\u9A6C\u9A82\u561B\u5417\u57CB\u4E70\u9EA6\u5356\u8FC8\u8109\u7792\u9992\u86EE\u6EE1\u8513\u66FC\u6162\u6F2B"],
      ["c340", "\u807E\u8081\u8082\u8085\u8088\u808A\u808D", 5, "\u8094\u8095\u8097\u8099\u809E\u80A3\u80A6\u80A7\u80A8\u80AC\u80B0\u80B3\u80B5\u80B6\u80B8\u80B9\u80BB\u80C5\u80C7", 4, "\u80CF", 6, "\u80D8\u80DF\u80E0\u80E2\u80E3\u80E6\u80EE\u80F5\u80F7\u80F9\u80FB\u80FE\u80FF\u8100\u8101\u8103\u8104\u8105\u8107\u8108\u810B"],
      ["c380", "\u810C\u8115\u8117\u8119\u811B\u811C\u811D\u811F", 12, "\u812D\u812E\u8130\u8133\u8134\u8135\u8137\u8139", 4, "\u813F\u8C29\u8292\u832B\u76F2\u6C13\u5FD9\u83BD\u732B\u8305\u951A\u6BDB\u77DB\u94C6\u536F\u8302\u5192\u5E3D\u8C8C\u8D38\u4E48\u73AB\u679A\u6885\u9176\u9709\u7164\u6CA1\u7709\u5A92\u9541\u6BCF\u7F8E\u6627\u5BD0\u59B9\u5A9A\u95E8\u95F7\u4EEC\u840C\u8499\u6AAC\u76DF\u9530\u731B\u68A6\u5B5F\u772F\u919A\u9761\u7CDC\u8FF7\u8C1C\u5F25\u7C73\u79D8\u89C5\u6CCC\u871C\u5BC6\u5E42\u68C9\u7720\u7EF5\u5195\u514D\u52C9\u5A29\u7F05\u9762\u82D7\u63CF\u7784\u85D0\u79D2\u6E3A\u5E99\u5999\u8511\u706D\u6C11\u62BF\u76BF\u654F\u60AF\u95FD\u660E\u879F\u9E23\u94ED\u540D\u547D\u8C2C\u6478"],
      ["c440", "\u8140", 5, "\u8147\u8149\u814D\u814E\u814F\u8152\u8156\u8157\u8158\u815B", 4, "\u8161\u8162\u8163\u8164\u8166\u8168\u816A\u816B\u816C\u816F\u8172\u8173\u8175\u8176\u8177\u8178\u8181\u8183", 4, "\u8189\u818B\u818C\u818D\u818E\u8190\u8192", 5, "\u8199\u819A\u819E", 4, "\u81A4\u81A5"],
      ["c480", "\u81A7\u81A9\u81AB", 7, "\u81B4", 5, "\u81BC\u81BD\u81BE\u81BF\u81C4\u81C5\u81C7\u81C8\u81C9\u81CB\u81CD", 6, "\u6479\u8611\u6A21\u819C\u78E8\u6469\u9B54\u62B9\u672B\u83AB\u58A8\u9ED8\u6CAB\u6F20\u5BDE\u964C\u8C0B\u725F\u67D0\u62C7\u7261\u4EA9\u59C6\u6BCD\u5893\u66AE\u5E55\u52DF\u6155\u6728\u76EE\u7766\u7267\u7A46\u62FF\u54EA\u5450\u94A0\u90A3\u5A1C\u7EB3\u6C16\u4E43\u5976\u8010\u5948\u5357\u7537\u96BE\u56CA\u6320\u8111\u607C\u95F9\u6DD6\u5462\u9981\u5185\u5AE9\u80FD\u59AE\u9713\u502A\u6CE5\u5C3C\u62DF\u4F60\u533F\u817B\u9006\u6EBA\u852B\u62C8\u5E74\u78BE\u64B5\u637B\u5FF5\u5A18\u917F\u9E1F\u5C3F\u634F\u8042\u5B7D\u556E\u954A\u954D\u6D85\u60A8\u67E0\u72DE\u51DD\u5B81"],
      ["c540", "\u81D4", 14, "\u81E4\u81E5\u81E6\u81E8\u81E9\u81EB\u81EE", 4, "\u81F5", 5, "\u81FD\u81FF\u8203\u8207", 4, "\u820E\u820F\u8211\u8213\u8215", 5, "\u821D\u8220\u8224\u8225\u8226\u8227\u8229\u822E\u8232\u823A\u823C\u823D\u823F"],
      ["c580", "\u8240\u8241\u8242\u8243\u8245\u8246\u8248\u824A\u824C\u824D\u824E\u8250", 7, "\u8259\u825B\u825C\u825D\u825E\u8260", 7, "\u8269\u62E7\u6CDE\u725B\u626D\u94AE\u7EBD\u8113\u6D53\u519C\u5F04\u5974\u52AA\u6012\u5973\u6696\u8650\u759F\u632A\u61E6\u7CEF\u8BFA\u54E6\u6B27\u9E25\u6BB4\u85D5\u5455\u5076\u6CA4\u556A\u8DB4\u722C\u5E15\u6015\u7436\u62CD\u6392\u724C\u5F98\u6E43\u6D3E\u6500\u6F58\u76D8\u78D0\u76FC\u7554\u5224\u53DB\u4E53\u5E9E\u65C1\u802A\u80D6\u629B\u5486\u5228\u70AE\u888D\u8DD1\u6CE1\u5478\u80DA\u57F9\u88F4\u8D54\u966A\u914D\u4F69\u6C9B\u55B7\u76C6\u7830\u62A8\u70F9\u6F8E\u5F6D\u84EC\u68DA\u787C\u7BF7\u81A8\u670B\u9E4F\u6367\u78B0\u576F\u7812\u9739\u6279\u62AB\u5288\u7435\u6BD7"],
      ["c640", "\u826A\u826B\u826C\u826D\u8271\u8275\u8276\u8277\u8278\u827B\u827C\u8280\u8281\u8283\u8285\u8286\u8287\u8289\u828C\u8290\u8293\u8294\u8295\u8296\u829A\u829B\u829E\u82A0\u82A2\u82A3\u82A7\u82B2\u82B5\u82B6\u82BA\u82BB\u82BC\u82BF\u82C0\u82C2\u82C3\u82C5\u82C6\u82C9\u82D0\u82D6\u82D9\u82DA\u82DD\u82E2\u82E7\u82E8\u82E9\u82EA\u82EC\u82ED\u82EE\u82F0\u82F2\u82F3\u82F5\u82F6\u82F8"],
      ["c680", "\u82FA\u82FC", 4, "\u830A\u830B\u830D\u8310\u8312\u8313\u8316\u8318\u8319\u831D", 9, "\u8329\u832A\u832E\u8330\u8332\u8337\u833B\u833D\u5564\u813E\u75B2\u76AE\u5339\u75DE\u50FB\u5C41\u8B6C\u7BC7\u504F\u7247\u9A97\u98D8\u6F02\u74E2\u7968\u6487\u77A5\u62FC\u9891\u8D2B\u54C1\u8058\u4E52\u576A\u82F9\u840D\u5E73\u51ED\u74F6\u8BC4\u5C4F\u5761\u6CFC\u9887\u5A46\u7834\u9B44\u8FEB\u7C95\u5256\u6251\u94FA\u4EC6\u8386\u8461\u83E9\u84B2\u57D4\u6734\u5703\u666E\u6D66\u8C31\u66DD\u7011\u671F\u6B3A\u6816\u621A\u59BB\u4E03\u51C4\u6F06\u67D2\u6C8F\u5176\u68CB\u5947\u6B67\u7566\u5D0E\u8110\u9F50\u65D7\u7948\u7941\u9A91\u8D77\u5C82\u4E5E\u4F01\u542F\u5951\u780C\u5668\u6C14\u8FC4\u5F03\u6C7D\u6CE3\u8BAB\u6390"],
      ["c740", "\u833E\u833F\u8341\u8342\u8344\u8345\u8348\u834A", 4, "\u8353\u8355", 4, "\u835D\u8362\u8370", 6, "\u8379\u837A\u837E", 6, "\u8387\u8388\u838A\u838B\u838C\u838D\u838F\u8390\u8391\u8394\u8395\u8396\u8397\u8399\u839A\u839D\u839F\u83A1", 6, "\u83AC\u83AD\u83AE"],
      ["c780", "\u83AF\u83B5\u83BB\u83BE\u83BF\u83C2\u83C3\u83C4\u83C6\u83C8\u83C9\u83CB\u83CD\u83CE\u83D0\u83D1\u83D2\u83D3\u83D5\u83D7\u83D9\u83DA\u83DB\u83DE\u83E2\u83E3\u83E4\u83E6\u83E7\u83E8\u83EB\u83EC\u83ED\u6070\u6D3D\u7275\u6266\u948E\u94C5\u5343\u8FC1\u7B7E\u4EDF\u8C26\u4E7E\u9ED4\u94B1\u94B3\u524D\u6F5C\u9063\u6D45\u8C34\u5811\u5D4C\u6B20\u6B49\u67AA\u545B\u8154\u7F8C\u5899\u8537\u5F3A\u62A2\u6A47\u9539\u6572\u6084\u6865\u77A7\u4E54\u4FA8\u5DE7\u9798\u64AC\u7FD8\u5CED\u4FCF\u7A8D\u5207\u8304\u4E14\u602F\u7A83\u94A6\u4FB5\u4EB2\u79E6\u7434\u52E4\u82B9\u64D2\u79BD\u5BDD\u6C81\u9752\u8F7B\u6C22\u503E\u537F\u6E05\u64CE\u6674\u6C30\u60C5\u9877\u8BF7\u5E86\u743C\u7A77\u79CB\u4E18\u90B1\u7403\u6C42\u56DA\u914B\u6CC5\u8D8B\u533A\u86C6\u66F2\u8EAF\u5C48\u9A71\u6E20"],
      ["c840", "\u83EE\u83EF\u83F3", 4, "\u83FA\u83FB\u83FC\u83FE\u83FF\u8400\u8402\u8405\u8407\u8408\u8409\u840A\u8410\u8412", 5, "\u8419\u841A\u841B\u841E", 5, "\u8429", 7, "\u8432", 5, "\u8439\u843A\u843B\u843E", 7, "\u8447\u8448\u8449"],
      ["c880", "\u844A", 6, "\u8452", 4, "\u8458\u845D\u845E\u845F\u8460\u8462\u8464", 4, "\u846A\u846E\u846F\u8470\u8472\u8474\u8477\u8479\u847B\u847C\u53D6\u5A36\u9F8B\u8DA3\u53BB\u5708\u98A7\u6743\u919B\u6CC9\u5168\u75CA\u62F3\u72AC\u5238\u529D\u7F3A\u7094\u7638\u5374\u9E4A\u69B7\u786E\u96C0\u88D9\u7FA4\u7136\u71C3\u5189\u67D3\u74E4\u58E4\u6518\u56B7\u8BA9\u9976\u6270\u7ED5\u60F9\u70ED\u58EC\u4EC1\u4EBA\u5FCD\u97E7\u4EFB\u8BA4\u5203\u598A\u7EAB\u6254\u4ECD\u65E5\u620E\u8338\u84C9\u8363\u878D\u7194\u6EB6\u5BB9\u7ED2\u5197\u63C9\u67D4\u8089\u8339\u8815\u5112\u5B7A\u5982\u8FB1\u4E73\u6C5D\u5165\u8925\u8F6F\u962E\u854A\u745E\u9510\u95F0\u6DA6\u82E5\u5F31\u6492\u6D12\u8428\u816E\u9CC3\u585E\u8D5B\u4E09\u53C1"],
      ["c940", "\u847D", 4, "\u8483\u8484\u8485\u8486\u848A\u848D\u848F", 7, "\u8498\u849A\u849B\u849D\u849E\u849F\u84A0\u84A2", 12, "\u84B0\u84B1\u84B3\u84B5\u84B6\u84B7\u84BB\u84BC\u84BE\u84C0\u84C2\u84C3\u84C5\u84C6\u84C7\u84C8\u84CB\u84CC\u84CE\u84CF\u84D2\u84D4\u84D5\u84D7"],
      ["c980", "\u84D8", 4, "\u84DE\u84E1\u84E2\u84E4\u84E7", 4, "\u84ED\u84EE\u84EF\u84F1", 10, "\u84FD\u84FE\u8500\u8501\u8502\u4F1E\u6563\u6851\u55D3\u4E27\u6414\u9A9A\u626B\u5AC2\u745F\u8272\u6DA9\u68EE\u50E7\u838E\u7802\u6740\u5239\u6C99\u7EB1\u50BB\u5565\u715E\u7B5B\u6652\u73CA\u82EB\u6749\u5C71\u5220\u717D\u886B\u95EA\u9655\u64C5\u8D61\u81B3\u5584\u6C55\u6247\u7F2E\u5892\u4F24\u5546\u8D4F\u664C\u4E0A\u5C1A\u88F3\u68A2\u634E\u7A0D\u70E7\u828D\u52FA\u97F6\u5C11\u54E8\u90B5\u7ECD\u5962\u8D4A\u86C7\u820C\u820D\u8D66\u6444\u5C04\u6151\u6D89\u793E\u8BBE\u7837\u7533\u547B\u4F38\u8EAB\u6DF1\u5A20\u7EC5\u795E\u6C88\u5BA1\u5A76\u751A\u80BE\u614E\u6E17\u58F0\u751F\u7525\u7272\u5347\u7EF3"],
      ["ca40", "\u8503", 8, "\u850D\u850E\u850F\u8510\u8512\u8514\u8515\u8516\u8518\u8519\u851B\u851C\u851D\u851E\u8520\u8522", 8, "\u852D", 9, "\u853E", 4, "\u8544\u8545\u8546\u8547\u854B", 10],
      ["ca80", "\u8557\u8558\u855A\u855B\u855C\u855D\u855F", 4, "\u8565\u8566\u8567\u8569", 8, "\u8573\u8575\u8576\u8577\u8578\u857C\u857D\u857F\u8580\u8581\u7701\u76DB\u5269\u80DC\u5723\u5E08\u5931\u72EE\u65BD\u6E7F\u8BD7\u5C38\u8671\u5341\u77F3\u62FE\u65F6\u4EC0\u98DF\u8680\u5B9E\u8BC6\u53F2\u77E2\u4F7F\u5C4E\u9A76\u59CB\u5F0F\u793A\u58EB\u4E16\u67FF\u4E8B\u62ED\u8A93\u901D\u52BF\u662F\u55DC\u566C\u9002\u4ED5\u4F8D\u91CA\u9970\u6C0F\u5E02\u6043\u5BA4\u89C6\u8BD5\u6536\u624B\u9996\u5B88\u5BFF\u6388\u552E\u53D7\u7626\u517D\u852C\u67A2\u68B3\u6B8A\u6292\u8F93\u53D4\u8212\u6DD1\u758F\u4E66\u8D4E\u5B70\u719F\u85AF\u6691\u66D9\u7F72\u8700\u9ECD\u9F20\u5C5E\u672F\u8FF0\u6811\u675F\u620D\u7AD6\u5885\u5EB6\u6570\u6F31"],
      ["cb40", "\u8582\u8583\u8586\u8588", 6, "\u8590", 10, "\u859D", 6, "\u85A5\u85A6\u85A7\u85A9\u85AB\u85AC\u85AD\u85B1", 5, "\u85B8\u85BA", 6, "\u85C2", 6, "\u85CA", 4, "\u85D1\u85D2"],
      ["cb80", "\u85D4\u85D6", 5, "\u85DD", 6, "\u85E5\u85E6\u85E7\u85E8\u85EA", 14, "\u6055\u5237\u800D\u6454\u8870\u7529\u5E05\u6813\u62F4\u971C\u53CC\u723D\u8C01\u6C34\u7761\u7A0E\u542E\u77AC\u987A\u821C\u8BF4\u7855\u6714\u70C1\u65AF\u6495\u5636\u601D\u79C1\u53F8\u4E1D\u6B7B\u8086\u5BFA\u55E3\u56DB\u4F3A\u4F3C\u9972\u5DF3\u677E\u8038\u6002\u9882\u9001\u5B8B\u8BBC\u8BF5\u641C\u8258\u64DE\u55FD\u82CF\u9165\u4FD7\u7D20\u901F\u7C9F\u50F3\u5851\u6EAF\u5BBF\u8BC9\u8083\u9178\u849C\u7B97\u867D\u968B\u968F\u7EE5\u9AD3\u788E\u5C81\u7A57\u9042\u96A7\u795F\u5B59\u635F\u7B0B\u84D1\u68AD\u5506\u7F29\u7410\u7D22\u9501\u6240\u584C\u4ED6\u5B83\u5979\u5854"],
      ["cc40", "\u85F9\u85FA\u85FC\u85FD\u85FE\u8600", 4, "\u8606", 10, "\u8612\u8613\u8614\u8615\u8617", 15, "\u8628\u862A", 13, "\u8639\u863A\u863B\u863D\u863E\u863F\u8640"],
      ["cc80", "\u8641", 11, "\u8652\u8653\u8655", 4, "\u865B\u865C\u865D\u865F\u8660\u8661\u8663", 7, "\u736D\u631E\u8E4B\u8E0F\u80CE\u82D4\u62AC\u53F0\u6CF0\u915E\u592A\u6001\u6C70\u574D\u644A\u8D2A\u762B\u6EE9\u575B\u6A80\u75F0\u6F6D\u8C2D\u8C08\u5766\u6BEF\u8892\u78B3\u63A2\u53F9\u70AD\u6C64\u5858\u642A\u5802\u68E0\u819B\u5510\u7CD6\u5018\u8EBA\u6DCC\u8D9F\u70EB\u638F\u6D9B\u6ED4\u7EE6\u8404\u6843\u9003\u6DD8\u9676\u8BA8\u5957\u7279\u85E4\u817E\u75BC\u8A8A\u68AF\u5254\u8E22\u9511\u63D0\u9898\u8E44\u557C\u4F53\u66FF\u568F\u60D5\u6D95\u5243\u5C49\u5929\u6DFB\u586B\u7530\u751C\u606C\u8214\u8146\u6311\u6761\u8FE2\u773A\u8DF3\u8D34\u94C1\u5E16\u5385\u542C\u70C3"],
      ["cd40", "\u866D\u866F\u8670\u8672", 6, "\u8683", 6, "\u868E", 4, "\u8694\u8696", 5, "\u869E", 4, "\u86A5\u86A6\u86AB\u86AD\u86AE\u86B2\u86B3\u86B7\u86B8\u86B9\u86BB", 4, "\u86C1\u86C2\u86C3\u86C5\u86C8\u86CC\u86CD\u86D2\u86D3\u86D5\u86D6\u86D7\u86DA\u86DC"],
      ["cd80", "\u86DD\u86E0\u86E1\u86E2\u86E3\u86E5\u86E6\u86E7\u86E8\u86EA\u86EB\u86EC\u86EF\u86F5\u86F6\u86F7\u86FA\u86FB\u86FC\u86FD\u86FF\u8701\u8704\u8705\u8706\u870B\u870C\u870E\u870F\u8710\u8711\u8714\u8716\u6C40\u5EF7\u505C\u4EAD\u5EAD\u633A\u8247\u901A\u6850\u916E\u77B3\u540C\u94DC\u5F64\u7AE5\u6876\u6345\u7B52\u7EDF\u75DB\u5077\u6295\u5934\u900F\u51F8\u79C3\u7A81\u56FE\u5F92\u9014\u6D82\u5C60\u571F\u5410\u5154\u6E4D\u56E2\u63A8\u9893\u817F\u8715\u892A\u9000\u541E\u5C6F\u81C0\u62D6\u6258\u8131\u9E35\u9640\u9A6E\u9A7C\u692D\u59A5\u62D3\u553E\u6316\u54C7\u86D9\u6D3C\u5A03\u74E6\u889C\u6B6A\u5916\u8C4C\u5F2F\u6E7E\u73A9\u987D\u4E38\u70F7\u5B8C\u7897\u633D\u665A\u7696\u60CB\u5B9B\u5A49\u4E07\u8155\u6C6A\u738B\u4EA1\u6789\u7F51\u5F80\u65FA\u671B\u5FD8\u5984\u5A01"],
      ["ce40", "\u8719\u871B\u871D\u871F\u8720\u8724\u8726\u8727\u8728\u872A\u872B\u872C\u872D\u872F\u8730\u8732\u8733\u8735\u8736\u8738\u8739\u873A\u873C\u873D\u8740", 6, "\u874A\u874B\u874D\u874F\u8750\u8751\u8752\u8754\u8755\u8756\u8758\u875A", 5, "\u8761\u8762\u8766", 7, "\u876F\u8771\u8772\u8773\u8775"],
      ["ce80", "\u8777\u8778\u8779\u877A\u877F\u8780\u8781\u8784\u8786\u8787\u8789\u878A\u878C\u878E", 4, "\u8794\u8795\u8796\u8798", 6, "\u87A0", 4, "\u5DCD\u5FAE\u5371\u97E6\u8FDD\u6845\u56F4\u552F\u60DF\u4E3A\u6F4D\u7EF4\u82C7\u840E\u59D4\u4F1F\u4F2A\u5C3E\u7EAC\u672A\u851A\u5473\u754F\u80C3\u5582\u9B4F\u4F4D\u6E2D\u8C13\u5C09\u6170\u536B\u761F\u6E29\u868A\u6587\u95FB\u7EB9\u543B\u7A33\u7D0A\u95EE\u55E1\u7FC1\u74EE\u631D\u8717\u6DA1\u7A9D\u6211\u65A1\u5367\u63E1\u6C83\u5DEB\u545C\u94A8\u4E4C\u6C61\u8BEC\u5C4B\u65E0\u829C\u68A7\u543E\u5434\u6BCB\u6B66\u4E94\u6342\u5348\u821E\u4F0D\u4FAE\u575E\u620A\u96FE\u6664\u7269\u52FF\u52A1\u609F\u8BEF\u6614\u7199\u6790\u897F\u7852\u77FD\u6670\u563B\u5438\u9521\u727A"],
      ["cf40", "\u87A5\u87A6\u87A7\u87A9\u87AA\u87AE\u87B0\u87B1\u87B2\u87B4\u87B6\u87B7\u87B8\u87B9\u87BB\u87BC\u87BE\u87BF\u87C1", 4, "\u87C7\u87C8\u87C9\u87CC", 4, "\u87D4", 6, "\u87DC\u87DD\u87DE\u87DF\u87E1\u87E2\u87E3\u87E4\u87E6\u87E7\u87E8\u87E9\u87EB\u87EC\u87ED\u87EF", 9],
      ["cf80", "\u87FA\u87FB\u87FC\u87FD\u87FF\u8800\u8801\u8802\u8804", 5, "\u880B", 7, "\u8814\u8817\u8818\u8819\u881A\u881C", 4, "\u8823\u7A00\u606F\u5E0C\u6089\u819D\u5915\u60DC\u7184\u70EF\u6EAA\u6C50\u7280\u6A84\u88AD\u5E2D\u4E60\u5AB3\u559C\u94E3\u6D17\u7CFB\u9699\u620F\u7EC6\u778E\u867E\u5323\u971E\u8F96\u6687\u5CE1\u4FA0\u72ED\u4E0B\u53A6\u590F\u5413\u6380\u9528\u5148\u4ED9\u9C9C\u7EA4\u54B8\u8D24\u8854\u8237\u95F2\u6D8E\u5F26\u5ACC\u663E\u9669\u73B0\u732E\u53BF\u817A\u9985\u7FA1\u5BAA\u9677\u9650\u7EBF\u76F8\u53A2\u9576\u9999\u7BB1\u8944\u6E58\u4E61\u7FD4\u7965\u8BE6\u60F3\u54CD\u4EAB\u9879\u5DF7\u6A61\u50CF\u5411\u8C61\u8427\u785D\u9704\u524A\u54EE\u56A3\u9500\u6D88\u5BB5\u6DC6\u6653"],
      ["d040", "\u8824", 13, "\u8833", 5, "\u883A\u883B\u883D\u883E\u883F\u8841\u8842\u8843\u8846", 5, "\u884E", 5, "\u8855\u8856\u8858\u885A", 6, "\u8866\u8867\u886A\u886D\u886F\u8871\u8873\u8874\u8875\u8876\u8878\u8879\u887A"],
      ["d080", "\u887B\u887C\u8880\u8883\u8886\u8887\u8889\u888A\u888C\u888E\u888F\u8890\u8891\u8893\u8894\u8895\u8897", 4, "\u889D", 4, "\u88A3\u88A5", 5, "\u5C0F\u5B5D\u6821\u8096\u5578\u7B11\u6548\u6954\u4E9B\u6B47\u874E\u978B\u534F\u631F\u643A\u90AA\u659C\u80C1\u8C10\u5199\u68B0\u5378\u87F9\u61C8\u6CC4\u6CFB\u8C22\u5C51\u85AA\u82AF\u950C\u6B23\u8F9B\u65B0\u5FFB\u5FC3\u4FE1\u8845\u661F\u8165\u7329\u60FA\u5174\u5211\u578B\u5F62\u90A2\u884C\u9192\u5E78\u674F\u6027\u59D3\u5144\u51F6\u80F8\u5308\u6C79\u96C4\u718A\u4F11\u4FEE\u7F9E\u673D\u55C5\u9508\u79C0\u8896\u7EE3\u589F\u620C\u9700\u865A\u5618\u987B\u5F90\u8BB8\u84C4\u9157\u53D9\u65ED\u5E8F\u755C\u6064\u7D6E\u5A7F\u7EEA\u7EED\u8F69\u55A7\u5BA3\u60AC\u65CB\u7384"],
      ["d140", "\u88AC\u88AE\u88AF\u88B0\u88B2", 4, "\u88B8\u88B9\u88BA\u88BB\u88BD\u88BE\u88BF\u88C0\u88C3\u88C4\u88C7\u88C8\u88CA\u88CB\u88CC\u88CD\u88CF\u88D0\u88D1\u88D3\u88D6\u88D7\u88DA", 4, "\u88E0\u88E1\u88E6\u88E7\u88E9", 6, "\u88F2\u88F5\u88F6\u88F7\u88FA\u88FB\u88FD\u88FF\u8900\u8901\u8903", 5],
      ["d180", "\u8909\u890B", 4, "\u8911\u8914", 4, "\u891C", 4, "\u8922\u8923\u8924\u8926\u8927\u8928\u8929\u892C\u892D\u892E\u892F\u8931\u8932\u8933\u8935\u8937\u9009\u7663\u7729\u7EDA\u9774\u859B\u5B66\u7A74\u96EA\u8840\u52CB\u718F\u5FAA\u65EC\u8BE2\u5BFB\u9A6F\u5DE1\u6B89\u6C5B\u8BAD\u8BAF\u900A\u8FC5\u538B\u62BC\u9E26\u9E2D\u5440\u4E2B\u82BD\u7259\u869C\u5D16\u8859\u6DAF\u96C5\u54D1\u4E9A\u8BB6\u7109\u54BD\u9609\u70DF\u6DF9\u76D0\u4E25\u7814\u8712\u5CA9\u5EF6\u8A00\u989C\u960E\u708E\u6CBF\u5944\u63A9\u773C\u884D\u6F14\u8273\u5830\u71D5\u538C\u781A\u96C1\u5501\u5F66\u7130\u5BB4\u8C1A\u9A8C\u6B83\u592E\u9E2F\u79E7\u6768\u626C\u4F6F\u75A1\u7F8A\u6D0B\u9633\u6C27\u4EF0\u75D2\u517B\u6837\u6F3E\u9080\u8170\u5996\u7476"],
      ["d240", "\u8938", 8, "\u8942\u8943\u8945", 24, "\u8960", 5, "\u8967", 19, "\u897C"],
      ["d280", "\u897D\u897E\u8980\u8982\u8984\u8985\u8987", 26, "\u6447\u5C27\u9065\u7A91\u8C23\u59DA\u54AC\u8200\u836F\u8981\u8000\u6930\u564E\u8036\u7237\u91CE\u51B6\u4E5F\u9875\u6396\u4E1A\u53F6\u66F3\u814B\u591C\u6DB2\u4E00\u58F9\u533B\u63D6\u94F1\u4F9D\u4F0A\u8863\u9890\u5937\u9057\u79FB\u4EEA\u80F0\u7591\u6C82\u5B9C\u59E8\u5F5D\u6905\u8681\u501A\u5DF2\u4E59\u77E3\u4EE5\u827A\u6291\u6613\u9091\u5C79\u4EBF\u5F79\u81C6\u9038\u8084\u75AB\u4EA6\u88D4\u610F\u6BC5\u5FC6\u4E49\u76CA\u6EA2\u8BE3\u8BAE\u8C0A\u8BD1\u5F02\u7FFC\u7FCC\u7ECE\u8335\u836B\u56E0\u6BB7\u97F3\u9634\u59FB\u541F\u94F6\u6DEB\u5BC5\u996E\u5C39\u5F15\u9690"],
      ["d340", "\u89A2", 30, "\u89C3\u89CD\u89D3\u89D4\u89D5\u89D7\u89D8\u89D9\u89DB\u89DD\u89DF\u89E0\u89E1\u89E2\u89E4\u89E7\u89E8\u89E9\u89EA\u89EC\u89ED\u89EE\u89F0\u89F1\u89F2\u89F4", 6],
      ["d380", "\u89FB", 4, "\u8A01", 5, "\u8A08", 21, "\u5370\u82F1\u6A31\u5A74\u9E70\u5E94\u7F28\u83B9\u8424\u8425\u8367\u8747\u8FCE\u8D62\u76C8\u5F71\u9896\u786C\u6620\u54DF\u62E5\u4F63\u81C3\u75C8\u5EB8\u96CD\u8E0A\u86F9\u548F\u6CF3\u6D8C\u6C38\u607F\u52C7\u7528\u5E7D\u4F18\u60A0\u5FE7\u5C24\u7531\u90AE\u94C0\u72B9\u6CB9\u6E38\u9149\u6709\u53CB\u53F3\u4F51\u91C9\u8BF1\u53C8\u5E7C\u8FC2\u6DE4\u4E8E\u76C2\u6986\u865E\u611A\u8206\u4F59\u4FDE\u903E\u9C7C\u6109\u6E1D\u6E14\u9685\u4E88\u5A31\u96E8\u4E0E\u5C7F\u79B9\u5B87\u8BED\u7FBD\u7389\u57DF\u828B\u90C1\u5401\u9047\u55BB\u5CEA\u5FA1\u6108\u6B32\u72F1\u80B2\u8A89"],
      ["d440", "\u8A1E", 31, "\u8A3F", 8, "\u8A49", 21],
      ["d480", "\u8A5F", 25, "\u8A7A", 6, "\u6D74\u5BD3\u88D5\u9884\u8C6B\u9A6D\u9E33\u6E0A\u51A4\u5143\u57A3\u8881\u539F\u63F4\u8F95\u56ED\u5458\u5706\u733F\u6E90\u7F18\u8FDC\u82D1\u613F\u6028\u9662\u66F0\u7EA6\u8D8A\u8DC3\u94A5\u5CB3\u7CA4\u6708\u60A6\u9605\u8018\u4E91\u90E7\u5300\u9668\u5141\u8FD0\u8574\u915D\u6655\u97F5\u5B55\u531D\u7838\u6742\u683D\u54C9\u707E\u5BB0\u8F7D\u518D\u5728\u54B1\u6512\u6682\u8D5E\u8D43\u810F\u846C\u906D\u7CDF\u51FF\u85FB\u67A3\u65E9\u6FA1\u86A4\u8E81\u566A\u9020\u7682\u7076\u71E5\u8D23\u62E9\u5219\u6CFD\u8D3C\u600E\u589E\u618E\u66FE\u8D60\u624E\u55B3\u6E23\u672D\u8F67"],
      ["d540", "\u8A81", 7, "\u8A8B", 7, "\u8A94", 46],
      ["d580", "\u8AC3", 32, "\u94E1\u95F8\u7728\u6805\u69A8\u548B\u4E4D\u70B8\u8BC8\u6458\u658B\u5B85\u7A84\u503A\u5BE8\u77BB\u6BE1\u8A79\u7C98\u6CBE\u76CF\u65A9\u8F97\u5D2D\u5C55\u8638\u6808\u5360\u6218\u7AD9\u6E5B\u7EFD\u6A1F\u7AE0\u5F70\u6F33\u5F20\u638C\u6DA8\u6756\u4E08\u5E10\u8D26\u4ED7\u80C0\u7634\u969C\u62DB\u662D\u627E\u6CBC\u8D75\u7167\u7F69\u5146\u8087\u53EC\u906E\u6298\u54F2\u86F0\u8F99\u8005\u9517\u8517\u8FD9\u6D59\u73CD\u659F\u771F\u7504\u7827\u81FB\u8D1E\u9488\u4FA6\u6795\u75B9\u8BCA\u9707\u632F\u9547\u9635\u84B8\u6323\u7741\u5F81\u72F0\u4E89\u6014\u6574\u62EF\u6B63\u653F"],
      ["d640", "\u8AE4", 34, "\u8B08", 27],
      ["d680", "\u8B24\u8B25\u8B27", 30, "\u5E27\u75C7\u90D1\u8BC1\u829D\u679D\u652F\u5431\u8718\u77E5\u80A2\u8102\u6C41\u4E4B\u7EC7\u804C\u76F4\u690D\u6B96\u6267\u503C\u4F84\u5740\u6307\u6B62\u8DBE\u53EA\u65E8\u7EB8\u5FD7\u631A\u63B7\u81F3\u81F4\u7F6E\u5E1C\u5CD9\u5236\u667A\u79E9\u7A1A\u8D28\u7099\u75D4\u6EDE\u6CBB\u7A92\u4E2D\u76C5\u5FE0\u949F\u8877\u7EC8\u79CD\u80BF\u91CD\u4EF2\u4F17\u821F\u5468\u5DDE\u6D32\u8BCC\u7CA5\u8F74\u8098\u5E1A\u5492\u76B1\u5B99\u663C\u9AA4\u73E0\u682A\u86DB\u6731\u732A\u8BF8\u8BDB\u9010\u7AF9\u70DB\u716E\u62C4\u77A9\u5631\u4E3B\u8457\u67F1\u52A9\u86C0\u8D2E\u94F8\u7B51"],
      ["d740", "\u8B46", 31, "\u8B67", 4, "\u8B6D", 25],
      ["d780", "\u8B87", 24, "\u8BAC\u8BB1\u8BBB\u8BC7\u8BD0\u8BEA\u8C09\u8C1E\u4F4F\u6CE8\u795D\u9A7B\u6293\u722A\u62FD\u4E13\u7816\u8F6C\u64B0\u8D5A\u7BC6\u6869\u5E84\u88C5\u5986\u649E\u58EE\u72B6\u690E\u9525\u8FFD\u8D58\u5760\u7F00\u8C06\u51C6\u6349\u62D9\u5353\u684C\u7422\u8301\u914C\u5544\u7740\u707C\u6D4A\u5179\u54A8\u8D44\u59FF\u6ECB\u6DC4\u5B5C\u7D2B\u4ED4\u7C7D\u6ED3\u5B50\u81EA\u6E0D\u5B57\u9B03\u68D5\u8E2A\u5B97\u7EFC\u603B\u7EB5\u90B9\u8D70\u594F\u63CD\u79DF\u8DB3\u5352\u65CF\u7956\u8BC5\u963B\u7EC4\u94BB\u7E82\u5634\u9189\u6700\u7F6A\u5C0A\u9075\u6628\u5DE6\u4F50\u67DE\u505A\u4F5C\u5750\u5EA7"],
      ["d840", "\u8C38", 8, "\u8C42\u8C43\u8C44\u8C45\u8C48\u8C4A\u8C4B\u8C4D", 7, "\u8C56\u8C57\u8C58\u8C59\u8C5B", 5, "\u8C63", 6, "\u8C6C", 6, "\u8C74\u8C75\u8C76\u8C77\u8C7B", 6, "\u8C83\u8C84\u8C86\u8C87"],
      ["d880", "\u8C88\u8C8B\u8C8D", 6, "\u8C95\u8C96\u8C97\u8C99", 20, "\u4E8D\u4E0C\u5140\u4E10\u5EFF\u5345\u4E15\u4E98\u4E1E\u9B32\u5B6C\u5669\u4E28\u79BA\u4E3F\u5315\u4E47\u592D\u723B\u536E\u6C10\u56DF\u80E4\u9997\u6BD3\u777E\u9F17\u4E36\u4E9F\u9F10\u4E5C\u4E69\u4E93\u8288\u5B5B\u556C\u560F\u4EC4\u538D\u539D\u53A3\u53A5\u53AE\u9765\u8D5D\u531A\u53F5\u5326\u532E\u533E\u8D5C\u5366\u5363\u5202\u5208\u520E\u522D\u5233\u523F\u5240\u524C\u525E\u5261\u525C\u84AF\u527D\u5282\u5281\u5290\u5293\u5182\u7F54\u4EBB\u4EC3\u4EC9\u4EC2\u4EE8\u4EE1\u4EEB\u4EDE\u4F1B\u4EF3\u4F22\u4F64\u4EF5\u4F25\u4F27\u4F09\u4F2B\u4F5E\u4F67\u6538\u4F5A\u4F5D"],
      ["d940", "\u8CAE", 62],
      ["d980", "\u8CED", 32, "\u4F5F\u4F57\u4F32\u4F3D\u4F76\u4F74\u4F91\u4F89\u4F83\u4F8F\u4F7E\u4F7B\u4FAA\u4F7C\u4FAC\u4F94\u4FE6\u4FE8\u4FEA\u4FC5\u4FDA\u4FE3\u4FDC\u4FD1\u4FDF\u4FF8\u5029\u504C\u4FF3\u502C\u500F\u502E\u502D\u4FFE\u501C\u500C\u5025\u5028\u507E\u5043\u5055\u5048\u504E\u506C\u507B\u50A5\u50A7\u50A9\u50BA\u50D6\u5106\u50ED\u50EC\u50E6\u50EE\u5107\u510B\u4EDD\u6C3D\u4F58\u4F65\u4FCE\u9FA0\u6C46\u7C74\u516E\u5DFD\u9EC9\u9998\u5181\u5914\u52F9\u530D\u8A07\u5310\u51EB\u5919\u5155\u4EA0\u5156\u4EB3\u886E\u88A4\u4EB5\u8114\u88D2\u7980\u5B34\u8803\u7FB8\u51AB\u51B1\u51BD\u51BC"],
      ["da40", "\u8D0E", 14, "\u8D20\u8D51\u8D52\u8D57\u8D5F\u8D65\u8D68\u8D69\u8D6A\u8D6C\u8D6E\u8D6F\u8D71\u8D72\u8D78", 8, "\u8D82\u8D83\u8D86\u8D87\u8D88\u8D89\u8D8C", 4, "\u8D92\u8D93\u8D95", 9, "\u8DA0\u8DA1"],
      ["da80", "\u8DA2\u8DA4", 12, "\u8DB2\u8DB6\u8DB7\u8DB9\u8DBB\u8DBD\u8DC0\u8DC1\u8DC2\u8DC5\u8DC7\u8DC8\u8DC9\u8DCA\u8DCD\u8DD0\u8DD2\u8DD3\u8DD4\u51C7\u5196\u51A2\u51A5\u8BA0\u8BA6\u8BA7\u8BAA\u8BB4\u8BB5\u8BB7\u8BC2\u8BC3\u8BCB\u8BCF\u8BCE\u8BD2\u8BD3\u8BD4\u8BD6\u8BD8\u8BD9\u8BDC\u8BDF\u8BE0\u8BE4\u8BE8\u8BE9\u8BEE\u8BF0\u8BF3\u8BF6\u8BF9\u8BFC\u8BFF\u8C00\u8C02\u8C04\u8C07\u8C0C\u8C0F\u8C11\u8C12\u8C14\u8C15\u8C16\u8C19\u8C1B\u8C18\u8C1D\u8C1F\u8C20\u8C21\u8C25\u8C27\u8C2A\u8C2B\u8C2E\u8C2F\u8C32\u8C33\u8C35\u8C36\u5369\u537A\u961D\u9622\u9621\u9631\u962A\u963D\u963C\u9642\u9649\u9654\u965F\u9667\u966C\u9672\u9674\u9688\u968D\u9697\u96B0\u9097\u909B\u909D\u9099\u90AC\u90A1\u90B4\u90B3\u90B6\u90BA"],
      ["db40", "\u8DD5\u8DD8\u8DD9\u8DDC\u8DE0\u8DE1\u8DE2\u8DE5\u8DE6\u8DE7\u8DE9\u8DED\u8DEE\u8DF0\u8DF1\u8DF2\u8DF4\u8DF6\u8DFC\u8DFE", 6, "\u8E06\u8E07\u8E08\u8E0B\u8E0D\u8E0E\u8E10\u8E11\u8E12\u8E13\u8E15", 7, "\u8E20\u8E21\u8E24", 4, "\u8E2B\u8E2D\u8E30\u8E32\u8E33\u8E34\u8E36\u8E37\u8E38\u8E3B\u8E3C\u8E3E"],
      ["db80", "\u8E3F\u8E43\u8E45\u8E46\u8E4C", 4, "\u8E53", 5, "\u8E5A", 11, "\u8E67\u8E68\u8E6A\u8E6B\u8E6E\u8E71\u90B8\u90B0\u90CF\u90C5\u90BE\u90D0\u90C4\u90C7\u90D3\u90E6\u90E2\u90DC\u90D7\u90DB\u90EB\u90EF\u90FE\u9104\u9122\u911E\u9123\u9131\u912F\u9139\u9143\u9146\u520D\u5942\u52A2\u52AC\u52AD\u52BE\u54FF\u52D0\u52D6\u52F0\u53DF\u71EE\u77CD\u5EF4\u51F5\u51FC\u9B2F\u53B6\u5F01\u755A\u5DEF\u574C\u57A9\u57A1\u587E\u58BC\u58C5\u58D1\u5729\u572C\u572A\u5733\u5739\u572E\u572F\u575C\u573B\u5742\u5769\u5785\u576B\u5786\u577C\u577B\u5768\u576D\u5776\u5773\u57AD\u57A4\u578C\u57B2\u57CF\u57A7\u57B4\u5793\u57A0\u57D5\u57D8\u57DA\u57D9\u57D2\u57B8\u57F4\u57EF\u57F8\u57E4\u57DD"],
      ["dc40", "\u8E73\u8E75\u8E77", 4, "\u8E7D\u8E7E\u8E80\u8E82\u8E83\u8E84\u8E86\u8E88", 6, "\u8E91\u8E92\u8E93\u8E95", 6, "\u8E9D\u8E9F", 11, "\u8EAD\u8EAE\u8EB0\u8EB1\u8EB3", 6, "\u8EBB", 7],
      ["dc80", "\u8EC3", 10, "\u8ECF", 21, "\u580B\u580D\u57FD\u57ED\u5800\u581E\u5819\u5844\u5820\u5865\u586C\u5881\u5889\u589A\u5880\u99A8\u9F19\u61FF\u8279\u827D\u827F\u828F\u828A\u82A8\u8284\u828E\u8291\u8297\u8299\u82AB\u82B8\u82BE\u82B0\u82C8\u82CA\u82E3\u8298\u82B7\u82AE\u82CB\u82CC\u82C1\u82A9\u82B4\u82A1\u82AA\u829F\u82C4\u82CE\u82A4\u82E1\u8309\u82F7\u82E4\u830F\u8307\u82DC\u82F4\u82D2\u82D8\u830C\u82FB\u82D3\u8311\u831A\u8306\u8314\u8315\u82E0\u82D5\u831C\u8351\u835B\u835C\u8308\u8392\u833C\u8334\u8331\u839B\u835E\u832F\u834F\u8347\u8343\u835F\u8340\u8317\u8360\u832D\u833A\u8333\u8366\u8365"],
      ["dd40", "\u8EE5", 62],
      ["dd80", "\u8F24", 32, "\u8368\u831B\u8369\u836C\u836A\u836D\u836E\u83B0\u8378\u83B3\u83B4\u83A0\u83AA\u8393\u839C\u8385\u837C\u83B6\u83A9\u837D\u83B8\u837B\u8398\u839E\u83A8\u83BA\u83BC\u83C1\u8401\u83E5\u83D8\u5807\u8418\u840B\u83DD\u83FD\u83D6\u841C\u8438\u8411\u8406\u83D4\u83DF\u840F\u8403\u83F8\u83F9\u83EA\u83C5\u83C0\u8426\u83F0\u83E1\u845C\u8451\u845A\u8459\u8473\u8487\u8488\u847A\u8489\u8478\u843C\u8446\u8469\u8476\u848C\u848E\u8431\u846D\u84C1\u84CD\u84D0\u84E6\u84BD\u84D3\u84CA\u84BF\u84BA\u84E0\u84A1\u84B9\u84B4\u8497\u84E5\u84E3\u850C\u750D\u8538\u84F0\u8539\u851F\u853A"],
      ["de40", "\u8F45", 32, "\u8F6A\u8F80\u8F8C\u8F92\u8F9D\u8FA0\u8FA1\u8FA2\u8FA4\u8FA5\u8FA6\u8FA7\u8FAA\u8FAC\u8FAD\u8FAE\u8FAF\u8FB2\u8FB3\u8FB4\u8FB5\u8FB7\u8FB8\u8FBA\u8FBB\u8FBC\u8FBF\u8FC0\u8FC3\u8FC6"],
      ["de80", "\u8FC9", 4, "\u8FCF\u8FD2\u8FD6\u8FD7\u8FDA\u8FE0\u8FE1\u8FE3\u8FE7\u8FEC\u8FEF\u8FF1\u8FF2\u8FF4\u8FF5\u8FF6\u8FFA\u8FFB\u8FFC\u8FFE\u8FFF\u9007\u9008\u900C\u900E\u9013\u9015\u9018\u8556\u853B\u84FF\u84FC\u8559\u8548\u8568\u8564\u855E\u857A\u77A2\u8543\u8572\u857B\u85A4\u85A8\u8587\u858F\u8579\u85AE\u859C\u8585\u85B9\u85B7\u85B0\u85D3\u85C1\u85DC\u85FF\u8627\u8605\u8629\u8616\u863C\u5EFE\u5F08\u593C\u5941\u8037\u5955\u595A\u5958\u530F\u5C22\u5C25\u5C2C\u5C34\u624C\u626A\u629F\u62BB\u62CA\u62DA\u62D7\u62EE\u6322\u62F6\u6339\u634B\u6343\u63AD\u63F6\u6371\u637A\u638E\u63B4\u636D\u63AC\u638A\u6369\u63AE\u63BC\u63F2\u63F8\u63E0\u63FF\u63C4\u63DE\u63CE\u6452\u63C6\u63BE\u6445\u6441\u640B\u641B\u6420\u640C\u6426\u6421\u645E\u6484\u646D\u6496"],
      ["df40", "\u9019\u901C\u9023\u9024\u9025\u9027", 5, "\u9030", 4, "\u9037\u9039\u903A\u903D\u903F\u9040\u9043\u9045\u9046\u9048", 4, "\u904E\u9054\u9055\u9056\u9059\u905A\u905C", 5, "\u9064\u9066\u9067\u9069\u906A\u906B\u906C\u906F", 4, "\u9076", 6, "\u907E\u9081"],
      ["df80", "\u9084\u9085\u9086\u9087\u9089\u908A\u908C", 4, "\u9092\u9094\u9096\u9098\u909A\u909C\u909E\u909F\u90A0\u90A4\u90A5\u90A7\u90A8\u90A9\u90AB\u90AD\u90B2\u90B7\u90BC\u90BD\u90BF\u90C0\u647A\u64B7\u64B8\u6499\u64BA\u64C0\u64D0\u64D7\u64E4\u64E2\u6509\u6525\u652E\u5F0B\u5FD2\u7519\u5F11\u535F\u53F1\u53FD\u53E9\u53E8\u53FB\u5412\u5416\u5406\u544B\u5452\u5453\u5454\u5456\u5443\u5421\u5457\u5459\u5423\u5432\u5482\u5494\u5477\u5471\u5464\u549A\u549B\u5484\u5476\u5466\u549D\u54D0\u54AD\u54C2\u54B4\u54D2\u54A7\u54A6\u54D3\u54D4\u5472\u54A3\u54D5\u54BB\u54BF\u54CC\u54D9\u54DA\u54DC\u54A9\u54AA\u54A4\u54DD\u54CF\u54DE\u551B\u54E7\u5520\u54FD\u5514\u54F3\u5522\u5523\u550F\u5511\u5527\u552A\u5567\u558F\u55B5\u5549\u556D\u5541\u5555\u553F\u5550\u553C"],
      ["e040", "\u90C2\u90C3\u90C6\u90C8\u90C9\u90CB\u90CC\u90CD\u90D2\u90D4\u90D5\u90D6\u90D8\u90D9\u90DA\u90DE\u90DF\u90E0\u90E3\u90E4\u90E5\u90E9\u90EA\u90EC\u90EE\u90F0\u90F1\u90F2\u90F3\u90F5\u90F6\u90F7\u90F9\u90FA\u90FB\u90FC\u90FF\u9100\u9101\u9103\u9105", 19, "\u911A\u911B\u911C"],
      ["e080", "\u911D\u911F\u9120\u9121\u9124", 10, "\u9130\u9132", 6, "\u913A", 8, "\u9144\u5537\u5556\u5575\u5576\u5577\u5533\u5530\u555C\u558B\u55D2\u5583\u55B1\u55B9\u5588\u5581\u559F\u557E\u55D6\u5591\u557B\u55DF\u55BD\u55BE\u5594\u5599\u55EA\u55F7\u55C9\u561F\u55D1\u55EB\u55EC\u55D4\u55E6\u55DD\u55C4\u55EF\u55E5\u55F2\u55F3\u55CC\u55CD\u55E8\u55F5\u55E4\u8F94\u561E\u5608\u560C\u5601\u5624\u5623\u55FE\u5600\u5627\u562D\u5658\u5639\u5657\u562C\u564D\u5662\u5659\u565C\u564C\u5654\u5686\u5664\u5671\u566B\u567B\u567C\u5685\u5693\u56AF\u56D4\u56D7\u56DD\u56E1\u56F5\u56EB\u56F9\u56FF\u5704\u570A\u5709\u571C\u5E0F\u5E19\u5E14\u5E11\u5E31\u5E3B\u5E3C"],
      ["e140", "\u9145\u9147\u9148\u9151\u9153\u9154\u9155\u9156\u9158\u9159\u915B\u915C\u915F\u9160\u9166\u9167\u9168\u916B\u916D\u9173\u917A\u917B\u917C\u9180", 4, "\u9186\u9188\u918A\u918E\u918F\u9193", 6, "\u919C", 5, "\u91A4", 5, "\u91AB\u91AC\u91B0\u91B1\u91B2\u91B3\u91B6\u91B7\u91B8\u91B9\u91BB"],
      ["e180", "\u91BC", 10, "\u91C8\u91CB\u91D0\u91D2", 9, "\u91DD", 8, "\u5E37\u5E44\u5E54\u5E5B\u5E5E\u5E61\u5C8C\u5C7A\u5C8D\u5C90\u5C96\u5C88\u5C98\u5C99\u5C91\u5C9A\u5C9C\u5CB5\u5CA2\u5CBD\u5CAC\u5CAB\u5CB1\u5CA3\u5CC1\u5CB7\u5CC4\u5CD2\u5CE4\u5CCB\u5CE5\u5D02\u5D03\u5D27\u5D26\u5D2E\u5D24\u5D1E\u5D06\u5D1B\u5D58\u5D3E\u5D34\u5D3D\u5D6C\u5D5B\u5D6F\u5D5D\u5D6B\u5D4B\u5D4A\u5D69\u5D74\u5D82\u5D99\u5D9D\u8C73\u5DB7\u5DC5\u5F73\u5F77\u5F82\u5F87\u5F89\u5F8C\u5F95\u5F99\u5F9C\u5FA8\u5FAD\u5FB5\u5FBC\u8862\u5F61\u72AD\u72B0\u72B4\u72B7\u72B8\u72C3\u72C1\u72CE\u72CD\u72D2\u72E8\u72EF\u72E9\u72F2\u72F4\u72F7\u7301\u72F3\u7303\u72FA"],
      ["e240", "\u91E6", 62],
      ["e280", "\u9225", 32, "\u72FB\u7317\u7313\u7321\u730A\u731E\u731D\u7315\u7322\u7339\u7325\u732C\u7338\u7331\u7350\u734D\u7357\u7360\u736C\u736F\u737E\u821B\u5925\u98E7\u5924\u5902\u9963\u9967", 5, "\u9974\u9977\u997D\u9980\u9984\u9987\u998A\u998D\u9990\u9991\u9993\u9994\u9995\u5E80\u5E91\u5E8B\u5E96\u5EA5\u5EA0\u5EB9\u5EB5\u5EBE\u5EB3\u8D53\u5ED2\u5ED1\u5EDB\u5EE8\u5EEA\u81BA\u5FC4\u5FC9\u5FD6\u5FCF\u6003\u5FEE\u6004\u5FE1\u5FE4\u5FFE\u6005\u6006\u5FEA\u5FED\u5FF8\u6019\u6035\u6026\u601B\u600F\u600D\u6029\u602B\u600A\u603F\u6021\u6078\u6079\u607B\u607A\u6042"],
      ["e340", "\u9246", 45, "\u9275", 16],
      ["e380", "\u9286", 7, "\u928F", 24, "\u606A\u607D\u6096\u609A\u60AD\u609D\u6083\u6092\u608C\u609B\u60EC\u60BB\u60B1\u60DD\u60D8\u60C6\u60DA\u60B4\u6120\u6126\u6115\u6123\u60F4\u6100\u610E\u612B\u614A\u6175\u61AC\u6194\u61A7\u61B7\u61D4\u61F5\u5FDD\u96B3\u95E9\u95EB\u95F1\u95F3\u95F5\u95F6\u95FC\u95FE\u9603\u9604\u9606\u9608\u960A\u960B\u960C\u960D\u960F\u9612\u9615\u9616\u9617\u9619\u961A\u4E2C\u723F\u6215\u6C35\u6C54\u6C5C\u6C4A\u6CA3\u6C85\u6C90\u6C94\u6C8C\u6C68\u6C69\u6C74\u6C76\u6C86\u6CA9\u6CD0\u6CD4\u6CAD\u6CF7\u6CF8\u6CF1\u6CD7\u6CB2\u6CE0\u6CD6\u6CFA\u6CEB\u6CEE\u6CB1\u6CD3\u6CEF\u6CFE"],
      ["e440", "\u92A8", 5, "\u92AF", 24, "\u92C9", 31],
      ["e480", "\u92E9", 32, "\u6D39\u6D27\u6D0C\u6D43\u6D48\u6D07\u6D04\u6D19\u6D0E\u6D2B\u6D4D\u6D2E\u6D35\u6D1A\u6D4F\u6D52\u6D54\u6D33\u6D91\u6D6F\u6D9E\u6DA0\u6D5E\u6D93\u6D94\u6D5C\u6D60\u6D7C\u6D63\u6E1A\u6DC7\u6DC5\u6DDE\u6E0E\u6DBF\u6DE0\u6E11\u6DE6\u6DDD\u6DD9\u6E16\u6DAB\u6E0C\u6DAE\u6E2B\u6E6E\u6E4E\u6E6B\u6EB2\u6E5F\u6E86\u6E53\u6E54\u6E32\u6E25\u6E44\u6EDF\u6EB1\u6E98\u6EE0\u6F2D\u6EE2\u6EA5\u6EA7\u6EBD\u6EBB\u6EB7\u6ED7\u6EB4\u6ECF\u6E8F\u6EC2\u6E9F\u6F62\u6F46\u6F47\u6F24\u6F15\u6EF9\u6F2F\u6F36\u6F4B\u6F74\u6F2A\u6F09\u6F29\u6F89\u6F8D\u6F8C\u6F78\u6F72\u6F7C\u6F7A\u6FD1"],
      ["e540", "\u930A", 51, "\u933F", 10],
      ["e580", "\u934A", 31, "\u936B\u6FC9\u6FA7\u6FB9\u6FB6\u6FC2\u6FE1\u6FEE\u6FDE\u6FE0\u6FEF\u701A\u7023\u701B\u7039\u7035\u704F\u705E\u5B80\u5B84\u5B95\u5B93\u5BA5\u5BB8\u752F\u9A9E\u6434\u5BE4\u5BEE\u8930\u5BF0\u8E47\u8B07\u8FB6\u8FD3\u8FD5\u8FE5\u8FEE\u8FE4\u8FE9\u8FE6\u8FF3\u8FE8\u9005\u9004\u900B\u9026\u9011\u900D\u9016\u9021\u9035\u9036\u902D\u902F\u9044\u9051\u9052\u9050\u9068\u9058\u9062\u905B\u66B9\u9074\u907D\u9082\u9088\u9083\u908B\u5F50\u5F57\u5F56\u5F58\u5C3B\u54AB\u5C50\u5C59\u5B71\u5C63\u5C66\u7FBC\u5F2A\u5F29\u5F2D\u8274\u5F3C\u9B3B\u5C6E\u5981\u5983\u598D\u59A9\u59AA\u59A3"],
      ["e640", "\u936C", 34, "\u9390", 27],
      ["e680", "\u93AC", 29, "\u93CB\u93CC\u93CD\u5997\u59CA\u59AB\u599E\u59A4\u59D2\u59B2\u59AF\u59D7\u59BE\u5A05\u5A06\u59DD\u5A08\u59E3\u59D8\u59F9\u5A0C\u5A09\u5A32\u5A34\u5A11\u5A23\u5A13\u5A40\u5A67\u5A4A\u5A55\u5A3C\u5A62\u5A75\u80EC\u5AAA\u5A9B\u5A77\u5A7A\u5ABE\u5AEB\u5AB2\u5AD2\u5AD4\u5AB8\u5AE0\u5AE3\u5AF1\u5AD6\u5AE6\u5AD8\u5ADC\u5B09\u5B17\u5B16\u5B32\u5B37\u5B40\u5C15\u5C1C\u5B5A\u5B65\u5B73\u5B51\u5B53\u5B62\u9A75\u9A77\u9A78\u9A7A\u9A7F\u9A7D\u9A80\u9A81\u9A85\u9A88\u9A8A\u9A90\u9A92\u9A93\u9A96\u9A98\u9A9B\u9A9C\u9A9D\u9A9F\u9AA0\u9AA2\u9AA3\u9AA5\u9AA7\u7E9F\u7EA1\u7EA3\u7EA5\u7EA8\u7EA9"],
      ["e740", "\u93CE", 7, "\u93D7", 54],
      ["e780", "\u940E", 32, "\u7EAD\u7EB0\u7EBE\u7EC0\u7EC1\u7EC2\u7EC9\u7ECB\u7ECC\u7ED0\u7ED4\u7ED7\u7EDB\u7EE0\u7EE1\u7EE8\u7EEB\u7EEE\u7EEF\u7EF1\u7EF2\u7F0D\u7EF6\u7EFA\u7EFB\u7EFE\u7F01\u7F02\u7F03\u7F07\u7F08\u7F0B\u7F0C\u7F0F\u7F11\u7F12\u7F17\u7F19\u7F1C\u7F1B\u7F1F\u7F21", 6, "\u7F2A\u7F2B\u7F2C\u7F2D\u7F2F", 4, "\u7F35\u5E7A\u757F\u5DDB\u753E\u9095\u738E\u7391\u73AE\u73A2\u739F\u73CF\u73C2\u73D1\u73B7\u73B3\u73C0\u73C9\u73C8\u73E5\u73D9\u987C\u740A\u73E9\u73E7\u73DE\u73BA\u73F2\u740F\u742A\u745B\u7426\u7425\u7428\u7430\u742E\u742C"],
      ["e840", "\u942F", 14, "\u943F", 43, "\u946C\u946D\u946E\u946F"],
      ["e880", "\u9470", 20, "\u9491\u9496\u9498\u94C7\u94CF\u94D3\u94D4\u94DA\u94E6\u94FB\u951C\u9520\u741B\u741A\u7441\u745C\u7457\u7455\u7459\u7477\u746D\u747E\u749C\u748E\u7480\u7481\u7487\u748B\u749E\u74A8\u74A9\u7490\u74A7\u74D2\u74BA\u97EA\u97EB\u97EC\u674C\u6753\u675E\u6748\u6769\u67A5\u6787\u676A\u6773\u6798\u67A7\u6775\u67A8\u679E\u67AD\u678B\u6777\u677C\u67F0\u6809\u67D8\u680A\u67E9\u67B0\u680C\u67D9\u67B5\u67DA\u67B3\u67DD\u6800\u67C3\u67B8\u67E2\u680E\u67C1\u67FD\u6832\u6833\u6860\u6861\u684E\u6862\u6844\u6864\u6883\u681D\u6855\u6866\u6841\u6867\u6840\u683E\u684A\u6849\u6829\u68B5\u688F\u6874\u6877\u6893\u686B\u68C2\u696E\u68FC\u691F\u6920\u68F9"],
      ["e940", "\u9527\u9533\u953D\u9543\u9548\u954B\u9555\u955A\u9560\u956E\u9574\u9575\u9577", 7, "\u9580", 42],
      ["e980", "\u95AB", 32, "\u6924\u68F0\u690B\u6901\u6957\u68E3\u6910\u6971\u6939\u6960\u6942\u695D\u6984\u696B\u6980\u6998\u6978\u6934\u69CC\u6987\u6988\u69CE\u6989\u6966\u6963\u6979\u699B\u69A7\u69BB\u69AB\u69AD\u69D4\u69B1\u69C1\u69CA\u69DF\u6995\u69E0\u698D\u69FF\u6A2F\u69ED\u6A17\u6A18\u6A65\u69F2\u6A44\u6A3E\u6AA0\u6A50\u6A5B\u6A35\u6A8E\u6A79\u6A3D\u6A28\u6A58\u6A7C\u6A91\u6A90\u6AA9\u6A97\u6AAB\u7337\u7352\u6B81\u6B82\u6B87\u6B84\u6B92\u6B93\u6B8D\u6B9A\u6B9B\u6BA1\u6BAA\u8F6B\u8F6D\u8F71\u8F72\u8F73\u8F75\u8F76\u8F78\u8F77\u8F79\u8F7A\u8F7C\u8F7E\u8F81\u8F82\u8F84\u8F87\u8F8B"],
      ["ea40", "\u95CC", 27, "\u95EC\u95FF\u9607\u9613\u9618\u961B\u961E\u9620\u9623", 6, "\u962B\u962C\u962D\u962F\u9630\u9637\u9638\u9639\u963A\u963E\u9641\u9643\u964A\u964E\u964F\u9651\u9652\u9653\u9656\u9657"],
      ["ea80", "\u9658\u9659\u965A\u965C\u965D\u965E\u9660\u9663\u9665\u9666\u966B\u966D", 4, "\u9673\u9678", 12, "\u9687\u9689\u968A\u8F8D\u8F8E\u8F8F\u8F98\u8F9A\u8ECE\u620B\u6217\u621B\u621F\u6222\u6221\u6225\u6224\u622C\u81E7\u74EF\u74F4\u74FF\u750F\u7511\u7513\u6534\u65EE\u65EF\u65F0\u660A\u6619\u6772\u6603\u6615\u6600\u7085\u66F7\u661D\u6634\u6631\u6636\u6635\u8006\u665F\u6654\u6641\u664F\u6656\u6661\u6657\u6677\u6684\u668C\u66A7\u669D\u66BE\u66DB\u66DC\u66E6\u66E9\u8D32\u8D33\u8D36\u8D3B\u8D3D\u8D40\u8D45\u8D46\u8D48\u8D49\u8D47\u8D4D\u8D55\u8D59\u89C7\u89CA\u89CB\u89CC\u89CE\u89CF\u89D0\u89D1\u726E\u729F\u725D\u7266\u726F\u727E\u727F\u7284\u728B\u728D\u728F\u7292\u6308\u6332\u63B0"],
      ["eb40", "\u968C\u968E\u9691\u9692\u9693\u9695\u9696\u969A\u969B\u969D", 9, "\u96A8", 7, "\u96B1\u96B2\u96B4\u96B5\u96B7\u96B8\u96BA\u96BB\u96BF\u96C2\u96C3\u96C8\u96CA\u96CB\u96D0\u96D1\u96D3\u96D4\u96D6", 9, "\u96E1", 6, "\u96EB"],
      ["eb80", "\u96EC\u96ED\u96EE\u96F0\u96F1\u96F2\u96F4\u96F5\u96F8\u96FA\u96FB\u96FC\u96FD\u96FF\u9702\u9703\u9705\u970A\u970B\u970C\u9710\u9711\u9712\u9714\u9715\u9717", 4, "\u971D\u971F\u9720\u643F\u64D8\u8004\u6BEA\u6BF3\u6BFD\u6BF5\u6BF9\u6C05\u6C07\u6C06\u6C0D\u6C15\u6C18\u6C19\u6C1A\u6C21\u6C29\u6C24\u6C2A\u6C32\u6535\u6555\u656B\u724D\u7252\u7256\u7230\u8662\u5216\u809F\u809C\u8093\u80BC\u670A\u80BD\u80B1\u80AB\u80AD\u80B4\u80B7\u80E7\u80E8\u80E9\u80EA\u80DB\u80C2\u80C4\u80D9\u80CD\u80D7\u6710\u80DD\u80EB\u80F1\u80F4\u80ED\u810D\u810E\u80F2\u80FC\u6715\u8112\u8C5A\u8136\u811E\u812C\u8118\u8132\u8148\u814C\u8153\u8174\u8159\u815A\u8171\u8160\u8169\u817C\u817D\u816D\u8167\u584D\u5AB5\u8188\u8182\u8191\u6ED5\u81A3\u81AA\u81CC\u6726\u81CA\u81BB"],
      ["ec40", "\u9721", 8, "\u972B\u972C\u972E\u972F\u9731\u9733", 4, "\u973A\u973B\u973C\u973D\u973F", 18, "\u9754\u9755\u9757\u9758\u975A\u975C\u975D\u975F\u9763\u9764\u9766\u9767\u9768\u976A", 7],
      ["ec80", "\u9772\u9775\u9777", 4, "\u977D", 7, "\u9786", 4, "\u978C\u978E\u978F\u9790\u9793\u9795\u9796\u9797\u9799", 4, "\u81C1\u81A6\u6B24\u6B37\u6B39\u6B43\u6B46\u6B59\u98D1\u98D2\u98D3\u98D5\u98D9\u98DA\u6BB3\u5F40\u6BC2\u89F3\u6590\u9F51\u6593\u65BC\u65C6\u65C4\u65C3\u65CC\u65CE\u65D2\u65D6\u7080\u709C\u7096\u709D\u70BB\u70C0\u70B7\u70AB\u70B1\u70E8\u70CA\u7110\u7113\u7116\u712F\u7131\u7173\u715C\u7168\u7145\u7172\u714A\u7178\u717A\u7198\u71B3\u71B5\u71A8\u71A0\u71E0\u71D4\u71E7\u71F9\u721D\u7228\u706C\u7118\u7166\u71B9\u623E\u623D\u6243\u6248\u6249\u793B\u7940\u7946\u7949\u795B\u795C\u7953\u795A\u7962\u7957\u7960\u796F\u7967\u797A\u7985\u798A\u799A\u79A7\u79B3\u5FD1\u5FD0"],
      ["ed40", "\u979E\u979F\u97A1\u97A2\u97A4", 6, "\u97AC\u97AE\u97B0\u97B1\u97B3\u97B5", 46],
      ["ed80", "\u97E4\u97E5\u97E8\u97EE", 4, "\u97F4\u97F7", 23, "\u603C\u605D\u605A\u6067\u6041\u6059\u6063\u60AB\u6106\u610D\u615D\u61A9\u619D\u61CB\u61D1\u6206\u8080\u807F\u6C93\u6CF6\u6DFC\u77F6\u77F8\u7800\u7809\u7817\u7818\u7811\u65AB\u782D\u781C\u781D\u7839\u783A\u783B\u781F\u783C\u7825\u782C\u7823\u7829\u784E\u786D\u7856\u7857\u7826\u7850\u7847\u784C\u786A\u789B\u7893\u789A\u7887\u789C\u78A1\u78A3\u78B2\u78B9\u78A5\u78D4\u78D9\u78C9\u78EC\u78F2\u7905\u78F4\u7913\u7924\u791E\u7934\u9F9B\u9EF9\u9EFB\u9EFC\u76F1\u7704\u770D\u76F9\u7707\u7708\u771A\u7722\u7719\u772D\u7726\u7735\u7738\u7750\u7751\u7747\u7743\u775A\u7768"],
      ["ee40", "\u980F", 62],
      ["ee80", "\u984E", 32, "\u7762\u7765\u777F\u778D\u777D\u7780\u778C\u7791\u779F\u77A0\u77B0\u77B5\u77BD\u753A\u7540\u754E\u754B\u7548\u755B\u7572\u7579\u7583\u7F58\u7F61\u7F5F\u8A48\u7F68\u7F74\u7F71\u7F79\u7F81\u7F7E\u76CD\u76E5\u8832\u9485\u9486\u9487\u948B\u948A\u948C\u948D\u948F\u9490\u9494\u9497\u9495\u949A\u949B\u949C\u94A3\u94A4\u94AB\u94AA\u94AD\u94AC\u94AF\u94B0\u94B2\u94B4\u94B6", 4, "\u94BC\u94BD\u94BF\u94C4\u94C8", 6, "\u94D0\u94D1\u94D2\u94D5\u94D6\u94D7\u94D9\u94D8\u94DB\u94DE\u94DF\u94E0\u94E2\u94E4\u94E5\u94E7\u94E8\u94EA"],
      ["ef40", "\u986F", 5, "\u988B\u988E\u9892\u9895\u9899\u98A3\u98A8", 37, "\u98CF\u98D0\u98D4\u98D6\u98D7\u98DB\u98DC\u98DD\u98E0", 4],
      ["ef80", "\u98E5\u98E6\u98E9", 30, "\u94E9\u94EB\u94EE\u94EF\u94F3\u94F4\u94F5\u94F7\u94F9\u94FC\u94FD\u94FF\u9503\u9502\u9506\u9507\u9509\u950A\u950D\u950E\u950F\u9512", 4, "\u9518\u951B\u951D\u951E\u951F\u9522\u952A\u952B\u9529\u952C\u9531\u9532\u9534\u9536\u9537\u9538\u953C\u953E\u953F\u9542\u9535\u9544\u9545\u9546\u9549\u954C\u954E\u954F\u9552\u9553\u9554\u9556\u9557\u9558\u9559\u955B\u955E\u955F\u955D\u9561\u9562\u9564", 8, "\u956F\u9571\u9572\u9573\u953A\u77E7\u77EC\u96C9\u79D5\u79ED\u79E3\u79EB\u7A06\u5D47\u7A03\u7A02\u7A1E\u7A14"],
      ["f040", "\u9908", 4, "\u990E\u990F\u9911", 28, "\u992F", 26],
      ["f080", "\u994A", 9, "\u9956", 12, "\u9964\u9966\u9973\u9978\u9979\u997B\u997E\u9982\u9983\u9989\u7A39\u7A37\u7A51\u9ECF\u99A5\u7A70\u7688\u768E\u7693\u7699\u76A4\u74DE\u74E0\u752C\u9E20\u9E22\u9E28", 4, "\u9E32\u9E31\u9E36\u9E38\u9E37\u9E39\u9E3A\u9E3E\u9E41\u9E42\u9E44\u9E46\u9E47\u9E48\u9E49\u9E4B\u9E4C\u9E4E\u9E51\u9E55\u9E57\u9E5A\u9E5B\u9E5C\u9E5E\u9E63\u9E66", 6, "\u9E71\u9E6D\u9E73\u7592\u7594\u7596\u75A0\u759D\u75AC\u75A3\u75B3\u75B4\u75B8\u75C4\u75B1\u75B0\u75C3\u75C2\u75D6\u75CD\u75E3\u75E8\u75E6\u75E4\u75EB\u75E7\u7603\u75F1\u75FC\u75FF\u7610\u7600\u7605\u760C\u7617\u760A\u7625\u7618\u7615\u7619"],
      ["f140", "\u998C\u998E\u999A", 10, "\u99A6\u99A7\u99A9", 47],
      ["f180", "\u99D9", 32, "\u761B\u763C\u7622\u7620\u7640\u762D\u7630\u763F\u7635\u7643\u763E\u7633\u764D\u765E\u7654\u765C\u7656\u766B\u766F\u7FCA\u7AE6\u7A78\u7A79\u7A80\u7A86\u7A88\u7A95\u7AA6\u7AA0\u7AAC\u7AA8\u7AAD\u7AB3\u8864\u8869\u8872\u887D\u887F\u8882\u88A2\u88C6\u88B7\u88BC\u88C9\u88E2\u88CE\u88E3\u88E5\u88F1\u891A\u88FC\u88E8\u88FE\u88F0\u8921\u8919\u8913\u891B\u890A\u8934\u892B\u8936\u8941\u8966\u897B\u758B\u80E5\u76B2\u76B4\u77DC\u8012\u8014\u8016\u801C\u8020\u8022\u8025\u8026\u8027\u8029\u8028\u8031\u800B\u8035\u8043\u8046\u804D\u8052\u8069\u8071\u8983\u9878\u9880\u9883"],
      ["f240", "\u99FA", 62],
      ["f280", "\u9A39", 32, "\u9889\u988C\u988D\u988F\u9894\u989A\u989B\u989E\u989F\u98A1\u98A2\u98A5\u98A6\u864D\u8654\u866C\u866E\u867F\u867A\u867C\u867B\u86A8\u868D\u868B\u86AC\u869D\u86A7\u86A3\u86AA\u8693\u86A9\u86B6\u86C4\u86B5\u86CE\u86B0\u86BA\u86B1\u86AF\u86C9\u86CF\u86B4\u86E9\u86F1\u86F2\u86ED\u86F3\u86D0\u8713\u86DE\u86F4\u86DF\u86D8\u86D1\u8703\u8707\u86F8\u8708\u870A\u870D\u8709\u8723\u873B\u871E\u8725\u872E\u871A\u873E\u8748\u8734\u8731\u8729\u8737\u873F\u8782\u8722\u877D\u877E\u877B\u8760\u8770\u874C\u876E\u878B\u8753\u8763\u877C\u8764\u8759\u8765\u8793\u87AF\u87A8\u87D2"],
      ["f340", "\u9A5A", 17, "\u9A72\u9A83\u9A89\u9A8D\u9A8E\u9A94\u9A95\u9A99\u9AA6\u9AA9", 6, "\u9AB2\u9AB3\u9AB4\u9AB5\u9AB9\u9ABB\u9ABD\u9ABE\u9ABF\u9AC3\u9AC4\u9AC6", 4, "\u9ACD\u9ACE\u9ACF\u9AD0\u9AD2\u9AD4\u9AD5\u9AD6\u9AD7\u9AD9\u9ADA\u9ADB\u9ADC"],
      ["f380", "\u9ADD\u9ADE\u9AE0\u9AE2\u9AE3\u9AE4\u9AE5\u9AE7\u9AE8\u9AE9\u9AEA\u9AEC\u9AEE\u9AF0", 8, "\u9AFA\u9AFC", 6, "\u9B04\u9B05\u9B06\u87C6\u8788\u8785\u87AD\u8797\u8783\u87AB\u87E5\u87AC\u87B5\u87B3\u87CB\u87D3\u87BD\u87D1\u87C0\u87CA\u87DB\u87EA\u87E0\u87EE\u8816\u8813\u87FE\u880A\u881B\u8821\u8839\u883C\u7F36\u7F42\u7F44\u7F45\u8210\u7AFA\u7AFD\u7B08\u7B03\u7B04\u7B15\u7B0A\u7B2B\u7B0F\u7B47\u7B38\u7B2A\u7B19\u7B2E\u7B31\u7B20\u7B25\u7B24\u7B33\u7B3E\u7B1E\u7B58\u7B5A\u7B45\u7B75\u7B4C\u7B5D\u7B60\u7B6E\u7B7B\u7B62\u7B72\u7B71\u7B90\u7BA6\u7BA7\u7BB8\u7BAC\u7B9D\u7BA8\u7B85\u7BAA\u7B9C\u7BA2\u7BAB\u7BB4\u7BD1\u7BC1\u7BCC\u7BDD\u7BDA\u7BE5\u7BE6\u7BEA\u7C0C\u7BFE\u7BFC\u7C0F\u7C16\u7C0B"],
      ["f440", "\u9B07\u9B09", 5, "\u9B10\u9B11\u9B12\u9B14", 10, "\u9B20\u9B21\u9B22\u9B24", 10, "\u9B30\u9B31\u9B33", 7, "\u9B3D\u9B3E\u9B3F\u9B40\u9B46\u9B4A\u9B4B\u9B4C\u9B4E\u9B50\u9B52\u9B53\u9B55", 5],
      ["f480", "\u9B5B", 32, "\u7C1F\u7C2A\u7C26\u7C38\u7C41\u7C40\u81FE\u8201\u8202\u8204\u81EC\u8844\u8221\u8222\u8223\u822D\u822F\u8228\u822B\u8238\u823B\u8233\u8234\u823E\u8244\u8249\u824B\u824F\u825A\u825F\u8268\u887E\u8885\u8888\u88D8\u88DF\u895E\u7F9D\u7F9F\u7FA7\u7FAF\u7FB0\u7FB2\u7C7C\u6549\u7C91\u7C9D\u7C9C\u7C9E\u7CA2\u7CB2\u7CBC\u7CBD\u7CC1\u7CC7\u7CCC\u7CCD\u7CC8\u7CC5\u7CD7\u7CE8\u826E\u66A8\u7FBF\u7FCE\u7FD5\u7FE5\u7FE1\u7FE6\u7FE9\u7FEE\u7FF3\u7CF8\u7D77\u7DA6\u7DAE\u7E47\u7E9B\u9EB8\u9EB4\u8D73\u8D84\u8D94\u8D91\u8DB1\u8D67\u8D6D\u8C47\u8C49\u914A\u9150\u914E\u914F\u9164"],
      ["f540", "\u9B7C", 62],
      ["f580", "\u9BBB", 32, "\u9162\u9161\u9170\u9169\u916F\u917D\u917E\u9172\u9174\u9179\u918C\u9185\u9190\u918D\u9191\u91A2\u91A3\u91AA\u91AD\u91AE\u91AF\u91B5\u91B4\u91BA\u8C55\u9E7E\u8DB8\u8DEB\u8E05\u8E59\u8E69\u8DB5\u8DBF\u8DBC\u8DBA\u8DC4\u8DD6\u8DD7\u8DDA\u8DDE\u8DCE\u8DCF\u8DDB\u8DC6\u8DEC\u8DF7\u8DF8\u8DE3\u8DF9\u8DFB\u8DE4\u8E09\u8DFD\u8E14\u8E1D\u8E1F\u8E2C\u8E2E\u8E23\u8E2F\u8E3A\u8E40\u8E39\u8E35\u8E3D\u8E31\u8E49\u8E41\u8E42\u8E51\u8E52\u8E4A\u8E70\u8E76\u8E7C\u8E6F\u8E74\u8E85\u8E8F\u8E94\u8E90\u8E9C\u8E9E\u8C78\u8C82\u8C8A\u8C85\u8C98\u8C94\u659B\u89D6\u89DE\u89DA\u89DC"],
      ["f640", "\u9BDC", 62],
      ["f680", "\u9C1B", 32, "\u89E5\u89EB\u89EF\u8A3E\u8B26\u9753\u96E9\u96F3\u96EF\u9706\u9701\u9708\u970F\u970E\u972A\u972D\u9730\u973E\u9F80\u9F83\u9F85", 5, "\u9F8C\u9EFE\u9F0B\u9F0D\u96B9\u96BC\u96BD\u96CE\u96D2\u77BF\u96E0\u928E\u92AE\u92C8\u933E\u936A\u93CA\u938F\u943E\u946B\u9C7F\u9C82\u9C85\u9C86\u9C87\u9C88\u7A23\u9C8B\u9C8E\u9C90\u9C91\u9C92\u9C94\u9C95\u9C9A\u9C9B\u9C9E", 5, "\u9CA5", 4, "\u9CAB\u9CAD\u9CAE\u9CB0", 7, "\u9CBA\u9CBB\u9CBC\u9CBD\u9CC4\u9CC5\u9CC6\u9CC7\u9CCA\u9CCB"],
      ["f740", "\u9C3C", 62],
      ["f780", "\u9C7B\u9C7D\u9C7E\u9C80\u9C83\u9C84\u9C89\u9C8A\u9C8C\u9C8F\u9C93\u9C96\u9C97\u9C98\u9C99\u9C9D\u9CAA\u9CAC\u9CAF\u9CB9\u9CBE", 4, "\u9CC8\u9CC9\u9CD1\u9CD2\u9CDA\u9CDB\u9CE0\u9CE1\u9CCC", 4, "\u9CD3\u9CD4\u9CD5\u9CD7\u9CD8\u9CD9\u9CDC\u9CDD\u9CDF\u9CE2\u977C\u9785\u9791\u9792\u9794\u97AF\u97AB\u97A3\u97B2\u97B4\u9AB1\u9AB0\u9AB7\u9E58\u9AB6\u9ABA\u9ABC\u9AC1\u9AC0\u9AC5\u9AC2\u9ACB\u9ACC\u9AD1\u9B45\u9B43\u9B47\u9B49\u9B48\u9B4D\u9B51\u98E8\u990D\u992E\u9955\u9954\u9ADF\u9AE1\u9AE6\u9AEF\u9AEB\u9AFB\u9AED\u9AF9\u9B08\u9B0F\u9B13\u9B1F\u9B23\u9EBD\u9EBE\u7E3B\u9E82\u9E87\u9E88\u9E8B\u9E92\u93D6\u9E9D\u9E9F\u9EDB\u9EDC\u9EDD\u9EE0\u9EDF\u9EE2\u9EE9\u9EE7\u9EE5\u9EEA\u9EEF\u9F22\u9F2C\u9F2F\u9F39\u9F37\u9F3D\u9F3E\u9F44"],
      ["f840", "\u9CE3", 62],
      ["f880", "\u9D22", 32],
      ["f940", "\u9D43", 62],
      ["f980", "\u9D82", 32],
      ["fa40", "\u9DA3", 62],
      ["fa80", "\u9DE2", 32],
      ["fb40", "\u9E03", 27, "\u9E24\u9E27\u9E2E\u9E30\u9E34\u9E3B\u9E3C\u9E40\u9E4D\u9E50\u9E52\u9E53\u9E54\u9E56\u9E59\u9E5D\u9E5F\u9E60\u9E61\u9E62\u9E65\u9E6E\u9E6F\u9E72\u9E74", 9, "\u9E80"],
      ["fb80", "\u9E81\u9E83\u9E84\u9E85\u9E86\u9E89\u9E8A\u9E8C", 5, "\u9E94", 8, "\u9E9E\u9EA0", 5, "\u9EA7\u9EA8\u9EA9\u9EAA"],
      ["fc40", "\u9EAB", 8, "\u9EB5\u9EB6\u9EB7\u9EB9\u9EBA\u9EBC\u9EBF", 4, "\u9EC5\u9EC6\u9EC7\u9EC8\u9ECA\u9ECB\u9ECC\u9ED0\u9ED2\u9ED3\u9ED5\u9ED6\u9ED7\u9ED9\u9EDA\u9EDE\u9EE1\u9EE3\u9EE4\u9EE6\u9EE8\u9EEB\u9EEC\u9EED\u9EEE\u9EF0", 8, "\u9EFA\u9EFD\u9EFF", 6],
      ["fc80", "\u9F06", 4, "\u9F0C\u9F0F\u9F11\u9F12\u9F14\u9F15\u9F16\u9F18\u9F1A", 5, "\u9F21\u9F23", 8, "\u9F2D\u9F2E\u9F30\u9F31"],
      ["fd40", "\u9F32", 4, "\u9F38\u9F3A\u9F3C\u9F3F", 4, "\u9F45", 10, "\u9F52", 38],
      ["fd80", "\u9F79", 5, "\u9F81\u9F82\u9F8D", 11, "\u9F9C\u9F9D\u9F9E\u9FA1", 4, "\uF92C\uF979\uF995\uF9E7\uF9F1"],
      ["fe40", "\uFA0C\uFA0D\uFA0E\uFA0F\uFA11\uFA13\uFA14\uFA18\uFA1F\uFA20\uFA21\uFA23\uFA24\uFA27\uFA28\uFA29"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS({
  "node_modules/iconv-lite/encodings/tables/gbk-added.json"(exports2, module2) {
    module2.exports = [
      ["a140", "\uE4C6", 62],
      ["a180", "\uE505", 32],
      ["a240", "\uE526", 62],
      ["a280", "\uE565", 32],
      ["a2ab", "\uE766", 5],
      ["a2e3", "\u20AC\uE76D"],
      ["a2ef", "\uE76E\uE76F"],
      ["a2fd", "\uE770\uE771"],
      ["a340", "\uE586", 62],
      ["a380", "\uE5C5", 31, "\u3000"],
      ["a440", "\uE5E6", 62],
      ["a480", "\uE625", 32],
      ["a4f4", "\uE772", 10],
      ["a540", "\uE646", 62],
      ["a580", "\uE685", 32],
      ["a5f7", "\uE77D", 7],
      ["a640", "\uE6A6", 62],
      ["a680", "\uE6E5", 32],
      ["a6b9", "\uE785", 7],
      ["a6d9", "\uE78D", 6],
      ["a6ec", "\uE794\uE795"],
      ["a6f3", "\uE796"],
      ["a6f6", "\uE797", 8],
      ["a740", "\uE706", 62],
      ["a780", "\uE745", 32],
      ["a7c2", "\uE7A0", 14],
      ["a7f2", "\uE7AF", 12],
      ["a896", "\uE7BC", 10],
      ["a8bc", "\uE7C7"],
      ["a8bf", "\u01F9"],
      ["a8c1", "\uE7C9\uE7CA\uE7CB\uE7CC"],
      ["a8ea", "\uE7CD", 20],
      ["a958", "\uE7E2"],
      ["a95b", "\uE7E3"],
      ["a95d", "\uE7E4\uE7E5\uE7E6"],
      ["a989", "\u303E\u2FF0", 11],
      ["a997", "\uE7F4", 12],
      ["a9f0", "\uE801", 14],
      ["aaa1", "\uE000", 93],
      ["aba1", "\uE05E", 93],
      ["aca1", "\uE0BC", 93],
      ["ada1", "\uE11A", 93],
      ["aea1", "\uE178", 93],
      ["afa1", "\uE1D6", 93],
      ["d7fa", "\uE810", 4],
      ["f8a1", "\uE234", 93],
      ["f9a1", "\uE292", 93],
      ["faa1", "\uE2F0", 93],
      ["fba1", "\uE34E", 93],
      ["fca1", "\uE3AC", 93],
      ["fda1", "\uE40A", 93],
      ["fe50", "\u2E81\uE816\uE817\uE818\u2E84\u3473\u3447\u2E88\u2E8B\uE81E\u359E\u361A\u360E\u2E8C\u2E97\u396E\u3918\uE826\u39CF\u39DF\u3A73\u39D0\uE82B\uE82C\u3B4E\u3C6E\u3CE0\u2EA7\uE831\uE832\u2EAA\u4056\u415F\u2EAE\u4337\u2EB3\u2EB6\u2EB7\uE83B\u43B1\u43AC\u2EBB\u43DD\u44D6\u4661\u464C\uE843"],
      ["fe80", "\u4723\u4729\u477C\u478D\u2ECA\u4947\u497A\u497D\u4982\u4983\u4985\u4986\u499F\u499B\u49B7\u49B6\uE854\uE855\u4CA3\u4C9F\u4CA0\u4CA1\u4C77\u4CA2\u4D13", 6, "\u4DAE\uE864\uE468", 93]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS({
  "node_modules/iconv-lite/encodings/tables/gb18030-ranges.json"(exports2, module2) {
    module2.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3] };
  }
});

// node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS({
  "node_modules/iconv-lite/encodings/tables/cp949.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["8141", "\uAC02\uAC03\uAC05\uAC06\uAC0B", 4, "\uAC18\uAC1E\uAC1F\uAC21\uAC22\uAC23\uAC25", 6, "\uAC2E\uAC32\uAC33\uAC34"],
      ["8161", "\uAC35\uAC36\uAC37\uAC3A\uAC3B\uAC3D\uAC3E\uAC3F\uAC41", 9, "\uAC4C\uAC4E", 5, "\uAC55"],
      ["8181", "\uAC56\uAC57\uAC59\uAC5A\uAC5B\uAC5D", 18, "\uAC72\uAC73\uAC75\uAC76\uAC79\uAC7B", 4, "\uAC82\uAC87\uAC88\uAC8D\uAC8E\uAC8F\uAC91\uAC92\uAC93\uAC95", 6, "\uAC9E\uACA2", 5, "\uACAB\uACAD\uACAE\uACB1", 6, "\uACBA\uACBE\uACBF\uACC0\uACC2\uACC3\uACC5\uACC6\uACC7\uACC9\uACCA\uACCB\uACCD", 7, "\uACD6\uACD8", 7, "\uACE2\uACE3\uACE5\uACE6\uACE9\uACEB\uACED\uACEE\uACF2\uACF4\uACF7", 4, "\uACFE\uACFF\uAD01\uAD02\uAD03\uAD05\uAD07", 4, "\uAD0E\uAD10\uAD12\uAD13"],
      ["8241", "\uAD14\uAD15\uAD16\uAD17\uAD19\uAD1A\uAD1B\uAD1D\uAD1E\uAD1F\uAD21", 7, "\uAD2A\uAD2B\uAD2E", 5],
      ["8261", "\uAD36\uAD37\uAD39\uAD3A\uAD3B\uAD3D", 6, "\uAD46\uAD48\uAD4A", 5, "\uAD51\uAD52\uAD53\uAD55\uAD56\uAD57"],
      ["8281", "\uAD59", 7, "\uAD62\uAD64", 7, "\uAD6E\uAD6F\uAD71\uAD72\uAD77\uAD78\uAD79\uAD7A\uAD7E\uAD80\uAD83", 4, "\uAD8A\uAD8B\uAD8D\uAD8E\uAD8F\uAD91", 10, "\uAD9E", 5, "\uADA5", 17, "\uADB8", 7, "\uADC2\uADC3\uADC5\uADC6\uADC7\uADC9", 6, "\uADD2\uADD4", 7, "\uADDD\uADDE\uADDF\uADE1\uADE2\uADE3\uADE5", 18],
      ["8341", "\uADFA\uADFB\uADFD\uADFE\uAE02", 5, "\uAE0A\uAE0C\uAE0E", 5, "\uAE15", 7],
      ["8361", "\uAE1D", 18, "\uAE32\uAE33\uAE35\uAE36\uAE39\uAE3B\uAE3C"],
      ["8381", "\uAE3D\uAE3E\uAE3F\uAE42\uAE44\uAE47\uAE48\uAE49\uAE4B\uAE4F\uAE51\uAE52\uAE53\uAE55\uAE57", 4, "\uAE5E\uAE62\uAE63\uAE64\uAE66\uAE67\uAE6A\uAE6B\uAE6D\uAE6E\uAE6F\uAE71", 6, "\uAE7A\uAE7E", 5, "\uAE86", 5, "\uAE8D", 46, "\uAEBF\uAEC1\uAEC2\uAEC3\uAEC5", 6, "\uAECE\uAED2", 5, "\uAEDA\uAEDB\uAEDD", 8],
      ["8441", "\uAEE6\uAEE7\uAEE9\uAEEA\uAEEC\uAEEE", 5, "\uAEF5\uAEF6\uAEF7\uAEF9\uAEFA\uAEFB\uAEFD", 8],
      ["8461", "\uAF06\uAF09\uAF0A\uAF0B\uAF0C\uAF0E\uAF0F\uAF11", 18],
      ["8481", "\uAF24", 7, "\uAF2E\uAF2F\uAF31\uAF33\uAF35", 6, "\uAF3E\uAF40\uAF44\uAF45\uAF46\uAF47\uAF4A", 5, "\uAF51", 10, "\uAF5E", 5, "\uAF66", 18, "\uAF7A", 5, "\uAF81\uAF82\uAF83\uAF85\uAF86\uAF87\uAF89", 6, "\uAF92\uAF93\uAF94\uAF96", 5, "\uAF9D", 26, "\uAFBA\uAFBB\uAFBD\uAFBE"],
      ["8541", "\uAFBF\uAFC1", 5, "\uAFCA\uAFCC\uAFCF", 4, "\uAFD5", 6, "\uAFDD", 4],
      ["8561", "\uAFE2", 5, "\uAFEA", 5, "\uAFF2\uAFF3\uAFF5\uAFF6\uAFF7\uAFF9", 6, "\uB002\uB003"],
      ["8581", "\uB005", 6, "\uB00D\uB00E\uB00F\uB011\uB012\uB013\uB015", 6, "\uB01E", 9, "\uB029", 26, "\uB046\uB047\uB049\uB04B\uB04D\uB04F\uB050\uB051\uB052\uB056\uB058\uB05A\uB05B\uB05C\uB05E", 29, "\uB07E\uB07F\uB081\uB082\uB083\uB085", 6, "\uB08E\uB090\uB092", 5, "\uB09B\uB09D\uB09E\uB0A3\uB0A4"],
      ["8641", "\uB0A5\uB0A6\uB0A7\uB0AA\uB0B0\uB0B2\uB0B6\uB0B7\uB0B9\uB0BA\uB0BB\uB0BD", 6, "\uB0C6\uB0CA", 5, "\uB0D2"],
      ["8661", "\uB0D3\uB0D5\uB0D6\uB0D7\uB0D9", 6, "\uB0E1\uB0E2\uB0E3\uB0E4\uB0E6", 10],
      ["8681", "\uB0F1", 22, "\uB10A\uB10D\uB10E\uB10F\uB111\uB114\uB115\uB116\uB117\uB11A\uB11E", 4, "\uB126\uB127\uB129\uB12A\uB12B\uB12D", 6, "\uB136\uB13A", 5, "\uB142\uB143\uB145\uB146\uB147\uB149", 6, "\uB152\uB153\uB156\uB157\uB159\uB15A\uB15B\uB15D\uB15E\uB15F\uB161", 22, "\uB17A\uB17B\uB17D\uB17E\uB17F\uB181\uB183", 4, "\uB18A\uB18C\uB18E\uB18F\uB190\uB191\uB195\uB196\uB197\uB199\uB19A\uB19B\uB19D"],
      ["8741", "\uB19E", 9, "\uB1A9", 15],
      ["8761", "\uB1B9", 18, "\uB1CD\uB1CE\uB1CF\uB1D1\uB1D2\uB1D3\uB1D5"],
      ["8781", "\uB1D6", 5, "\uB1DE\uB1E0", 7, "\uB1EA\uB1EB\uB1ED\uB1EE\uB1EF\uB1F1", 7, "\uB1FA\uB1FC\uB1FE", 5, "\uB206\uB207\uB209\uB20A\uB20D", 6, "\uB216\uB218\uB21A", 5, "\uB221", 18, "\uB235", 6, "\uB23D", 26, "\uB259\uB25A\uB25B\uB25D\uB25E\uB25F\uB261", 6, "\uB26A", 4],
      ["8841", "\uB26F", 4, "\uB276", 5, "\uB27D", 6, "\uB286\uB287\uB288\uB28A", 4],
      ["8861", "\uB28F\uB292\uB293\uB295\uB296\uB297\uB29B", 4, "\uB2A2\uB2A4\uB2A7\uB2A8\uB2A9\uB2AB\uB2AD\uB2AE\uB2AF\uB2B1\uB2B2\uB2B3\uB2B5\uB2B6\uB2B7"],
      ["8881", "\uB2B8", 15, "\uB2CA\uB2CB\uB2CD\uB2CE\uB2CF\uB2D1\uB2D3", 4, "\uB2DA\uB2DC\uB2DE\uB2DF\uB2E0\uB2E1\uB2E3\uB2E7\uB2E9\uB2EA\uB2F0\uB2F1\uB2F2\uB2F6\uB2FC\uB2FD\uB2FE\uB302\uB303\uB305\uB306\uB307\uB309", 6, "\uB312\uB316", 5, "\uB31D", 54, "\uB357\uB359\uB35A\uB35D\uB360\uB361\uB362\uB363"],
      ["8941", "\uB366\uB368\uB36A\uB36C\uB36D\uB36F\uB372\uB373\uB375\uB376\uB377\uB379", 6, "\uB382\uB386", 5, "\uB38D"],
      ["8961", "\uB38E\uB38F\uB391\uB392\uB393\uB395", 10, "\uB3A2", 5, "\uB3A9\uB3AA\uB3AB\uB3AD"],
      ["8981", "\uB3AE", 21, "\uB3C6\uB3C7\uB3C9\uB3CA\uB3CD\uB3CF\uB3D1\uB3D2\uB3D3\uB3D6\uB3D8\uB3DA\uB3DC\uB3DE\uB3DF\uB3E1\uB3E2\uB3E3\uB3E5\uB3E6\uB3E7\uB3E9", 18, "\uB3FD", 18, "\uB411", 6, "\uB419\uB41A\uB41B\uB41D\uB41E\uB41F\uB421", 6, "\uB42A\uB42C", 7, "\uB435", 15],
      ["8a41", "\uB445", 10, "\uB452\uB453\uB455\uB456\uB457\uB459", 6, "\uB462\uB464\uB466"],
      ["8a61", "\uB467", 4, "\uB46D", 18, "\uB481\uB482"],
      ["8a81", "\uB483", 4, "\uB489", 19, "\uB49E", 5, "\uB4A5\uB4A6\uB4A7\uB4A9\uB4AA\uB4AB\uB4AD", 7, "\uB4B6\uB4B8\uB4BA", 5, "\uB4C1\uB4C2\uB4C3\uB4C5\uB4C6\uB4C7\uB4C9", 6, "\uB4D1\uB4D2\uB4D3\uB4D4\uB4D6", 5, "\uB4DE\uB4DF\uB4E1\uB4E2\uB4E5\uB4E7", 4, "\uB4EE\uB4F0\uB4F2", 5, "\uB4F9", 26, "\uB516\uB517\uB519\uB51A\uB51D"],
      ["8b41", "\uB51E", 5, "\uB526\uB52B", 4, "\uB532\uB533\uB535\uB536\uB537\uB539", 6, "\uB542\uB546"],
      ["8b61", "\uB547\uB548\uB549\uB54A\uB54E\uB54F\uB551\uB552\uB553\uB555", 6, "\uB55E\uB562", 8],
      ["8b81", "\uB56B", 52, "\uB5A2\uB5A3\uB5A5\uB5A6\uB5A7\uB5A9\uB5AC\uB5AD\uB5AE\uB5AF\uB5B2\uB5B6", 4, "\uB5BE\uB5BF\uB5C1\uB5C2\uB5C3\uB5C5", 6, "\uB5CE\uB5D2", 5, "\uB5D9", 18, "\uB5ED", 18],
      ["8c41", "\uB600", 15, "\uB612\uB613\uB615\uB616\uB617\uB619", 4],
      ["8c61", "\uB61E", 6, "\uB626", 5, "\uB62D", 6, "\uB635", 5],
      ["8c81", "\uB63B", 12, "\uB649", 26, "\uB665\uB666\uB667\uB669", 50, "\uB69E\uB69F\uB6A1\uB6A2\uB6A3\uB6A5", 5, "\uB6AD\uB6AE\uB6AF\uB6B0\uB6B2", 16],
      ["8d41", "\uB6C3", 16, "\uB6D5", 8],
      ["8d61", "\uB6DE", 17, "\uB6F1\uB6F2\uB6F3\uB6F5\uB6F6\uB6F7\uB6F9\uB6FA"],
      ["8d81", "\uB6FB", 4, "\uB702\uB703\uB704\uB706", 33, "\uB72A\uB72B\uB72D\uB72E\uB731", 6, "\uB73A\uB73C", 7, "\uB745\uB746\uB747\uB749\uB74A\uB74B\uB74D", 6, "\uB756", 9, "\uB761\uB762\uB763\uB765\uB766\uB767\uB769", 6, "\uB772\uB774\uB776", 5, "\uB77E\uB77F\uB781\uB782\uB783\uB785", 6, "\uB78E\uB793\uB794\uB795\uB79A\uB79B\uB79D\uB79E"],
      ["8e41", "\uB79F\uB7A1", 6, "\uB7AA\uB7AE", 5, "\uB7B6\uB7B7\uB7B9", 8],
      ["8e61", "\uB7C2", 4, "\uB7C8\uB7CA", 19],
      ["8e81", "\uB7DE", 13, "\uB7EE\uB7EF\uB7F1\uB7F2\uB7F3\uB7F5", 6, "\uB7FE\uB802", 4, "\uB80A\uB80B\uB80D\uB80E\uB80F\uB811", 6, "\uB81A\uB81C\uB81E", 5, "\uB826\uB827\uB829\uB82A\uB82B\uB82D", 6, "\uB836\uB83A", 5, "\uB841\uB842\uB843\uB845", 11, "\uB852\uB854", 7, "\uB85E\uB85F\uB861\uB862\uB863\uB865", 6, "\uB86E\uB870\uB872", 5, "\uB879\uB87A\uB87B\uB87D", 7],
      ["8f41", "\uB885", 7, "\uB88E", 17],
      ["8f61", "\uB8A0", 7, "\uB8A9", 6, "\uB8B1\uB8B2\uB8B3\uB8B5\uB8B6\uB8B7\uB8B9", 4],
      ["8f81", "\uB8BE\uB8BF\uB8C2\uB8C4\uB8C6", 5, "\uB8CD\uB8CE\uB8CF\uB8D1\uB8D2\uB8D3\uB8D5", 7, "\uB8DE\uB8E0\uB8E2", 5, "\uB8EA\uB8EB\uB8ED\uB8EE\uB8EF\uB8F1", 6, "\uB8FA\uB8FC\uB8FE", 5, "\uB905", 18, "\uB919", 6, "\uB921", 26, "\uB93E\uB93F\uB941\uB942\uB943\uB945", 6, "\uB94D\uB94E\uB950\uB952", 5],
      ["9041", "\uB95A\uB95B\uB95D\uB95E\uB95F\uB961", 6, "\uB96A\uB96C\uB96E", 5, "\uB976\uB977\uB979\uB97A\uB97B\uB97D"],
      ["9061", "\uB97E", 5, "\uB986\uB988\uB98B\uB98C\uB98F", 15],
      ["9081", "\uB99F", 12, "\uB9AE\uB9AF\uB9B1\uB9B2\uB9B3\uB9B5", 6, "\uB9BE\uB9C0\uB9C2", 5, "\uB9CA\uB9CB\uB9CD\uB9D3", 4, "\uB9DA\uB9DC\uB9DF\uB9E0\uB9E2\uB9E6\uB9E7\uB9E9\uB9EA\uB9EB\uB9ED", 6, "\uB9F6\uB9FB", 4, "\uBA02", 5, "\uBA09", 11, "\uBA16", 33, "\uBA3A\uBA3B\uBA3D\uBA3E\uBA3F\uBA41\uBA43\uBA44\uBA45\uBA46"],
      ["9141", "\uBA47\uBA4A\uBA4C\uBA4F\uBA50\uBA51\uBA52\uBA56\uBA57\uBA59\uBA5A\uBA5B\uBA5D", 6, "\uBA66\uBA6A", 5],
      ["9161", "\uBA72\uBA73\uBA75\uBA76\uBA77\uBA79", 9, "\uBA86\uBA88\uBA89\uBA8A\uBA8B\uBA8D", 5],
      ["9181", "\uBA93", 20, "\uBAAA\uBAAD\uBAAE\uBAAF\uBAB1\uBAB3", 4, "\uBABA\uBABC\uBABE", 5, "\uBAC5\uBAC6\uBAC7\uBAC9", 14, "\uBADA", 33, "\uBAFD\uBAFE\uBAFF\uBB01\uBB02\uBB03\uBB05", 7, "\uBB0E\uBB10\uBB12", 5, "\uBB19\uBB1A\uBB1B\uBB1D\uBB1E\uBB1F\uBB21", 6],
      ["9241", "\uBB28\uBB2A\uBB2C", 7, "\uBB37\uBB39\uBB3A\uBB3F", 4, "\uBB46\uBB48\uBB4A\uBB4B\uBB4C\uBB4E\uBB51\uBB52"],
      ["9261", "\uBB53\uBB55\uBB56\uBB57\uBB59", 7, "\uBB62\uBB64", 7, "\uBB6D", 4],
      ["9281", "\uBB72", 21, "\uBB89\uBB8A\uBB8B\uBB8D\uBB8E\uBB8F\uBB91", 18, "\uBBA5\uBBA6\uBBA7\uBBA9\uBBAA\uBBAB\uBBAD", 6, "\uBBB5\uBBB6\uBBB8", 7, "\uBBC1\uBBC2\uBBC3\uBBC5\uBBC6\uBBC7\uBBC9", 6, "\uBBD1\uBBD2\uBBD4", 35, "\uBBFA\uBBFB\uBBFD\uBBFE\uBC01"],
      ["9341", "\uBC03", 4, "\uBC0A\uBC0E\uBC10\uBC12\uBC13\uBC19\uBC1A\uBC20\uBC21\uBC22\uBC23\uBC26\uBC28\uBC2A\uBC2B\uBC2C\uBC2E\uBC2F\uBC32\uBC33\uBC35"],
      ["9361", "\uBC36\uBC37\uBC39", 6, "\uBC42\uBC46\uBC47\uBC48\uBC4A\uBC4B\uBC4E\uBC4F\uBC51", 8],
      ["9381", "\uBC5A\uBC5B\uBC5C\uBC5E", 37, "\uBC86\uBC87\uBC89\uBC8A\uBC8D\uBC8F", 4, "\uBC96\uBC98\uBC9B", 4, "\uBCA2\uBCA3\uBCA5\uBCA6\uBCA9", 6, "\uBCB2\uBCB6", 5, "\uBCBE\uBCBF\uBCC1\uBCC2\uBCC3\uBCC5", 7, "\uBCCE\uBCD2\uBCD3\uBCD4\uBCD6\uBCD7\uBCD9\uBCDA\uBCDB\uBCDD", 22, "\uBCF7\uBCF9\uBCFA\uBCFB\uBCFD"],
      ["9441", "\uBCFE", 5, "\uBD06\uBD08\uBD0A", 5, "\uBD11\uBD12\uBD13\uBD15", 8],
      ["9461", "\uBD1E", 5, "\uBD25", 6, "\uBD2D", 12],
      ["9481", "\uBD3A", 5, "\uBD41", 6, "\uBD4A\uBD4B\uBD4D\uBD4E\uBD4F\uBD51", 6, "\uBD5A", 9, "\uBD65\uBD66\uBD67\uBD69", 22, "\uBD82\uBD83\uBD85\uBD86\uBD8B", 4, "\uBD92\uBD94\uBD96\uBD97\uBD98\uBD9B\uBD9D", 6, "\uBDA5", 10, "\uBDB1", 6, "\uBDB9", 24],
      ["9541", "\uBDD2\uBDD3\uBDD6\uBDD7\uBDD9\uBDDA\uBDDB\uBDDD", 11, "\uBDEA", 5, "\uBDF1"],
      ["9561", "\uBDF2\uBDF3\uBDF5\uBDF6\uBDF7\uBDF9", 6, "\uBE01\uBE02\uBE04\uBE06", 5, "\uBE0E\uBE0F\uBE11\uBE12\uBE13"],
      ["9581", "\uBE15", 6, "\uBE1E\uBE20", 35, "\uBE46\uBE47\uBE49\uBE4A\uBE4B\uBE4D\uBE4F", 4, "\uBE56\uBE58\uBE5C\uBE5D\uBE5E\uBE5F\uBE62\uBE63\uBE65\uBE66\uBE67\uBE69\uBE6B", 4, "\uBE72\uBE76", 4, "\uBE7E\uBE7F\uBE81\uBE82\uBE83\uBE85", 6, "\uBE8E\uBE92", 5, "\uBE9A", 13, "\uBEA9", 14],
      ["9641", "\uBEB8", 23, "\uBED2\uBED3"],
      ["9661", "\uBED5\uBED6\uBED9", 6, "\uBEE1\uBEE2\uBEE6", 5, "\uBEED", 8],
      ["9681", "\uBEF6", 10, "\uBF02", 5, "\uBF0A", 13, "\uBF1A\uBF1E", 33, "\uBF42\uBF43\uBF45\uBF46\uBF47\uBF49", 6, "\uBF52\uBF53\uBF54\uBF56", 44],
      ["9741", "\uBF83", 16, "\uBF95", 8],
      ["9761", "\uBF9E", 17, "\uBFB1", 7],
      ["9781", "\uBFB9", 11, "\uBFC6", 5, "\uBFCE\uBFCF\uBFD1\uBFD2\uBFD3\uBFD5", 6, "\uBFDD\uBFDE\uBFE0\uBFE2", 89, "\uC03D\uC03E\uC03F"],
      ["9841", "\uC040", 16, "\uC052", 5, "\uC059\uC05A\uC05B"],
      ["9861", "\uC05D\uC05E\uC05F\uC061", 6, "\uC06A", 15],
      ["9881", "\uC07A", 21, "\uC092\uC093\uC095\uC096\uC097\uC099", 6, "\uC0A2\uC0A4\uC0A6", 5, "\uC0AE\uC0B1\uC0B2\uC0B7", 4, "\uC0BE\uC0C2\uC0C3\uC0C4\uC0C6\uC0C7\uC0CA\uC0CB\uC0CD\uC0CE\uC0CF\uC0D1", 6, "\uC0DA\uC0DE", 5, "\uC0E6\uC0E7\uC0E9\uC0EA\uC0EB\uC0ED", 6, "\uC0F6\uC0F8\uC0FA", 5, "\uC101\uC102\uC103\uC105\uC106\uC107\uC109", 6, "\uC111\uC112\uC113\uC114\uC116", 5, "\uC121\uC122\uC125\uC128\uC129\uC12A\uC12B\uC12E"],
      ["9941", "\uC132\uC133\uC134\uC135\uC137\uC13A\uC13B\uC13D\uC13E\uC13F\uC141", 6, "\uC14A\uC14E", 5, "\uC156\uC157"],
      ["9961", "\uC159\uC15A\uC15B\uC15D", 6, "\uC166\uC16A", 5, "\uC171\uC172\uC173\uC175\uC176\uC177\uC179\uC17A\uC17B"],
      ["9981", "\uC17C", 8, "\uC186", 5, "\uC18F\uC191\uC192\uC193\uC195\uC197", 4, "\uC19E\uC1A0\uC1A2\uC1A3\uC1A4\uC1A6\uC1A7\uC1AA\uC1AB\uC1AD\uC1AE\uC1AF\uC1B1", 11, "\uC1BE", 5, "\uC1C5\uC1C6\uC1C7\uC1C9\uC1CA\uC1CB\uC1CD", 6, "\uC1D5\uC1D6\uC1D9", 6, "\uC1E1\uC1E2\uC1E3\uC1E5\uC1E6\uC1E7\uC1E9", 6, "\uC1F2\uC1F4", 7, "\uC1FE\uC1FF\uC201\uC202\uC203\uC205", 6, "\uC20E\uC210\uC212", 5, "\uC21A\uC21B\uC21D\uC21E\uC221\uC222\uC223"],
      ["9a41", "\uC224\uC225\uC226\uC227\uC22A\uC22C\uC22E\uC230\uC233\uC235", 16],
      ["9a61", "\uC246\uC247\uC249", 6, "\uC252\uC253\uC255\uC256\uC257\uC259", 6, "\uC261\uC262\uC263\uC264\uC266"],
      ["9a81", "\uC267", 4, "\uC26E\uC26F\uC271\uC272\uC273\uC275", 6, "\uC27E\uC280\uC282", 5, "\uC28A", 5, "\uC291", 6, "\uC299\uC29A\uC29C\uC29E", 5, "\uC2A6\uC2A7\uC2A9\uC2AA\uC2AB\uC2AE", 5, "\uC2B6\uC2B8\uC2BA", 33, "\uC2DE\uC2DF\uC2E1\uC2E2\uC2E5", 5, "\uC2EE\uC2F0\uC2F2\uC2F3\uC2F4\uC2F5\uC2F7\uC2FA\uC2FD\uC2FE\uC2FF\uC301", 6, "\uC30A\uC30B\uC30E\uC30F"],
      ["9b41", "\uC310\uC311\uC312\uC316\uC317\uC319\uC31A\uC31B\uC31D", 6, "\uC326\uC327\uC32A", 8],
      ["9b61", "\uC333", 17, "\uC346", 7],
      ["9b81", "\uC34E", 25, "\uC36A\uC36B\uC36D\uC36E\uC36F\uC371\uC373", 4, "\uC37A\uC37B\uC37E", 5, "\uC385\uC386\uC387\uC389\uC38A\uC38B\uC38D", 50, "\uC3C1", 22, "\uC3DA"],
      ["9c41", "\uC3DB\uC3DD\uC3DE\uC3E1\uC3E3", 4, "\uC3EA\uC3EB\uC3EC\uC3EE", 5, "\uC3F6\uC3F7\uC3F9", 5],
      ["9c61", "\uC3FF", 8, "\uC409", 6, "\uC411", 9],
      ["9c81", "\uC41B", 8, "\uC425", 6, "\uC42D\uC42E\uC42F\uC431\uC432\uC433\uC435", 6, "\uC43E", 9, "\uC449", 26, "\uC466\uC467\uC469\uC46A\uC46B\uC46D", 6, "\uC476\uC477\uC478\uC47A", 5, "\uC481", 18, "\uC495", 6, "\uC49D", 12],
      ["9d41", "\uC4AA", 13, "\uC4B9\uC4BA\uC4BB\uC4BD", 8],
      ["9d61", "\uC4C6", 25],
      ["9d81", "\uC4E0", 8, "\uC4EA", 5, "\uC4F2\uC4F3\uC4F5\uC4F6\uC4F7\uC4F9\uC4FB\uC4FC\uC4FD\uC4FE\uC502", 9, "\uC50D\uC50E\uC50F\uC511\uC512\uC513\uC515", 6, "\uC51D", 10, "\uC52A\uC52B\uC52D\uC52E\uC52F\uC531", 6, "\uC53A\uC53C\uC53E", 5, "\uC546\uC547\uC54B\uC54F\uC550\uC551\uC552\uC556\uC55A\uC55B\uC55C\uC55F\uC562\uC563\uC565\uC566\uC567\uC569", 6, "\uC572\uC576", 5, "\uC57E\uC57F\uC581\uC582\uC583\uC585\uC586\uC588\uC589\uC58A\uC58B\uC58E\uC590\uC592\uC593\uC594"],
      ["9e41", "\uC596\uC599\uC59A\uC59B\uC59D\uC59E\uC59F\uC5A1", 7, "\uC5AA", 9, "\uC5B6"],
      ["9e61", "\uC5B7\uC5BA\uC5BF", 4, "\uC5CB\uC5CD\uC5CF\uC5D2\uC5D3\uC5D5\uC5D6\uC5D7\uC5D9", 6, "\uC5E2\uC5E4\uC5E6\uC5E7"],
      ["9e81", "\uC5E8\uC5E9\uC5EA\uC5EB\uC5EF\uC5F1\uC5F2\uC5F3\uC5F5\uC5F8\uC5F9\uC5FA\uC5FB\uC602\uC603\uC604\uC609\uC60A\uC60B\uC60D\uC60E\uC60F\uC611", 6, "\uC61A\uC61D", 6, "\uC626\uC627\uC629\uC62A\uC62B\uC62F\uC631\uC632\uC636\uC638\uC63A\uC63C\uC63D\uC63E\uC63F\uC642\uC643\uC645\uC646\uC647\uC649", 6, "\uC652\uC656", 5, "\uC65E\uC65F\uC661", 10, "\uC66D\uC66E\uC670\uC672", 5, "\uC67A\uC67B\uC67D\uC67E\uC67F\uC681", 6, "\uC68A\uC68C\uC68E", 5, "\uC696\uC697\uC699\uC69A\uC69B\uC69D", 6, "\uC6A6"],
      ["9f41", "\uC6A8\uC6AA", 5, "\uC6B2\uC6B3\uC6B5\uC6B6\uC6B7\uC6BB", 4, "\uC6C2\uC6C4\uC6C6", 5, "\uC6CE"],
      ["9f61", "\uC6CF\uC6D1\uC6D2\uC6D3\uC6D5", 6, "\uC6DE\uC6DF\uC6E2", 5, "\uC6EA\uC6EB\uC6ED\uC6EE\uC6EF\uC6F1\uC6F2"],
      ["9f81", "\uC6F3", 4, "\uC6FA\uC6FB\uC6FC\uC6FE", 5, "\uC706\uC707\uC709\uC70A\uC70B\uC70D", 6, "\uC716\uC718\uC71A", 5, "\uC722\uC723\uC725\uC726\uC727\uC729", 6, "\uC732\uC734\uC736\uC738\uC739\uC73A\uC73B\uC73E\uC73F\uC741\uC742\uC743\uC745", 4, "\uC74B\uC74E\uC750\uC759\uC75A\uC75B\uC75D\uC75E\uC75F\uC761", 6, "\uC769\uC76A\uC76C", 7, "\uC776\uC777\uC779\uC77A\uC77B\uC77F\uC780\uC781\uC782\uC786\uC78B\uC78C\uC78D\uC78F\uC792\uC793\uC795\uC799\uC79B", 4, "\uC7A2\uC7A7", 4, "\uC7AE\uC7AF\uC7B1\uC7B2\uC7B3\uC7B5\uC7B6\uC7B7"],
      ["a041", "\uC7B8\uC7B9\uC7BA\uC7BB\uC7BE\uC7C2", 5, "\uC7CA\uC7CB\uC7CD\uC7CF\uC7D1", 6, "\uC7D9\uC7DA\uC7DB\uC7DC"],
      ["a061", "\uC7DE", 5, "\uC7E5\uC7E6\uC7E7\uC7E9\uC7EA\uC7EB\uC7ED", 13],
      ["a081", "\uC7FB", 4, "\uC802\uC803\uC805\uC806\uC807\uC809\uC80B", 4, "\uC812\uC814\uC817", 4, "\uC81E\uC81F\uC821\uC822\uC823\uC825", 6, "\uC82E\uC830\uC832", 5, "\uC839\uC83A\uC83B\uC83D\uC83E\uC83F\uC841", 6, "\uC84A\uC84B\uC84E", 5, "\uC855", 26, "\uC872\uC873\uC875\uC876\uC877\uC879\uC87B", 4, "\uC882\uC884\uC888\uC889\uC88A\uC88E", 5, "\uC895", 7, "\uC89E\uC8A0\uC8A2\uC8A3\uC8A4"],
      ["a141", "\uC8A5\uC8A6\uC8A7\uC8A9", 18, "\uC8BE\uC8BF\uC8C0\uC8C1"],
      ["a161", "\uC8C2\uC8C3\uC8C5\uC8C6\uC8C7\uC8C9\uC8CA\uC8CB\uC8CD", 6, "\uC8D6\uC8D8\uC8DA", 5, "\uC8E2\uC8E3\uC8E5"],
      ["a181", "\uC8E6", 14, "\uC8F6", 5, "\uC8FE\uC8FF\uC901\uC902\uC903\uC907", 4, "\uC90E\u3000\u3001\u3002\xB7\u2025\u2026\xA8\u3003\xAD\u2015\u2225\uFF3C\u223C\u2018\u2019\u201C\u201D\u3014\u3015\u3008", 9, "\xB1\xD7\xF7\u2260\u2264\u2265\u221E\u2234\xB0\u2032\u2033\u2103\u212B\uFFE0\uFFE1\uFFE5\u2642\u2640\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\xA7\u203B\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u2192\u2190\u2191\u2193\u2194\u3013\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229\u2227\u2228\uFFE2"],
      ["a241", "\uC910\uC912", 5, "\uC919", 18],
      ["a261", "\uC92D", 6, "\uC935", 18],
      ["a281", "\uC948", 7, "\uC952\uC953\uC955\uC956\uC957\uC959", 6, "\uC962\uC964", 7, "\uC96D\uC96E\uC96F\u21D2\u21D4\u2200\u2203\xB4\uFF5E\u02C7\u02D8\u02DD\u02DA\u02D9\xB8\u02DB\xA1\xBF\u02D0\u222E\u2211\u220F\xA4\u2109\u2030\u25C1\u25C0\u25B7\u25B6\u2664\u2660\u2661\u2665\u2667\u2663\u2299\u25C8\u25A3\u25D0\u25D1\u2592\u25A4\u25A5\u25A8\u25A7\u25A6\u25A9\u2668\u260F\u260E\u261C\u261E\xB6\u2020\u2021\u2195\u2197\u2199\u2196\u2198\u266D\u2669\u266A\u266C\u327F\u321C\u2116\u33C7\u2122\u33C2\u33D8\u2121\u20AC\xAE"],
      ["a341", "\uC971\uC972\uC973\uC975", 6, "\uC97D", 10, "\uC98A\uC98B\uC98D\uC98E\uC98F"],
      ["a361", "\uC991", 6, "\uC99A\uC99C\uC99E", 16],
      ["a381", "\uC9AF", 16, "\uC9C2\uC9C3\uC9C5\uC9C6\uC9C9\uC9CB", 4, "\uC9D2\uC9D4\uC9D7\uC9D8\uC9DB\uFF01", 58, "\uFFE6\uFF3D", 32, "\uFFE3"],
      ["a441", "\uC9DE\uC9DF\uC9E1\uC9E3\uC9E5\uC9E6\uC9E8\uC9E9\uC9EA\uC9EB\uC9EE\uC9F2", 5, "\uC9FA\uC9FB\uC9FD\uC9FE\uC9FF\uCA01\uCA02\uCA03\uCA04"],
      ["a461", "\uCA05\uCA06\uCA07\uCA0A\uCA0E", 5, "\uCA15\uCA16\uCA17\uCA19", 12],
      ["a481", "\uCA26\uCA27\uCA28\uCA2A", 28, "\u3131", 93],
      ["a541", "\uCA47", 4, "\uCA4E\uCA4F\uCA51\uCA52\uCA53\uCA55", 6, "\uCA5E\uCA62", 5, "\uCA69\uCA6A"],
      ["a561", "\uCA6B", 17, "\uCA7E", 5, "\uCA85\uCA86"],
      ["a581", "\uCA87", 16, "\uCA99", 14, "\u2170", 9],
      ["a5b0", "\u2160", 9],
      ["a5c1", "\u0391", 16, "\u03A3", 6],
      ["a5e1", "\u03B1", 16, "\u03C3", 6],
      ["a641", "\uCAA8", 19, "\uCABE\uCABF\uCAC1\uCAC2\uCAC3\uCAC5"],
      ["a661", "\uCAC6", 5, "\uCACE\uCAD0\uCAD2\uCAD4\uCAD5\uCAD6\uCAD7\uCADA", 5, "\uCAE1", 6],
      ["a681", "\uCAE8\uCAE9\uCAEA\uCAEB\uCAED", 6, "\uCAF5", 18, "\uCB09\uCB0A\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542\u2512\u2511\u251A\u2519\u2516\u2515\u250E\u250D\u251E\u251F\u2521\u2522\u2526\u2527\u2529\u252A\u252D\u252E\u2531\u2532\u2535\u2536\u2539\u253A\u253D\u253E\u2540\u2541\u2543", 7],
      ["a741", "\uCB0B", 4, "\uCB11\uCB12\uCB13\uCB15\uCB16\uCB17\uCB19", 6, "\uCB22", 7],
      ["a761", "\uCB2A", 22, "\uCB42\uCB43\uCB44"],
      ["a781", "\uCB45\uCB46\uCB47\uCB4A\uCB4B\uCB4D\uCB4E\uCB4F\uCB51", 6, "\uCB5A\uCB5B\uCB5C\uCB5E", 5, "\uCB65", 7, "\u3395\u3396\u3397\u2113\u3398\u33C4\u33A3\u33A4\u33A5\u33A6\u3399", 9, "\u33CA\u338D\u338E\u338F\u33CF\u3388\u3389\u33C8\u33A7\u33A8\u33B0", 9, "\u3380", 4, "\u33BA", 5, "\u3390", 4, "\u2126\u33C0\u33C1\u338A\u338B\u338C\u33D6\u33C5\u33AD\u33AE\u33AF\u33DB\u33A9\u33AA\u33AB\u33AC\u33DD\u33D0\u33D3\u33C3\u33C9\u33DC\u33C6"],
      ["a841", "\uCB6D", 10, "\uCB7A", 14],
      ["a861", "\uCB89", 18, "\uCB9D", 6],
      ["a881", "\uCBA4", 19, "\uCBB9", 11, "\xC6\xD0\xAA\u0126"],
      ["a8a6", "\u0132"],
      ["a8a8", "\u013F\u0141\xD8\u0152\xBA\xDE\u0166\u014A"],
      ["a8b1", "\u3260", 27, "\u24D0", 25, "\u2460", 14, "\xBD\u2153\u2154\xBC\xBE\u215B\u215C\u215D\u215E"],
      ["a941", "\uCBC5", 14, "\uCBD5", 10],
      ["a961", "\uCBE0\uCBE1\uCBE2\uCBE3\uCBE5\uCBE6\uCBE8\uCBEA", 18],
      ["a981", "\uCBFD", 14, "\uCC0E\uCC0F\uCC11\uCC12\uCC13\uCC15", 6, "\uCC1E\uCC1F\uCC20\uCC23\uCC24\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0140\u0142\xF8\u0153\xDF\xFE\u0167\u014B\u0149\u3200", 27, "\u249C", 25, "\u2474", 14, "\xB9\xB2\xB3\u2074\u207F\u2081\u2082\u2083\u2084"],
      ["aa41", "\uCC25\uCC26\uCC2A\uCC2B\uCC2D\uCC2F\uCC31", 6, "\uCC3A\uCC3F", 4, "\uCC46\uCC47\uCC49\uCC4A\uCC4B\uCC4D\uCC4E"],
      ["aa61", "\uCC4F", 4, "\uCC56\uCC5A", 5, "\uCC61\uCC62\uCC63\uCC65\uCC67\uCC69", 6, "\uCC71\uCC72"],
      ["aa81", "\uCC73\uCC74\uCC76", 29, "\u3041", 82],
      ["ab41", "\uCC94\uCC95\uCC96\uCC97\uCC9A\uCC9B\uCC9D\uCC9E\uCC9F\uCCA1", 6, "\uCCAA\uCCAE", 5, "\uCCB6\uCCB7\uCCB9"],
      ["ab61", "\uCCBA\uCCBB\uCCBD", 6, "\uCCC6\uCCC8\uCCCA", 5, "\uCCD1\uCCD2\uCCD3\uCCD5", 5],
      ["ab81", "\uCCDB", 8, "\uCCE5", 6, "\uCCED\uCCEE\uCCEF\uCCF1", 12, "\u30A1", 85],
      ["ac41", "\uCCFE\uCCFF\uCD00\uCD02", 5, "\uCD0A\uCD0B\uCD0D\uCD0E\uCD0F\uCD11", 6, "\uCD1A\uCD1C\uCD1E\uCD1F\uCD20"],
      ["ac61", "\uCD21\uCD22\uCD23\uCD25\uCD26\uCD27\uCD29\uCD2A\uCD2B\uCD2D", 11, "\uCD3A", 4],
      ["ac81", "\uCD3F", 28, "\uCD5D\uCD5E\uCD5F\u0410", 5, "\u0401\u0416", 25],
      ["acd1", "\u0430", 5, "\u0451\u0436", 25],
      ["ad41", "\uCD61\uCD62\uCD63\uCD65", 6, "\uCD6E\uCD70\uCD72", 5, "\uCD79", 7],
      ["ad61", "\uCD81", 6, "\uCD89", 10, "\uCD96\uCD97\uCD99\uCD9A\uCD9B\uCD9D\uCD9E\uCD9F"],
      ["ad81", "\uCDA0\uCDA1\uCDA2\uCDA3\uCDA6\uCDA8\uCDAA", 5, "\uCDB1", 18, "\uCDC5"],
      ["ae41", "\uCDC6", 5, "\uCDCD\uCDCE\uCDCF\uCDD1", 16],
      ["ae61", "\uCDE2", 5, "\uCDE9\uCDEA\uCDEB\uCDED\uCDEE\uCDEF\uCDF1", 6, "\uCDFA\uCDFC\uCDFE", 4],
      ["ae81", "\uCE03\uCE05\uCE06\uCE07\uCE09\uCE0A\uCE0B\uCE0D", 6, "\uCE15\uCE16\uCE17\uCE18\uCE1A", 5, "\uCE22\uCE23\uCE25\uCE26\uCE27\uCE29\uCE2A\uCE2B"],
      ["af41", "\uCE2C\uCE2D\uCE2E\uCE2F\uCE32\uCE34\uCE36", 19],
      ["af61", "\uCE4A", 13, "\uCE5A\uCE5B\uCE5D\uCE5E\uCE62", 5, "\uCE6A\uCE6C"],
      ["af81", "\uCE6E", 5, "\uCE76\uCE77\uCE79\uCE7A\uCE7B\uCE7D", 6, "\uCE86\uCE88\uCE8A", 5, "\uCE92\uCE93\uCE95\uCE96\uCE97\uCE99"],
      ["b041", "\uCE9A", 5, "\uCEA2\uCEA6", 5, "\uCEAE", 12],
      ["b061", "\uCEBB", 5, "\uCEC2", 19],
      ["b081", "\uCED6", 13, "\uCEE6\uCEE7\uCEE9\uCEEA\uCEED", 6, "\uCEF6\uCEFA", 5, "\uAC00\uAC01\uAC04\uAC07\uAC08\uAC09\uAC0A\uAC10", 7, "\uAC19", 4, "\uAC20\uAC24\uAC2C\uAC2D\uAC2F\uAC30\uAC31\uAC38\uAC39\uAC3C\uAC40\uAC4B\uAC4D\uAC54\uAC58\uAC5C\uAC70\uAC71\uAC74\uAC77\uAC78\uAC7A\uAC80\uAC81\uAC83\uAC84\uAC85\uAC86\uAC89\uAC8A\uAC8B\uAC8C\uAC90\uAC94\uAC9C\uAC9D\uAC9F\uACA0\uACA1\uACA8\uACA9\uACAA\uACAC\uACAF\uACB0\uACB8\uACB9\uACBB\uACBC\uACBD\uACC1\uACC4\uACC8\uACCC\uACD5\uACD7\uACE0\uACE1\uACE4\uACE7\uACE8\uACEA\uACEC\uACEF\uACF0\uACF1\uACF3\uACF5\uACF6\uACFC\uACFD\uAD00\uAD04\uAD06"],
      ["b141", "\uCF02\uCF03\uCF05\uCF06\uCF07\uCF09", 6, "\uCF12\uCF14\uCF16", 5, "\uCF1D\uCF1E\uCF1F\uCF21\uCF22\uCF23"],
      ["b161", "\uCF25", 6, "\uCF2E\uCF32", 5, "\uCF39", 11],
      ["b181", "\uCF45", 14, "\uCF56\uCF57\uCF59\uCF5A\uCF5B\uCF5D", 6, "\uCF66\uCF68\uCF6A\uCF6B\uCF6C\uAD0C\uAD0D\uAD0F\uAD11\uAD18\uAD1C\uAD20\uAD29\uAD2C\uAD2D\uAD34\uAD35\uAD38\uAD3C\uAD44\uAD45\uAD47\uAD49\uAD50\uAD54\uAD58\uAD61\uAD63\uAD6C\uAD6D\uAD70\uAD73\uAD74\uAD75\uAD76\uAD7B\uAD7C\uAD7D\uAD7F\uAD81\uAD82\uAD88\uAD89\uAD8C\uAD90\uAD9C\uAD9D\uADA4\uADB7\uADC0\uADC1\uADC4\uADC8\uADD0\uADD1\uADD3\uADDC\uADE0\uADE4\uADF8\uADF9\uADFC\uADFF\uAE00\uAE01\uAE08\uAE09\uAE0B\uAE0D\uAE14\uAE30\uAE31\uAE34\uAE37\uAE38\uAE3A\uAE40\uAE41\uAE43\uAE45\uAE46\uAE4A\uAE4C\uAE4D\uAE4E\uAE50\uAE54\uAE56\uAE5C\uAE5D\uAE5F\uAE60\uAE61\uAE65\uAE68\uAE69\uAE6C\uAE70\uAE78"],
      ["b241", "\uCF6D\uCF6E\uCF6F\uCF72\uCF73\uCF75\uCF76\uCF77\uCF79", 6, "\uCF81\uCF82\uCF83\uCF84\uCF86", 5, "\uCF8D"],
      ["b261", "\uCF8E", 18, "\uCFA2", 5, "\uCFA9"],
      ["b281", "\uCFAA", 5, "\uCFB1", 18, "\uCFC5", 6, "\uAE79\uAE7B\uAE7C\uAE7D\uAE84\uAE85\uAE8C\uAEBC\uAEBD\uAEBE\uAEC0\uAEC4\uAECC\uAECD\uAECF\uAED0\uAED1\uAED8\uAED9\uAEDC\uAEE8\uAEEB\uAEED\uAEF4\uAEF8\uAEFC\uAF07\uAF08\uAF0D\uAF10\uAF2C\uAF2D\uAF30\uAF32\uAF34\uAF3C\uAF3D\uAF3F\uAF41\uAF42\uAF43\uAF48\uAF49\uAF50\uAF5C\uAF5D\uAF64\uAF65\uAF79\uAF80\uAF84\uAF88\uAF90\uAF91\uAF95\uAF9C\uAFB8\uAFB9\uAFBC\uAFC0\uAFC7\uAFC8\uAFC9\uAFCB\uAFCD\uAFCE\uAFD4\uAFDC\uAFE8\uAFE9\uAFF0\uAFF1\uAFF4\uAFF8\uB000\uB001\uB004\uB00C\uB010\uB014\uB01C\uB01D\uB028\uB044\uB045\uB048\uB04A\uB04C\uB04E\uB053\uB054\uB055\uB057\uB059"],
      ["b341", "\uCFCC", 19, "\uCFE2\uCFE3\uCFE5\uCFE6\uCFE7\uCFE9"],
      ["b361", "\uCFEA", 5, "\uCFF2\uCFF4\uCFF6", 5, "\uCFFD\uCFFE\uCFFF\uD001\uD002\uD003\uD005", 5],
      ["b381", "\uD00B", 5, "\uD012", 5, "\uD019", 19, "\uB05D\uB07C\uB07D\uB080\uB084\uB08C\uB08D\uB08F\uB091\uB098\uB099\uB09A\uB09C\uB09F\uB0A0\uB0A1\uB0A2\uB0A8\uB0A9\uB0AB", 4, "\uB0B1\uB0B3\uB0B4\uB0B5\uB0B8\uB0BC\uB0C4\uB0C5\uB0C7\uB0C8\uB0C9\uB0D0\uB0D1\uB0D4\uB0D8\uB0E0\uB0E5\uB108\uB109\uB10B\uB10C\uB110\uB112\uB113\uB118\uB119\uB11B\uB11C\uB11D\uB123\uB124\uB125\uB128\uB12C\uB134\uB135\uB137\uB138\uB139\uB140\uB141\uB144\uB148\uB150\uB151\uB154\uB155\uB158\uB15C\uB160\uB178\uB179\uB17C\uB180\uB182\uB188\uB189\uB18B\uB18D\uB192\uB193\uB194\uB198\uB19C\uB1A8\uB1CC\uB1D0\uB1D4\uB1DC\uB1DD"],
      ["b441", "\uD02E", 5, "\uD036\uD037\uD039\uD03A\uD03B\uD03D", 6, "\uD046\uD048\uD04A", 5],
      ["b461", "\uD051\uD052\uD053\uD055\uD056\uD057\uD059", 6, "\uD061", 10, "\uD06E\uD06F"],
      ["b481", "\uD071\uD072\uD073\uD075", 6, "\uD07E\uD07F\uD080\uD082", 18, "\uB1DF\uB1E8\uB1E9\uB1EC\uB1F0\uB1F9\uB1FB\uB1FD\uB204\uB205\uB208\uB20B\uB20C\uB214\uB215\uB217\uB219\uB220\uB234\uB23C\uB258\uB25C\uB260\uB268\uB269\uB274\uB275\uB27C\uB284\uB285\uB289\uB290\uB291\uB294\uB298\uB299\uB29A\uB2A0\uB2A1\uB2A3\uB2A5\uB2A6\uB2AA\uB2AC\uB2B0\uB2B4\uB2C8\uB2C9\uB2CC\uB2D0\uB2D2\uB2D8\uB2D9\uB2DB\uB2DD\uB2E2\uB2E4\uB2E5\uB2E6\uB2E8\uB2EB", 4, "\uB2F3\uB2F4\uB2F5\uB2F7", 4, "\uB2FF\uB300\uB301\uB304\uB308\uB310\uB311\uB313\uB314\uB315\uB31C\uB354\uB355\uB356\uB358\uB35B\uB35C\uB35E\uB35F\uB364\uB365"],
      ["b541", "\uD095", 14, "\uD0A6\uD0A7\uD0A9\uD0AA\uD0AB\uD0AD", 5],
      ["b561", "\uD0B3\uD0B6\uD0B8\uD0BA", 5, "\uD0C2\uD0C3\uD0C5\uD0C6\uD0C7\uD0CA", 5, "\uD0D2\uD0D6", 4],
      ["b581", "\uD0DB\uD0DE\uD0DF\uD0E1\uD0E2\uD0E3\uD0E5", 6, "\uD0EE\uD0F2", 5, "\uD0F9", 11, "\uB367\uB369\uB36B\uB36E\uB370\uB371\uB374\uB378\uB380\uB381\uB383\uB384\uB385\uB38C\uB390\uB394\uB3A0\uB3A1\uB3A8\uB3AC\uB3C4\uB3C5\uB3C8\uB3CB\uB3CC\uB3CE\uB3D0\uB3D4\uB3D5\uB3D7\uB3D9\uB3DB\uB3DD\uB3E0\uB3E4\uB3E8\uB3FC\uB410\uB418\uB41C\uB420\uB428\uB429\uB42B\uB434\uB450\uB451\uB454\uB458\uB460\uB461\uB463\uB465\uB46C\uB480\uB488\uB49D\uB4A4\uB4A8\uB4AC\uB4B5\uB4B7\uB4B9\uB4C0\uB4C4\uB4C8\uB4D0\uB4D5\uB4DC\uB4DD\uB4E0\uB4E3\uB4E4\uB4E6\uB4EC\uB4ED\uB4EF\uB4F1\uB4F8\uB514\uB515\uB518\uB51B\uB51C\uB524\uB525\uB527\uB528\uB529\uB52A\uB530\uB531\uB534\uB538"],
      ["b641", "\uD105", 7, "\uD10E", 17],
      ["b661", "\uD120", 15, "\uD132\uD133\uD135\uD136\uD137\uD139\uD13B\uD13C\uD13D\uD13E"],
      ["b681", "\uD13F\uD142\uD146", 5, "\uD14E\uD14F\uD151\uD152\uD153\uD155", 6, "\uD15E\uD160\uD162", 5, "\uD169\uD16A\uD16B\uD16D\uB540\uB541\uB543\uB544\uB545\uB54B\uB54C\uB54D\uB550\uB554\uB55C\uB55D\uB55F\uB560\uB561\uB5A0\uB5A1\uB5A4\uB5A8\uB5AA\uB5AB\uB5B0\uB5B1\uB5B3\uB5B4\uB5B5\uB5BB\uB5BC\uB5BD\uB5C0\uB5C4\uB5CC\uB5CD\uB5CF\uB5D0\uB5D1\uB5D8\uB5EC\uB610\uB611\uB614\uB618\uB625\uB62C\uB634\uB648\uB664\uB668\uB69C\uB69D\uB6A0\uB6A4\uB6AB\uB6AC\uB6B1\uB6D4\uB6F0\uB6F4\uB6F8\uB700\uB701\uB705\uB728\uB729\uB72C\uB72F\uB730\uB738\uB739\uB73B\uB744\uB748\uB74C\uB754\uB755\uB760\uB764\uB768\uB770\uB771\uB773\uB775\uB77C\uB77D\uB780\uB784\uB78C\uB78D\uB78F\uB790\uB791\uB792\uB796\uB797"],
      ["b741", "\uD16E", 13, "\uD17D", 6, "\uD185\uD186\uD187\uD189\uD18A"],
      ["b761", "\uD18B", 20, "\uD1A2\uD1A3\uD1A5\uD1A6\uD1A7"],
      ["b781", "\uD1A9", 6, "\uD1B2\uD1B4\uD1B6\uD1B7\uD1B8\uD1B9\uD1BB\uD1BD\uD1BE\uD1BF\uD1C1", 14, "\uB798\uB799\uB79C\uB7A0\uB7A8\uB7A9\uB7AB\uB7AC\uB7AD\uB7B4\uB7B5\uB7B8\uB7C7\uB7C9\uB7EC\uB7ED\uB7F0\uB7F4\uB7FC\uB7FD\uB7FF\uB800\uB801\uB807\uB808\uB809\uB80C\uB810\uB818\uB819\uB81B\uB81D\uB824\uB825\uB828\uB82C\uB834\uB835\uB837\uB838\uB839\uB840\uB844\uB851\uB853\uB85C\uB85D\uB860\uB864\uB86C\uB86D\uB86F\uB871\uB878\uB87C\uB88D\uB8A8\uB8B0\uB8B4\uB8B8\uB8C0\uB8C1\uB8C3\uB8C5\uB8CC\uB8D0\uB8D4\uB8DD\uB8DF\uB8E1\uB8E8\uB8E9\uB8EC\uB8F0\uB8F8\uB8F9\uB8FB\uB8FD\uB904\uB918\uB920\uB93C\uB93D\uB940\uB944\uB94C\uB94F\uB951\uB958\uB959\uB95C\uB960\uB968\uB969"],
      ["b841", "\uD1D0", 7, "\uD1D9", 17],
      ["b861", "\uD1EB", 8, "\uD1F5\uD1F6\uD1F7\uD1F9", 13],
      ["b881", "\uD208\uD20A", 5, "\uD211", 24, "\uB96B\uB96D\uB974\uB975\uB978\uB97C\uB984\uB985\uB987\uB989\uB98A\uB98D\uB98E\uB9AC\uB9AD\uB9B0\uB9B4\uB9BC\uB9BD\uB9BF\uB9C1\uB9C8\uB9C9\uB9CC\uB9CE", 4, "\uB9D8\uB9D9\uB9DB\uB9DD\uB9DE\uB9E1\uB9E3\uB9E4\uB9E5\uB9E8\uB9EC\uB9F4\uB9F5\uB9F7\uB9F8\uB9F9\uB9FA\uBA00\uBA01\uBA08\uBA15\uBA38\uBA39\uBA3C\uBA40\uBA42\uBA48\uBA49\uBA4B\uBA4D\uBA4E\uBA53\uBA54\uBA55\uBA58\uBA5C\uBA64\uBA65\uBA67\uBA68\uBA69\uBA70\uBA71\uBA74\uBA78\uBA83\uBA84\uBA85\uBA87\uBA8C\uBAA8\uBAA9\uBAAB\uBAAC\uBAB0\uBAB2\uBAB8\uBAB9\uBABB\uBABD\uBAC4\uBAC8\uBAD8\uBAD9\uBAFC"],
      ["b941", "\uD22A\uD22B\uD22E\uD22F\uD231\uD232\uD233\uD235", 6, "\uD23E\uD240\uD242", 5, "\uD249\uD24A\uD24B\uD24C"],
      ["b961", "\uD24D", 14, "\uD25D", 6, "\uD265\uD266\uD267\uD268"],
      ["b981", "\uD269", 22, "\uD282\uD283\uD285\uD286\uD287\uD289\uD28A\uD28B\uD28C\uBB00\uBB04\uBB0D\uBB0F\uBB11\uBB18\uBB1C\uBB20\uBB29\uBB2B\uBB34\uBB35\uBB36\uBB38\uBB3B\uBB3C\uBB3D\uBB3E\uBB44\uBB45\uBB47\uBB49\uBB4D\uBB4F\uBB50\uBB54\uBB58\uBB61\uBB63\uBB6C\uBB88\uBB8C\uBB90\uBBA4\uBBA8\uBBAC\uBBB4\uBBB7\uBBC0\uBBC4\uBBC8\uBBD0\uBBD3\uBBF8\uBBF9\uBBFC\uBBFF\uBC00\uBC02\uBC08\uBC09\uBC0B\uBC0C\uBC0D\uBC0F\uBC11\uBC14", 4, "\uBC1B", 4, "\uBC24\uBC25\uBC27\uBC29\uBC2D\uBC30\uBC31\uBC34\uBC38\uBC40\uBC41\uBC43\uBC44\uBC45\uBC49\uBC4C\uBC4D\uBC50\uBC5D\uBC84\uBC85\uBC88\uBC8B\uBC8C\uBC8E\uBC94\uBC95\uBC97"],
      ["ba41", "\uD28D\uD28E\uD28F\uD292\uD293\uD294\uD296", 5, "\uD29D\uD29E\uD29F\uD2A1\uD2A2\uD2A3\uD2A5", 6, "\uD2AD"],
      ["ba61", "\uD2AE\uD2AF\uD2B0\uD2B2", 5, "\uD2BA\uD2BB\uD2BD\uD2BE\uD2C1\uD2C3", 4, "\uD2CA\uD2CC", 5],
      ["ba81", "\uD2D2\uD2D3\uD2D5\uD2D6\uD2D7\uD2D9\uD2DA\uD2DB\uD2DD", 6, "\uD2E6", 9, "\uD2F2\uD2F3\uD2F5\uD2F6\uD2F7\uD2F9\uD2FA\uBC99\uBC9A\uBCA0\uBCA1\uBCA4\uBCA7\uBCA8\uBCB0\uBCB1\uBCB3\uBCB4\uBCB5\uBCBC\uBCBD\uBCC0\uBCC4\uBCCD\uBCCF\uBCD0\uBCD1\uBCD5\uBCD8\uBCDC\uBCF4\uBCF5\uBCF6\uBCF8\uBCFC\uBD04\uBD05\uBD07\uBD09\uBD10\uBD14\uBD24\uBD2C\uBD40\uBD48\uBD49\uBD4C\uBD50\uBD58\uBD59\uBD64\uBD68\uBD80\uBD81\uBD84\uBD87\uBD88\uBD89\uBD8A\uBD90\uBD91\uBD93\uBD95\uBD99\uBD9A\uBD9C\uBDA4\uBDB0\uBDB8\uBDD4\uBDD5\uBDD8\uBDDC\uBDE9\uBDF0\uBDF4\uBDF8\uBE00\uBE03\uBE05\uBE0C\uBE0D\uBE10\uBE14\uBE1C\uBE1D\uBE1F\uBE44\uBE45\uBE48\uBE4C\uBE4E\uBE54\uBE55\uBE57\uBE59\uBE5A\uBE5B\uBE60\uBE61\uBE64"],
      ["bb41", "\uD2FB", 4, "\uD302\uD304\uD306", 5, "\uD30F\uD311\uD312\uD313\uD315\uD317", 4, "\uD31E\uD322\uD323"],
      ["bb61", "\uD324\uD326\uD327\uD32A\uD32B\uD32D\uD32E\uD32F\uD331", 6, "\uD33A\uD33E", 5, "\uD346\uD347\uD348\uD349"],
      ["bb81", "\uD34A", 31, "\uBE68\uBE6A\uBE70\uBE71\uBE73\uBE74\uBE75\uBE7B\uBE7C\uBE7D\uBE80\uBE84\uBE8C\uBE8D\uBE8F\uBE90\uBE91\uBE98\uBE99\uBEA8\uBED0\uBED1\uBED4\uBED7\uBED8\uBEE0\uBEE3\uBEE4\uBEE5\uBEEC\uBF01\uBF08\uBF09\uBF18\uBF19\uBF1B\uBF1C\uBF1D\uBF40\uBF41\uBF44\uBF48\uBF50\uBF51\uBF55\uBF94\uBFB0\uBFC5\uBFCC\uBFCD\uBFD0\uBFD4\uBFDC\uBFDF\uBFE1\uC03C\uC051\uC058\uC05C\uC060\uC068\uC069\uC090\uC091\uC094\uC098\uC0A0\uC0A1\uC0A3\uC0A5\uC0AC\uC0AD\uC0AF\uC0B0\uC0B3\uC0B4\uC0B5\uC0B6\uC0BC\uC0BD\uC0BF\uC0C0\uC0C1\uC0C5\uC0C8\uC0C9\uC0CC\uC0D0\uC0D8\uC0D9\uC0DB\uC0DC\uC0DD\uC0E4"],
      ["bc41", "\uD36A", 17, "\uD37E\uD37F\uD381\uD382\uD383\uD385\uD386\uD387"],
      ["bc61", "\uD388\uD389\uD38A\uD38B\uD38E\uD392", 5, "\uD39A\uD39B\uD39D\uD39E\uD39F\uD3A1", 6, "\uD3AA\uD3AC\uD3AE"],
      ["bc81", "\uD3AF", 4, "\uD3B5\uD3B6\uD3B7\uD3B9\uD3BA\uD3BB\uD3BD", 6, "\uD3C6\uD3C7\uD3CA", 5, "\uD3D1", 5, "\uC0E5\uC0E8\uC0EC\uC0F4\uC0F5\uC0F7\uC0F9\uC100\uC104\uC108\uC110\uC115\uC11C", 4, "\uC123\uC124\uC126\uC127\uC12C\uC12D\uC12F\uC130\uC131\uC136\uC138\uC139\uC13C\uC140\uC148\uC149\uC14B\uC14C\uC14D\uC154\uC155\uC158\uC15C\uC164\uC165\uC167\uC168\uC169\uC170\uC174\uC178\uC185\uC18C\uC18D\uC18E\uC190\uC194\uC196\uC19C\uC19D\uC19F\uC1A1\uC1A5\uC1A8\uC1A9\uC1AC\uC1B0\uC1BD\uC1C4\uC1C8\uC1CC\uC1D4\uC1D7\uC1D8\uC1E0\uC1E4\uC1E8\uC1F0\uC1F1\uC1F3\uC1FC\uC1FD\uC200\uC204\uC20C\uC20D\uC20F\uC211\uC218\uC219\uC21C\uC21F\uC220\uC228\uC229\uC22B\uC22D"],
      ["bd41", "\uD3D7\uD3D9", 7, "\uD3E2\uD3E4", 7, "\uD3EE\uD3EF\uD3F1\uD3F2\uD3F3\uD3F5\uD3F6\uD3F7"],
      ["bd61", "\uD3F8\uD3F9\uD3FA\uD3FB\uD3FE\uD400\uD402", 5, "\uD409", 13],
      ["bd81", "\uD417", 5, "\uD41E", 25, "\uC22F\uC231\uC232\uC234\uC248\uC250\uC251\uC254\uC258\uC260\uC265\uC26C\uC26D\uC270\uC274\uC27C\uC27D\uC27F\uC281\uC288\uC289\uC290\uC298\uC29B\uC29D\uC2A4\uC2A5\uC2A8\uC2AC\uC2AD\uC2B4\uC2B5\uC2B7\uC2B9\uC2DC\uC2DD\uC2E0\uC2E3\uC2E4\uC2EB\uC2EC\uC2ED\uC2EF\uC2F1\uC2F6\uC2F8\uC2F9\uC2FB\uC2FC\uC300\uC308\uC309\uC30C\uC30D\uC313\uC314\uC315\uC318\uC31C\uC324\uC325\uC328\uC329\uC345\uC368\uC369\uC36C\uC370\uC372\uC378\uC379\uC37C\uC37D\uC384\uC388\uC38C\uC3C0\uC3D8\uC3D9\uC3DC\uC3DF\uC3E0\uC3E2\uC3E8\uC3E9\uC3ED\uC3F4\uC3F5\uC3F8\uC408\uC410\uC424\uC42C\uC430"],
      ["be41", "\uD438", 7, "\uD441\uD442\uD443\uD445", 14],
      ["be61", "\uD454", 7, "\uD45D\uD45E\uD45F\uD461\uD462\uD463\uD465", 7, "\uD46E\uD470\uD471\uD472"],
      ["be81", "\uD473", 4, "\uD47A\uD47B\uD47D\uD47E\uD481\uD483", 4, "\uD48A\uD48C\uD48E", 5, "\uD495", 8, "\uC434\uC43C\uC43D\uC448\uC464\uC465\uC468\uC46C\uC474\uC475\uC479\uC480\uC494\uC49C\uC4B8\uC4BC\uC4E9\uC4F0\uC4F1\uC4F4\uC4F8\uC4FA\uC4FF\uC500\uC501\uC50C\uC510\uC514\uC51C\uC528\uC529\uC52C\uC530\uC538\uC539\uC53B\uC53D\uC544\uC545\uC548\uC549\uC54A\uC54C\uC54D\uC54E\uC553\uC554\uC555\uC557\uC558\uC559\uC55D\uC55E\uC560\uC561\uC564\uC568\uC570\uC571\uC573\uC574\uC575\uC57C\uC57D\uC580\uC584\uC587\uC58C\uC58D\uC58F\uC591\uC595\uC597\uC598\uC59C\uC5A0\uC5A9\uC5B4\uC5B5\uC5B8\uC5B9\uC5BB\uC5BC\uC5BD\uC5BE\uC5C4", 6, "\uC5CC\uC5CE"],
      ["bf41", "\uD49E", 10, "\uD4AA", 14],
      ["bf61", "\uD4B9", 18, "\uD4CD\uD4CE\uD4CF\uD4D1\uD4D2\uD4D3\uD4D5"],
      ["bf81", "\uD4D6", 5, "\uD4DD\uD4DE\uD4E0", 7, "\uD4E9\uD4EA\uD4EB\uD4ED\uD4EE\uD4EF\uD4F1", 6, "\uD4F9\uD4FA\uD4FC\uC5D0\uC5D1\uC5D4\uC5D8\uC5E0\uC5E1\uC5E3\uC5E5\uC5EC\uC5ED\uC5EE\uC5F0\uC5F4\uC5F6\uC5F7\uC5FC", 5, "\uC605\uC606\uC607\uC608\uC60C\uC610\uC618\uC619\uC61B\uC61C\uC624\uC625\uC628\uC62C\uC62D\uC62E\uC630\uC633\uC634\uC635\uC637\uC639\uC63B\uC640\uC641\uC644\uC648\uC650\uC651\uC653\uC654\uC655\uC65C\uC65D\uC660\uC66C\uC66F\uC671\uC678\uC679\uC67C\uC680\uC688\uC689\uC68B\uC68D\uC694\uC695\uC698\uC69C\uC6A4\uC6A5\uC6A7\uC6A9\uC6B0\uC6B1\uC6B4\uC6B8\uC6B9\uC6BA\uC6C0\uC6C1\uC6C3\uC6C5\uC6CC\uC6CD\uC6D0\uC6D4\uC6DC\uC6DD\uC6E0\uC6E1\uC6E8"],
      ["c041", "\uD4FE", 5, "\uD505\uD506\uD507\uD509\uD50A\uD50B\uD50D", 6, "\uD516\uD518", 5],
      ["c061", "\uD51E", 25],
      ["c081", "\uD538\uD539\uD53A\uD53B\uD53E\uD53F\uD541\uD542\uD543\uD545", 6, "\uD54E\uD550\uD552", 5, "\uD55A\uD55B\uD55D\uD55E\uD55F\uD561\uD562\uD563\uC6E9\uC6EC\uC6F0\uC6F8\uC6F9\uC6FD\uC704\uC705\uC708\uC70C\uC714\uC715\uC717\uC719\uC720\uC721\uC724\uC728\uC730\uC731\uC733\uC735\uC737\uC73C\uC73D\uC740\uC744\uC74A\uC74C\uC74D\uC74F\uC751", 7, "\uC75C\uC760\uC768\uC76B\uC774\uC775\uC778\uC77C\uC77D\uC77E\uC783\uC784\uC785\uC787\uC788\uC789\uC78A\uC78E\uC790\uC791\uC794\uC796\uC797\uC798\uC79A\uC7A0\uC7A1\uC7A3\uC7A4\uC7A5\uC7A6\uC7AC\uC7AD\uC7B0\uC7B4\uC7BC\uC7BD\uC7BF\uC7C0\uC7C1\uC7C8\uC7C9\uC7CC\uC7CE\uC7D0\uC7D8\uC7DD\uC7E4\uC7E8\uC7EC\uC800\uC801\uC804\uC808\uC80A"],
      ["c141", "\uD564\uD566\uD567\uD56A\uD56C\uD56E", 5, "\uD576\uD577\uD579\uD57A\uD57B\uD57D", 6, "\uD586\uD58A\uD58B"],
      ["c161", "\uD58C\uD58D\uD58E\uD58F\uD591", 19, "\uD5A6\uD5A7"],
      ["c181", "\uD5A8", 31, "\uC810\uC811\uC813\uC815\uC816\uC81C\uC81D\uC820\uC824\uC82C\uC82D\uC82F\uC831\uC838\uC83C\uC840\uC848\uC849\uC84C\uC84D\uC854\uC870\uC871\uC874\uC878\uC87A\uC880\uC881\uC883\uC885\uC886\uC887\uC88B\uC88C\uC88D\uC894\uC89D\uC89F\uC8A1\uC8A8\uC8BC\uC8BD\uC8C4\uC8C8\uC8CC\uC8D4\uC8D5\uC8D7\uC8D9\uC8E0\uC8E1\uC8E4\uC8F5\uC8FC\uC8FD\uC900\uC904\uC905\uC906\uC90C\uC90D\uC90F\uC911\uC918\uC92C\uC934\uC950\uC951\uC954\uC958\uC960\uC961\uC963\uC96C\uC970\uC974\uC97C\uC988\uC989\uC98C\uC990\uC998\uC999\uC99B\uC99D\uC9C0\uC9C1\uC9C4\uC9C7\uC9C8\uC9CA\uC9D0\uC9D1\uC9D3"],
      ["c241", "\uD5CA\uD5CB\uD5CD\uD5CE\uD5CF\uD5D1\uD5D3", 4, "\uD5DA\uD5DC\uD5DE", 5, "\uD5E6\uD5E7\uD5E9\uD5EA\uD5EB\uD5ED\uD5EE"],
      ["c261", "\uD5EF", 4, "\uD5F6\uD5F8\uD5FA", 5, "\uD602\uD603\uD605\uD606\uD607\uD609", 6, "\uD612"],
      ["c281", "\uD616", 5, "\uD61D\uD61E\uD61F\uD621\uD622\uD623\uD625", 7, "\uD62E", 9, "\uD63A\uD63B\uC9D5\uC9D6\uC9D9\uC9DA\uC9DC\uC9DD\uC9E0\uC9E2\uC9E4\uC9E7\uC9EC\uC9ED\uC9EF\uC9F0\uC9F1\uC9F8\uC9F9\uC9FC\uCA00\uCA08\uCA09\uCA0B\uCA0C\uCA0D\uCA14\uCA18\uCA29\uCA4C\uCA4D\uCA50\uCA54\uCA5C\uCA5D\uCA5F\uCA60\uCA61\uCA68\uCA7D\uCA84\uCA98\uCABC\uCABD\uCAC0\uCAC4\uCACC\uCACD\uCACF\uCAD1\uCAD3\uCAD8\uCAD9\uCAE0\uCAEC\uCAF4\uCB08\uCB10\uCB14\uCB18\uCB20\uCB21\uCB41\uCB48\uCB49\uCB4C\uCB50\uCB58\uCB59\uCB5D\uCB64\uCB78\uCB79\uCB9C\uCBB8\uCBD4\uCBE4\uCBE7\uCBE9\uCC0C\uCC0D\uCC10\uCC14\uCC1C\uCC1D\uCC21\uCC22\uCC27\uCC28\uCC29\uCC2C\uCC2E\uCC30\uCC38\uCC39\uCC3B"],
      ["c341", "\uD63D\uD63E\uD63F\uD641\uD642\uD643\uD644\uD646\uD647\uD64A\uD64C\uD64E\uD64F\uD650\uD652\uD653\uD656\uD657\uD659\uD65A\uD65B\uD65D", 4],
      ["c361", "\uD662", 4, "\uD668\uD66A", 5, "\uD672\uD673\uD675", 11],
      ["c381", "\uD681\uD682\uD684\uD686", 5, "\uD68E\uD68F\uD691\uD692\uD693\uD695", 7, "\uD69E\uD6A0\uD6A2", 5, "\uD6A9\uD6AA\uCC3C\uCC3D\uCC3E\uCC44\uCC45\uCC48\uCC4C\uCC54\uCC55\uCC57\uCC58\uCC59\uCC60\uCC64\uCC66\uCC68\uCC70\uCC75\uCC98\uCC99\uCC9C\uCCA0\uCCA8\uCCA9\uCCAB\uCCAC\uCCAD\uCCB4\uCCB5\uCCB8\uCCBC\uCCC4\uCCC5\uCCC7\uCCC9\uCCD0\uCCD4\uCCE4\uCCEC\uCCF0\uCD01\uCD08\uCD09\uCD0C\uCD10\uCD18\uCD19\uCD1B\uCD1D\uCD24\uCD28\uCD2C\uCD39\uCD5C\uCD60\uCD64\uCD6C\uCD6D\uCD6F\uCD71\uCD78\uCD88\uCD94\uCD95\uCD98\uCD9C\uCDA4\uCDA5\uCDA7\uCDA9\uCDB0\uCDC4\uCDCC\uCDD0\uCDE8\uCDEC\uCDF0\uCDF8\uCDF9\uCDFB\uCDFD\uCE04\uCE08\uCE0C\uCE14\uCE19\uCE20\uCE21\uCE24\uCE28\uCE30\uCE31\uCE33\uCE35"],
      ["c441", "\uD6AB\uD6AD\uD6AE\uD6AF\uD6B1", 7, "\uD6BA\uD6BC", 7, "\uD6C6\uD6C7\uD6C9\uD6CA\uD6CB"],
      ["c461", "\uD6CD\uD6CE\uD6CF\uD6D0\uD6D2\uD6D3\uD6D5\uD6D6\uD6D8\uD6DA", 5, "\uD6E1\uD6E2\uD6E3\uD6E5\uD6E6\uD6E7\uD6E9", 4],
      ["c481", "\uD6EE\uD6EF\uD6F1\uD6F2\uD6F3\uD6F4\uD6F6", 5, "\uD6FE\uD6FF\uD701\uD702\uD703\uD705", 11, "\uD712\uD713\uD714\uCE58\uCE59\uCE5C\uCE5F\uCE60\uCE61\uCE68\uCE69\uCE6B\uCE6D\uCE74\uCE75\uCE78\uCE7C\uCE84\uCE85\uCE87\uCE89\uCE90\uCE91\uCE94\uCE98\uCEA0\uCEA1\uCEA3\uCEA4\uCEA5\uCEAC\uCEAD\uCEC1\uCEE4\uCEE5\uCEE8\uCEEB\uCEEC\uCEF4\uCEF5\uCEF7\uCEF8\uCEF9\uCF00\uCF01\uCF04\uCF08\uCF10\uCF11\uCF13\uCF15\uCF1C\uCF20\uCF24\uCF2C\uCF2D\uCF2F\uCF30\uCF31\uCF38\uCF54\uCF55\uCF58\uCF5C\uCF64\uCF65\uCF67\uCF69\uCF70\uCF71\uCF74\uCF78\uCF80\uCF85\uCF8C\uCFA1\uCFA8\uCFB0\uCFC4\uCFE0\uCFE1\uCFE4\uCFE8\uCFF0\uCFF1\uCFF3\uCFF5\uCFFC\uD000\uD004\uD011\uD018\uD02D\uD034\uD035\uD038\uD03C"],
      ["c541", "\uD715\uD716\uD717\uD71A\uD71B\uD71D\uD71E\uD71F\uD721", 6, "\uD72A\uD72C\uD72E", 5, "\uD736\uD737\uD739"],
      ["c561", "\uD73A\uD73B\uD73D", 6, "\uD745\uD746\uD748\uD74A", 5, "\uD752\uD753\uD755\uD75A", 4],
      ["c581", "\uD75F\uD762\uD764\uD766\uD767\uD768\uD76A\uD76B\uD76D\uD76E\uD76F\uD771\uD772\uD773\uD775", 6, "\uD77E\uD77F\uD780\uD782", 5, "\uD78A\uD78B\uD044\uD045\uD047\uD049\uD050\uD054\uD058\uD060\uD06C\uD06D\uD070\uD074\uD07C\uD07D\uD081\uD0A4\uD0A5\uD0A8\uD0AC\uD0B4\uD0B5\uD0B7\uD0B9\uD0C0\uD0C1\uD0C4\uD0C8\uD0C9\uD0D0\uD0D1\uD0D3\uD0D4\uD0D5\uD0DC\uD0DD\uD0E0\uD0E4\uD0EC\uD0ED\uD0EF\uD0F0\uD0F1\uD0F8\uD10D\uD130\uD131\uD134\uD138\uD13A\uD140\uD141\uD143\uD144\uD145\uD14C\uD14D\uD150\uD154\uD15C\uD15D\uD15F\uD161\uD168\uD16C\uD17C\uD184\uD188\uD1A0\uD1A1\uD1A4\uD1A8\uD1B0\uD1B1\uD1B3\uD1B5\uD1BA\uD1BC\uD1C0\uD1D8\uD1F4\uD1F8\uD207\uD209\uD210\uD22C\uD22D\uD230\uD234\uD23C\uD23D\uD23F\uD241\uD248\uD25C"],
      ["c641", "\uD78D\uD78E\uD78F\uD791", 6, "\uD79A\uD79C\uD79E", 5],
      ["c6a1", "\uD264\uD280\uD281\uD284\uD288\uD290\uD291\uD295\uD29C\uD2A0\uD2A4\uD2AC\uD2B1\uD2B8\uD2B9\uD2BC\uD2BF\uD2C0\uD2C2\uD2C8\uD2C9\uD2CB\uD2D4\uD2D8\uD2DC\uD2E4\uD2E5\uD2F0\uD2F1\uD2F4\uD2F8\uD300\uD301\uD303\uD305\uD30C\uD30D\uD30E\uD310\uD314\uD316\uD31C\uD31D\uD31F\uD320\uD321\uD325\uD328\uD329\uD32C\uD330\uD338\uD339\uD33B\uD33C\uD33D\uD344\uD345\uD37C\uD37D\uD380\uD384\uD38C\uD38D\uD38F\uD390\uD391\uD398\uD399\uD39C\uD3A0\uD3A8\uD3A9\uD3AB\uD3AD\uD3B4\uD3B8\uD3BC\uD3C4\uD3C5\uD3C8\uD3C9\uD3D0\uD3D8\uD3E1\uD3E3\uD3EC\uD3ED\uD3F0\uD3F4\uD3FC\uD3FD\uD3FF\uD401"],
      ["c7a1", "\uD408\uD41D\uD440\uD444\uD45C\uD460\uD464\uD46D\uD46F\uD478\uD479\uD47C\uD47F\uD480\uD482\uD488\uD489\uD48B\uD48D\uD494\uD4A9\uD4CC\uD4D0\uD4D4\uD4DC\uD4DF\uD4E8\uD4EC\uD4F0\uD4F8\uD4FB\uD4FD\uD504\uD508\uD50C\uD514\uD515\uD517\uD53C\uD53D\uD540\uD544\uD54C\uD54D\uD54F\uD551\uD558\uD559\uD55C\uD560\uD565\uD568\uD569\uD56B\uD56D\uD574\uD575\uD578\uD57C\uD584\uD585\uD587\uD588\uD589\uD590\uD5A5\uD5C8\uD5C9\uD5CC\uD5D0\uD5D2\uD5D8\uD5D9\uD5DB\uD5DD\uD5E4\uD5E5\uD5E8\uD5EC\uD5F4\uD5F5\uD5F7\uD5F9\uD600\uD601\uD604\uD608\uD610\uD611\uD613\uD614\uD615\uD61C\uD620"],
      ["c8a1", "\uD624\uD62D\uD638\uD639\uD63C\uD640\uD645\uD648\uD649\uD64B\uD64D\uD651\uD654\uD655\uD658\uD65C\uD667\uD669\uD670\uD671\uD674\uD683\uD685\uD68C\uD68D\uD690\uD694\uD69D\uD69F\uD6A1\uD6A8\uD6AC\uD6B0\uD6B9\uD6BB\uD6C4\uD6C5\uD6C8\uD6CC\uD6D1\uD6D4\uD6D7\uD6D9\uD6E0\uD6E4\uD6E8\uD6F0\uD6F5\uD6FC\uD6FD\uD700\uD704\uD711\uD718\uD719\uD71C\uD720\uD728\uD729\uD72B\uD72D\uD734\uD735\uD738\uD73C\uD744\uD747\uD749\uD750\uD751\uD754\uD756\uD757\uD758\uD759\uD760\uD761\uD763\uD765\uD769\uD76C\uD770\uD774\uD77C\uD77D\uD781\uD788\uD789\uD78C\uD790\uD798\uD799\uD79B\uD79D"],
      ["caa1", "\u4F3D\u4F73\u5047\u50F9\u52A0\u53EF\u5475\u54E5\u5609\u5AC1\u5BB6\u6687\u67B6\u67B7\u67EF\u6B4C\u73C2\u75C2\u7A3C\u82DB\u8304\u8857\u8888\u8A36\u8CC8\u8DCF\u8EFB\u8FE6\u99D5\u523B\u5374\u5404\u606A\u6164\u6BBC\u73CF\u811A\u89BA\u89D2\u95A3\u4F83\u520A\u58BE\u5978\u59E6\u5E72\u5E79\u61C7\u63C0\u6746\u67EC\u687F\u6F97\u764E\u770B\u78F5\u7A08\u7AFF\u7C21\u809D\u826E\u8271\u8AEB\u9593\u4E6B\u559D\u66F7\u6E34\u78A3\u7AED\u845B\u8910\u874E\u97A8\u52D8\u574E\u582A\u5D4C\u611F\u61BE\u6221\u6562\u67D1\u6A44\u6E1B\u7518\u75B3\u76E3\u77B0\u7D3A\u90AF\u9451\u9452\u9F95"],
      ["cba1", "\u5323\u5CAC\u7532\u80DB\u9240\u9598\u525B\u5808\u59DC\u5CA1\u5D17\u5EB7\u5F3A\u5F4A\u6177\u6C5F\u757A\u7586\u7CE0\u7D73\u7DB1\u7F8C\u8154\u8221\u8591\u8941\u8B1B\u92FC\u964D\u9C47\u4ECB\u4EF7\u500B\u51F1\u584F\u6137\u613E\u6168\u6539\u69EA\u6F11\u75A5\u7686\u76D6\u7B87\u82A5\u84CB\uF900\u93A7\u958B\u5580\u5BA2\u5751\uF901\u7CB3\u7FB9\u91B5\u5028\u53BB\u5C45\u5DE8\u62D2\u636E\u64DA\u64E7\u6E20\u70AC\u795B\u8DDD\u8E1E\uF902\u907D\u9245\u92F8\u4E7E\u4EF6\u5065\u5DFE\u5EFA\u6106\u6957\u8171\u8654\u8E47\u9375\u9A2B\u4E5E\u5091\u6770\u6840\u5109\u528D\u5292\u6AA2"],
      ["cca1", "\u77BC\u9210\u9ED4\u52AB\u602F\u8FF2\u5048\u61A9\u63ED\u64CA\u683C\u6A84\u6FC0\u8188\u89A1\u9694\u5805\u727D\u72AC\u7504\u7D79\u7E6D\u80A9\u898B\u8B74\u9063\u9D51\u6289\u6C7A\u6F54\u7D50\u7F3A\u8A23\u517C\u614A\u7B9D\u8B19\u9257\u938C\u4EAC\u4FD3\u501E\u50BE\u5106\u52C1\u52CD\u537F\u5770\u5883\u5E9A\u5F91\u6176\u61AC\u64CE\u656C\u666F\u66BB\u66F4\u6897\u6D87\u7085\u70F1\u749F\u74A5\u74CA\u75D9\u786C\u78EC\u7ADF\u7AF6\u7D45\u7D93\u8015\u803F\u811B\u8396\u8B66\u8F15\u9015\u93E1\u9803\u9838\u9A5A\u9BE8\u4FC2\u5553\u583A\u5951\u5B63\u5C46\u60B8\u6212\u6842\u68B0"],
      ["cda1", "\u68E8\u6EAA\u754C\u7678\u78CE\u7A3D\u7CFB\u7E6B\u7E7C\u8A08\u8AA1\u8C3F\u968E\u9DC4\u53E4\u53E9\u544A\u5471\u56FA\u59D1\u5B64\u5C3B\u5EAB\u62F7\u6537\u6545\u6572\u66A0\u67AF\u69C1\u6CBD\u75FC\u7690\u777E\u7A3F\u7F94\u8003\u80A1\u818F\u82E6\u82FD\u83F0\u85C1\u8831\u88B4\u8AA5\uF903\u8F9C\u932E\u96C7\u9867\u9AD8\u9F13\u54ED\u659B\u66F2\u688F\u7A40\u8C37\u9D60\u56F0\u5764\u5D11\u6606\u68B1\u68CD\u6EFE\u7428\u889E\u9BE4\u6C68\uF904\u9AA8\u4F9B\u516C\u5171\u529F\u5B54\u5DE5\u6050\u606D\u62F1\u63A7\u653B\u73D9\u7A7A\u86A3\u8CA2\u978F\u4E32\u5BE1\u6208\u679C\u74DC"],
      ["cea1", "\u79D1\u83D3\u8A87\u8AB2\u8DE8\u904E\u934B\u9846\u5ED3\u69E8\u85FF\u90ED\uF905\u51A0\u5B98\u5BEC\u6163\u68FA\u6B3E\u704C\u742F\u74D8\u7BA1\u7F50\u83C5\u89C0\u8CAB\u95DC\u9928\u522E\u605D\u62EC\u9002\u4F8A\u5149\u5321\u58D9\u5EE3\u66E0\u6D38\u709A\u72C2\u73D6\u7B50\u80F1\u945B\u5366\u639B\u7F6B\u4E56\u5080\u584A\u58DE\u602A\u6127\u62D0\u69D0\u9B41\u5B8F\u7D18\u80B1\u8F5F\u4EA4\u50D1\u54AC\u55AC\u5B0C\u5DA0\u5DE7\u652A\u654E\u6821\u6A4B\u72E1\u768E\u77EF\u7D5E\u7FF9\u81A0\u854E\u86DF\u8F03\u8F4E\u90CA\u9903\u9A55\u9BAB\u4E18\u4E45\u4E5D\u4EC7\u4FF1\u5177\u52FE"],
      ["cfa1", "\u5340\u53E3\u53E5\u548E\u5614\u5775\u57A2\u5BC7\u5D87\u5ED0\u61FC\u62D8\u6551\u67B8\u67E9\u69CB\u6B50\u6BC6\u6BEC\u6C42\u6E9D\u7078\u72D7\u7396\u7403\u77BF\u77E9\u7A76\u7D7F\u8009\u81FC\u8205\u820A\u82DF\u8862\u8B33\u8CFC\u8EC0\u9011\u90B1\u9264\u92B6\u99D2\u9A45\u9CE9\u9DD7\u9F9C\u570B\u5C40\u83CA\u97A0\u97AB\u9EB4\u541B\u7A98\u7FA4\u88D9\u8ECD\u90E1\u5800\u5C48\u6398\u7A9F\u5BAE\u5F13\u7A79\u7AAE\u828E\u8EAC\u5026\u5238\u52F8\u5377\u5708\u62F3\u6372\u6B0A\u6DC3\u7737\u53A5\u7357\u8568\u8E76\u95D5\u673A\u6AC3\u6F70\u8A6D\u8ECC\u994B\uF906\u6677\u6B78\u8CB4"],
      ["d0a1", "\u9B3C\uF907\u53EB\u572D\u594E\u63C6\u69FB\u73EA\u7845\u7ABA\u7AC5\u7CFE\u8475\u898F\u8D73\u9035\u95A8\u52FB\u5747\u7547\u7B60\u83CC\u921E\uF908\u6A58\u514B\u524B\u5287\u621F\u68D8\u6975\u9699\u50C5\u52A4\u52E4\u61C3\u65A4\u6839\u69FF\u747E\u7B4B\u82B9\u83EB\u89B2\u8B39\u8FD1\u9949\uF909\u4ECA\u5997\u64D2\u6611\u6A8E\u7434\u7981\u79BD\u82A9\u887E\u887F\u895F\uF90A\u9326\u4F0B\u53CA\u6025\u6271\u6C72\u7D1A\u7D66\u4E98\u5162\u77DC\u80AF\u4F01\u4F0E\u5176\u5180\u55DC\u5668\u573B\u57FA\u57FC\u5914\u5947\u5993\u5BC4\u5C90\u5D0E\u5DF1\u5E7E\u5FCC\u6280\u65D7\u65E3"],
      ["d1a1", "\u671E\u671F\u675E\u68CB\u68C4\u6A5F\u6B3A\u6C23\u6C7D\u6C82\u6DC7\u7398\u7426\u742A\u7482\u74A3\u7578\u757F\u7881\u78EF\u7941\u7947\u7948\u797A\u7B95\u7D00\u7DBA\u7F88\u8006\u802D\u808C\u8A18\u8B4F\u8C48\u8D77\u9321\u9324\u98E2\u9951\u9A0E\u9A0F\u9A65\u9E92\u7DCA\u4F76\u5409\u62EE\u6854\u91D1\u55AB\u513A\uF90B\uF90C\u5A1C\u61E6\uF90D\u62CF\u62FF\uF90E", 5, "\u90A3\uF914", 4, "\u8AFE\uF919\uF91A\uF91B\uF91C\u6696\uF91D\u7156\uF91E\uF91F\u96E3\uF920\u634F\u637A\u5357\uF921\u678F\u6960\u6E73\uF922\u7537\uF923\uF924\uF925"],
      ["d2a1", "\u7D0D\uF926\uF927\u8872\u56CA\u5A18\uF928", 4, "\u4E43\uF92D\u5167\u5948\u67F0\u8010\uF92E\u5973\u5E74\u649A\u79CA\u5FF5\u606C\u62C8\u637B\u5BE7\u5BD7\u52AA\uF92F\u5974\u5F29\u6012\uF930\uF931\uF932\u7459\uF933", 5, "\u99D1\uF939", 10, "\u6FC3\uF944\uF945\u81BF\u8FB2\u60F1\uF946\uF947\u8166\uF948\uF949\u5C3F\uF94A", 7, "\u5AE9\u8A25\u677B\u7D10\uF952", 5, "\u80FD\uF958\uF959\u5C3C\u6CE5\u533F\u6EBA\u591A\u8336"],
      ["d3a1", "\u4E39\u4EB6\u4F46\u55AE\u5718\u58C7\u5F56\u65B7\u65E6\u6A80\u6BB5\u6E4D\u77ED\u7AEF\u7C1E\u7DDE\u86CB\u8892\u9132\u935B\u64BB\u6FBE\u737A\u75B8\u9054\u5556\u574D\u61BA\u64D4\u66C7\u6DE1\u6E5B\u6F6D\u6FB9\u75F0\u8043\u81BD\u8541\u8983\u8AC7\u8B5A\u931F\u6C93\u7553\u7B54\u8E0F\u905D\u5510\u5802\u5858\u5E62\u6207\u649E\u68E0\u7576\u7CD6\u87B3\u9EE8\u4EE3\u5788\u576E\u5927\u5C0D\u5CB1\u5E36\u5F85\u6234\u64E1\u73B3\u81FA\u888B\u8CB8\u968A\u9EDB\u5B85\u5FB7\u60B3\u5012\u5200\u5230\u5716\u5835\u5857\u5C0E\u5C60\u5CF6\u5D8B\u5EA6\u5F92\u60BC\u6311\u6389\u6417\u6843"],
      ["d4a1", "\u68F9\u6AC2\u6DD8\u6E21\u6ED4\u6FE4\u71FE\u76DC\u7779\u79B1\u7A3B\u8404\u89A9\u8CED\u8DF3\u8E48\u9003\u9014\u9053\u90FD\u934D\u9676\u97DC\u6BD2\u7006\u7258\u72A2\u7368\u7763\u79BF\u7BE4\u7E9B\u8B80\u58A9\u60C7\u6566\u65FD\u66BE\u6C8C\u711E\u71C9\u8C5A\u9813\u4E6D\u7A81\u4EDD\u51AC\u51CD\u52D5\u540C\u61A7\u6771\u6850\u68DF\u6D1E\u6F7C\u75BC\u77B3\u7AE5\u80F4\u8463\u9285\u515C\u6597\u675C\u6793\u75D8\u7AC7\u8373\uF95A\u8C46\u9017\u982D\u5C6F\u81C0\u829A\u9041\u906F\u920D\u5F97\u5D9D\u6A59\u71C8\u767B\u7B49\u85E4\u8B04\u9127\u9A30\u5587\u61F6\uF95B\u7669\u7F85"],
      ["d5a1", "\u863F\u87BA\u88F8\u908F\uF95C\u6D1B\u70D9\u73DE\u7D61\u843D\uF95D\u916A\u99F1\uF95E\u4E82\u5375\u6B04\u6B12\u703E\u721B\u862D\u9E1E\u524C\u8FA3\u5D50\u64E5\u652C\u6B16\u6FEB\u7C43\u7E9C\u85CD\u8964\u89BD\u62C9\u81D8\u881F\u5ECA\u6717\u6D6A\u72FC\u7405\u746F\u8782\u90DE\u4F86\u5D0D\u5FA0\u840A\u51B7\u63A0\u7565\u4EAE\u5006\u5169\u51C9\u6881\u6A11\u7CAE\u7CB1\u7CE7\u826F\u8AD2\u8F1B\u91CF\u4FB6\u5137\u52F5\u5442\u5EEC\u616E\u623E\u65C5\u6ADA\u6FFE\u792A\u85DC\u8823\u95AD\u9A62\u9A6A\u9E97\u9ECE\u529B\u66C6\u6B77\u701D\u792B\u8F62\u9742\u6190\u6200\u6523\u6F23"],
      ["d6a1", "\u7149\u7489\u7DF4\u806F\u84EE\u8F26\u9023\u934A\u51BD\u5217\u52A3\u6D0C\u70C8\u88C2\u5EC9\u6582\u6BAE\u6FC2\u7C3E\u7375\u4EE4\u4F36\u56F9\uF95F\u5CBA\u5DBA\u601C\u73B2\u7B2D\u7F9A\u7FCE\u8046\u901E\u9234\u96F6\u9748\u9818\u9F61\u4F8B\u6FA7\u79AE\u91B4\u96B7\u52DE\uF960\u6488\u64C4\u6AD3\u6F5E\u7018\u7210\u76E7\u8001\u8606\u865C\u8DEF\u8F05\u9732\u9B6F\u9DFA\u9E75\u788C\u797F\u7DA0\u83C9\u9304\u9E7F\u9E93\u8AD6\u58DF\u5F04\u6727\u7027\u74CF\u7C60\u807E\u5121\u7028\u7262\u78CA\u8CC2\u8CDA\u8CF4\u96F7\u4E86\u50DA\u5BEE\u5ED6\u6599\u71CE\u7642\u77AD\u804A\u84FC"],
      ["d7a1", "\u907C\u9B27\u9F8D\u58D8\u5A41\u5C62\u6A13\u6DDA\u6F0F\u763B\u7D2F\u7E37\u851E\u8938\u93E4\u964B\u5289\u65D2\u67F3\u69B4\u6D41\u6E9C\u700F\u7409\u7460\u7559\u7624\u786B\u8B2C\u985E\u516D\u622E\u9678\u4F96\u502B\u5D19\u6DEA\u7DB8\u8F2A\u5F8B\u6144\u6817\uF961\u9686\u52D2\u808B\u51DC\u51CC\u695E\u7A1C\u7DBE\u83F1\u9675\u4FDA\u5229\u5398\u540F\u550E\u5C65\u60A7\u674E\u68A8\u6D6C\u7281\u72F8\u7406\u7483\uF962\u75E2\u7C6C\u7F79\u7FB8\u8389\u88CF\u88E1\u91CC\u91D0\u96E2\u9BC9\u541D\u6F7E\u71D0\u7498\u85FA\u8EAA\u96A3\u9C57\u9E9F\u6797\u6DCB\u7433\u81E8\u9716\u782C"],
      ["d8a1", "\u7ACB\u7B20\u7C92\u6469\u746A\u75F2\u78BC\u78E8\u99AC\u9B54\u9EBB\u5BDE\u5E55\u6F20\u819C\u83AB\u9088\u4E07\u534D\u5A29\u5DD2\u5F4E\u6162\u633D\u6669\u66FC\u6EFF\u6F2B\u7063\u779E\u842C\u8513\u883B\u8F13\u9945\u9C3B\u551C\u62B9\u672B\u6CAB\u8309\u896A\u977A\u4EA1\u5984\u5FD8\u5FD9\u671B\u7DB2\u7F54\u8292\u832B\u83BD\u8F1E\u9099\u57CB\u59B9\u5A92\u5BD0\u6627\u679A\u6885\u6BCF\u7164\u7F75\u8CB7\u8CE3\u9081\u9B45\u8108\u8C8A\u964C\u9A40\u9EA5\u5B5F\u6C13\u731B\u76F2\u76DF\u840C\u51AA\u8993\u514D\u5195\u52C9\u68C9\u6C94\u7704\u7720\u7DBF\u7DEC\u9762\u9EB5\u6EC5"],
      ["d9a1", "\u8511\u51A5\u540D\u547D\u660E\u669D\u6927\u6E9F\u76BF\u7791\u8317\u84C2\u879F\u9169\u9298\u9CF4\u8882\u4FAE\u5192\u52DF\u59C6\u5E3D\u6155\u6478\u6479\u66AE\u67D0\u6A21\u6BCD\u6BDB\u725F\u7261\u7441\u7738\u77DB\u8017\u82BC\u8305\u8B00\u8B28\u8C8C\u6728\u6C90\u7267\u76EE\u7766\u7A46\u9DA9\u6B7F\u6C92\u5922\u6726\u8499\u536F\u5893\u5999\u5EDF\u63CF\u6634\u6773\u6E3A\u732B\u7AD7\u82D7\u9328\u52D9\u5DEB\u61AE\u61CB\u620A\u62C7\u64AB\u65E0\u6959\u6B66\u6BCB\u7121\u73F7\u755D\u7E46\u821E\u8302\u856A\u8AA3\u8CBF\u9727\u9D61\u58A8\u9ED8\u5011\u520E\u543B\u554F\u6587"],
      ["daa1", "\u6C76\u7D0A\u7D0B\u805E\u868A\u9580\u96EF\u52FF\u6C95\u7269\u5473\u5A9A\u5C3E\u5D4B\u5F4C\u5FAE\u672A\u68B6\u6963\u6E3C\u6E44\u7709\u7C73\u7F8E\u8587\u8B0E\u8FF7\u9761\u9EF4\u5CB7\u60B6\u610D\u61AB\u654F\u65FB\u65FC\u6C11\u6CEF\u739F\u73C9\u7DE1\u9594\u5BC6\u871C\u8B10\u525D\u535A\u62CD\u640F\u64B2\u6734\u6A38\u6CCA\u73C0\u749E\u7B94\u7C95\u7E1B\u818A\u8236\u8584\u8FEB\u96F9\u99C1\u4F34\u534A\u53CD\u53DB\u62CC\u642C\u6500\u6591\u69C3\u6CEE\u6F58\u73ED\u7554\u7622\u76E4\u76FC\u78D0\u78FB\u792C\u7D46\u822C\u87E0\u8FD4\u9812\u98EF\u52C3\u62D4\u64A5\u6E24\u6F51"],
      ["dba1", "\u767C\u8DCB\u91B1\u9262\u9AEE\u9B43\u5023\u508D\u574A\u59A8\u5C28\u5E47\u5F77\u623F\u653E\u65B9\u65C1\u6609\u678B\u699C\u6EC2\u78C5\u7D21\u80AA\u8180\u822B\u82B3\u84A1\u868C\u8A2A\u8B17\u90A6\u9632\u9F90\u500D\u4FF3\uF963\u57F9\u5F98\u62DC\u6392\u676F\u6E43\u7119\u76C3\u80CC\u80DA\u88F4\u88F5\u8919\u8CE0\u8F29\u914D\u966A\u4F2F\u4F70\u5E1B\u67CF\u6822\u767D\u767E\u9B44\u5E61\u6A0A\u7169\u71D4\u756A\uF964\u7E41\u8543\u85E9\u98DC\u4F10\u7B4F\u7F70\u95A5\u51E1\u5E06\u68B5\u6C3E\u6C4E\u6CDB\u72AF\u7BC4\u8303\u6CD5\u743A\u50FB\u5288\u58C1\u64D8\u6A97\u74A7\u7656"],
      ["dca1", "\u78A7\u8617\u95E2\u9739\uF965\u535E\u5F01\u8B8A\u8FA8\u8FAF\u908A\u5225\u77A5\u9C49\u9F08\u4E19\u5002\u5175\u5C5B\u5E77\u661E\u663A\u67C4\u68C5\u70B3\u7501\u75C5\u79C9\u7ADD\u8F27\u9920\u9A08\u4FDD\u5821\u5831\u5BF6\u666E\u6B65\u6D11\u6E7A\u6F7D\u73E4\u752B\u83E9\u88DC\u8913\u8B5C\u8F14\u4F0F\u50D5\u5310\u535C\u5B93\u5FA9\u670D\u798F\u8179\u832F\u8514\u8907\u8986\u8F39\u8F3B\u99A5\u9C12\u672C\u4E76\u4FF8\u5949\u5C01\u5CEF\u5CF0\u6367\u68D2\u70FD\u71A2\u742B\u7E2B\u84EC\u8702\u9022\u92D2\u9CF3\u4E0D\u4ED8\u4FEF\u5085\u5256\u526F\u5426\u5490\u57E0\u592B\u5A66"],
      ["dda1", "\u5B5A\u5B75\u5BCC\u5E9C\uF966\u6276\u6577\u65A7\u6D6E\u6EA5\u7236\u7B26\u7C3F\u7F36\u8150\u8151\u819A\u8240\u8299\u83A9\u8A03\u8CA0\u8CE6\u8CFB\u8D74\u8DBA\u90E8\u91DC\u961C\u9644\u99D9\u9CE7\u5317\u5206\u5429\u5674\u58B3\u5954\u596E\u5FFF\u61A4\u626E\u6610\u6C7E\u711A\u76C6\u7C89\u7CDE\u7D1B\u82AC\u8CC1\u96F0\uF967\u4F5B\u5F17\u5F7F\u62C2\u5D29\u670B\u68DA\u787C\u7E43\u9D6C\u4E15\u5099\u5315\u532A\u5351\u5983\u5A62\u5E87\u60B2\u618A\u6249\u6279\u6590\u6787\u69A7\u6BD4\u6BD6\u6BD7\u6BD8\u6CB8\uF968\u7435\u75FA\u7812\u7891\u79D5\u79D8\u7C83\u7DCB\u7FE1\u80A5"],
      ["dea1", "\u813E\u81C2\u83F2\u871A\u88E8\u8AB9\u8B6C\u8CBB\u9119\u975E\u98DB\u9F3B\u56AC\u5B2A\u5F6C\u658C\u6AB3\u6BAF\u6D5C\u6FF1\u7015\u725D\u73AD\u8CA7\u8CD3\u983B\u6191\u6C37\u8058\u9A01\u4E4D\u4E8B\u4E9B\u4ED5\u4F3A\u4F3C\u4F7F\u4FDF\u50FF\u53F2\u53F8\u5506\u55E3\u56DB\u58EB\u5962\u5A11\u5BEB\u5BFA\u5C04\u5DF3\u5E2B\u5F99\u601D\u6368\u659C\u65AF\u67F6\u67FB\u68AD\u6B7B\u6C99\u6CD7\u6E23\u7009\u7345\u7802\u793E\u7940\u7960\u79C1\u7BE9\u7D17\u7D72\u8086\u820D\u838E\u84D1\u86C7\u88DF\u8A50\u8A5E\u8B1D\u8CDC\u8D66\u8FAD\u90AA\u98FC\u99DF\u9E9D\u524A\uF969\u6714\uF96A"],
      ["dfa1", "\u5098\u522A\u5C71\u6563\u6C55\u73CA\u7523\u759D\u7B97\u849C\u9178\u9730\u4E77\u6492\u6BBA\u715E\u85A9\u4E09\uF96B\u6749\u68EE\u6E17\u829F\u8518\u886B\u63F7\u6F81\u9212\u98AF\u4E0A\u50B7\u50CF\u511F\u5546\u55AA\u5617\u5B40\u5C19\u5CE0\u5E38\u5E8A\u5EA0\u5EC2\u60F3\u6851\u6A61\u6E58\u723D\u7240\u72C0\u76F8\u7965\u7BB1\u7FD4\u88F3\u89F4\u8A73\u8C61\u8CDE\u971C\u585E\u74BD\u8CFD\u55C7\uF96C\u7A61\u7D22\u8272\u7272\u751F\u7525\uF96D\u7B19\u5885\u58FB\u5DBC\u5E8F\u5EB6\u5F90\u6055\u6292\u637F\u654D\u6691\u66D9\u66F8\u6816\u68F2\u7280\u745E\u7B6E\u7D6E\u7DD6\u7F72"],
      ["e0a1", "\u80E5\u8212\u85AF\u897F\u8A93\u901D\u92E4\u9ECD\u9F20\u5915\u596D\u5E2D\u60DC\u6614\u6673\u6790\u6C50\u6DC5\u6F5F\u77F3\u78A9\u84C6\u91CB\u932B\u4ED9\u50CA\u5148\u5584\u5B0B\u5BA3\u6247\u657E\u65CB\u6E32\u717D\u7401\u7444\u7487\u74BF\u766C\u79AA\u7DDA\u7E55\u7FA8\u817A\u81B3\u8239\u861A\u87EC\u8A75\u8DE3\u9078\u9291\u9425\u994D\u9BAE\u5368\u5C51\u6954\u6CC4\u6D29\u6E2B\u820C\u859B\u893B\u8A2D\u8AAA\u96EA\u9F67\u5261\u66B9\u6BB2\u7E96\u87FE\u8D0D\u9583\u965D\u651D\u6D89\u71EE\uF96E\u57CE\u59D3\u5BAC\u6027\u60FA\u6210\u661F\u665F\u7329\u73F9\u76DB\u7701\u7B6C"],
      ["e1a1", "\u8056\u8072\u8165\u8AA0\u9192\u4E16\u52E2\u6B72\u6D17\u7A05\u7B39\u7D30\uF96F\u8CB0\u53EC\u562F\u5851\u5BB5\u5C0F\u5C11\u5DE2\u6240\u6383\u6414\u662D\u68B3\u6CBC\u6D88\u6EAF\u701F\u70A4\u71D2\u7526\u758F\u758E\u7619\u7B11\u7BE0\u7C2B\u7D20\u7D39\u852C\u856D\u8607\u8A34\u900D\u9061\u90B5\u92B7\u97F6\u9A37\u4FD7\u5C6C\u675F\u6D91\u7C9F\u7E8C\u8B16\u8D16\u901F\u5B6B\u5DFD\u640D\u84C0\u905C\u98E1\u7387\u5B8B\u609A\u677E\u6DDE\u8A1F\u8AA6\u9001\u980C\u5237\uF970\u7051\u788E\u9396\u8870\u91D7\u4FEE\u53D7\u55FD\u56DA\u5782\u58FD\u5AC2\u5B88\u5CAB\u5CC0\u5E25\u6101"],
      ["e2a1", "\u620D\u624B\u6388\u641C\u6536\u6578\u6A39\u6B8A\u6C34\u6D19\u6F31\u71E7\u72E9\u7378\u7407\u74B2\u7626\u7761\u79C0\u7A57\u7AEA\u7CB9\u7D8F\u7DAC\u7E61\u7F9E\u8129\u8331\u8490\u84DA\u85EA\u8896\u8AB0\u8B90\u8F38\u9042\u9083\u916C\u9296\u92B9\u968B\u96A7\u96A8\u96D6\u9700\u9808\u9996\u9AD3\u9B1A\u53D4\u587E\u5919\u5B70\u5BBF\u6DD1\u6F5A\u719F\u7421\u74B9\u8085\u83FD\u5DE1\u5F87\u5FAA\u6042\u65EC\u6812\u696F\u6A53\u6B89\u6D35\u6DF3\u73E3\u76FE\u77AC\u7B4D\u7D14\u8123\u821C\u8340\u84F4\u8563\u8A62\u8AC4\u9187\u931E\u9806\u99B4\u620C\u8853\u8FF0\u9265\u5D07\u5D27"],
      ["e3a1", "\u5D69\u745F\u819D\u8768\u6FD5\u62FE\u7FD2\u8936\u8972\u4E1E\u4E58\u50E7\u52DD\u5347\u627F\u6607\u7E69\u8805\u965E\u4F8D\u5319\u5636\u59CB\u5AA4\u5C38\u5C4E\u5C4D\u5E02\u5F11\u6043\u65BD\u662F\u6642\u67BE\u67F4\u731C\u77E2\u793A\u7FC5\u8494\u84CD\u8996\u8A66\u8A69\u8AE1\u8C55\u8C7A\u57F4\u5BD4\u5F0F\u606F\u62ED\u690D\u6B96\u6E5C\u7184\u7BD2\u8755\u8B58\u8EFE\u98DF\u98FE\u4F38\u4F81\u4FE1\u547B\u5A20\u5BB8\u613C\u65B0\u6668\u71FC\u7533\u795E\u7D33\u814E\u81E3\u8398\u85AA\u85CE\u8703\u8A0A\u8EAB\u8F9B\uF971\u8FC5\u5931\u5BA4\u5BE6\u6089\u5BE9\u5C0B\u5FC3\u6C81"],
      ["e4a1", "\uF972\u6DF1\u700B\u751A\u82AF\u8AF6\u4EC0\u5341\uF973\u96D9\u6C0F\u4E9E\u4FC4\u5152\u555E\u5A25\u5CE8\u6211\u7259\u82BD\u83AA\u86FE\u8859\u8A1D\u963F\u96C5\u9913\u9D09\u9D5D\u580A\u5CB3\u5DBD\u5E44\u60E1\u6115\u63E1\u6A02\u6E25\u9102\u9354\u984E\u9C10\u9F77\u5B89\u5CB8\u6309\u664F\u6848\u773C\u96C1\u978D\u9854\u9B9F\u65A1\u8B01\u8ECB\u95BC\u5535\u5CA9\u5DD6\u5EB5\u6697\u764C\u83F4\u95C7\u58D3\u62BC\u72CE\u9D28\u4EF0\u592E\u600F\u663B\u6B83\u79E7\u9D26\u5393\u54C0\u57C3\u5D16\u611B\u66D6\u6DAF\u788D\u827E\u9698\u9744\u5384\u627C\u6396\u6DB2\u7E0A\u814B\u984D"],
      ["e5a1", "\u6AFB\u7F4C\u9DAF\u9E1A\u4E5F\u503B\u51B6\u591C\u60F9\u63F6\u6930\u723A\u8036\uF974\u91CE\u5F31\uF975\uF976\u7D04\u82E5\u846F\u84BB\u85E5\u8E8D\uF977\u4F6F\uF978\uF979\u58E4\u5B43\u6059\u63DA\u6518\u656D\u6698\uF97A\u694A\u6A23\u6D0B\u7001\u716C\u75D2\u760D\u79B3\u7A70\uF97B\u7F8A\uF97C\u8944\uF97D\u8B93\u91C0\u967D\uF97E\u990A\u5704\u5FA1\u65BC\u6F01\u7600\u79A6\u8A9E\u99AD\u9B5A\u9F6C\u5104\u61B6\u6291\u6A8D\u81C6\u5043\u5830\u5F66\u7109\u8A00\u8AFA\u5B7C\u8616\u4FFA\u513C\u56B4\u5944\u63A9\u6DF9\u5DAA\u696D\u5186\u4E88\u4F59\uF97F\uF980\uF981\u5982\uF982"],
      ["e6a1", "\uF983\u6B5F\u6C5D\uF984\u74B5\u7916\uF985\u8207\u8245\u8339\u8F3F\u8F5D\uF986\u9918\uF987\uF988\uF989\u4EA6\uF98A\u57DF\u5F79\u6613\uF98B\uF98C\u75AB\u7E79\u8B6F\uF98D\u9006\u9A5B\u56A5\u5827\u59F8\u5A1F\u5BB4\uF98E\u5EF6\uF98F\uF990\u6350\u633B\uF991\u693D\u6C87\u6CBF\u6D8E\u6D93\u6DF5\u6F14\uF992\u70DF\u7136\u7159\uF993\u71C3\u71D5\uF994\u784F\u786F\uF995\u7B75\u7DE3\uF996\u7E2F\uF997\u884D\u8EDF\uF998\uF999\uF99A\u925B\uF99B\u9CF6\uF99C\uF99D\uF99E\u6085\u6D85\uF99F\u71B1\uF9A0\uF9A1\u95B1\u53AD\uF9A2\uF9A3\uF9A4\u67D3\uF9A5\u708E\u7130\u7430\u8276\u82D2"],
      ["e7a1", "\uF9A6\u95BB\u9AE5\u9E7D\u66C4\uF9A7\u71C1\u8449\uF9A8\uF9A9\u584B\uF9AA\uF9AB\u5DB8\u5F71\uF9AC\u6620\u668E\u6979\u69AE\u6C38\u6CF3\u6E36\u6F41\u6FDA\u701B\u702F\u7150\u71DF\u7370\uF9AD\u745B\uF9AE\u74D4\u76C8\u7A4E\u7E93\uF9AF\uF9B0\u82F1\u8A60\u8FCE\uF9B1\u9348\uF9B2\u9719\uF9B3\uF9B4\u4E42\u502A\uF9B5\u5208\u53E1\u66F3\u6C6D\u6FCA\u730A\u777F\u7A62\u82AE\u85DD\u8602\uF9B6\u88D4\u8A63\u8B7D\u8C6B\uF9B7\u92B3\uF9B8\u9713\u9810\u4E94\u4F0D\u4FC9\u50B2\u5348\u543E\u5433\u55DA\u5862\u58BA\u5967\u5A1B\u5BE4\u609F\uF9B9\u61CA\u6556\u65FF\u6664\u68A7\u6C5A\u6FB3"],
      ["e8a1", "\u70CF\u71AC\u7352\u7B7D\u8708\u8AA4\u9C32\u9F07\u5C4B\u6C83\u7344\u7389\u923A\u6EAB\u7465\u761F\u7A69\u7E15\u860A\u5140\u58C5\u64C1\u74EE\u7515\u7670\u7FC1\u9095\u96CD\u9954\u6E26\u74E6\u7AA9\u7AAA\u81E5\u86D9\u8778\u8A1B\u5A49\u5B8C\u5B9B\u68A1\u6900\u6D63\u73A9\u7413\u742C\u7897\u7DE9\u7FEB\u8118\u8155\u839E\u8C4C\u962E\u9811\u66F0\u5F80\u65FA\u6789\u6C6A\u738B\u502D\u5A03\u6B6A\u77EE\u5916\u5D6C\u5DCD\u7325\u754F\uF9BA\uF9BB\u50E5\u51F9\u582F\u592D\u5996\u59DA\u5BE5\uF9BC\uF9BD\u5DA2\u62D7\u6416\u6493\u64FE\uF9BE\u66DC\uF9BF\u6A48\uF9C0\u71FF\u7464\uF9C1"],
      ["e9a1", "\u7A88\u7AAF\u7E47\u7E5E\u8000\u8170\uF9C2\u87EF\u8981\u8B20\u9059\uF9C3\u9080\u9952\u617E\u6B32\u6D74\u7E1F\u8925\u8FB1\u4FD1\u50AD\u5197\u52C7\u57C7\u5889\u5BB9\u5EB8\u6142\u6995\u6D8C\u6E67\u6EB6\u7194\u7462\u7528\u752C\u8073\u8338\u84C9\u8E0A\u9394\u93DE\uF9C4\u4E8E\u4F51\u5076\u512A\u53C8\u53CB\u53F3\u5B87\u5BD3\u5C24\u611A\u6182\u65F4\u725B\u7397\u7440\u76C2\u7950\u7991\u79B9\u7D06\u7FBD\u828B\u85D5\u865E\u8FC2\u9047\u90F5\u91EA\u9685\u96E8\u96E9\u52D6\u5F67\u65ED\u6631\u682F\u715C\u7A36\u90C1\u980A\u4E91\uF9C5\u6A52\u6B9E\u6F90\u7189\u8018\u82B8\u8553"],
      ["eaa1", "\u904B\u9695\u96F2\u97FB\u851A\u9B31\u4E90\u718A\u96C4\u5143\u539F\u54E1\u5713\u5712\u57A3\u5A9B\u5AC4\u5BC3\u6028\u613F\u63F4\u6C85\u6D39\u6E72\u6E90\u7230\u733F\u7457\u82D1\u8881\u8F45\u9060\uF9C6\u9662\u9858\u9D1B\u6708\u8D8A\u925E\u4F4D\u5049\u50DE\u5371\u570D\u59D4\u5A01\u5C09\u6170\u6690\u6E2D\u7232\u744B\u7DEF\u80C3\u840E\u8466\u853F\u875F\u885B\u8918\u8B02\u9055\u97CB\u9B4F\u4E73\u4F91\u5112\u516A\uF9C7\u552F\u55A9\u5B7A\u5BA5\u5E7C\u5E7D\u5EBE\u60A0\u60DF\u6108\u6109\u63C4\u6538\u6709\uF9C8\u67D4\u67DA\uF9C9\u6961\u6962\u6CB9\u6D27\uF9CA\u6E38\uF9CB"],
      ["eba1", "\u6FE1\u7336\u7337\uF9CC\u745C\u7531\uF9CD\u7652\uF9CE\uF9CF\u7DAD\u81FE\u8438\u88D5\u8A98\u8ADB\u8AED\u8E30\u8E42\u904A\u903E\u907A\u9149\u91C9\u936E\uF9D0\uF9D1\u5809\uF9D2\u6BD3\u8089\u80B2\uF9D3\uF9D4\u5141\u596B\u5C39\uF9D5\uF9D6\u6F64\u73A7\u80E4\u8D07\uF9D7\u9217\u958F\uF9D8\uF9D9\uF9DA\uF9DB\u807F\u620E\u701C\u7D68\u878D\uF9DC\u57A0\u6069\u6147\u6BB7\u8ABE\u9280\u96B1\u4E59\u541F\u6DEB\u852D\u9670\u97F3\u98EE\u63D6\u6CE3\u9091\u51DD\u61C9\u81BA\u9DF9\u4F9D\u501A\u5100\u5B9C\u610F\u61FF\u64EC\u6905\u6BC5\u7591\u77E3\u7FA9\u8264\u858F\u87FB\u8863\u8ABC"],
      ["eca1", "\u8B70\u91AB\u4E8C\u4EE5\u4F0A\uF9DD\uF9DE\u5937\u59E8\uF9DF\u5DF2\u5F1B\u5F5B\u6021\uF9E0\uF9E1\uF9E2\uF9E3\u723E\u73E5\uF9E4\u7570\u75CD\uF9E5\u79FB\uF9E6\u800C\u8033\u8084\u82E1\u8351\uF9E7\uF9E8\u8CBD\u8CB3\u9087\uF9E9\uF9EA\u98F4\u990C\uF9EB\uF9EC\u7037\u76CA\u7FCA\u7FCC\u7FFC\u8B1A\u4EBA\u4EC1\u5203\u5370\uF9ED\u54BD\u56E0\u59FB\u5BC5\u5F15\u5FCD\u6E6E\uF9EE\uF9EF\u7D6A\u8335\uF9F0\u8693\u8A8D\uF9F1\u976D\u9777\uF9F2\uF9F3\u4E00\u4F5A\u4F7E\u58F9\u65E5\u6EA2\u9038\u93B0\u99B9\u4EFB\u58EC\u598A\u59D9\u6041\uF9F4\uF9F5\u7A14\uF9F6\u834F\u8CC3\u5165\u5344"],
      ["eda1", "\uF9F7\uF9F8\uF9F9\u4ECD\u5269\u5B55\u82BF\u4ED4\u523A\u54A8\u59C9\u59FF\u5B50\u5B57\u5B5C\u6063\u6148\u6ECB\u7099\u716E\u7386\u74F7\u75B5\u78C1\u7D2B\u8005\u81EA\u8328\u8517\u85C9\u8AEE\u8CC7\u96CC\u4F5C\u52FA\u56BC\u65AB\u6628\u707C\u70B8\u7235\u7DBD\u828D\u914C\u96C0\u9D72\u5B71\u68E7\u6B98\u6F7A\u76DE\u5C91\u66AB\u6F5B\u7BB4\u7C2A\u8836\u96DC\u4E08\u4ED7\u5320\u5834\u58BB\u58EF\u596C\u5C07\u5E33\u5E84\u5F35\u638C\u66B2\u6756\u6A1F\u6AA3\u6B0C\u6F3F\u7246\uF9FA\u7350\u748B\u7AE0\u7CA7\u8178\u81DF\u81E7\u838A\u846C\u8523\u8594\u85CF\u88DD\u8D13\u91AC\u9577"],
      ["eea1", "\u969C\u518D\u54C9\u5728\u5BB0\u624D\u6750\u683D\u6893\u6E3D\u6ED3\u707D\u7E21\u88C1\u8CA1\u8F09\u9F4B\u9F4E\u722D\u7B8F\u8ACD\u931A\u4F47\u4F4E\u5132\u5480\u59D0\u5E95\u62B5\u6775\u696E\u6A17\u6CAE\u6E1A\u72D9\u732A\u75BD\u7BB8\u7D35\u82E7\u83F9\u8457\u85F7\u8A5B\u8CAF\u8E87\u9019\u90B8\u96CE\u9F5F\u52E3\u540A\u5AE1\u5BC2\u6458\u6575\u6EF4\u72C4\uF9FB\u7684\u7A4D\u7B1B\u7C4D\u7E3E\u7FDF\u837B\u8B2B\u8CCA\u8D64\u8DE1\u8E5F\u8FEA\u8FF9\u9069\u93D1\u4F43\u4F7A\u50B3\u5168\u5178\u524D\u526A\u5861\u587C\u5960\u5C08\u5C55\u5EDB\u609B\u6230\u6813\u6BBF\u6C08\u6FB1"],
      ["efa1", "\u714E\u7420\u7530\u7538\u7551\u7672\u7B4C\u7B8B\u7BAD\u7BC6\u7E8F\u8A6E\u8F3E\u8F49\u923F\u9293\u9322\u942B\u96FB\u985A\u986B\u991E\u5207\u622A\u6298\u6D59\u7664\u7ACA\u7BC0\u7D76\u5360\u5CBE\u5E97\u6F38\u70B9\u7C98\u9711\u9B8E\u9EDE\u63A5\u647A\u8776\u4E01\u4E95\u4EAD\u505C\u5075\u5448\u59C3\u5B9A\u5E40\u5EAD\u5EF7\u5F81\u60C5\u633A\u653F\u6574\u65CC\u6676\u6678\u67FE\u6968\u6A89\u6B63\u6C40\u6DC0\u6DE8\u6E1F\u6E5E\u701E\u70A1\u738E\u73FD\u753A\u775B\u7887\u798E\u7A0B\u7A7D\u7CBE\u7D8E\u8247\u8A02\u8AEA\u8C9E\u912D\u914A\u91D8\u9266\u92CC\u9320\u9706\u9756"],
      ["f0a1", "\u975C\u9802\u9F0E\u5236\u5291\u557C\u5824\u5E1D\u5F1F\u608C\u63D0\u68AF\u6FDF\u796D\u7B2C\u81CD\u85BA\u88FD\u8AF8\u8E44\u918D\u9664\u969B\u973D\u984C\u9F4A\u4FCE\u5146\u51CB\u52A9\u5632\u5F14\u5F6B\u63AA\u64CD\u65E9\u6641\u66FA\u66F9\u671D\u689D\u68D7\u69FD\u6F15\u6F6E\u7167\u71E5\u722A\u74AA\u773A\u7956\u795A\u79DF\u7A20\u7A95\u7C97\u7CDF\u7D44\u7E70\u8087\u85FB\u86A4\u8A54\u8ABF\u8D99\u8E81\u9020\u906D\u91E3\u963B\u96D5\u9CE5\u65CF\u7C07\u8DB3\u93C3\u5B58\u5C0A\u5352\u62D9\u731D\u5027\u5B97\u5F9E\u60B0\u616B\u68D5\u6DD9\u742E\u7A2E\u7D42\u7D9C\u7E31\u816B"],
      ["f1a1", "\u8E2A\u8E35\u937E\u9418\u4F50\u5750\u5DE6\u5EA7\u632B\u7F6A\u4E3B\u4F4F\u4F8F\u505A\u59DD\u80C4\u546A\u5468\u55FE\u594F\u5B99\u5DDE\u5EDA\u665D\u6731\u67F1\u682A\u6CE8\u6D32\u6E4A\u6F8D\u70B7\u73E0\u7587\u7C4C\u7D02\u7D2C\u7DA2\u821F\u86DB\u8A3B\u8A85\u8D70\u8E8A\u8F33\u9031\u914E\u9152\u9444\u99D0\u7AF9\u7CA5\u4FCA\u5101\u51C6\u57C8\u5BEF\u5CFB\u6659\u6A3D\u6D5A\u6E96\u6FEC\u710C\u756F\u7AE3\u8822\u9021\u9075\u96CB\u99FF\u8301\u4E2D\u4EF2\u8846\u91CD\u537D\u6ADB\u696B\u6C41\u847A\u589E\u618E\u66FE\u62EF\u70DD\u7511\u75C7\u7E52\u84B8\u8B49\u8D08\u4E4B\u53EA"],
      ["f2a1", "\u54AB\u5730\u5740\u5FD7\u6301\u6307\u646F\u652F\u65E8\u667A\u679D\u67B3\u6B62\u6C60\u6C9A\u6F2C\u77E5\u7825\u7949\u7957\u7D19\u80A2\u8102\u81F3\u829D\u82B7\u8718\u8A8C\uF9FC\u8D04\u8DBE\u9072\u76F4\u7A19\u7A37\u7E54\u8077\u5507\u55D4\u5875\u632F\u6422\u6649\u664B\u686D\u699B\u6B84\u6D25\u6EB1\u73CD\u7468\u74A1\u755B\u75B9\u76E1\u771E\u778B\u79E6\u7E09\u7E1D\u81FB\u852F\u8897\u8A3A\u8CD1\u8EEB\u8FB0\u9032\u93AD\u9663\u9673\u9707\u4F84\u53F1\u59EA\u5AC9\u5E19\u684E\u74C6\u75BE\u79E9\u7A92\u81A3\u86ED\u8CEA\u8DCC\u8FED\u659F\u6715\uF9FD\u57F7\u6F57\u7DDD\u8F2F"],
      ["f3a1", "\u93F6\u96C6\u5FB5\u61F2\u6F84\u4E14\u4F98\u501F\u53C9\u55DF\u5D6F\u5DEE\u6B21\u6B64\u78CB\u7B9A\uF9FE\u8E49\u8ECA\u906E\u6349\u643E\u7740\u7A84\u932F\u947F\u9F6A\u64B0\u6FAF\u71E6\u74A8\u74DA\u7AC4\u7C12\u7E82\u7CB2\u7E98\u8B9A\u8D0A\u947D\u9910\u994C\u5239\u5BDF\u64E6\u672D\u7D2E\u50ED\u53C3\u5879\u6158\u6159\u61FA\u65AC\u7AD9\u8B92\u8B96\u5009\u5021\u5275\u5531\u5A3C\u5EE0\u5F70\u6134\u655E\u660C\u6636\u66A2\u69CD\u6EC4\u6F32\u7316\u7621\u7A93\u8139\u8259\u83D6\u84BC\u50B5\u57F0\u5BC0\u5BE8\u5F69\u63A1\u7826\u7DB5\u83DC\u8521\u91C7\u91F5\u518A\u67F5\u7B56"],
      ["f4a1", "\u8CAC\u51C4\u59BB\u60BD\u8655\u501C\uF9FF\u5254\u5C3A\u617D\u621A\u62D3\u64F2\u65A5\u6ECC\u7620\u810A\u8E60\u965F\u96BB\u4EDF\u5343\u5598\u5929\u5DDD\u64C5\u6CC9\u6DFA\u7394\u7A7F\u821B\u85A6\u8CE4\u8E10\u9077\u91E7\u95E1\u9621\u97C6\u51F8\u54F2\u5586\u5FB9\u64A4\u6F88\u7DB4\u8F1F\u8F4D\u9435\u50C9\u5C16\u6CBE\u6DFB\u751B\u77BB\u7C3D\u7C64\u8A79\u8AC2\u581E\u59BE\u5E16\u6377\u7252\u758A\u776B\u8ADC\u8CBC\u8F12\u5EF3\u6674\u6DF8\u807D\u83C1\u8ACB\u9751\u9BD6\uFA00\u5243\u66FF\u6D95\u6EEF\u7DE0\u8AE6\u902E\u905E\u9AD4\u521D\u527F\u54E8\u6194\u6284\u62DB\u68A2"],
      ["f5a1", "\u6912\u695A\u6A35\u7092\u7126\u785D\u7901\u790E\u79D2\u7A0D\u8096\u8278\u82D5\u8349\u8549\u8C82\u8D85\u9162\u918B\u91AE\u4FC3\u56D1\u71ED\u77D7\u8700\u89F8\u5BF8\u5FD6\u6751\u90A8\u53E2\u585A\u5BF5\u60A4\u6181\u6460\u7E3D\u8070\u8525\u9283\u64AE\u50AC\u5D14\u6700\u589C\u62BD\u63A8\u690E\u6978\u6A1E\u6E6B\u76BA\u79CB\u82BB\u8429\u8ACF\u8DA8\u8FFD\u9112\u914B\u919C\u9310\u9318\u939A\u96DB\u9A36\u9C0D\u4E11\u755C\u795D\u7AFA\u7B51\u7BC9\u7E2E\u84C4\u8E59\u8E74\u8EF8\u9010\u6625\u693F\u7443\u51FA\u672E\u9EDC\u5145\u5FE0\u6C96\u87F2\u885D\u8877\u60B4\u81B5\u8403"],
      ["f6a1", "\u8D05\u53D6\u5439\u5634\u5A36\u5C31\u708A\u7FE0\u805A\u8106\u81ED\u8DA3\u9189\u9A5F\u9DF2\u5074\u4EC4\u53A0\u60FB\u6E2C\u5C64\u4F88\u5024\u55E4\u5CD9\u5E5F\u6065\u6894\u6CBB\u6DC4\u71BE\u75D4\u75F4\u7661\u7A1A\u7A49\u7DC7\u7DFB\u7F6E\u81F4\u86A9\u8F1C\u96C9\u99B3\u9F52\u5247\u52C5\u98ED\u89AA\u4E03\u67D2\u6F06\u4FB5\u5BE2\u6795\u6C88\u6D78\u741B\u7827\u91DD\u937C\u87C4\u79E4\u7A31\u5FEB\u4ED6\u54A4\u553E\u58AE\u59A5\u60F0\u6253\u62D6\u6736\u6955\u8235\u9640\u99B1\u99DD\u502C\u5353\u5544\u577C\uFA01\u6258\uFA02\u64E2\u666B\u67DD\u6FC1\u6FEF\u7422\u7438\u8A17"],
      ["f7a1", "\u9438\u5451\u5606\u5766\u5F48\u619A\u6B4E\u7058\u70AD\u7DBB\u8A95\u596A\u812B\u63A2\u7708\u803D\u8CAA\u5854\u642D\u69BB\u5B95\u5E11\u6E6F\uFA03\u8569\u514C\u53F0\u592A\u6020\u614B\u6B86\u6C70\u6CF0\u7B1E\u80CE\u82D4\u8DC6\u90B0\u98B1\uFA04\u64C7\u6FA4\u6491\u6504\u514E\u5410\u571F\u8A0E\u615F\u6876\uFA05\u75DB\u7B52\u7D71\u901A\u5806\u69CC\u817F\u892A\u9000\u9839\u5078\u5957\u59AC\u6295\u900F\u9B2A\u615D\u7279\u95D6\u5761\u5A46\u5DF4\u628A\u64AD\u64FA\u6777\u6CE2\u6D3E\u722C\u7436\u7834\u7F77\u82AD\u8DDB\u9817\u5224\u5742\u677F\u7248\u74E3\u8CA9\u8FA6\u9211"],
      ["f8a1", "\u962A\u516B\u53ED\u634C\u4F69\u5504\u6096\u6557\u6C9B\u6D7F\u724C\u72FD\u7A17\u8987\u8C9D\u5F6D\u6F8E\u70F9\u81A8\u610E\u4FBF\u504F\u6241\u7247\u7BC7\u7DE8\u7FE9\u904D\u97AD\u9A19\u8CB6\u576A\u5E73\u67B0\u840D\u8A55\u5420\u5B16\u5E63\u5EE2\u5F0A\u6583\u80BA\u853D\u9589\u965B\u4F48\u5305\u530D\u530F\u5486\u54FA\u5703\u5E03\u6016\u629B\u62B1\u6355\uFA06\u6CE1\u6D66\u75B1\u7832\u80DE\u812F\u82DE\u8461\u84B2\u888D\u8912\u900B\u92EA\u98FD\u9B91\u5E45\u66B4\u66DD\u7011\u7206\uFA07\u4FF5\u527D\u5F6A\u6153\u6753\u6A19\u6F02\u74E2\u7968\u8868\u8C79\u98C7\u98C4\u9A43"],
      ["f9a1", "\u54C1\u7A1F\u6953\u8AF7\u8C4A\u98A8\u99AE\u5F7C\u62AB\u75B2\u76AE\u88AB\u907F\u9642\u5339\u5F3C\u5FC5\u6CCC\u73CC\u7562\u758B\u7B46\u82FE\u999D\u4E4F\u903C\u4E0B\u4F55\u53A6\u590F\u5EC8\u6630\u6CB3\u7455\u8377\u8766\u8CC0\u9050\u971E\u9C15\u58D1\u5B78\u8650\u8B14\u9DB4\u5BD2\u6068\u608D\u65F1\u6C57\u6F22\u6FA3\u701A\u7F55\u7FF0\u9591\u9592\u9650\u97D3\u5272\u8F44\u51FD\u542B\u54B8\u5563\u558A\u6ABB\u6DB5\u7DD8\u8266\u929C\u9677\u9E79\u5408\u54C8\u76D2\u86E4\u95A4\u95D4\u965C\u4EA2\u4F09\u59EE\u5AE6\u5DF7\u6052\u6297\u676D\u6841\u6C86\u6E2F\u7F38\u809B\u822A"],
      ["faa1", "\uFA08\uFA09\u9805\u4EA5\u5055\u54B3\u5793\u595A\u5B69\u5BB3\u61C8\u6977\u6D77\u7023\u87F9\u89E3\u8A72\u8AE7\u9082\u99ED\u9AB8\u52BE\u6838\u5016\u5E78\u674F\u8347\u884C\u4EAB\u5411\u56AE\u73E6\u9115\u97FF\u9909\u9957\u9999\u5653\u589F\u865B\u8A31\u61B2\u6AF6\u737B\u8ED2\u6B47\u96AA\u9A57\u5955\u7200\u8D6B\u9769\u4FD4\u5CF4\u5F26\u61F8\u665B\u6CEB\u70AB\u7384\u73B9\u73FE\u7729\u774D\u7D43\u7D62\u7E23\u8237\u8852\uFA0A\u8CE2\u9249\u986F\u5B51\u7A74\u8840\u9801\u5ACC\u4FE0\u5354\u593E\u5CFD\u633E\u6D79\u72F9\u8105\u8107\u83A2\u92CF\u9830\u4EA8\u5144\u5211\u578B"],
      ["fba1", "\u5F62\u6CC2\u6ECE\u7005\u7050\u70AF\u7192\u73E9\u7469\u834A\u87A2\u8861\u9008\u90A2\u93A3\u99A8\u516E\u5F57\u60E0\u6167\u66B3\u8559\u8E4A\u91AF\u978B\u4E4E\u4E92\u547C\u58D5\u58FA\u597D\u5CB5\u5F27\u6236\u6248\u660A\u6667\u6BEB\u6D69\u6DCF\u6E56\u6EF8\u6F94\u6FE0\u6FE9\u705D\u72D0\u7425\u745A\u74E0\u7693\u795C\u7CCA\u7E1E\u80E1\u82A6\u846B\u84BF\u864E\u865F\u8774\u8B77\u8C6A\u93AC\u9800\u9865\u60D1\u6216\u9177\u5A5A\u660F\u6DF7\u6E3E\u743F\u9B42\u5FFD\u60DA\u7B0F\u54C4\u5F18\u6C5E\u6CD3\u6D2A\u70D8\u7D05\u8679\u8A0C\u9D3B\u5316\u548C\u5B05\u6A3A\u706B\u7575"],
      ["fca1", "\u798D\u79BE\u82B1\u83EF\u8A71\u8B41\u8CA8\u9774\uFA0B\u64F4\u652B\u78BA\u78BB\u7A6B\u4E38\u559A\u5950\u5BA6\u5E7B\u60A3\u63DB\u6B61\u6665\u6853\u6E19\u7165\u74B0\u7D08\u9084\u9A69\u9C25\u6D3B\u6ED1\u733E\u8C41\u95CA\u51F0\u5E4C\u5FA8\u604D\u60F6\u6130\u614C\u6643\u6644\u69A5\u6CC1\u6E5F\u6EC9\u6F62\u714C\u749C\u7687\u7BC1\u7C27\u8352\u8757\u9051\u968D\u9EC3\u532F\u56DE\u5EFB\u5F8A\u6062\u6094\u61F7\u6666\u6703\u6A9C\u6DEE\u6FAE\u7070\u736A\u7E6A\u81BE\u8334\u86D4\u8AA8\u8CC4\u5283\u7372\u5B96\u6A6B\u9404\u54EE\u5686\u5B5D\u6548\u6585\u66C9\u689F\u6D8D\u6DC6"],
      ["fda1", "\u723B\u80B4\u9175\u9A4D\u4FAF\u5019\u539A\u540E\u543C\u5589\u55C5\u5E3F\u5F8C\u673D\u7166\u73DD\u9005\u52DB\u52F3\u5864\u58CE\u7104\u718F\u71FB\u85B0\u8A13\u6688\u85A8\u55A7\u6684\u714A\u8431\u5349\u5599\u6BC1\u5F59\u5FBD\u63EE\u6689\u7147\u8AF1\u8F1D\u9EBE\u4F11\u643A\u70CB\u7566\u8667\u6064\u8B4E\u9DF8\u5147\u51F6\u5308\u6D36\u80F8\u9ED1\u6615\u6B23\u7098\u75D5\u5403\u5C79\u7D07\u8A16\u6B20\u6B3D\u6B46\u5438\u6070\u6D3D\u7FD5\u8208\u50D6\u51DE\u559C\u566B\u56CD\u59EC\u5B09\u5E0C\u6199\u6198\u6231\u665E\u66E6\u7199\u71B9\u71BA\u72A7\u79A7\u7A00\u7FB2\u8A70"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS({
  "node_modules/iconv-lite/encodings/tables/cp950.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["a140", "\u3000\uFF0C\u3001\u3002\uFF0E\u2027\uFF1B\uFF1A\uFF1F\uFF01\uFE30\u2026\u2025\uFE50\uFE51\uFE52\xB7\uFE54\uFE55\uFE56\uFE57\uFF5C\u2013\uFE31\u2014\uFE33\u2574\uFE34\uFE4F\uFF08\uFF09\uFE35\uFE36\uFF5B\uFF5D\uFE37\uFE38\u3014\u3015\uFE39\uFE3A\u3010\u3011\uFE3B\uFE3C\u300A\u300B\uFE3D\uFE3E\u3008\u3009\uFE3F\uFE40\u300C\u300D\uFE41\uFE42\u300E\u300F\uFE43\uFE44\uFE59\uFE5A"],
      ["a1a1", "\uFE5B\uFE5C\uFE5D\uFE5E\u2018\u2019\u201C\u201D\u301D\u301E\u2035\u2032\uFF03\uFF06\uFF0A\u203B\xA7\u3003\u25CB\u25CF\u25B3\u25B2\u25CE\u2606\u2605\u25C7\u25C6\u25A1\u25A0\u25BD\u25BC\u32A3\u2105\xAF\uFFE3\uFF3F\u02CD\uFE49\uFE4A\uFE4D\uFE4E\uFE4B\uFE4C\uFE5F\uFE60\uFE61\uFF0B\uFF0D\xD7\xF7\xB1\u221A\uFF1C\uFF1E\uFF1D\u2266\u2267\u2260\u221E\u2252\u2261\uFE62", 4, "\uFF5E\u2229\u222A\u22A5\u2220\u221F\u22BF\u33D2\u33D1\u222B\u222E\u2235\u2234\u2640\u2642\u2295\u2299\u2191\u2193\u2190\u2192\u2196\u2197\u2199\u2198\u2225\u2223\uFF0F"],
      ["a240", "\uFF3C\u2215\uFE68\uFF04\uFFE5\u3012\uFFE0\uFFE1\uFF05\uFF20\u2103\u2109\uFE69\uFE6A\uFE6B\u33D5\u339C\u339D\u339E\u33CE\u33A1\u338E\u338F\u33C4\xB0\u5159\u515B\u515E\u515D\u5161\u5163\u55E7\u74E9\u7CCE\u2581", 7, "\u258F\u258E\u258D\u258C\u258B\u258A\u2589\u253C\u2534\u252C\u2524\u251C\u2594\u2500\u2502\u2595\u250C\u2510\u2514\u2518\u256D"],
      ["a2a1", "\u256E\u2570\u256F\u2550\u255E\u256A\u2561\u25E2\u25E3\u25E5\u25E4\u2571\u2572\u2573\uFF10", 9, "\u2160", 9, "\u3021", 8, "\u5341\u5344\u5345\uFF21", 25, "\uFF41", 21],
      ["a340", "\uFF57\uFF58\uFF59\uFF5A\u0391", 16, "\u03A3", 6, "\u03B1", 16, "\u03C3", 6, "\u3105", 10],
      ["a3a1", "\u3110", 25, "\u02D9\u02C9\u02CA\u02C7\u02CB"],
      ["a3e1", "\u20AC"],
      ["a440", "\u4E00\u4E59\u4E01\u4E03\u4E43\u4E5D\u4E86\u4E8C\u4EBA\u513F\u5165\u516B\u51E0\u5200\u5201\u529B\u5315\u5341\u535C\u53C8\u4E09\u4E0B\u4E08\u4E0A\u4E2B\u4E38\u51E1\u4E45\u4E48\u4E5F\u4E5E\u4E8E\u4EA1\u5140\u5203\u52FA\u5343\u53C9\u53E3\u571F\u58EB\u5915\u5927\u5973\u5B50\u5B51\u5B53\u5BF8\u5C0F\u5C22\u5C38\u5C71\u5DDD\u5DE5\u5DF1\u5DF2\u5DF3\u5DFE\u5E72\u5EFE\u5F0B\u5F13\u624D"],
      ["a4a1", "\u4E11\u4E10\u4E0D\u4E2D\u4E30\u4E39\u4E4B\u5C39\u4E88\u4E91\u4E95\u4E92\u4E94\u4EA2\u4EC1\u4EC0\u4EC3\u4EC6\u4EC7\u4ECD\u4ECA\u4ECB\u4EC4\u5143\u5141\u5167\u516D\u516E\u516C\u5197\u51F6\u5206\u5207\u5208\u52FB\u52FE\u52FF\u5316\u5339\u5348\u5347\u5345\u535E\u5384\u53CB\u53CA\u53CD\u58EC\u5929\u592B\u592A\u592D\u5B54\u5C11\u5C24\u5C3A\u5C6F\u5DF4\u5E7B\u5EFF\u5F14\u5F15\u5FC3\u6208\u6236\u624B\u624E\u652F\u6587\u6597\u65A4\u65B9\u65E5\u66F0\u6708\u6728\u6B20\u6B62\u6B79\u6BCB\u6BD4\u6BDB\u6C0F\u6C34\u706B\u722A\u7236\u723B\u7247\u7259\u725B\u72AC\u738B\u4E19"],
      ["a540", "\u4E16\u4E15\u4E14\u4E18\u4E3B\u4E4D\u4E4F\u4E4E\u4EE5\u4ED8\u4ED4\u4ED5\u4ED6\u4ED7\u4EE3\u4EE4\u4ED9\u4EDE\u5145\u5144\u5189\u518A\u51AC\u51F9\u51FA\u51F8\u520A\u52A0\u529F\u5305\u5306\u5317\u531D\u4EDF\u534A\u5349\u5361\u5360\u536F\u536E\u53BB\u53EF\u53E4\u53F3\u53EC\u53EE\u53E9\u53E8\u53FC\u53F8\u53F5\u53EB\u53E6\u53EA\u53F2\u53F1\u53F0\u53E5\u53ED\u53FB\u56DB\u56DA\u5916"],
      ["a5a1", "\u592E\u5931\u5974\u5976\u5B55\u5B83\u5C3C\u5DE8\u5DE7\u5DE6\u5E02\u5E03\u5E73\u5E7C\u5F01\u5F18\u5F17\u5FC5\u620A\u6253\u6254\u6252\u6251\u65A5\u65E6\u672E\u672C\u672A\u672B\u672D\u6B63\u6BCD\u6C11\u6C10\u6C38\u6C41\u6C40\u6C3E\u72AF\u7384\u7389\u74DC\u74E6\u7518\u751F\u7528\u7529\u7530\u7531\u7532\u7533\u758B\u767D\u76AE\u76BF\u76EE\u77DB\u77E2\u77F3\u793A\u79BE\u7A74\u7ACB\u4E1E\u4E1F\u4E52\u4E53\u4E69\u4E99\u4EA4\u4EA6\u4EA5\u4EFF\u4F09\u4F19\u4F0A\u4F15\u4F0D\u4F10\u4F11\u4F0F\u4EF2\u4EF6\u4EFB\u4EF0\u4EF3\u4EFD\u4F01\u4F0B\u5149\u5147\u5146\u5148\u5168"],
      ["a640", "\u5171\u518D\u51B0\u5217\u5211\u5212\u520E\u5216\u52A3\u5308\u5321\u5320\u5370\u5371\u5409\u540F\u540C\u540A\u5410\u5401\u540B\u5404\u5411\u540D\u5408\u5403\u540E\u5406\u5412\u56E0\u56DE\u56DD\u5733\u5730\u5728\u572D\u572C\u572F\u5729\u5919\u591A\u5937\u5938\u5984\u5978\u5983\u597D\u5979\u5982\u5981\u5B57\u5B58\u5B87\u5B88\u5B85\u5B89\u5BFA\u5C16\u5C79\u5DDE\u5E06\u5E76\u5E74"],
      ["a6a1", "\u5F0F\u5F1B\u5FD9\u5FD6\u620E\u620C\u620D\u6210\u6263\u625B\u6258\u6536\u65E9\u65E8\u65EC\u65ED\u66F2\u66F3\u6709\u673D\u6734\u6731\u6735\u6B21\u6B64\u6B7B\u6C16\u6C5D\u6C57\u6C59\u6C5F\u6C60\u6C50\u6C55\u6C61\u6C5B\u6C4D\u6C4E\u7070\u725F\u725D\u767E\u7AF9\u7C73\u7CF8\u7F36\u7F8A\u7FBD\u8001\u8003\u800C\u8012\u8033\u807F\u8089\u808B\u808C\u81E3\u81EA\u81F3\u81FC\u820C\u821B\u821F\u826E\u8272\u827E\u866B\u8840\u884C\u8863\u897F\u9621\u4E32\u4EA8\u4F4D\u4F4F\u4F47\u4F57\u4F5E\u4F34\u4F5B\u4F55\u4F30\u4F50\u4F51\u4F3D\u4F3A\u4F38\u4F43\u4F54\u4F3C\u4F46\u4F63"],
      ["a740", "\u4F5C\u4F60\u4F2F\u4F4E\u4F36\u4F59\u4F5D\u4F48\u4F5A\u514C\u514B\u514D\u5175\u51B6\u51B7\u5225\u5224\u5229\u522A\u5228\u52AB\u52A9\u52AA\u52AC\u5323\u5373\u5375\u541D\u542D\u541E\u543E\u5426\u544E\u5427\u5446\u5443\u5433\u5448\u5442\u541B\u5429\u544A\u5439\u543B\u5438\u542E\u5435\u5436\u5420\u543C\u5440\u5431\u542B\u541F\u542C\u56EA\u56F0\u56E4\u56EB\u574A\u5751\u5740\u574D"],
      ["a7a1", "\u5747\u574E\u573E\u5750\u574F\u573B\u58EF\u593E\u599D\u5992\u59A8\u599E\u59A3\u5999\u5996\u598D\u59A4\u5993\u598A\u59A5\u5B5D\u5B5C\u5B5A\u5B5B\u5B8C\u5B8B\u5B8F\u5C2C\u5C40\u5C41\u5C3F\u5C3E\u5C90\u5C91\u5C94\u5C8C\u5DEB\u5E0C\u5E8F\u5E87\u5E8A\u5EF7\u5F04\u5F1F\u5F64\u5F62\u5F77\u5F79\u5FD8\u5FCC\u5FD7\u5FCD\u5FF1\u5FEB\u5FF8\u5FEA\u6212\u6211\u6284\u6297\u6296\u6280\u6276\u6289\u626D\u628A\u627C\u627E\u6279\u6273\u6292\u626F\u6298\u626E\u6295\u6293\u6291\u6286\u6539\u653B\u6538\u65F1\u66F4\u675F\u674E\u674F\u6750\u6751\u675C\u6756\u675E\u6749\u6746\u6760"],
      ["a840", "\u6753\u6757\u6B65\u6BCF\u6C42\u6C5E\u6C99\u6C81\u6C88\u6C89\u6C85\u6C9B\u6C6A\u6C7A\u6C90\u6C70\u6C8C\u6C68\u6C96\u6C92\u6C7D\u6C83\u6C72\u6C7E\u6C74\u6C86\u6C76\u6C8D\u6C94\u6C98\u6C82\u7076\u707C\u707D\u7078\u7262\u7261\u7260\u72C4\u72C2\u7396\u752C\u752B\u7537\u7538\u7682\u76EF\u77E3\u79C1\u79C0\u79BF\u7A76\u7CFB\u7F55\u8096\u8093\u809D\u8098\u809B\u809A\u80B2\u826F\u8292"],
      ["a8a1", "\u828B\u828D\u898B\u89D2\u8A00\u8C37\u8C46\u8C55\u8C9D\u8D64\u8D70\u8DB3\u8EAB\u8ECA\u8F9B\u8FB0\u8FC2\u8FC6\u8FC5\u8FC4\u5DE1\u9091\u90A2\u90AA\u90A6\u90A3\u9149\u91C6\u91CC\u9632\u962E\u9631\u962A\u962C\u4E26\u4E56\u4E73\u4E8B\u4E9B\u4E9E\u4EAB\u4EAC\u4F6F\u4F9D\u4F8D\u4F73\u4F7F\u4F6C\u4F9B\u4F8B\u4F86\u4F83\u4F70\u4F75\u4F88\u4F69\u4F7B\u4F96\u4F7E\u4F8F\u4F91\u4F7A\u5154\u5152\u5155\u5169\u5177\u5176\u5178\u51BD\u51FD\u523B\u5238\u5237\u523A\u5230\u522E\u5236\u5241\u52BE\u52BB\u5352\u5354\u5353\u5351\u5366\u5377\u5378\u5379\u53D6\u53D4\u53D7\u5473\u5475"],
      ["a940", "\u5496\u5478\u5495\u5480\u547B\u5477\u5484\u5492\u5486\u547C\u5490\u5471\u5476\u548C\u549A\u5462\u5468\u548B\u547D\u548E\u56FA\u5783\u5777\u576A\u5769\u5761\u5766\u5764\u577C\u591C\u5949\u5947\u5948\u5944\u5954\u59BE\u59BB\u59D4\u59B9\u59AE\u59D1\u59C6\u59D0\u59CD\u59CB\u59D3\u59CA\u59AF\u59B3\u59D2\u59C5\u5B5F\u5B64\u5B63\u5B97\u5B9A\u5B98\u5B9C\u5B99\u5B9B\u5C1A\u5C48\u5C45"],
      ["a9a1", "\u5C46\u5CB7\u5CA1\u5CB8\u5CA9\u5CAB\u5CB1\u5CB3\u5E18\u5E1A\u5E16\u5E15\u5E1B\u5E11\u5E78\u5E9A\u5E97\u5E9C\u5E95\u5E96\u5EF6\u5F26\u5F27\u5F29\u5F80\u5F81\u5F7F\u5F7C\u5FDD\u5FE0\u5FFD\u5FF5\u5FFF\u600F\u6014\u602F\u6035\u6016\u602A\u6015\u6021\u6027\u6029\u602B\u601B\u6216\u6215\u623F\u623E\u6240\u627F\u62C9\u62CC\u62C4\u62BF\u62C2\u62B9\u62D2\u62DB\u62AB\u62D3\u62D4\u62CB\u62C8\u62A8\u62BD\u62BC\u62D0\u62D9\u62C7\u62CD\u62B5\u62DA\u62B1\u62D8\u62D6\u62D7\u62C6\u62AC\u62CE\u653E\u65A7\u65BC\u65FA\u6614\u6613\u660C\u6606\u6602\u660E\u6600\u660F\u6615\u660A"],
      ["aa40", "\u6607\u670D\u670B\u676D\u678B\u6795\u6771\u679C\u6773\u6777\u6787\u679D\u6797\u676F\u6770\u677F\u6789\u677E\u6790\u6775\u679A\u6793\u677C\u676A\u6772\u6B23\u6B66\u6B67\u6B7F\u6C13\u6C1B\u6CE3\u6CE8\u6CF3\u6CB1\u6CCC\u6CE5\u6CB3\u6CBD\u6CBE\u6CBC\u6CE2\u6CAB\u6CD5\u6CD3\u6CB8\u6CC4\u6CB9\u6CC1\u6CAE\u6CD7\u6CC5\u6CF1\u6CBF\u6CBB\u6CE1\u6CDB\u6CCA\u6CAC\u6CEF\u6CDC\u6CD6\u6CE0"],
      ["aaa1", "\u7095\u708E\u7092\u708A\u7099\u722C\u722D\u7238\u7248\u7267\u7269\u72C0\u72CE\u72D9\u72D7\u72D0\u73A9\u73A8\u739F\u73AB\u73A5\u753D\u759D\u7599\u759A\u7684\u76C2\u76F2\u76F4\u77E5\u77FD\u793E\u7940\u7941\u79C9\u79C8\u7A7A\u7A79\u7AFA\u7CFE\u7F54\u7F8C\u7F8B\u8005\u80BA\u80A5\u80A2\u80B1\u80A1\u80AB\u80A9\u80B4\u80AA\u80AF\u81E5\u81FE\u820D\u82B3\u829D\u8299\u82AD\u82BD\u829F\u82B9\u82B1\u82AC\u82A5\u82AF\u82B8\u82A3\u82B0\u82BE\u82B7\u864E\u8671\u521D\u8868\u8ECB\u8FCE\u8FD4\u8FD1\u90B5\u90B8\u90B1\u90B6\u91C7\u91D1\u9577\u9580\u961C\u9640\u963F\u963B\u9644"],
      ["ab40", "\u9642\u96B9\u96E8\u9752\u975E\u4E9F\u4EAD\u4EAE\u4FE1\u4FB5\u4FAF\u4FBF\u4FE0\u4FD1\u4FCF\u4FDD\u4FC3\u4FB6\u4FD8\u4FDF\u4FCA\u4FD7\u4FAE\u4FD0\u4FC4\u4FC2\u4FDA\u4FCE\u4FDE\u4FB7\u5157\u5192\u5191\u51A0\u524E\u5243\u524A\u524D\u524C\u524B\u5247\u52C7\u52C9\u52C3\u52C1\u530D\u5357\u537B\u539A\u53DB\u54AC\u54C0\u54A8\u54CE\u54C9\u54B8\u54A6\u54B3\u54C7\u54C2\u54BD\u54AA\u54C1"],
      ["aba1", "\u54C4\u54C8\u54AF\u54AB\u54B1\u54BB\u54A9\u54A7\u54BF\u56FF\u5782\u578B\u57A0\u57A3\u57A2\u57CE\u57AE\u5793\u5955\u5951\u594F\u594E\u5950\u59DC\u59D8\u59FF\u59E3\u59E8\u5A03\u59E5\u59EA\u59DA\u59E6\u5A01\u59FB\u5B69\u5BA3\u5BA6\u5BA4\u5BA2\u5BA5\u5C01\u5C4E\u5C4F\u5C4D\u5C4B\u5CD9\u5CD2\u5DF7\u5E1D\u5E25\u5E1F\u5E7D\u5EA0\u5EA6\u5EFA\u5F08\u5F2D\u5F65\u5F88\u5F85\u5F8A\u5F8B\u5F87\u5F8C\u5F89\u6012\u601D\u6020\u6025\u600E\u6028\u604D\u6070\u6068\u6062\u6046\u6043\u606C\u606B\u606A\u6064\u6241\u62DC\u6316\u6309\u62FC\u62ED\u6301\u62EE\u62FD\u6307\u62F1\u62F7"],
      ["ac40", "\u62EF\u62EC\u62FE\u62F4\u6311\u6302\u653F\u6545\u65AB\u65BD\u65E2\u6625\u662D\u6620\u6627\u662F\u661F\u6628\u6631\u6624\u66F7\u67FF\u67D3\u67F1\u67D4\u67D0\u67EC\u67B6\u67AF\u67F5\u67E9\u67EF\u67C4\u67D1\u67B4\u67DA\u67E5\u67B8\u67CF\u67DE\u67F3\u67B0\u67D9\u67E2\u67DD\u67D2\u6B6A\u6B83\u6B86\u6BB5\u6BD2\u6BD7\u6C1F\u6CC9\u6D0B\u6D32\u6D2A\u6D41\u6D25\u6D0C\u6D31\u6D1E\u6D17"],
      ["aca1", "\u6D3B\u6D3D\u6D3E\u6D36\u6D1B\u6CF5\u6D39\u6D27\u6D38\u6D29\u6D2E\u6D35\u6D0E\u6D2B\u70AB\u70BA\u70B3\u70AC\u70AF\u70AD\u70B8\u70AE\u70A4\u7230\u7272\u726F\u7274\u72E9\u72E0\u72E1\u73B7\u73CA\u73BB\u73B2\u73CD\u73C0\u73B3\u751A\u752D\u754F\u754C\u754E\u754B\u75AB\u75A4\u75A5\u75A2\u75A3\u7678\u7686\u7687\u7688\u76C8\u76C6\u76C3\u76C5\u7701\u76F9\u76F8\u7709\u770B\u76FE\u76FC\u7707\u77DC\u7802\u7814\u780C\u780D\u7946\u7949\u7948\u7947\u79B9\u79BA\u79D1\u79D2\u79CB\u7A7F\u7A81\u7AFF\u7AFD\u7C7D\u7D02\u7D05\u7D00\u7D09\u7D07\u7D04\u7D06\u7F38\u7F8E\u7FBF\u8004"],
      ["ad40", "\u8010\u800D\u8011\u8036\u80D6\u80E5\u80DA\u80C3\u80C4\u80CC\u80E1\u80DB\u80CE\u80DE\u80E4\u80DD\u81F4\u8222\u82E7\u8303\u8305\u82E3\u82DB\u82E6\u8304\u82E5\u8302\u8309\u82D2\u82D7\u82F1\u8301\u82DC\u82D4\u82D1\u82DE\u82D3\u82DF\u82EF\u8306\u8650\u8679\u867B\u867A\u884D\u886B\u8981\u89D4\u8A08\u8A02\u8A03\u8C9E\u8CA0\u8D74\u8D73\u8DB4\u8ECD\u8ECC\u8FF0\u8FE6\u8FE2\u8FEA\u8FE5"],
      ["ada1", "\u8FED\u8FEB\u8FE4\u8FE8\u90CA\u90CE\u90C1\u90C3\u914B\u914A\u91CD\u9582\u9650\u964B\u964C\u964D\u9762\u9769\u97CB\u97ED\u97F3\u9801\u98A8\u98DB\u98DF\u9996\u9999\u4E58\u4EB3\u500C\u500D\u5023\u4FEF\u5026\u5025\u4FF8\u5029\u5016\u5006\u503C\u501F\u501A\u5012\u5011\u4FFA\u5000\u5014\u5028\u4FF1\u5021\u500B\u5019\u5018\u4FF3\u4FEE\u502D\u502A\u4FFE\u502B\u5009\u517C\u51A4\u51A5\u51A2\u51CD\u51CC\u51C6\u51CB\u5256\u525C\u5254\u525B\u525D\u532A\u537F\u539F\u539D\u53DF\u54E8\u5510\u5501\u5537\u54FC\u54E5\u54F2\u5506\u54FA\u5514\u54E9\u54ED\u54E1\u5509\u54EE\u54EA"],
      ["ae40", "\u54E6\u5527\u5507\u54FD\u550F\u5703\u5704\u57C2\u57D4\u57CB\u57C3\u5809\u590F\u5957\u5958\u595A\u5A11\u5A18\u5A1C\u5A1F\u5A1B\u5A13\u59EC\u5A20\u5A23\u5A29\u5A25\u5A0C\u5A09\u5B6B\u5C58\u5BB0\u5BB3\u5BB6\u5BB4\u5BAE\u5BB5\u5BB9\u5BB8\u5C04\u5C51\u5C55\u5C50\u5CED\u5CFD\u5CFB\u5CEA\u5CE8\u5CF0\u5CF6\u5D01\u5CF4\u5DEE\u5E2D\u5E2B\u5EAB\u5EAD\u5EA7\u5F31\u5F92\u5F91\u5F90\u6059"],
      ["aea1", "\u6063\u6065\u6050\u6055\u606D\u6069\u606F\u6084\u609F\u609A\u608D\u6094\u608C\u6085\u6096\u6247\u62F3\u6308\u62FF\u634E\u633E\u632F\u6355\u6342\u6346\u634F\u6349\u633A\u6350\u633D\u632A\u632B\u6328\u634D\u634C\u6548\u6549\u6599\u65C1\u65C5\u6642\u6649\u664F\u6643\u6652\u664C\u6645\u6641\u66F8\u6714\u6715\u6717\u6821\u6838\u6848\u6846\u6853\u6839\u6842\u6854\u6829\u68B3\u6817\u684C\u6851\u683D\u67F4\u6850\u6840\u683C\u6843\u682A\u6845\u6813\u6818\u6841\u6B8A\u6B89\u6BB7\u6C23\u6C27\u6C28\u6C26\u6C24\u6CF0\u6D6A\u6D95\u6D88\u6D87\u6D66\u6D78\u6D77\u6D59\u6D93"],
      ["af40", "\u6D6C\u6D89\u6D6E\u6D5A\u6D74\u6D69\u6D8C\u6D8A\u6D79\u6D85\u6D65\u6D94\u70CA\u70D8\u70E4\u70D9\u70C8\u70CF\u7239\u7279\u72FC\u72F9\u72FD\u72F8\u72F7\u7386\u73ED\u7409\u73EE\u73E0\u73EA\u73DE\u7554\u755D\u755C\u755A\u7559\u75BE\u75C5\u75C7\u75B2\u75B3\u75BD\u75BC\u75B9\u75C2\u75B8\u768B\u76B0\u76CA\u76CD\u76CE\u7729\u771F\u7720\u7728\u77E9\u7830\u7827\u7838\u781D\u7834\u7837"],
      ["afa1", "\u7825\u782D\u7820\u781F\u7832\u7955\u7950\u7960\u795F\u7956\u795E\u795D\u7957\u795A\u79E4\u79E3\u79E7\u79DF\u79E6\u79E9\u79D8\u7A84\u7A88\u7AD9\u7B06\u7B11\u7C89\u7D21\u7D17\u7D0B\u7D0A\u7D20\u7D22\u7D14\u7D10\u7D15\u7D1A\u7D1C\u7D0D\u7D19\u7D1B\u7F3A\u7F5F\u7F94\u7FC5\u7FC1\u8006\u8018\u8015\u8019\u8017\u803D\u803F\u80F1\u8102\u80F0\u8105\u80ED\u80F4\u8106\u80F8\u80F3\u8108\u80FD\u810A\u80FC\u80EF\u81ED\u81EC\u8200\u8210\u822A\u822B\u8228\u822C\u82BB\u832B\u8352\u8354\u834A\u8338\u8350\u8349\u8335\u8334\u834F\u8332\u8339\u8336\u8317\u8340\u8331\u8328\u8343"],
      ["b040", "\u8654\u868A\u86AA\u8693\u86A4\u86A9\u868C\u86A3\u869C\u8870\u8877\u8881\u8882\u887D\u8879\u8A18\u8A10\u8A0E\u8A0C\u8A15\u8A0A\u8A17\u8A13\u8A16\u8A0F\u8A11\u8C48\u8C7A\u8C79\u8CA1\u8CA2\u8D77\u8EAC\u8ED2\u8ED4\u8ECF\u8FB1\u9001\u9006\u8FF7\u9000\u8FFA\u8FF4\u9003\u8FFD\u9005\u8FF8\u9095\u90E1\u90DD\u90E2\u9152\u914D\u914C\u91D8\u91DD\u91D7\u91DC\u91D9\u9583\u9662\u9663\u9661"],
      ["b0a1", "\u965B\u965D\u9664\u9658\u965E\u96BB\u98E2\u99AC\u9AA8\u9AD8\u9B25\u9B32\u9B3C\u4E7E\u507A\u507D\u505C\u5047\u5043\u504C\u505A\u5049\u5065\u5076\u504E\u5055\u5075\u5074\u5077\u504F\u500F\u506F\u506D\u515C\u5195\u51F0\u526A\u526F\u52D2\u52D9\u52D8\u52D5\u5310\u530F\u5319\u533F\u5340\u533E\u53C3\u66FC\u5546\u556A\u5566\u5544\u555E\u5561\u5543\u554A\u5531\u5556\u554F\u5555\u552F\u5564\u5538\u552E\u555C\u552C\u5563\u5533\u5541\u5557\u5708\u570B\u5709\u57DF\u5805\u580A\u5806\u57E0\u57E4\u57FA\u5802\u5835\u57F7\u57F9\u5920\u5962\u5A36\u5A41\u5A49\u5A66\u5A6A\u5A40"],
      ["b140", "\u5A3C\u5A62\u5A5A\u5A46\u5A4A\u5B70\u5BC7\u5BC5\u5BC4\u5BC2\u5BBF\u5BC6\u5C09\u5C08\u5C07\u5C60\u5C5C\u5C5D\u5D07\u5D06\u5D0E\u5D1B\u5D16\u5D22\u5D11\u5D29\u5D14\u5D19\u5D24\u5D27\u5D17\u5DE2\u5E38\u5E36\u5E33\u5E37\u5EB7\u5EB8\u5EB6\u5EB5\u5EBE\u5F35\u5F37\u5F57\u5F6C\u5F69\u5F6B\u5F97\u5F99\u5F9E\u5F98\u5FA1\u5FA0\u5F9C\u607F\u60A3\u6089\u60A0\u60A8\u60CB\u60B4\u60E6\u60BD"],
      ["b1a1", "\u60C5\u60BB\u60B5\u60DC\u60BC\u60D8\u60D5\u60C6\u60DF\u60B8\u60DA\u60C7\u621A\u621B\u6248\u63A0\u63A7\u6372\u6396\u63A2\u63A5\u6377\u6367\u6398\u63AA\u6371\u63A9\u6389\u6383\u639B\u636B\u63A8\u6384\u6388\u6399\u63A1\u63AC\u6392\u638F\u6380\u637B\u6369\u6368\u637A\u655D\u6556\u6551\u6559\u6557\u555F\u654F\u6558\u6555\u6554\u659C\u659B\u65AC\u65CF\u65CB\u65CC\u65CE\u665D\u665A\u6664\u6668\u6666\u665E\u66F9\u52D7\u671B\u6881\u68AF\u68A2\u6893\u68B5\u687F\u6876\u68B1\u68A7\u6897\u68B0\u6883\u68C4\u68AD\u6886\u6885\u6894\u689D\u68A8\u689F\u68A1\u6882\u6B32\u6BBA"],
      ["b240", "\u6BEB\u6BEC\u6C2B\u6D8E\u6DBC\u6DF3\u6DD9\u6DB2\u6DE1\u6DCC\u6DE4\u6DFB\u6DFA\u6E05\u6DC7\u6DCB\u6DAF\u6DD1\u6DAE\u6DDE\u6DF9\u6DB8\u6DF7\u6DF5\u6DC5\u6DD2\u6E1A\u6DB5\u6DDA\u6DEB\u6DD8\u6DEA\u6DF1\u6DEE\u6DE8\u6DC6\u6DC4\u6DAA\u6DEC\u6DBF\u6DE6\u70F9\u7109\u710A\u70FD\u70EF\u723D\u727D\u7281\u731C\u731B\u7316\u7313\u7319\u7387\u7405\u740A\u7403\u7406\u73FE\u740D\u74E0\u74F6"],
      ["b2a1", "\u74F7\u751C\u7522\u7565\u7566\u7562\u7570\u758F\u75D4\u75D5\u75B5\u75CA\u75CD\u768E\u76D4\u76D2\u76DB\u7737\u773E\u773C\u7736\u7738\u773A\u786B\u7843\u784E\u7965\u7968\u796D\u79FB\u7A92\u7A95\u7B20\u7B28\u7B1B\u7B2C\u7B26\u7B19\u7B1E\u7B2E\u7C92\u7C97\u7C95\u7D46\u7D43\u7D71\u7D2E\u7D39\u7D3C\u7D40\u7D30\u7D33\u7D44\u7D2F\u7D42\u7D32\u7D31\u7F3D\u7F9E\u7F9A\u7FCC\u7FCE\u7FD2\u801C\u804A\u8046\u812F\u8116\u8123\u812B\u8129\u8130\u8124\u8202\u8235\u8237\u8236\u8239\u838E\u839E\u8398\u8378\u83A2\u8396\u83BD\u83AB\u8392\u838A\u8393\u8389\u83A0\u8377\u837B\u837C"],
      ["b340", "\u8386\u83A7\u8655\u5F6A\u86C7\u86C0\u86B6\u86C4\u86B5\u86C6\u86CB\u86B1\u86AF\u86C9\u8853\u889E\u8888\u88AB\u8892\u8896\u888D\u888B\u8993\u898F\u8A2A\u8A1D\u8A23\u8A25\u8A31\u8A2D\u8A1F\u8A1B\u8A22\u8C49\u8C5A\u8CA9\u8CAC\u8CAB\u8CA8\u8CAA\u8CA7\u8D67\u8D66\u8DBE\u8DBA\u8EDB\u8EDF\u9019\u900D\u901A\u9017\u9023\u901F\u901D\u9010\u9015\u901E\u9020\u900F\u9022\u9016\u901B\u9014"],
      ["b3a1", "\u90E8\u90ED\u90FD\u9157\u91CE\u91F5\u91E6\u91E3\u91E7\u91ED\u91E9\u9589\u966A\u9675\u9673\u9678\u9670\u9674\u9676\u9677\u966C\u96C0\u96EA\u96E9\u7AE0\u7ADF\u9802\u9803\u9B5A\u9CE5\u9E75\u9E7F\u9EA5\u9EBB\u50A2\u508D\u5085\u5099\u5091\u5080\u5096\u5098\u509A\u6700\u51F1\u5272\u5274\u5275\u5269\u52DE\u52DD\u52DB\u535A\u53A5\u557B\u5580\u55A7\u557C\u558A\u559D\u5598\u5582\u559C\u55AA\u5594\u5587\u558B\u5583\u55B3\u55AE\u559F\u553E\u55B2\u559A\u55BB\u55AC\u55B1\u557E\u5589\u55AB\u5599\u570D\u582F\u582A\u5834\u5824\u5830\u5831\u5821\u581D\u5820\u58F9\u58FA\u5960"],
      ["b440", "\u5A77\u5A9A\u5A7F\u5A92\u5A9B\u5AA7\u5B73\u5B71\u5BD2\u5BCC\u5BD3\u5BD0\u5C0A\u5C0B\u5C31\u5D4C\u5D50\u5D34\u5D47\u5DFD\u5E45\u5E3D\u5E40\u5E43\u5E7E\u5ECA\u5EC1\u5EC2\u5EC4\u5F3C\u5F6D\u5FA9\u5FAA\u5FA8\u60D1\u60E1\u60B2\u60B6\u60E0\u611C\u6123\u60FA\u6115\u60F0\u60FB\u60F4\u6168\u60F1\u610E\u60F6\u6109\u6100\u6112\u621F\u6249\u63A3\u638C\u63CF\u63C0\u63E9\u63C9\u63C6\u63CD"],
      ["b4a1", "\u63D2\u63E3\u63D0\u63E1\u63D6\u63ED\u63EE\u6376\u63F4\u63EA\u63DB\u6452\u63DA\u63F9\u655E\u6566\u6562\u6563\u6591\u6590\u65AF\u666E\u6670\u6674\u6676\u666F\u6691\u667A\u667E\u6677\u66FE\u66FF\u671F\u671D\u68FA\u68D5\u68E0\u68D8\u68D7\u6905\u68DF\u68F5\u68EE\u68E7\u68F9\u68D2\u68F2\u68E3\u68CB\u68CD\u690D\u6912\u690E\u68C9\u68DA\u696E\u68FB\u6B3E\u6B3A\u6B3D\u6B98\u6B96\u6BBC\u6BEF\u6C2E\u6C2F\u6C2C\u6E2F\u6E38\u6E54\u6E21\u6E32\u6E67\u6E4A\u6E20\u6E25\u6E23\u6E1B\u6E5B\u6E58\u6E24\u6E56\u6E6E\u6E2D\u6E26\u6E6F\u6E34\u6E4D\u6E3A\u6E2C\u6E43\u6E1D\u6E3E\u6ECB"],
      ["b540", "\u6E89\u6E19\u6E4E\u6E63\u6E44\u6E72\u6E69\u6E5F\u7119\u711A\u7126\u7130\u7121\u7136\u716E\u711C\u724C\u7284\u7280\u7336\u7325\u7334\u7329\u743A\u742A\u7433\u7422\u7425\u7435\u7436\u7434\u742F\u741B\u7426\u7428\u7525\u7526\u756B\u756A\u75E2\u75DB\u75E3\u75D9\u75D8\u75DE\u75E0\u767B\u767C\u7696\u7693\u76B4\u76DC\u774F\u77ED\u785D\u786C\u786F\u7A0D\u7A08\u7A0B\u7A05\u7A00\u7A98"],
      ["b5a1", "\u7A97\u7A96\u7AE5\u7AE3\u7B49\u7B56\u7B46\u7B50\u7B52\u7B54\u7B4D\u7B4B\u7B4F\u7B51\u7C9F\u7CA5\u7D5E\u7D50\u7D68\u7D55\u7D2B\u7D6E\u7D72\u7D61\u7D66\u7D62\u7D70\u7D73\u5584\u7FD4\u7FD5\u800B\u8052\u8085\u8155\u8154\u814B\u8151\u814E\u8139\u8146\u813E\u814C\u8153\u8174\u8212\u821C\u83E9\u8403\u83F8\u840D\u83E0\u83C5\u840B\u83C1\u83EF\u83F1\u83F4\u8457\u840A\u83F0\u840C\u83CC\u83FD\u83F2\u83CA\u8438\u840E\u8404\u83DC\u8407\u83D4\u83DF\u865B\u86DF\u86D9\u86ED\u86D4\u86DB\u86E4\u86D0\u86DE\u8857\u88C1\u88C2\u88B1\u8983\u8996\u8A3B\u8A60\u8A55\u8A5E\u8A3C\u8A41"],
      ["b640", "\u8A54\u8A5B\u8A50\u8A46\u8A34\u8A3A\u8A36\u8A56\u8C61\u8C82\u8CAF\u8CBC\u8CB3\u8CBD\u8CC1\u8CBB\u8CC0\u8CB4\u8CB7\u8CB6\u8CBF\u8CB8\u8D8A\u8D85\u8D81\u8DCE\u8DDD\u8DCB\u8DDA\u8DD1\u8DCC\u8DDB\u8DC6\u8EFB\u8EF8\u8EFC\u8F9C\u902E\u9035\u9031\u9038\u9032\u9036\u9102\u90F5\u9109\u90FE\u9163\u9165\u91CF\u9214\u9215\u9223\u9209\u921E\u920D\u9210\u9207\u9211\u9594\u958F\u958B\u9591"],
      ["b6a1", "\u9593\u9592\u958E\u968A\u968E\u968B\u967D\u9685\u9686\u968D\u9672\u9684\u96C1\u96C5\u96C4\u96C6\u96C7\u96EF\u96F2\u97CC\u9805\u9806\u9808\u98E7\u98EA\u98EF\u98E9\u98F2\u98ED\u99AE\u99AD\u9EC3\u9ECD\u9ED1\u4E82\u50AD\u50B5\u50B2\u50B3\u50C5\u50BE\u50AC\u50B7\u50BB\u50AF\u50C7\u527F\u5277\u527D\u52DF\u52E6\u52E4\u52E2\u52E3\u532F\u55DF\u55E8\u55D3\u55E6\u55CE\u55DC\u55C7\u55D1\u55E3\u55E4\u55EF\u55DA\u55E1\u55C5\u55C6\u55E5\u55C9\u5712\u5713\u585E\u5851\u5858\u5857\u585A\u5854\u586B\u584C\u586D\u584A\u5862\u5852\u584B\u5967\u5AC1\u5AC9\u5ACC\u5ABE\u5ABD\u5ABC"],
      ["b740", "\u5AB3\u5AC2\u5AB2\u5D69\u5D6F\u5E4C\u5E79\u5EC9\u5EC8\u5F12\u5F59\u5FAC\u5FAE\u611A\u610F\u6148\u611F\u60F3\u611B\u60F9\u6101\u6108\u614E\u614C\u6144\u614D\u613E\u6134\u6127\u610D\u6106\u6137\u6221\u6222\u6413\u643E\u641E\u642A\u642D\u643D\u642C\u640F\u641C\u6414\u640D\u6436\u6416\u6417\u6406\u656C\u659F\u65B0\u6697\u6689\u6687\u6688\u6696\u6684\u6698\u668D\u6703\u6994\u696D"],
      ["b7a1", "\u695A\u6977\u6960\u6954\u6975\u6930\u6982\u694A\u6968\u696B\u695E\u6953\u6979\u6986\u695D\u6963\u695B\u6B47\u6B72\u6BC0\u6BBF\u6BD3\u6BFD\u6EA2\u6EAF\u6ED3\u6EB6\u6EC2\u6E90\u6E9D\u6EC7\u6EC5\u6EA5\u6E98\u6EBC\u6EBA\u6EAB\u6ED1\u6E96\u6E9C\u6EC4\u6ED4\u6EAA\u6EA7\u6EB4\u714E\u7159\u7169\u7164\u7149\u7167\u715C\u716C\u7166\u714C\u7165\u715E\u7146\u7168\u7156\u723A\u7252\u7337\u7345\u733F\u733E\u746F\u745A\u7455\u745F\u745E\u7441\u743F\u7459\u745B\u745C\u7576\u7578\u7600\u75F0\u7601\u75F2\u75F1\u75FA\u75FF\u75F4\u75F3\u76DE\u76DF\u775B\u776B\u7766\u775E\u7763"],
      ["b840", "\u7779\u776A\u776C\u775C\u7765\u7768\u7762\u77EE\u788E\u78B0\u7897\u7898\u788C\u7889\u787C\u7891\u7893\u787F\u797A\u797F\u7981\u842C\u79BD\u7A1C\u7A1A\u7A20\u7A14\u7A1F\u7A1E\u7A9F\u7AA0\u7B77\u7BC0\u7B60\u7B6E\u7B67\u7CB1\u7CB3\u7CB5\u7D93\u7D79\u7D91\u7D81\u7D8F\u7D5B\u7F6E\u7F69\u7F6A\u7F72\u7FA9\u7FA8\u7FA4\u8056\u8058\u8086\u8084\u8171\u8170\u8178\u8165\u816E\u8173\u816B"],
      ["b8a1", "\u8179\u817A\u8166\u8205\u8247\u8482\u8477\u843D\u8431\u8475\u8466\u846B\u8449\u846C\u845B\u843C\u8435\u8461\u8463\u8469\u846D\u8446\u865E\u865C\u865F\u86F9\u8713\u8708\u8707\u8700\u86FE\u86FB\u8702\u8703\u8706\u870A\u8859\u88DF\u88D4\u88D9\u88DC\u88D8\u88DD\u88E1\u88CA\u88D5\u88D2\u899C\u89E3\u8A6B\u8A72\u8A73\u8A66\u8A69\u8A70\u8A87\u8A7C\u8A63\u8AA0\u8A71\u8A85\u8A6D\u8A62\u8A6E\u8A6C\u8A79\u8A7B\u8A3E\u8A68\u8C62\u8C8A\u8C89\u8CCA\u8CC7\u8CC8\u8CC4\u8CB2\u8CC3\u8CC2\u8CC5\u8DE1\u8DDF\u8DE8\u8DEF\u8DF3\u8DFA\u8DEA\u8DE4\u8DE6\u8EB2\u8F03\u8F09\u8EFE\u8F0A"],
      ["b940", "\u8F9F\u8FB2\u904B\u904A\u9053\u9042\u9054\u903C\u9055\u9050\u9047\u904F\u904E\u904D\u9051\u903E\u9041\u9112\u9117\u916C\u916A\u9169\u91C9\u9237\u9257\u9238\u923D\u9240\u923E\u925B\u924B\u9264\u9251\u9234\u9249\u924D\u9245\u9239\u923F\u925A\u9598\u9698\u9694\u9695\u96CD\u96CB\u96C9\u96CA\u96F7\u96FB\u96F9\u96F6\u9756\u9774\u9776\u9810\u9811\u9813\u980A\u9812\u980C\u98FC\u98F4"],
      ["b9a1", "\u98FD\u98FE\u99B3\u99B1\u99B4\u9AE1\u9CE9\u9E82\u9F0E\u9F13\u9F20\u50E7\u50EE\u50E5\u50D6\u50ED\u50DA\u50D5\u50CF\u50D1\u50F1\u50CE\u50E9\u5162\u51F3\u5283\u5282\u5331\u53AD\u55FE\u5600\u561B\u5617\u55FD\u5614\u5606\u5609\u560D\u560E\u55F7\u5616\u561F\u5608\u5610\u55F6\u5718\u5716\u5875\u587E\u5883\u5893\u588A\u5879\u5885\u587D\u58FD\u5925\u5922\u5924\u596A\u5969\u5AE1\u5AE6\u5AE9\u5AD7\u5AD6\u5AD8\u5AE3\u5B75\u5BDE\u5BE7\u5BE1\u5BE5\u5BE6\u5BE8\u5BE2\u5BE4\u5BDF\u5C0D\u5C62\u5D84\u5D87\u5E5B\u5E63\u5E55\u5E57\u5E54\u5ED3\u5ED6\u5F0A\u5F46\u5F70\u5FB9\u6147"],
      ["ba40", "\u613F\u614B\u6177\u6162\u6163\u615F\u615A\u6158\u6175\u622A\u6487\u6458\u6454\u64A4\u6478\u645F\u647A\u6451\u6467\u6434\u646D\u647B\u6572\u65A1\u65D7\u65D6\u66A2\u66A8\u669D\u699C\u69A8\u6995\u69C1\u69AE\u69D3\u69CB\u699B\u69B7\u69BB\u69AB\u69B4\u69D0\u69CD\u69AD\u69CC\u69A6\u69C3\u69A3\u6B49\u6B4C\u6C33\u6F33\u6F14\u6EFE\u6F13\u6EF4\u6F29\u6F3E\u6F20\u6F2C\u6F0F\u6F02\u6F22"],
      ["baa1", "\u6EFF\u6EEF\u6F06\u6F31\u6F38\u6F32\u6F23\u6F15\u6F2B\u6F2F\u6F88\u6F2A\u6EEC\u6F01\u6EF2\u6ECC\u6EF7\u7194\u7199\u717D\u718A\u7184\u7192\u723E\u7292\u7296\u7344\u7350\u7464\u7463\u746A\u7470\u746D\u7504\u7591\u7627\u760D\u760B\u7609\u7613\u76E1\u76E3\u7784\u777D\u777F\u7761\u78C1\u789F\u78A7\u78B3\u78A9\u78A3\u798E\u798F\u798D\u7A2E\u7A31\u7AAA\u7AA9\u7AED\u7AEF\u7BA1\u7B95\u7B8B\u7B75\u7B97\u7B9D\u7B94\u7B8F\u7BB8\u7B87\u7B84\u7CB9\u7CBD\u7CBE\u7DBB\u7DB0\u7D9C\u7DBD\u7DBE\u7DA0\u7DCA\u7DB4\u7DB2\u7DB1\u7DBA\u7DA2\u7DBF\u7DB5\u7DB8\u7DAD\u7DD2\u7DC7\u7DAC"],
      ["bb40", "\u7F70\u7FE0\u7FE1\u7FDF\u805E\u805A\u8087\u8150\u8180\u818F\u8188\u818A\u817F\u8182\u81E7\u81FA\u8207\u8214\u821E\u824B\u84C9\u84BF\u84C6\u84C4\u8499\u849E\u84B2\u849C\u84CB\u84B8\u84C0\u84D3\u8490\u84BC\u84D1\u84CA\u873F\u871C\u873B\u8722\u8725\u8734\u8718\u8755\u8737\u8729\u88F3\u8902\u88F4\u88F9\u88F8\u88FD\u88E8\u891A\u88EF\u8AA6\u8A8C\u8A9E\u8AA3\u8A8D\u8AA1\u8A93\u8AA4"],
      ["bba1", "\u8AAA\u8AA5\u8AA8\u8A98\u8A91\u8A9A\u8AA7\u8C6A\u8C8D\u8C8C\u8CD3\u8CD1\u8CD2\u8D6B\u8D99\u8D95\u8DFC\u8F14\u8F12\u8F15\u8F13\u8FA3\u9060\u9058\u905C\u9063\u9059\u905E\u9062\u905D\u905B\u9119\u9118\u911E\u9175\u9178\u9177\u9174\u9278\u9280\u9285\u9298\u9296\u927B\u9293\u929C\u92A8\u927C\u9291\u95A1\u95A8\u95A9\u95A3\u95A5\u95A4\u9699\u969C\u969B\u96CC\u96D2\u9700\u977C\u9785\u97F6\u9817\u9818\u98AF\u98B1\u9903\u9905\u990C\u9909\u99C1\u9AAF\u9AB0\u9AE6\u9B41\u9B42\u9CF4\u9CF6\u9CF3\u9EBC\u9F3B\u9F4A\u5104\u5100\u50FB\u50F5\u50F9\u5102\u5108\u5109\u5105\u51DC"],
      ["bc40", "\u5287\u5288\u5289\u528D\u528A\u52F0\u53B2\u562E\u563B\u5639\u5632\u563F\u5634\u5629\u5653\u564E\u5657\u5674\u5636\u562F\u5630\u5880\u589F\u589E\u58B3\u589C\u58AE\u58A9\u58A6\u596D\u5B09\u5AFB\u5B0B\u5AF5\u5B0C\u5B08\u5BEE\u5BEC\u5BE9\u5BEB\u5C64\u5C65\u5D9D\u5D94\u5E62\u5E5F\u5E61\u5EE2\u5EDA\u5EDF\u5EDD\u5EE3\u5EE0\u5F48\u5F71\u5FB7\u5FB5\u6176\u6167\u616E\u615D\u6155\u6182"],
      ["bca1", "\u617C\u6170\u616B\u617E\u61A7\u6190\u61AB\u618E\u61AC\u619A\u61A4\u6194\u61AE\u622E\u6469\u646F\u6479\u649E\u64B2\u6488\u6490\u64B0\u64A5\u6493\u6495\u64A9\u6492\u64AE\u64AD\u64AB\u649A\u64AC\u6499\u64A2\u64B3\u6575\u6577\u6578\u66AE\u66AB\u66B4\u66B1\u6A23\u6A1F\u69E8\u6A01\u6A1E\u6A19\u69FD\u6A21\u6A13\u6A0A\u69F3\u6A02\u6A05\u69ED\u6A11\u6B50\u6B4E\u6BA4\u6BC5\u6BC6\u6F3F\u6F7C\u6F84\u6F51\u6F66\u6F54\u6F86\u6F6D\u6F5B\u6F78\u6F6E\u6F8E\u6F7A\u6F70\u6F64\u6F97\u6F58\u6ED5\u6F6F\u6F60\u6F5F\u719F\u71AC\u71B1\u71A8\u7256\u729B\u734E\u7357\u7469\u748B\u7483"],
      ["bd40", "\u747E\u7480\u757F\u7620\u7629\u761F\u7624\u7626\u7621\u7622\u769A\u76BA\u76E4\u778E\u7787\u778C\u7791\u778B\u78CB\u78C5\u78BA\u78CA\u78BE\u78D5\u78BC\u78D0\u7A3F\u7A3C\u7A40\u7A3D\u7A37\u7A3B\u7AAF\u7AAE\u7BAD\u7BB1\u7BC4\u7BB4\u7BC6\u7BC7\u7BC1\u7BA0\u7BCC\u7CCA\u7DE0\u7DF4\u7DEF\u7DFB\u7DD8\u7DEC\u7DDD\u7DE8\u7DE3\u7DDA\u7DDE\u7DE9\u7D9E\u7DD9\u7DF2\u7DF9\u7F75\u7F77\u7FAF"],
      ["bda1", "\u7FE9\u8026\u819B\u819C\u819D\u81A0\u819A\u8198\u8517\u853D\u851A\u84EE\u852C\u852D\u8513\u8511\u8523\u8521\u8514\u84EC\u8525\u84FF\u8506\u8782\u8774\u8776\u8760\u8766\u8778\u8768\u8759\u8757\u874C\u8753\u885B\u885D\u8910\u8907\u8912\u8913\u8915\u890A\u8ABC\u8AD2\u8AC7\u8AC4\u8A95\u8ACB\u8AF8\u8AB2\u8AC9\u8AC2\u8ABF\u8AB0\u8AD6\u8ACD\u8AB6\u8AB9\u8ADB\u8C4C\u8C4E\u8C6C\u8CE0\u8CDE\u8CE6\u8CE4\u8CEC\u8CED\u8CE2\u8CE3\u8CDC\u8CEA\u8CE1\u8D6D\u8D9F\u8DA3\u8E2B\u8E10\u8E1D\u8E22\u8E0F\u8E29\u8E1F\u8E21\u8E1E\u8EBA\u8F1D\u8F1B\u8F1F\u8F29\u8F26\u8F2A\u8F1C\u8F1E"],
      ["be40", "\u8F25\u9069\u906E\u9068\u906D\u9077\u9130\u912D\u9127\u9131\u9187\u9189\u918B\u9183\u92C5\u92BB\u92B7\u92EA\u92AC\u92E4\u92C1\u92B3\u92BC\u92D2\u92C7\u92F0\u92B2\u95AD\u95B1\u9704\u9706\u9707\u9709\u9760\u978D\u978B\u978F\u9821\u982B\u981C\u98B3\u990A\u9913\u9912\u9918\u99DD\u99D0\u99DF\u99DB\u99D1\u99D5\u99D2\u99D9\u9AB7\u9AEE\u9AEF\u9B27\u9B45\u9B44\u9B77\u9B6F\u9D06\u9D09"],
      ["bea1", "\u9D03\u9EA9\u9EBE\u9ECE\u58A8\u9F52\u5112\u5118\u5114\u5110\u5115\u5180\u51AA\u51DD\u5291\u5293\u52F3\u5659\u566B\u5679\u5669\u5664\u5678\u566A\u5668\u5665\u5671\u566F\u566C\u5662\u5676\u58C1\u58BE\u58C7\u58C5\u596E\u5B1D\u5B34\u5B78\u5BF0\u5C0E\u5F4A\u61B2\u6191\u61A9\u618A\u61CD\u61B6\u61BE\u61CA\u61C8\u6230\u64C5\u64C1\u64CB\u64BB\u64BC\u64DA\u64C4\u64C7\u64C2\u64CD\u64BF\u64D2\u64D4\u64BE\u6574\u66C6\u66C9\u66B9\u66C4\u66C7\u66B8\u6A3D\u6A38\u6A3A\u6A59\u6A6B\u6A58\u6A39\u6A44\u6A62\u6A61\u6A4B\u6A47\u6A35\u6A5F\u6A48\u6B59\u6B77\u6C05\u6FC2\u6FB1\u6FA1"],
      ["bf40", "\u6FC3\u6FA4\u6FC1\u6FA7\u6FB3\u6FC0\u6FB9\u6FB6\u6FA6\u6FA0\u6FB4\u71BE\u71C9\u71D0\u71D2\u71C8\u71D5\u71B9\u71CE\u71D9\u71DC\u71C3\u71C4\u7368\u749C\u74A3\u7498\u749F\u749E\u74E2\u750C\u750D\u7634\u7638\u763A\u76E7\u76E5\u77A0\u779E\u779F\u77A5\u78E8\u78DA\u78EC\u78E7\u79A6\u7A4D\u7A4E\u7A46\u7A4C\u7A4B\u7ABA\u7BD9\u7C11\u7BC9\u7BE4\u7BDB\u7BE1\u7BE9\u7BE6\u7CD5\u7CD6\u7E0A"],
      ["bfa1", "\u7E11\u7E08\u7E1B\u7E23\u7E1E\u7E1D\u7E09\u7E10\u7F79\u7FB2\u7FF0\u7FF1\u7FEE\u8028\u81B3\u81A9\u81A8\u81FB\u8208\u8258\u8259\u854A\u8559\u8548\u8568\u8569\u8543\u8549\u856D\u856A\u855E\u8783\u879F\u879E\u87A2\u878D\u8861\u892A\u8932\u8925\u892B\u8921\u89AA\u89A6\u8AE6\u8AFA\u8AEB\u8AF1\u8B00\u8ADC\u8AE7\u8AEE\u8AFE\u8B01\u8B02\u8AF7\u8AED\u8AF3\u8AF6\u8AFC\u8C6B\u8C6D\u8C93\u8CF4\u8E44\u8E31\u8E34\u8E42\u8E39\u8E35\u8F3B\u8F2F\u8F38\u8F33\u8FA8\u8FA6\u9075\u9074\u9078\u9072\u907C\u907A\u9134\u9192\u9320\u9336\u92F8\u9333\u932F\u9322\u92FC\u932B\u9304\u931A"],
      ["c040", "\u9310\u9326\u9321\u9315\u932E\u9319\u95BB\u96A7\u96A8\u96AA\u96D5\u970E\u9711\u9716\u970D\u9713\u970F\u975B\u975C\u9766\u9798\u9830\u9838\u983B\u9837\u982D\u9839\u9824\u9910\u9928\u991E\u991B\u9921\u991A\u99ED\u99E2\u99F1\u9AB8\u9ABC\u9AFB\u9AED\u9B28\u9B91\u9D15\u9D23\u9D26\u9D28\u9D12\u9D1B\u9ED8\u9ED4\u9F8D\u9F9C\u512A\u511F\u5121\u5132\u52F5\u568E\u5680\u5690\u5685\u5687"],
      ["c0a1", "\u568F\u58D5\u58D3\u58D1\u58CE\u5B30\u5B2A\u5B24\u5B7A\u5C37\u5C68\u5DBC\u5DBA\u5DBD\u5DB8\u5E6B\u5F4C\u5FBD\u61C9\u61C2\u61C7\u61E6\u61CB\u6232\u6234\u64CE\u64CA\u64D8\u64E0\u64F0\u64E6\u64EC\u64F1\u64E2\u64ED\u6582\u6583\u66D9\u66D6\u6A80\u6A94\u6A84\u6AA2\u6A9C\u6ADB\u6AA3\u6A7E\u6A97\u6A90\u6AA0\u6B5C\u6BAE\u6BDA\u6C08\u6FD8\u6FF1\u6FDF\u6FE0\u6FDB\u6FE4\u6FEB\u6FEF\u6F80\u6FEC\u6FE1\u6FE9\u6FD5\u6FEE\u6FF0\u71E7\u71DF\u71EE\u71E6\u71E5\u71ED\u71EC\u71F4\u71E0\u7235\u7246\u7370\u7372\u74A9\u74B0\u74A6\u74A8\u7646\u7642\u764C\u76EA\u77B3\u77AA\u77B0\u77AC"],
      ["c140", "\u77A7\u77AD\u77EF\u78F7\u78FA\u78F4\u78EF\u7901\u79A7\u79AA\u7A57\u7ABF\u7C07\u7C0D\u7BFE\u7BF7\u7C0C\u7BE0\u7CE0\u7CDC\u7CDE\u7CE2\u7CDF\u7CD9\u7CDD\u7E2E\u7E3E\u7E46\u7E37\u7E32\u7E43\u7E2B\u7E3D\u7E31\u7E45\u7E41\u7E34\u7E39\u7E48\u7E35\u7E3F\u7E2F\u7F44\u7FF3\u7FFC\u8071\u8072\u8070\u806F\u8073\u81C6\u81C3\u81BA\u81C2\u81C0\u81BF\u81BD\u81C9\u81BE\u81E8\u8209\u8271\u85AA"],
      ["c1a1", "\u8584\u857E\u859C\u8591\u8594\u85AF\u859B\u8587\u85A8\u858A\u8667\u87C0\u87D1\u87B3\u87D2\u87C6\u87AB\u87BB\u87BA\u87C8\u87CB\u893B\u8936\u8944\u8938\u893D\u89AC\u8B0E\u8B17\u8B19\u8B1B\u8B0A\u8B20\u8B1D\u8B04\u8B10\u8C41\u8C3F\u8C73\u8CFA\u8CFD\u8CFC\u8CF8\u8CFB\u8DA8\u8E49\u8E4B\u8E48\u8E4A\u8F44\u8F3E\u8F42\u8F45\u8F3F\u907F\u907D\u9084\u9081\u9082\u9080\u9139\u91A3\u919E\u919C\u934D\u9382\u9328\u9375\u934A\u9365\u934B\u9318\u937E\u936C\u935B\u9370\u935A\u9354\u95CA\u95CB\u95CC\u95C8\u95C6\u96B1\u96B8\u96D6\u971C\u971E\u97A0\u97D3\u9846\u98B6\u9935\u9A01"],
      ["c240", "\u99FF\u9BAE\u9BAB\u9BAA\u9BAD\u9D3B\u9D3F\u9E8B\u9ECF\u9EDE\u9EDC\u9EDD\u9EDB\u9F3E\u9F4B\u53E2\u5695\u56AE\u58D9\u58D8\u5B38\u5F5D\u61E3\u6233\u64F4\u64F2\u64FE\u6506\u64FA\u64FB\u64F7\u65B7\u66DC\u6726\u6AB3\u6AAC\u6AC3\u6ABB\u6AB8\u6AC2\u6AAE\u6AAF\u6B5F\u6B78\u6BAF\u7009\u700B\u6FFE\u7006\u6FFA\u7011\u700F\u71FB\u71FC\u71FE\u71F8\u7377\u7375\u74A7\u74BF\u7515\u7656\u7658"],
      ["c2a1", "\u7652\u77BD\u77BF\u77BB\u77BC\u790E\u79AE\u7A61\u7A62\u7A60\u7AC4\u7AC5\u7C2B\u7C27\u7C2A\u7C1E\u7C23\u7C21\u7CE7\u7E54\u7E55\u7E5E\u7E5A\u7E61\u7E52\u7E59\u7F48\u7FF9\u7FFB\u8077\u8076\u81CD\u81CF\u820A\u85CF\u85A9\u85CD\u85D0\u85C9\u85B0\u85BA\u85B9\u85A6\u87EF\u87EC\u87F2\u87E0\u8986\u89B2\u89F4\u8B28\u8B39\u8B2C\u8B2B\u8C50\u8D05\u8E59\u8E63\u8E66\u8E64\u8E5F\u8E55\u8EC0\u8F49\u8F4D\u9087\u9083\u9088\u91AB\u91AC\u91D0\u9394\u938A\u9396\u93A2\u93B3\u93AE\u93AC\u93B0\u9398\u939A\u9397\u95D4\u95D6\u95D0\u95D5\u96E2\u96DC\u96D9\u96DB\u96DE\u9724\u97A3\u97A6"],
      ["c340", "\u97AD\u97F9\u984D\u984F\u984C\u984E\u9853\u98BA\u993E\u993F\u993D\u992E\u99A5\u9A0E\u9AC1\u9B03\u9B06\u9B4F\u9B4E\u9B4D\u9BCA\u9BC9\u9BFD\u9BC8\u9BC0\u9D51\u9D5D\u9D60\u9EE0\u9F15\u9F2C\u5133\u56A5\u58DE\u58DF\u58E2\u5BF5\u9F90\u5EEC\u61F2\u61F7\u61F6\u61F5\u6500\u650F\u66E0\u66DD\u6AE5\u6ADD\u6ADA\u6AD3\u701B\u701F\u7028\u701A\u701D\u7015\u7018\u7206\u720D\u7258\u72A2\u7378"],
      ["c3a1", "\u737A\u74BD\u74CA\u74E3\u7587\u7586\u765F\u7661\u77C7\u7919\u79B1\u7A6B\u7A69\u7C3E\u7C3F\u7C38\u7C3D\u7C37\u7C40\u7E6B\u7E6D\u7E79\u7E69\u7E6A\u7F85\u7E73\u7FB6\u7FB9\u7FB8\u81D8\u85E9\u85DD\u85EA\u85D5\u85E4\u85E5\u85F7\u87FB\u8805\u880D\u87F9\u87FE\u8960\u895F\u8956\u895E\u8B41\u8B5C\u8B58\u8B49\u8B5A\u8B4E\u8B4F\u8B46\u8B59\u8D08\u8D0A\u8E7C\u8E72\u8E87\u8E76\u8E6C\u8E7A\u8E74\u8F54\u8F4E\u8FAD\u908A\u908B\u91B1\u91AE\u93E1\u93D1\u93DF\u93C3\u93C8\u93DC\u93DD\u93D6\u93E2\u93CD\u93D8\u93E4\u93D7\u93E8\u95DC\u96B4\u96E3\u972A\u9727\u9761\u97DC\u97FB\u985E"],
      ["c440", "\u9858\u985B\u98BC\u9945\u9949\u9A16\u9A19\u9B0D\u9BE8\u9BE7\u9BD6\u9BDB\u9D89\u9D61\u9D72\u9D6A\u9D6C\u9E92\u9E97\u9E93\u9EB4\u52F8\u56A8\u56B7\u56B6\u56B4\u56BC\u58E4\u5B40\u5B43\u5B7D\u5BF6\u5DC9\u61F8\u61FA\u6518\u6514\u6519\u66E6\u6727\u6AEC\u703E\u7030\u7032\u7210\u737B\u74CF\u7662\u7665\u7926\u792A\u792C\u792B\u7AC7\u7AF6\u7C4C\u7C43\u7C4D\u7CEF\u7CF0\u8FAE\u7E7D\u7E7C"],
      ["c4a1", "\u7E82\u7F4C\u8000\u81DA\u8266\u85FB\u85F9\u8611\u85FA\u8606\u860B\u8607\u860A\u8814\u8815\u8964\u89BA\u89F8\u8B70\u8B6C\u8B66\u8B6F\u8B5F\u8B6B\u8D0F\u8D0D\u8E89\u8E81\u8E85\u8E82\u91B4\u91CB\u9418\u9403\u93FD\u95E1\u9730\u98C4\u9952\u9951\u99A8\u9A2B\u9A30\u9A37\u9A35\u9C13\u9C0D\u9E79\u9EB5\u9EE8\u9F2F\u9F5F\u9F63\u9F61\u5137\u5138\u56C1\u56C0\u56C2\u5914\u5C6C\u5DCD\u61FC\u61FE\u651D\u651C\u6595\u66E9\u6AFB\u6B04\u6AFA\u6BB2\u704C\u721B\u72A7\u74D6\u74D4\u7669\u77D3\u7C50\u7E8F\u7E8C\u7FBC\u8617\u862D\u861A\u8823\u8822\u8821\u881F\u896A\u896C\u89BD\u8B74"],
      ["c540", "\u8B77\u8B7D\u8D13\u8E8A\u8E8D\u8E8B\u8F5F\u8FAF\u91BA\u942E\u9433\u9435\u943A\u9438\u9432\u942B\u95E2\u9738\u9739\u9732\u97FF\u9867\u9865\u9957\u9A45\u9A43\u9A40\u9A3E\u9ACF\u9B54\u9B51\u9C2D\u9C25\u9DAF\u9DB4\u9DC2\u9DB8\u9E9D\u9EEF\u9F19\u9F5C\u9F66\u9F67\u513C\u513B\u56C8\u56CA\u56C9\u5B7F\u5DD4\u5DD2\u5F4E\u61FF\u6524\u6B0A\u6B61\u7051\u7058\u7380\u74E4\u758A\u766E\u766C"],
      ["c5a1", "\u79B3\u7C60\u7C5F\u807E\u807D\u81DF\u8972\u896F\u89FC\u8B80\u8D16\u8D17\u8E91\u8E93\u8F61\u9148\u9444\u9451\u9452\u973D\u973E\u97C3\u97C1\u986B\u9955\u9A55\u9A4D\u9AD2\u9B1A\u9C49\u9C31\u9C3E\u9C3B\u9DD3\u9DD7\u9F34\u9F6C\u9F6A\u9F94\u56CC\u5DD6\u6200\u6523\u652B\u652A\u66EC\u6B10\u74DA\u7ACA\u7C64\u7C63\u7C65\u7E93\u7E96\u7E94\u81E2\u8638\u863F\u8831\u8B8A\u9090\u908F\u9463\u9460\u9464\u9768\u986F\u995C\u9A5A\u9A5B\u9A57\u9AD3\u9AD4\u9AD1\u9C54\u9C57\u9C56\u9DE5\u9E9F\u9EF4\u56D1\u58E9\u652C\u705E\u7671\u7672\u77D7\u7F50\u7F88\u8836\u8839\u8862\u8B93\u8B92"],
      ["c640", "\u8B96\u8277\u8D1B\u91C0\u946A\u9742\u9748\u9744\u97C6\u9870\u9A5F\u9B22\u9B58\u9C5F\u9DF9\u9DFA\u9E7C\u9E7D\u9F07\u9F77\u9F72\u5EF3\u6B16\u7063\u7C6C\u7C6E\u883B\u89C0\u8EA1\u91C1\u9472\u9470\u9871\u995E\u9AD6\u9B23\u9ECC\u7064\u77DA\u8B9A\u9477\u97C9\u9A62\u9A65\u7E9C\u8B9C\u8EAA\u91C5\u947D\u947E\u947C\u9C77\u9C78\u9EF7\u8C54\u947F\u9E1A\u7228\u9A6A\u9B31\u9E1B\u9E1E\u7C72"],
      ["c940", "\u4E42\u4E5C\u51F5\u531A\u5382\u4E07\u4E0C\u4E47\u4E8D\u56D7\uFA0C\u5C6E\u5F73\u4E0F\u5187\u4E0E\u4E2E\u4E93\u4EC2\u4EC9\u4EC8\u5198\u52FC\u536C\u53B9\u5720\u5903\u592C\u5C10\u5DFF\u65E1\u6BB3\u6BCC\u6C14\u723F\u4E31\u4E3C\u4EE8\u4EDC\u4EE9\u4EE1\u4EDD\u4EDA\u520C\u531C\u534C\u5722\u5723\u5917\u592F\u5B81\u5B84\u5C12\u5C3B\u5C74\u5C73\u5E04\u5E80\u5E82\u5FC9\u6209\u6250\u6C15"],
      ["c9a1", "\u6C36\u6C43\u6C3F\u6C3B\u72AE\u72B0\u738A\u79B8\u808A\u961E\u4F0E\u4F18\u4F2C\u4EF5\u4F14\u4EF1\u4F00\u4EF7\u4F08\u4F1D\u4F02\u4F05\u4F22\u4F13\u4F04\u4EF4\u4F12\u51B1\u5213\u5209\u5210\u52A6\u5322\u531F\u534D\u538A\u5407\u56E1\u56DF\u572E\u572A\u5734\u593C\u5980\u597C\u5985\u597B\u597E\u5977\u597F\u5B56\u5C15\u5C25\u5C7C\u5C7A\u5C7B\u5C7E\u5DDF\u5E75\u5E84\u5F02\u5F1A\u5F74\u5FD5\u5FD4\u5FCF\u625C\u625E\u6264\u6261\u6266\u6262\u6259\u6260\u625A\u6265\u65EF\u65EE\u673E\u6739\u6738\u673B\u673A\u673F\u673C\u6733\u6C18\u6C46\u6C52\u6C5C\u6C4F\u6C4A\u6C54\u6C4B"],
      ["ca40", "\u6C4C\u7071\u725E\u72B4\u72B5\u738E\u752A\u767F\u7A75\u7F51\u8278\u827C\u8280\u827D\u827F\u864D\u897E\u9099\u9097\u9098\u909B\u9094\u9622\u9624\u9620\u9623\u4F56\u4F3B\u4F62\u4F49\u4F53\u4F64\u4F3E\u4F67\u4F52\u4F5F\u4F41\u4F58\u4F2D\u4F33\u4F3F\u4F61\u518F\u51B9\u521C\u521E\u5221\u52AD\u52AE\u5309\u5363\u5372\u538E\u538F\u5430\u5437\u542A\u5454\u5445\u5419\u541C\u5425\u5418"],
      ["caa1", "\u543D\u544F\u5441\u5428\u5424\u5447\u56EE\u56E7\u56E5\u5741\u5745\u574C\u5749\u574B\u5752\u5906\u5940\u59A6\u5998\u59A0\u5997\u598E\u59A2\u5990\u598F\u59A7\u59A1\u5B8E\u5B92\u5C28\u5C2A\u5C8D\u5C8F\u5C88\u5C8B\u5C89\u5C92\u5C8A\u5C86\u5C93\u5C95\u5DE0\u5E0A\u5E0E\u5E8B\u5E89\u5E8C\u5E88\u5E8D\u5F05\u5F1D\u5F78\u5F76\u5FD2\u5FD1\u5FD0\u5FED\u5FE8\u5FEE\u5FF3\u5FE1\u5FE4\u5FE3\u5FFA\u5FEF\u5FF7\u5FFB\u6000\u5FF4\u623A\u6283\u628C\u628E\u628F\u6294\u6287\u6271\u627B\u627A\u6270\u6281\u6288\u6277\u627D\u6272\u6274\u6537\u65F0\u65F4\u65F3\u65F2\u65F5\u6745\u6747"],
      ["cb40", "\u6759\u6755\u674C\u6748\u675D\u674D\u675A\u674B\u6BD0\u6C19\u6C1A\u6C78\u6C67\u6C6B\u6C84\u6C8B\u6C8F\u6C71\u6C6F\u6C69\u6C9A\u6C6D\u6C87\u6C95\u6C9C\u6C66\u6C73\u6C65\u6C7B\u6C8E\u7074\u707A\u7263\u72BF\u72BD\u72C3\u72C6\u72C1\u72BA\u72C5\u7395\u7397\u7393\u7394\u7392\u753A\u7539\u7594\u7595\u7681\u793D\u8034\u8095\u8099\u8090\u8092\u809C\u8290\u828F\u8285\u828E\u8291\u8293"],
      ["cba1", "\u828A\u8283\u8284\u8C78\u8FC9\u8FBF\u909F\u90A1\u90A5\u909E\u90A7\u90A0\u9630\u9628\u962F\u962D\u4E33\u4F98\u4F7C\u4F85\u4F7D\u4F80\u4F87\u4F76\u4F74\u4F89\u4F84\u4F77\u4F4C\u4F97\u4F6A\u4F9A\u4F79\u4F81\u4F78\u4F90\u4F9C\u4F94\u4F9E\u4F92\u4F82\u4F95\u4F6B\u4F6E\u519E\u51BC\u51BE\u5235\u5232\u5233\u5246\u5231\u52BC\u530A\u530B\u533C\u5392\u5394\u5487\u547F\u5481\u5491\u5482\u5488\u546B\u547A\u547E\u5465\u546C\u5474\u5466\u548D\u546F\u5461\u5460\u5498\u5463\u5467\u5464\u56F7\u56F9\u576F\u5772\u576D\u576B\u5771\u5770\u5776\u5780\u5775\u577B\u5773\u5774\u5762"],
      ["cc40", "\u5768\u577D\u590C\u5945\u59B5\u59BA\u59CF\u59CE\u59B2\u59CC\u59C1\u59B6\u59BC\u59C3\u59D6\u59B1\u59BD\u59C0\u59C8\u59B4\u59C7\u5B62\u5B65\u5B93\u5B95\u5C44\u5C47\u5CAE\u5CA4\u5CA0\u5CB5\u5CAF\u5CA8\u5CAC\u5C9F\u5CA3\u5CAD\u5CA2\u5CAA\u5CA7\u5C9D\u5CA5\u5CB6\u5CB0\u5CA6\u5E17\u5E14\u5E19\u5F28\u5F22\u5F23\u5F24\u5F54\u5F82\u5F7E\u5F7D\u5FDE\u5FE5\u602D\u6026\u6019\u6032\u600B"],
      ["cca1", "\u6034\u600A\u6017\u6033\u601A\u601E\u602C\u6022\u600D\u6010\u602E\u6013\u6011\u600C\u6009\u601C\u6214\u623D\u62AD\u62B4\u62D1\u62BE\u62AA\u62B6\u62CA\u62AE\u62B3\u62AF\u62BB\u62A9\u62B0\u62B8\u653D\u65A8\u65BB\u6609\u65FC\u6604\u6612\u6608\u65FB\u6603\u660B\u660D\u6605\u65FD\u6611\u6610\u66F6\u670A\u6785\u676C\u678E\u6792\u6776\u677B\u6798\u6786\u6784\u6774\u678D\u678C\u677A\u679F\u6791\u6799\u6783\u677D\u6781\u6778\u6779\u6794\u6B25\u6B80\u6B7E\u6BDE\u6C1D\u6C93\u6CEC\u6CEB\u6CEE\u6CD9\u6CB6\u6CD4\u6CAD\u6CE7\u6CB7\u6CD0\u6CC2\u6CBA\u6CC3\u6CC6\u6CED\u6CF2"],
      ["cd40", "\u6CD2\u6CDD\u6CB4\u6C8A\u6C9D\u6C80\u6CDE\u6CC0\u6D30\u6CCD\u6CC7\u6CB0\u6CF9\u6CCF\u6CE9\u6CD1\u7094\u7098\u7085\u7093\u7086\u7084\u7091\u7096\u7082\u709A\u7083\u726A\u72D6\u72CB\u72D8\u72C9\u72DC\u72D2\u72D4\u72DA\u72CC\u72D1\u73A4\u73A1\u73AD\u73A6\u73A2\u73A0\u73AC\u739D\u74DD\u74E8\u753F\u7540\u753E\u758C\u7598\u76AF\u76F3\u76F1\u76F0\u76F5\u77F8\u77FC\u77F9\u77FB\u77FA"],
      ["cda1", "\u77F7\u7942\u793F\u79C5\u7A78\u7A7B\u7AFB\u7C75\u7CFD\u8035\u808F\u80AE\u80A3\u80B8\u80B5\u80AD\u8220\u82A0\u82C0\u82AB\u829A\u8298\u829B\u82B5\u82A7\u82AE\u82BC\u829E\u82BA\u82B4\u82A8\u82A1\u82A9\u82C2\u82A4\u82C3\u82B6\u82A2\u8670\u866F\u866D\u866E\u8C56\u8FD2\u8FCB\u8FD3\u8FCD\u8FD6\u8FD5\u8FD7\u90B2\u90B4\u90AF\u90B3\u90B0\u9639\u963D\u963C\u963A\u9643\u4FCD\u4FC5\u4FD3\u4FB2\u4FC9\u4FCB\u4FC1\u4FD4\u4FDC\u4FD9\u4FBB\u4FB3\u4FDB\u4FC7\u4FD6\u4FBA\u4FC0\u4FB9\u4FEC\u5244\u5249\u52C0\u52C2\u533D\u537C\u5397\u5396\u5399\u5398\u54BA\u54A1\u54AD\u54A5\u54CF"],
      ["ce40", "\u54C3\u830D\u54B7\u54AE\u54D6\u54B6\u54C5\u54C6\u54A0\u5470\u54BC\u54A2\u54BE\u5472\u54DE\u54B0\u57B5\u579E\u579F\u57A4\u578C\u5797\u579D\u579B\u5794\u5798\u578F\u5799\u57A5\u579A\u5795\u58F4\u590D\u5953\u59E1\u59DE\u59EE\u5A00\u59F1\u59DD\u59FA\u59FD\u59FC\u59F6\u59E4\u59F2\u59F7\u59DB\u59E9\u59F3\u59F5\u59E0\u59FE\u59F4\u59ED\u5BA8\u5C4C\u5CD0\u5CD8\u5CCC\u5CD7\u5CCB\u5CDB"],
      ["cea1", "\u5CDE\u5CDA\u5CC9\u5CC7\u5CCA\u5CD6\u5CD3\u5CD4\u5CCF\u5CC8\u5CC6\u5CCE\u5CDF\u5CF8\u5DF9\u5E21\u5E22\u5E23\u5E20\u5E24\u5EB0\u5EA4\u5EA2\u5E9B\u5EA3\u5EA5\u5F07\u5F2E\u5F56\u5F86\u6037\u6039\u6054\u6072\u605E\u6045\u6053\u6047\u6049\u605B\u604C\u6040\u6042\u605F\u6024\u6044\u6058\u6066\u606E\u6242\u6243\u62CF\u630D\u630B\u62F5\u630E\u6303\u62EB\u62F9\u630F\u630C\u62F8\u62F6\u6300\u6313\u6314\u62FA\u6315\u62FB\u62F0\u6541\u6543\u65AA\u65BF\u6636\u6621\u6632\u6635\u661C\u6626\u6622\u6633\u662B\u663A\u661D\u6634\u6639\u662E\u670F\u6710\u67C1\u67F2\u67C8\u67BA"],
      ["cf40", "\u67DC\u67BB\u67F8\u67D8\u67C0\u67B7\u67C5\u67EB\u67E4\u67DF\u67B5\u67CD\u67B3\u67F7\u67F6\u67EE\u67E3\u67C2\u67B9\u67CE\u67E7\u67F0\u67B2\u67FC\u67C6\u67ED\u67CC\u67AE\u67E6\u67DB\u67FA\u67C9\u67CA\u67C3\u67EA\u67CB\u6B28\u6B82\u6B84\u6BB6\u6BD6\u6BD8\u6BE0\u6C20\u6C21\u6D28\u6D34\u6D2D\u6D1F\u6D3C\u6D3F\u6D12\u6D0A\u6CDA\u6D33\u6D04\u6D19\u6D3A\u6D1A\u6D11\u6D00\u6D1D\u6D42"],
      ["cfa1", "\u6D01\u6D18\u6D37\u6D03\u6D0F\u6D40\u6D07\u6D20\u6D2C\u6D08\u6D22\u6D09\u6D10\u70B7\u709F\u70BE\u70B1\u70B0\u70A1\u70B4\u70B5\u70A9\u7241\u7249\u724A\u726C\u7270\u7273\u726E\u72CA\u72E4\u72E8\u72EB\u72DF\u72EA\u72E6\u72E3\u7385\u73CC\u73C2\u73C8\u73C5\u73B9\u73B6\u73B5\u73B4\u73EB\u73BF\u73C7\u73BE\u73C3\u73C6\u73B8\u73CB\u74EC\u74EE\u752E\u7547\u7548\u75A7\u75AA\u7679\u76C4\u7708\u7703\u7704\u7705\u770A\u76F7\u76FB\u76FA\u77E7\u77E8\u7806\u7811\u7812\u7805\u7810\u780F\u780E\u7809\u7803\u7813\u794A\u794C\u794B\u7945\u7944\u79D5\u79CD\u79CF\u79D6\u79CE\u7A80"],
      ["d040", "\u7A7E\u7AD1\u7B00\u7B01\u7C7A\u7C78\u7C79\u7C7F\u7C80\u7C81\u7D03\u7D08\u7D01\u7F58\u7F91\u7F8D\u7FBE\u8007\u800E\u800F\u8014\u8037\u80D8\u80C7\u80E0\u80D1\u80C8\u80C2\u80D0\u80C5\u80E3\u80D9\u80DC\u80CA\u80D5\u80C9\u80CF\u80D7\u80E6\u80CD\u81FF\u8221\u8294\u82D9\u82FE\u82F9\u8307\u82E8\u8300\u82D5\u833A\u82EB\u82D6\u82F4\u82EC\u82E1\u82F2\u82F5\u830C\u82FB\u82F6\u82F0\u82EA"],
      ["d0a1", "\u82E4\u82E0\u82FA\u82F3\u82ED\u8677\u8674\u867C\u8673\u8841\u884E\u8867\u886A\u8869\u89D3\u8A04\u8A07\u8D72\u8FE3\u8FE1\u8FEE\u8FE0\u90F1\u90BD\u90BF\u90D5\u90C5\u90BE\u90C7\u90CB\u90C8\u91D4\u91D3\u9654\u964F\u9651\u9653\u964A\u964E\u501E\u5005\u5007\u5013\u5022\u5030\u501B\u4FF5\u4FF4\u5033\u5037\u502C\u4FF6\u4FF7\u5017\u501C\u5020\u5027\u5035\u502F\u5031\u500E\u515A\u5194\u5193\u51CA\u51C4\u51C5\u51C8\u51CE\u5261\u525A\u5252\u525E\u525F\u5255\u5262\u52CD\u530E\u539E\u5526\u54E2\u5517\u5512\u54E7\u54F3\u54E4\u551A\u54FF\u5504\u5508\u54EB\u5511\u5505\u54F1"],
      ["d140", "\u550A\u54FB\u54F7\u54F8\u54E0\u550E\u5503\u550B\u5701\u5702\u57CC\u5832\u57D5\u57D2\u57BA\u57C6\u57BD\u57BC\u57B8\u57B6\u57BF\u57C7\u57D0\u57B9\u57C1\u590E\u594A\u5A19\u5A16\u5A2D\u5A2E\u5A15\u5A0F\u5A17\u5A0A\u5A1E\u5A33\u5B6C\u5BA7\u5BAD\u5BAC\u5C03\u5C56\u5C54\u5CEC\u5CFF\u5CEE\u5CF1\u5CF7\u5D00\u5CF9\u5E29\u5E28\u5EA8\u5EAE\u5EAA\u5EAC\u5F33\u5F30\u5F67\u605D\u605A\u6067"],
      ["d1a1", "\u6041\u60A2\u6088\u6080\u6092\u6081\u609D\u6083\u6095\u609B\u6097\u6087\u609C\u608E\u6219\u6246\u62F2\u6310\u6356\u632C\u6344\u6345\u6336\u6343\u63E4\u6339\u634B\u634A\u633C\u6329\u6341\u6334\u6358\u6354\u6359\u632D\u6347\u6333\u635A\u6351\u6338\u6357\u6340\u6348\u654A\u6546\u65C6\u65C3\u65C4\u65C2\u664A\u665F\u6647\u6651\u6712\u6713\u681F\u681A\u6849\u6832\u6833\u683B\u684B\u684F\u6816\u6831\u681C\u6835\u682B\u682D\u682F\u684E\u6844\u6834\u681D\u6812\u6814\u6826\u6828\u682E\u684D\u683A\u6825\u6820\u6B2C\u6B2F\u6B2D\u6B31\u6B34\u6B6D\u8082\u6B88\u6BE6\u6BE4"],
      ["d240", "\u6BE8\u6BE3\u6BE2\u6BE7\u6C25\u6D7A\u6D63\u6D64\u6D76\u6D0D\u6D61\u6D92\u6D58\u6D62\u6D6D\u6D6F\u6D91\u6D8D\u6DEF\u6D7F\u6D86\u6D5E\u6D67\u6D60\u6D97\u6D70\u6D7C\u6D5F\u6D82\u6D98\u6D2F\u6D68\u6D8B\u6D7E\u6D80\u6D84\u6D16\u6D83\u6D7B\u6D7D\u6D75\u6D90\u70DC\u70D3\u70D1\u70DD\u70CB\u7F39\u70E2\u70D7\u70D2\u70DE\u70E0\u70D4\u70CD\u70C5\u70C6\u70C7\u70DA\u70CE\u70E1\u7242\u7278"],
      ["d2a1", "\u7277\u7276\u7300\u72FA\u72F4\u72FE\u72F6\u72F3\u72FB\u7301\u73D3\u73D9\u73E5\u73D6\u73BC\u73E7\u73E3\u73E9\u73DC\u73D2\u73DB\u73D4\u73DD\u73DA\u73D7\u73D8\u73E8\u74DE\u74DF\u74F4\u74F5\u7521\u755B\u755F\u75B0\u75C1\u75BB\u75C4\u75C0\u75BF\u75B6\u75BA\u768A\u76C9\u771D\u771B\u7710\u7713\u7712\u7723\u7711\u7715\u7719\u771A\u7722\u7727\u7823\u782C\u7822\u7835\u782F\u7828\u782E\u782B\u7821\u7829\u7833\u782A\u7831\u7954\u795B\u794F\u795C\u7953\u7952\u7951\u79EB\u79EC\u79E0\u79EE\u79ED\u79EA\u79DC\u79DE\u79DD\u7A86\u7A89\u7A85\u7A8B\u7A8C\u7A8A\u7A87\u7AD8\u7B10"],
      ["d340", "\u7B04\u7B13\u7B05\u7B0F\u7B08\u7B0A\u7B0E\u7B09\u7B12\u7C84\u7C91\u7C8A\u7C8C\u7C88\u7C8D\u7C85\u7D1E\u7D1D\u7D11\u7D0E\u7D18\u7D16\u7D13\u7D1F\u7D12\u7D0F\u7D0C\u7F5C\u7F61\u7F5E\u7F60\u7F5D\u7F5B\u7F96\u7F92\u7FC3\u7FC2\u7FC0\u8016\u803E\u8039\u80FA\u80F2\u80F9\u80F5\u8101\u80FB\u8100\u8201\u822F\u8225\u8333\u832D\u8344\u8319\u8351\u8325\u8356\u833F\u8341\u8326\u831C\u8322"],
      ["d3a1", "\u8342\u834E\u831B\u832A\u8308\u833C\u834D\u8316\u8324\u8320\u8337\u832F\u8329\u8347\u8345\u834C\u8353\u831E\u832C\u834B\u8327\u8348\u8653\u8652\u86A2\u86A8\u8696\u868D\u8691\u869E\u8687\u8697\u8686\u868B\u869A\u8685\u86A5\u8699\u86A1\u86A7\u8695\u8698\u868E\u869D\u8690\u8694\u8843\u8844\u886D\u8875\u8876\u8872\u8880\u8871\u887F\u886F\u8883\u887E\u8874\u887C\u8A12\u8C47\u8C57\u8C7B\u8CA4\u8CA3\u8D76\u8D78\u8DB5\u8DB7\u8DB6\u8ED1\u8ED3\u8FFE\u8FF5\u9002\u8FFF\u8FFB\u9004\u8FFC\u8FF6\u90D6\u90E0\u90D9\u90DA\u90E3\u90DF\u90E5\u90D8\u90DB\u90D7\u90DC\u90E4\u9150"],
      ["d440", "\u914E\u914F\u91D5\u91E2\u91DA\u965C\u965F\u96BC\u98E3\u9ADF\u9B2F\u4E7F\u5070\u506A\u5061\u505E\u5060\u5053\u504B\u505D\u5072\u5048\u504D\u5041\u505B\u504A\u5062\u5015\u5045\u505F\u5069\u506B\u5063\u5064\u5046\u5040\u506E\u5073\u5057\u5051\u51D0\u526B\u526D\u526C\u526E\u52D6\u52D3\u532D\u539C\u5575\u5576\u553C\u554D\u5550\u5534\u552A\u5551\u5562\u5536\u5535\u5530\u5552\u5545"],
      ["d4a1", "\u550C\u5532\u5565\u554E\u5539\u5548\u552D\u553B\u5540\u554B\u570A\u5707\u57FB\u5814\u57E2\u57F6\u57DC\u57F4\u5800\u57ED\u57FD\u5808\u57F8\u580B\u57F3\u57CF\u5807\u57EE\u57E3\u57F2\u57E5\u57EC\u57E1\u580E\u57FC\u5810\u57E7\u5801\u580C\u57F1\u57E9\u57F0\u580D\u5804\u595C\u5A60\u5A58\u5A55\u5A67\u5A5E\u5A38\u5A35\u5A6D\u5A50\u5A5F\u5A65\u5A6C\u5A53\u5A64\u5A57\u5A43\u5A5D\u5A52\u5A44\u5A5B\u5A48\u5A8E\u5A3E\u5A4D\u5A39\u5A4C\u5A70\u5A69\u5A47\u5A51\u5A56\u5A42\u5A5C\u5B72\u5B6E\u5BC1\u5BC0\u5C59\u5D1E\u5D0B\u5D1D\u5D1A\u5D20\u5D0C\u5D28\u5D0D\u5D26\u5D25\u5D0F"],
      ["d540", "\u5D30\u5D12\u5D23\u5D1F\u5D2E\u5E3E\u5E34\u5EB1\u5EB4\u5EB9\u5EB2\u5EB3\u5F36\u5F38\u5F9B\u5F96\u5F9F\u608A\u6090\u6086\u60BE\u60B0\u60BA\u60D3\u60D4\u60CF\u60E4\u60D9\u60DD\u60C8\u60B1\u60DB\u60B7\u60CA\u60BF\u60C3\u60CD\u60C0\u6332\u6365\u638A\u6382\u637D\u63BD\u639E\u63AD\u639D\u6397\u63AB\u638E\u636F\u6387\u6390\u636E\u63AF\u6375\u639C\u636D\u63AE\u637C\u63A4\u633B\u639F"],
      ["d5a1", "\u6378\u6385\u6381\u6391\u638D\u6370\u6553\u65CD\u6665\u6661\u665B\u6659\u665C\u6662\u6718\u6879\u6887\u6890\u689C\u686D\u686E\u68AE\u68AB\u6956\u686F\u68A3\u68AC\u68A9\u6875\u6874\u68B2\u688F\u6877\u6892\u687C\u686B\u6872\u68AA\u6880\u6871\u687E\u689B\u6896\u688B\u68A0\u6889\u68A4\u6878\u687B\u6891\u688C\u688A\u687D\u6B36\u6B33\u6B37\u6B38\u6B91\u6B8F\u6B8D\u6B8E\u6B8C\u6C2A\u6DC0\u6DAB\u6DB4\u6DB3\u6E74\u6DAC\u6DE9\u6DE2\u6DB7\u6DF6\u6DD4\u6E00\u6DC8\u6DE0\u6DDF\u6DD6\u6DBE\u6DE5\u6DDC\u6DDD\u6DDB\u6DF4\u6DCA\u6DBD\u6DED\u6DF0\u6DBA\u6DD5\u6DC2\u6DCF\u6DC9"],
      ["d640", "\u6DD0\u6DF2\u6DD3\u6DFD\u6DD7\u6DCD\u6DE3\u6DBB\u70FA\u710D\u70F7\u7117\u70F4\u710C\u70F0\u7104\u70F3\u7110\u70FC\u70FF\u7106\u7113\u7100\u70F8\u70F6\u710B\u7102\u710E\u727E\u727B\u727C\u727F\u731D\u7317\u7307\u7311\u7318\u730A\u7308\u72FF\u730F\u731E\u7388\u73F6\u73F8\u73F5\u7404\u7401\u73FD\u7407\u7400\u73FA\u73FC\u73FF\u740C\u740B\u73F4\u7408\u7564\u7563\u75CE\u75D2\u75CF"],
      ["d6a1", "\u75CB\u75CC\u75D1\u75D0\u768F\u7689\u76D3\u7739\u772F\u772D\u7731\u7732\u7734\u7733\u773D\u7725\u773B\u7735\u7848\u7852\u7849\u784D\u784A\u784C\u7826\u7845\u7850\u7964\u7967\u7969\u796A\u7963\u796B\u7961\u79BB\u79FA\u79F8\u79F6\u79F7\u7A8F\u7A94\u7A90\u7B35\u7B47\u7B34\u7B25\u7B30\u7B22\u7B24\u7B33\u7B18\u7B2A\u7B1D\u7B31\u7B2B\u7B2D\u7B2F\u7B32\u7B38\u7B1A\u7B23\u7C94\u7C98\u7C96\u7CA3\u7D35\u7D3D\u7D38\u7D36\u7D3A\u7D45\u7D2C\u7D29\u7D41\u7D47\u7D3E\u7D3F\u7D4A\u7D3B\u7D28\u7F63\u7F95\u7F9C\u7F9D\u7F9B\u7FCA\u7FCB\u7FCD\u7FD0\u7FD1\u7FC7\u7FCF\u7FC9\u801F"],
      ["d740", "\u801E\u801B\u8047\u8043\u8048\u8118\u8125\u8119\u811B\u812D\u811F\u812C\u811E\u8121\u8115\u8127\u811D\u8122\u8211\u8238\u8233\u823A\u8234\u8232\u8274\u8390\u83A3\u83A8\u838D\u837A\u8373\u83A4\u8374\u838F\u8381\u8395\u8399\u8375\u8394\u83A9\u837D\u8383\u838C\u839D\u839B\u83AA\u838B\u837E\u83A5\u83AF\u8388\u8397\u83B0\u837F\u83A6\u8387\u83AE\u8376\u839A\u8659\u8656\u86BF\u86B7"],
      ["d7a1", "\u86C2\u86C1\u86C5\u86BA\u86B0\u86C8\u86B9\u86B3\u86B8\u86CC\u86B4\u86BB\u86BC\u86C3\u86BD\u86BE\u8852\u8889\u8895\u88A8\u88A2\u88AA\u889A\u8891\u88A1\u889F\u8898\u88A7\u8899\u889B\u8897\u88A4\u88AC\u888C\u8893\u888E\u8982\u89D6\u89D9\u89D5\u8A30\u8A27\u8A2C\u8A1E\u8C39\u8C3B\u8C5C\u8C5D\u8C7D\u8CA5\u8D7D\u8D7B\u8D79\u8DBC\u8DC2\u8DB9\u8DBF\u8DC1\u8ED8\u8EDE\u8EDD\u8EDC\u8ED7\u8EE0\u8EE1\u9024\u900B\u9011\u901C\u900C\u9021\u90EF\u90EA\u90F0\u90F4\u90F2\u90F3\u90D4\u90EB\u90EC\u90E9\u9156\u9158\u915A\u9153\u9155\u91EC\u91F4\u91F1\u91F3\u91F8\u91E4\u91F9\u91EA"],
      ["d840", "\u91EB\u91F7\u91E8\u91EE\u957A\u9586\u9588\u967C\u966D\u966B\u9671\u966F\u96BF\u976A\u9804\u98E5\u9997\u509B\u5095\u5094\u509E\u508B\u50A3\u5083\u508C\u508E\u509D\u5068\u509C\u5092\u5082\u5087\u515F\u51D4\u5312\u5311\u53A4\u53A7\u5591\u55A8\u55A5\u55AD\u5577\u5645\u55A2\u5593\u5588\u558F\u55B5\u5581\u55A3\u5592\u55A4\u557D\u558C\u55A6\u557F\u5595\u55A1\u558E\u570C\u5829\u5837"],
      ["d8a1", "\u5819\u581E\u5827\u5823\u5828\u57F5\u5848\u5825\u581C\u581B\u5833\u583F\u5836\u582E\u5839\u5838\u582D\u582C\u583B\u5961\u5AAF\u5A94\u5A9F\u5A7A\u5AA2\u5A9E\u5A78\u5AA6\u5A7C\u5AA5\u5AAC\u5A95\u5AAE\u5A37\u5A84\u5A8A\u5A97\u5A83\u5A8B\u5AA9\u5A7B\u5A7D\u5A8C\u5A9C\u5A8F\u5A93\u5A9D\u5BEA\u5BCD\u5BCB\u5BD4\u5BD1\u5BCA\u5BCE\u5C0C\u5C30\u5D37\u5D43\u5D6B\u5D41\u5D4B\u5D3F\u5D35\u5D51\u5D4E\u5D55\u5D33\u5D3A\u5D52\u5D3D\u5D31\u5D59\u5D42\u5D39\u5D49\u5D38\u5D3C\u5D32\u5D36\u5D40\u5D45\u5E44\u5E41\u5F58\u5FA6\u5FA5\u5FAB\u60C9\u60B9\u60CC\u60E2\u60CE\u60C4\u6114"],
      ["d940", "\u60F2\u610A\u6116\u6105\u60F5\u6113\u60F8\u60FC\u60FE\u60C1\u6103\u6118\u611D\u6110\u60FF\u6104\u610B\u624A\u6394\u63B1\u63B0\u63CE\u63E5\u63E8\u63EF\u63C3\u649D\u63F3\u63CA\u63E0\u63F6\u63D5\u63F2\u63F5\u6461\u63DF\u63BE\u63DD\u63DC\u63C4\u63D8\u63D3\u63C2\u63C7\u63CC\u63CB\u63C8\u63F0\u63D7\u63D9\u6532\u6567\u656A\u6564\u655C\u6568\u6565\u658C\u659D\u659E\u65AE\u65D0\u65D2"],
      ["d9a1", "\u667C\u666C\u667B\u6680\u6671\u6679\u666A\u6672\u6701\u690C\u68D3\u6904\u68DC\u692A\u68EC\u68EA\u68F1\u690F\u68D6\u68F7\u68EB\u68E4\u68F6\u6913\u6910\u68F3\u68E1\u6907\u68CC\u6908\u6970\u68B4\u6911\u68EF\u68C6\u6914\u68F8\u68D0\u68FD\u68FC\u68E8\u690B\u690A\u6917\u68CE\u68C8\u68DD\u68DE\u68E6\u68F4\u68D1\u6906\u68D4\u68E9\u6915\u6925\u68C7\u6B39\u6B3B\u6B3F\u6B3C\u6B94\u6B97\u6B99\u6B95\u6BBD\u6BF0\u6BF2\u6BF3\u6C30\u6DFC\u6E46\u6E47\u6E1F\u6E49\u6E88\u6E3C\u6E3D\u6E45\u6E62\u6E2B\u6E3F\u6E41\u6E5D\u6E73\u6E1C\u6E33\u6E4B\u6E40\u6E51\u6E3B\u6E03\u6E2E\u6E5E"],
      ["da40", "\u6E68\u6E5C\u6E61\u6E31\u6E28\u6E60\u6E71\u6E6B\u6E39\u6E22\u6E30\u6E53\u6E65\u6E27\u6E78\u6E64\u6E77\u6E55\u6E79\u6E52\u6E66\u6E35\u6E36\u6E5A\u7120\u711E\u712F\u70FB\u712E\u7131\u7123\u7125\u7122\u7132\u711F\u7128\u713A\u711B\u724B\u725A\u7288\u7289\u7286\u7285\u728B\u7312\u730B\u7330\u7322\u7331\u7333\u7327\u7332\u732D\u7326\u7323\u7335\u730C\u742E\u742C\u7430\u742B\u7416"],
      ["daa1", "\u741A\u7421\u742D\u7431\u7424\u7423\u741D\u7429\u7420\u7432\u74FB\u752F\u756F\u756C\u75E7\u75DA\u75E1\u75E6\u75DD\u75DF\u75E4\u75D7\u7695\u7692\u76DA\u7746\u7747\u7744\u774D\u7745\u774A\u774E\u774B\u774C\u77DE\u77EC\u7860\u7864\u7865\u785C\u786D\u7871\u786A\u786E\u7870\u7869\u7868\u785E\u7862\u7974\u7973\u7972\u7970\u7A02\u7A0A\u7A03\u7A0C\u7A04\u7A99\u7AE6\u7AE4\u7B4A\u7B3B\u7B44\u7B48\u7B4C\u7B4E\u7B40\u7B58\u7B45\u7CA2\u7C9E\u7CA8\u7CA1\u7D58\u7D6F\u7D63\u7D53\u7D56\u7D67\u7D6A\u7D4F\u7D6D\u7D5C\u7D6B\u7D52\u7D54\u7D69\u7D51\u7D5F\u7D4E\u7F3E\u7F3F\u7F65"],
      ["db40", "\u7F66\u7FA2\u7FA0\u7FA1\u7FD7\u8051\u804F\u8050\u80FE\u80D4\u8143\u814A\u8152\u814F\u8147\u813D\u814D\u813A\u81E6\u81EE\u81F7\u81F8\u81F9\u8204\u823C\u823D\u823F\u8275\u833B\u83CF\u83F9\u8423\u83C0\u83E8\u8412\u83E7\u83E4\u83FC\u83F6\u8410\u83C6\u83C8\u83EB\u83E3\u83BF\u8401\u83DD\u83E5\u83D8\u83FF\u83E1\u83CB\u83CE\u83D6\u83F5\u83C9\u8409\u840F\u83DE\u8411\u8406\u83C2\u83F3"],
      ["dba1", "\u83D5\u83FA\u83C7\u83D1\u83EA\u8413\u83C3\u83EC\u83EE\u83C4\u83FB\u83D7\u83E2\u841B\u83DB\u83FE\u86D8\u86E2\u86E6\u86D3\u86E3\u86DA\u86EA\u86DD\u86EB\u86DC\u86EC\u86E9\u86D7\u86E8\u86D1\u8848\u8856\u8855\u88BA\u88D7\u88B9\u88B8\u88C0\u88BE\u88B6\u88BC\u88B7\u88BD\u88B2\u8901\u88C9\u8995\u8998\u8997\u89DD\u89DA\u89DB\u8A4E\u8A4D\u8A39\u8A59\u8A40\u8A57\u8A58\u8A44\u8A45\u8A52\u8A48\u8A51\u8A4A\u8A4C\u8A4F\u8C5F\u8C81\u8C80\u8CBA\u8CBE\u8CB0\u8CB9\u8CB5\u8D84\u8D80\u8D89\u8DD8\u8DD3\u8DCD\u8DC7\u8DD6\u8DDC\u8DCF\u8DD5\u8DD9\u8DC8\u8DD7\u8DC5\u8EEF\u8EF7\u8EFA"],
      ["dc40", "\u8EF9\u8EE6\u8EEE\u8EE5\u8EF5\u8EE7\u8EE8\u8EF6\u8EEB\u8EF1\u8EEC\u8EF4\u8EE9\u902D\u9034\u902F\u9106\u912C\u9104\u90FF\u90FC\u9108\u90F9\u90FB\u9101\u9100\u9107\u9105\u9103\u9161\u9164\u915F\u9162\u9160\u9201\u920A\u9225\u9203\u921A\u9226\u920F\u920C\u9200\u9212\u91FF\u91FD\u9206\u9204\u9227\u9202\u921C\u9224\u9219\u9217\u9205\u9216\u957B\u958D\u958C\u9590\u9687\u967E\u9688"],
      ["dca1", "\u9689\u9683\u9680\u96C2\u96C8\u96C3\u96F1\u96F0\u976C\u9770\u976E\u9807\u98A9\u98EB\u9CE6\u9EF9\u4E83\u4E84\u4EB6\u50BD\u50BF\u50C6\u50AE\u50C4\u50CA\u50B4\u50C8\u50C2\u50B0\u50C1\u50BA\u50B1\u50CB\u50C9\u50B6\u50B8\u51D7\u527A\u5278\u527B\u527C\u55C3\u55DB\u55CC\u55D0\u55CB\u55CA\u55DD\u55C0\u55D4\u55C4\u55E9\u55BF\u55D2\u558D\u55CF\u55D5\u55E2\u55D6\u55C8\u55F2\u55CD\u55D9\u55C2\u5714\u5853\u5868\u5864\u584F\u584D\u5849\u586F\u5855\u584E\u585D\u5859\u5865\u585B\u583D\u5863\u5871\u58FC\u5AC7\u5AC4\u5ACB\u5ABA\u5AB8\u5AB1\u5AB5\u5AB0\u5ABF\u5AC8\u5ABB\u5AC6"],
      ["dd40", "\u5AB7\u5AC0\u5ACA\u5AB4\u5AB6\u5ACD\u5AB9\u5A90\u5BD6\u5BD8\u5BD9\u5C1F\u5C33\u5D71\u5D63\u5D4A\u5D65\u5D72\u5D6C\u5D5E\u5D68\u5D67\u5D62\u5DF0\u5E4F\u5E4E\u5E4A\u5E4D\u5E4B\u5EC5\u5ECC\u5EC6\u5ECB\u5EC7\u5F40\u5FAF\u5FAD\u60F7\u6149\u614A\u612B\u6145\u6136\u6132\u612E\u6146\u612F\u614F\u6129\u6140\u6220\u9168\u6223\u6225\u6224\u63C5\u63F1\u63EB\u6410\u6412\u6409\u6420\u6424"],
      ["dda1", "\u6433\u6443\u641F\u6415\u6418\u6439\u6437\u6422\u6423\u640C\u6426\u6430\u6428\u6441\u6435\u642F\u640A\u641A\u6440\u6425\u6427\u640B\u63E7\u641B\u642E\u6421\u640E\u656F\u6592\u65D3\u6686\u668C\u6695\u6690\u668B\u668A\u6699\u6694\u6678\u6720\u6966\u695F\u6938\u694E\u6962\u6971\u693F\u6945\u696A\u6939\u6942\u6957\u6959\u697A\u6948\u6949\u6935\u696C\u6933\u693D\u6965\u68F0\u6978\u6934\u6969\u6940\u696F\u6944\u6976\u6958\u6941\u6974\u694C\u693B\u694B\u6937\u695C\u694F\u6951\u6932\u6952\u692F\u697B\u693C\u6B46\u6B45\u6B43\u6B42\u6B48\u6B41\u6B9B\uFA0D\u6BFB\u6BFC"],
      ["de40", "\u6BF9\u6BF7\u6BF8\u6E9B\u6ED6\u6EC8\u6E8F\u6EC0\u6E9F\u6E93\u6E94\u6EA0\u6EB1\u6EB9\u6EC6\u6ED2\u6EBD\u6EC1\u6E9E\u6EC9\u6EB7\u6EB0\u6ECD\u6EA6\u6ECF\u6EB2\u6EBE\u6EC3\u6EDC\u6ED8\u6E99\u6E92\u6E8E\u6E8D\u6EA4\u6EA1\u6EBF\u6EB3\u6ED0\u6ECA\u6E97\u6EAE\u6EA3\u7147\u7154\u7152\u7163\u7160\u7141\u715D\u7162\u7172\u7178\u716A\u7161\u7142\u7158\u7143\u714B\u7170\u715F\u7150\u7153"],
      ["dea1", "\u7144\u714D\u715A\u724F\u728D\u728C\u7291\u7290\u728E\u733C\u7342\u733B\u733A\u7340\u734A\u7349\u7444\u744A\u744B\u7452\u7451\u7457\u7440\u744F\u7450\u744E\u7442\u7446\u744D\u7454\u74E1\u74FF\u74FE\u74FD\u751D\u7579\u7577\u6983\u75EF\u760F\u7603\u75F7\u75FE\u75FC\u75F9\u75F8\u7610\u75FB\u75F6\u75ED\u75F5\u75FD\u7699\u76B5\u76DD\u7755\u775F\u7760\u7752\u7756\u775A\u7769\u7767\u7754\u7759\u776D\u77E0\u7887\u789A\u7894\u788F\u7884\u7895\u7885\u7886\u78A1\u7883\u7879\u7899\u7880\u7896\u787B\u797C\u7982\u797D\u7979\u7A11\u7A18\u7A19\u7A12\u7A17\u7A15\u7A22\u7A13"],
      ["df40", "\u7A1B\u7A10\u7AA3\u7AA2\u7A9E\u7AEB\u7B66\u7B64\u7B6D\u7B74\u7B69\u7B72\u7B65\u7B73\u7B71\u7B70\u7B61\u7B78\u7B76\u7B63\u7CB2\u7CB4\u7CAF\u7D88\u7D86\u7D80\u7D8D\u7D7F\u7D85\u7D7A\u7D8E\u7D7B\u7D83\u7D7C\u7D8C\u7D94\u7D84\u7D7D\u7D92\u7F6D\u7F6B\u7F67\u7F68\u7F6C\u7FA6\u7FA5\u7FA7\u7FDB\u7FDC\u8021\u8164\u8160\u8177\u815C\u8169\u815B\u8162\u8172\u6721\u815E\u8176\u8167\u816F"],
      ["dfa1", "\u8144\u8161\u821D\u8249\u8244\u8240\u8242\u8245\u84F1\u843F\u8456\u8476\u8479\u848F\u848D\u8465\u8451\u8440\u8486\u8467\u8430\u844D\u847D\u845A\u8459\u8474\u8473\u845D\u8507\u845E\u8437\u843A\u8434\u847A\u8443\u8478\u8432\u8445\u8429\u83D9\u844B\u842F\u8442\u842D\u845F\u8470\u8439\u844E\u844C\u8452\u846F\u84C5\u848E\u843B\u8447\u8436\u8433\u8468\u847E\u8444\u842B\u8460\u8454\u846E\u8450\u870B\u8704\u86F7\u870C\u86FA\u86D6\u86F5\u874D\u86F8\u870E\u8709\u8701\u86F6\u870D\u8705\u88D6\u88CB\u88CD\u88CE\u88DE\u88DB\u88DA\u88CC\u88D0\u8985\u899B\u89DF\u89E5\u89E4"],
      ["e040", "\u89E1\u89E0\u89E2\u89DC\u89E6\u8A76\u8A86\u8A7F\u8A61\u8A3F\u8A77\u8A82\u8A84\u8A75\u8A83\u8A81\u8A74\u8A7A\u8C3C\u8C4B\u8C4A\u8C65\u8C64\u8C66\u8C86\u8C84\u8C85\u8CCC\u8D68\u8D69\u8D91\u8D8C\u8D8E\u8D8F\u8D8D\u8D93\u8D94\u8D90\u8D92\u8DF0\u8DE0\u8DEC\u8DF1\u8DEE\u8DD0\u8DE9\u8DE3\u8DE2\u8DE7\u8DF2\u8DEB\u8DF4\u8F06\u8EFF\u8F01\u8F00\u8F05\u8F07\u8F08\u8F02\u8F0B\u9052\u903F"],
      ["e0a1", "\u9044\u9049\u903D\u9110\u910D\u910F\u9111\u9116\u9114\u910B\u910E\u916E\u916F\u9248\u9252\u9230\u923A\u9266\u9233\u9265\u925E\u9283\u922E\u924A\u9246\u926D\u926C\u924F\u9260\u9267\u926F\u9236\u9261\u9270\u9231\u9254\u9263\u9250\u9272\u924E\u9253\u924C\u9256\u9232\u959F\u959C\u959E\u959B\u9692\u9693\u9691\u9697\u96CE\u96FA\u96FD\u96F8\u96F5\u9773\u9777\u9778\u9772\u980F\u980D\u980E\u98AC\u98F6\u98F9\u99AF\u99B2\u99B0\u99B5\u9AAD\u9AAB\u9B5B\u9CEA\u9CED\u9CE7\u9E80\u9EFD\u50E6\u50D4\u50D7\u50E8\u50F3\u50DB\u50EA\u50DD\u50E4\u50D3\u50EC\u50F0\u50EF\u50E3\u50E0"],
      ["e140", "\u51D8\u5280\u5281\u52E9\u52EB\u5330\u53AC\u5627\u5615\u560C\u5612\u55FC\u560F\u561C\u5601\u5613\u5602\u55FA\u561D\u5604\u55FF\u55F9\u5889\u587C\u5890\u5898\u5886\u5881\u587F\u5874\u588B\u587A\u5887\u5891\u588E\u5876\u5882\u5888\u587B\u5894\u588F\u58FE\u596B\u5ADC\u5AEE\u5AE5\u5AD5\u5AEA\u5ADA\u5AED\u5AEB\u5AF3\u5AE2\u5AE0\u5ADB\u5AEC\u5ADE\u5ADD\u5AD9\u5AE8\u5ADF\u5B77\u5BE0"],
      ["e1a1", "\u5BE3\u5C63\u5D82\u5D80\u5D7D\u5D86\u5D7A\u5D81\u5D77\u5D8A\u5D89\u5D88\u5D7E\u5D7C\u5D8D\u5D79\u5D7F\u5E58\u5E59\u5E53\u5ED8\u5ED1\u5ED7\u5ECE\u5EDC\u5ED5\u5ED9\u5ED2\u5ED4\u5F44\u5F43\u5F6F\u5FB6\u612C\u6128\u6141\u615E\u6171\u6173\u6152\u6153\u6172\u616C\u6180\u6174\u6154\u617A\u615B\u6165\u613B\u616A\u6161\u6156\u6229\u6227\u622B\u642B\u644D\u645B\u645D\u6474\u6476\u6472\u6473\u647D\u6475\u6466\u64A6\u644E\u6482\u645E\u645C\u644B\u6453\u6460\u6450\u647F\u643F\u646C\u646B\u6459\u6465\u6477\u6573\u65A0\u66A1\u66A0\u669F\u6705\u6704\u6722\u69B1\u69B6\u69C9"],
      ["e240", "\u69A0\u69CE\u6996\u69B0\u69AC\u69BC\u6991\u6999\u698E\u69A7\u698D\u69A9\u69BE\u69AF\u69BF\u69C4\u69BD\u69A4\u69D4\u69B9\u69CA\u699A\u69CF\u69B3\u6993\u69AA\u69A1\u699E\u69D9\u6997\u6990\u69C2\u69B5\u69A5\u69C6\u6B4A\u6B4D\u6B4B\u6B9E\u6B9F\u6BA0\u6BC3\u6BC4\u6BFE\u6ECE\u6EF5\u6EF1\u6F03\u6F25\u6EF8\u6F37\u6EFB\u6F2E\u6F09\u6F4E\u6F19\u6F1A\u6F27\u6F18\u6F3B\u6F12\u6EED\u6F0A"],
      ["e2a1", "\u6F36\u6F73\u6EF9\u6EEE\u6F2D\u6F40\u6F30\u6F3C\u6F35\u6EEB\u6F07\u6F0E\u6F43\u6F05\u6EFD\u6EF6\u6F39\u6F1C\u6EFC\u6F3A\u6F1F\u6F0D\u6F1E\u6F08\u6F21\u7187\u7190\u7189\u7180\u7185\u7182\u718F\u717B\u7186\u7181\u7197\u7244\u7253\u7297\u7295\u7293\u7343\u734D\u7351\u734C\u7462\u7473\u7471\u7475\u7472\u7467\u746E\u7500\u7502\u7503\u757D\u7590\u7616\u7608\u760C\u7615\u7611\u760A\u7614\u76B8\u7781\u777C\u7785\u7782\u776E\u7780\u776F\u777E\u7783\u78B2\u78AA\u78B4\u78AD\u78A8\u787E\u78AB\u789E\u78A5\u78A0\u78AC\u78A2\u78A4\u7998\u798A\u798B\u7996\u7995\u7994\u7993"],
      ["e340", "\u7997\u7988\u7992\u7990\u7A2B\u7A4A\u7A30\u7A2F\u7A28\u7A26\u7AA8\u7AAB\u7AAC\u7AEE\u7B88\u7B9C\u7B8A\u7B91\u7B90\u7B96\u7B8D\u7B8C\u7B9B\u7B8E\u7B85\u7B98\u5284\u7B99\u7BA4\u7B82\u7CBB\u7CBF\u7CBC\u7CBA\u7DA7\u7DB7\u7DC2\u7DA3\u7DAA\u7DC1\u7DC0\u7DC5\u7D9D\u7DCE\u7DC4\u7DC6\u7DCB\u7DCC\u7DAF\u7DB9\u7D96\u7DBC\u7D9F\u7DA6\u7DAE\u7DA9\u7DA1\u7DC9\u7F73\u7FE2\u7FE3\u7FE5\u7FDE"],
      ["e3a1", "\u8024\u805D\u805C\u8189\u8186\u8183\u8187\u818D\u818C\u818B\u8215\u8497\u84A4\u84A1\u849F\u84BA\u84CE\u84C2\u84AC\u84AE\u84AB\u84B9\u84B4\u84C1\u84CD\u84AA\u849A\u84B1\u84D0\u849D\u84A7\u84BB\u84A2\u8494\u84C7\u84CC\u849B\u84A9\u84AF\u84A8\u84D6\u8498\u84B6\u84CF\u84A0\u84D7\u84D4\u84D2\u84DB\u84B0\u8491\u8661\u8733\u8723\u8728\u876B\u8740\u872E\u871E\u8721\u8719\u871B\u8743\u872C\u8741\u873E\u8746\u8720\u8732\u872A\u872D\u873C\u8712\u873A\u8731\u8735\u8742\u8726\u8727\u8738\u8724\u871A\u8730\u8711\u88F7\u88E7\u88F1\u88F2\u88FA\u88FE\u88EE\u88FC\u88F6\u88FB"],
      ["e440", "\u88F0\u88EC\u88EB\u899D\u89A1\u899F\u899E\u89E9\u89EB\u89E8\u8AAB\u8A99\u8A8B\u8A92\u8A8F\u8A96\u8C3D\u8C68\u8C69\u8CD5\u8CCF\u8CD7\u8D96\u8E09\u8E02\u8DFF\u8E0D\u8DFD\u8E0A\u8E03\u8E07\u8E06\u8E05\u8DFE\u8E00\u8E04\u8F10\u8F11\u8F0E\u8F0D\u9123\u911C\u9120\u9122\u911F\u911D\u911A\u9124\u9121\u911B\u917A\u9172\u9179\u9173\u92A5\u92A4\u9276\u929B\u927A\u92A0\u9294\u92AA\u928D"],
      ["e4a1", "\u92A6\u929A\u92AB\u9279\u9297\u927F\u92A3\u92EE\u928E\u9282\u9295\u92A2\u927D\u9288\u92A1\u928A\u9286\u928C\u9299\u92A7\u927E\u9287\u92A9\u929D\u928B\u922D\u969E\u96A1\u96FF\u9758\u977D\u977A\u977E\u9783\u9780\u9782\u977B\u9784\u9781\u977F\u97CE\u97CD\u9816\u98AD\u98AE\u9902\u9900\u9907\u999D\u999C\u99C3\u99B9\u99BB\u99BA\u99C2\u99BD\u99C7\u9AB1\u9AE3\u9AE7\u9B3E\u9B3F\u9B60\u9B61\u9B5F\u9CF1\u9CF2\u9CF5\u9EA7\u50FF\u5103\u5130\u50F8\u5106\u5107\u50F6\u50FE\u510B\u510C\u50FD\u510A\u528B\u528C\u52F1\u52EF\u5648\u5642\u564C\u5635\u5641\u564A\u5649\u5646\u5658"],
      ["e540", "\u565A\u5640\u5633\u563D\u562C\u563E\u5638\u562A\u563A\u571A\u58AB\u589D\u58B1\u58A0\u58A3\u58AF\u58AC\u58A5\u58A1\u58FF\u5AFF\u5AF4\u5AFD\u5AF7\u5AF6\u5B03\u5AF8\u5B02\u5AF9\u5B01\u5B07\u5B05\u5B0F\u5C67\u5D99\u5D97\u5D9F\u5D92\u5DA2\u5D93\u5D95\u5DA0\u5D9C\u5DA1\u5D9A\u5D9E\u5E69\u5E5D\u5E60\u5E5C\u7DF3\u5EDB\u5EDE\u5EE1\u5F49\u5FB2\u618B\u6183\u6179\u61B1\u61B0\u61A2\u6189"],
      ["e5a1", "\u619B\u6193\u61AF\u61AD\u619F\u6192\u61AA\u61A1\u618D\u6166\u61B3\u622D\u646E\u6470\u6496\u64A0\u6485\u6497\u649C\u648F\u648B\u648A\u648C\u64A3\u649F\u6468\u64B1\u6498\u6576\u657A\u6579\u657B\u65B2\u65B3\u66B5\u66B0\u66A9\u66B2\u66B7\u66AA\u66AF\u6A00\u6A06\u6A17\u69E5\u69F8\u6A15\u69F1\u69E4\u6A20\u69FF\u69EC\u69E2\u6A1B\u6A1D\u69FE\u6A27\u69F2\u69EE\u6A14\u69F7\u69E7\u6A40\u6A08\u69E6\u69FB\u6A0D\u69FC\u69EB\u6A09\u6A04\u6A18\u6A25\u6A0F\u69F6\u6A26\u6A07\u69F4\u6A16\u6B51\u6BA5\u6BA3\u6BA2\u6BA6\u6C01\u6C00\u6BFF\u6C02\u6F41\u6F26\u6F7E\u6F87\u6FC6\u6F92"],
      ["e640", "\u6F8D\u6F89\u6F8C\u6F62\u6F4F\u6F85\u6F5A\u6F96\u6F76\u6F6C\u6F82\u6F55\u6F72\u6F52\u6F50\u6F57\u6F94\u6F93\u6F5D\u6F00\u6F61\u6F6B\u6F7D\u6F67\u6F90\u6F53\u6F8B\u6F69\u6F7F\u6F95\u6F63\u6F77\u6F6A\u6F7B\u71B2\u71AF\u719B\u71B0\u71A0\u719A\u71A9\u71B5\u719D\u71A5\u719E\u71A4\u71A1\u71AA\u719C\u71A7\u71B3\u7298\u729A\u7358\u7352\u735E\u735F\u7360\u735D\u735B\u7361\u735A\u7359"],
      ["e6a1", "\u7362\u7487\u7489\u748A\u7486\u7481\u747D\u7485\u7488\u747C\u7479\u7508\u7507\u757E\u7625\u761E\u7619\u761D\u761C\u7623\u761A\u7628\u761B\u769C\u769D\u769E\u769B\u778D\u778F\u7789\u7788\u78CD\u78BB\u78CF\u78CC\u78D1\u78CE\u78D4\u78C8\u78C3\u78C4\u78C9\u799A\u79A1\u79A0\u799C\u79A2\u799B\u6B76\u7A39\u7AB2\u7AB4\u7AB3\u7BB7\u7BCB\u7BBE\u7BAC\u7BCE\u7BAF\u7BB9\u7BCA\u7BB5\u7CC5\u7CC8\u7CCC\u7CCB\u7DF7\u7DDB\u7DEA\u7DE7\u7DD7\u7DE1\u7E03\u7DFA\u7DE6\u7DF6\u7DF1\u7DF0\u7DEE\u7DDF\u7F76\u7FAC\u7FB0\u7FAD\u7FED\u7FEB\u7FEA\u7FEC\u7FE6\u7FE8\u8064\u8067\u81A3\u819F"],
      ["e740", "\u819E\u8195\u81A2\u8199\u8197\u8216\u824F\u8253\u8252\u8250\u824E\u8251\u8524\u853B\u850F\u8500\u8529\u850E\u8509\u850D\u851F\u850A\u8527\u851C\u84FB\u852B\u84FA\u8508\u850C\u84F4\u852A\u84F2\u8515\u84F7\u84EB\u84F3\u84FC\u8512\u84EA\u84E9\u8516\u84FE\u8528\u851D\u852E\u8502\u84FD\u851E\u84F6\u8531\u8526\u84E7\u84E8\u84F0\u84EF\u84F9\u8518\u8520\u8530\u850B\u8519\u852F\u8662"],
      ["e7a1", "\u8756\u8763\u8764\u8777\u87E1\u8773\u8758\u8754\u875B\u8752\u8761\u875A\u8751\u875E\u876D\u876A\u8750\u874E\u875F\u875D\u876F\u876C\u877A\u876E\u875C\u8765\u874F\u877B\u8775\u8762\u8767\u8769\u885A\u8905\u890C\u8914\u890B\u8917\u8918\u8919\u8906\u8916\u8911\u890E\u8909\u89A2\u89A4\u89A3\u89ED\u89F0\u89EC\u8ACF\u8AC6\u8AB8\u8AD3\u8AD1\u8AD4\u8AD5\u8ABB\u8AD7\u8ABE\u8AC0\u8AC5\u8AD8\u8AC3\u8ABA\u8ABD\u8AD9\u8C3E\u8C4D\u8C8F\u8CE5\u8CDF\u8CD9\u8CE8\u8CDA\u8CDD\u8CE7\u8DA0\u8D9C\u8DA1\u8D9B\u8E20\u8E23\u8E25\u8E24\u8E2E\u8E15\u8E1B\u8E16\u8E11\u8E19\u8E26\u8E27"],
      ["e840", "\u8E14\u8E12\u8E18\u8E13\u8E1C\u8E17\u8E1A\u8F2C\u8F24\u8F18\u8F1A\u8F20\u8F23\u8F16\u8F17\u9073\u9070\u906F\u9067\u906B\u912F\u912B\u9129\u912A\u9132\u9126\u912E\u9185\u9186\u918A\u9181\u9182\u9184\u9180\u92D0\u92C3\u92C4\u92C0\u92D9\u92B6\u92CF\u92F1\u92DF\u92D8\u92E9\u92D7\u92DD\u92CC\u92EF\u92C2\u92E8\u92CA\u92C8\u92CE\u92E6\u92CD\u92D5\u92C9\u92E0\u92DE\u92E7\u92D1\u92D3"],
      ["e8a1", "\u92B5\u92E1\u92C6\u92B4\u957C\u95AC\u95AB\u95AE\u95B0\u96A4\u96A2\u96D3\u9705\u9708\u9702\u975A\u978A\u978E\u9788\u97D0\u97CF\u981E\u981D\u9826\u9829\u9828\u9820\u981B\u9827\u98B2\u9908\u98FA\u9911\u9914\u9916\u9917\u9915\u99DC\u99CD\u99CF\u99D3\u99D4\u99CE\u99C9\u99D6\u99D8\u99CB\u99D7\u99CC\u9AB3\u9AEC\u9AEB\u9AF3\u9AF2\u9AF1\u9B46\u9B43\u9B67\u9B74\u9B71\u9B66\u9B76\u9B75\u9B70\u9B68\u9B64\u9B6C\u9CFC\u9CFA\u9CFD\u9CFF\u9CF7\u9D07\u9D00\u9CF9\u9CFB\u9D08\u9D05\u9D04\u9E83\u9ED3\u9F0F\u9F10\u511C\u5113\u5117\u511A\u5111\u51DE\u5334\u53E1\u5670\u5660\u566E"],
      ["e940", "\u5673\u5666\u5663\u566D\u5672\u565E\u5677\u571C\u571B\u58C8\u58BD\u58C9\u58BF\u58BA\u58C2\u58BC\u58C6\u5B17\u5B19\u5B1B\u5B21\u5B14\u5B13\u5B10\u5B16\u5B28\u5B1A\u5B20\u5B1E\u5BEF\u5DAC\u5DB1\u5DA9\u5DA7\u5DB5\u5DB0\u5DAE\u5DAA\u5DA8\u5DB2\u5DAD\u5DAF\u5DB4\u5E67\u5E68\u5E66\u5E6F\u5EE9\u5EE7\u5EE6\u5EE8\u5EE5\u5F4B\u5FBC\u619D\u61A8\u6196\u61C5\u61B4\u61C6\u61C1\u61CC\u61BA"],
      ["e9a1", "\u61BF\u61B8\u618C\u64D7\u64D6\u64D0\u64CF\u64C9\u64BD\u6489\u64C3\u64DB\u64F3\u64D9\u6533\u657F\u657C\u65A2\u66C8\u66BE\u66C0\u66CA\u66CB\u66CF\u66BD\u66BB\u66BA\u66CC\u6723\u6A34\u6A66\u6A49\u6A67\u6A32\u6A68\u6A3E\u6A5D\u6A6D\u6A76\u6A5B\u6A51\u6A28\u6A5A\u6A3B\u6A3F\u6A41\u6A6A\u6A64\u6A50\u6A4F\u6A54\u6A6F\u6A69\u6A60\u6A3C\u6A5E\u6A56\u6A55\u6A4D\u6A4E\u6A46\u6B55\u6B54\u6B56\u6BA7\u6BAA\u6BAB\u6BC8\u6BC7\u6C04\u6C03\u6C06\u6FAD\u6FCB\u6FA3\u6FC7\u6FBC\u6FCE\u6FC8\u6F5E\u6FC4\u6FBD\u6F9E\u6FCA\u6FA8\u7004\u6FA5\u6FAE\u6FBA\u6FAC\u6FAA\u6FCF\u6FBF\u6FB8"],
      ["ea40", "\u6FA2\u6FC9\u6FAB\u6FCD\u6FAF\u6FB2\u6FB0\u71C5\u71C2\u71BF\u71B8\u71D6\u71C0\u71C1\u71CB\u71D4\u71CA\u71C7\u71CF\u71BD\u71D8\u71BC\u71C6\u71DA\u71DB\u729D\u729E\u7369\u7366\u7367\u736C\u7365\u736B\u736A\u747F\u749A\u74A0\u7494\u7492\u7495\u74A1\u750B\u7580\u762F\u762D\u7631\u763D\u7633\u763C\u7635\u7632\u7630\u76BB\u76E6\u779A\u779D\u77A1\u779C\u779B\u77A2\u77A3\u7795\u7799"],
      ["eaa1", "\u7797\u78DD\u78E9\u78E5\u78EA\u78DE\u78E3\u78DB\u78E1\u78E2\u78ED\u78DF\u78E0\u79A4\u7A44\u7A48\u7A47\u7AB6\u7AB8\u7AB5\u7AB1\u7AB7\u7BDE\u7BE3\u7BE7\u7BDD\u7BD5\u7BE5\u7BDA\u7BE8\u7BF9\u7BD4\u7BEA\u7BE2\u7BDC\u7BEB\u7BD8\u7BDF\u7CD2\u7CD4\u7CD7\u7CD0\u7CD1\u7E12\u7E21\u7E17\u7E0C\u7E1F\u7E20\u7E13\u7E0E\u7E1C\u7E15\u7E1A\u7E22\u7E0B\u7E0F\u7E16\u7E0D\u7E14\u7E25\u7E24\u7F43\u7F7B\u7F7C\u7F7A\u7FB1\u7FEF\u802A\u8029\u806C\u81B1\u81A6\u81AE\u81B9\u81B5\u81AB\u81B0\u81AC\u81B4\u81B2\u81B7\u81A7\u81F2\u8255\u8256\u8257\u8556\u8545\u856B\u854D\u8553\u8561\u8558"],
      ["eb40", "\u8540\u8546\u8564\u8541\u8562\u8544\u8551\u8547\u8563\u853E\u855B\u8571\u854E\u856E\u8575\u8555\u8567\u8560\u858C\u8566\u855D\u8554\u8565\u856C\u8663\u8665\u8664\u879B\u878F\u8797\u8793\u8792\u8788\u8781\u8796\u8798\u8779\u8787\u87A3\u8785\u8790\u8791\u879D\u8784\u8794\u879C\u879A\u8789\u891E\u8926\u8930\u892D\u892E\u8927\u8931\u8922\u8929\u8923\u892F\u892C\u891F\u89F1\u8AE0"],
      ["eba1", "\u8AE2\u8AF2\u8AF4\u8AF5\u8ADD\u8B14\u8AE4\u8ADF\u8AF0\u8AC8\u8ADE\u8AE1\u8AE8\u8AFF\u8AEF\u8AFB\u8C91\u8C92\u8C90\u8CF5\u8CEE\u8CF1\u8CF0\u8CF3\u8D6C\u8D6E\u8DA5\u8DA7\u8E33\u8E3E\u8E38\u8E40\u8E45\u8E36\u8E3C\u8E3D\u8E41\u8E30\u8E3F\u8EBD\u8F36\u8F2E\u8F35\u8F32\u8F39\u8F37\u8F34\u9076\u9079\u907B\u9086\u90FA\u9133\u9135\u9136\u9193\u9190\u9191\u918D\u918F\u9327\u931E\u9308\u931F\u9306\u930F\u937A\u9338\u933C\u931B\u9323\u9312\u9301\u9346\u932D\u930E\u930D\u92CB\u931D\u92FA\u9325\u9313\u92F9\u92F7\u9334\u9302\u9324\u92FF\u9329\u9339\u9335\u932A\u9314\u930C"],
      ["ec40", "\u930B\u92FE\u9309\u9300\u92FB\u9316\u95BC\u95CD\u95BE\u95B9\u95BA\u95B6\u95BF\u95B5\u95BD\u96A9\u96D4\u970B\u9712\u9710\u9799\u9797\u9794\u97F0\u97F8\u9835\u982F\u9832\u9924\u991F\u9927\u9929\u999E\u99EE\u99EC\u99E5\u99E4\u99F0\u99E3\u99EA\u99E9\u99E7\u9AB9\u9ABF\u9AB4\u9ABB\u9AF6\u9AFA\u9AF9\u9AF7\u9B33\u9B80\u9B85\u9B87\u9B7C\u9B7E\u9B7B\u9B82\u9B93\u9B92\u9B90\u9B7A\u9B95"],
      ["eca1", "\u9B7D\u9B88\u9D25\u9D17\u9D20\u9D1E\u9D14\u9D29\u9D1D\u9D18\u9D22\u9D10\u9D19\u9D1F\u9E88\u9E86\u9E87\u9EAE\u9EAD\u9ED5\u9ED6\u9EFA\u9F12\u9F3D\u5126\u5125\u5122\u5124\u5120\u5129\u52F4\u5693\u568C\u568D\u5686\u5684\u5683\u567E\u5682\u567F\u5681\u58D6\u58D4\u58CF\u58D2\u5B2D\u5B25\u5B32\u5B23\u5B2C\u5B27\u5B26\u5B2F\u5B2E\u5B7B\u5BF1\u5BF2\u5DB7\u5E6C\u5E6A\u5FBE\u5FBB\u61C3\u61B5\u61BC\u61E7\u61E0\u61E5\u61E4\u61E8\u61DE\u64EF\u64E9\u64E3\u64EB\u64E4\u64E8\u6581\u6580\u65B6\u65DA\u66D2\u6A8D\u6A96\u6A81\u6AA5\u6A89\u6A9F\u6A9B\u6AA1\u6A9E\u6A87\u6A93\u6A8E"],
      ["ed40", "\u6A95\u6A83\u6AA8\u6AA4\u6A91\u6A7F\u6AA6\u6A9A\u6A85\u6A8C\u6A92\u6B5B\u6BAD\u6C09\u6FCC\u6FA9\u6FF4\u6FD4\u6FE3\u6FDC\u6FED\u6FE7\u6FE6\u6FDE\u6FF2\u6FDD\u6FE2\u6FE8\u71E1\u71F1\u71E8\u71F2\u71E4\u71F0\u71E2\u7373\u736E\u736F\u7497\u74B2\u74AB\u7490\u74AA\u74AD\u74B1\u74A5\u74AF\u7510\u7511\u7512\u750F\u7584\u7643\u7648\u7649\u7647\u76A4\u76E9\u77B5\u77AB\u77B2\u77B7\u77B6"],
      ["eda1", "\u77B4\u77B1\u77A8\u77F0\u78F3\u78FD\u7902\u78FB\u78FC\u78F2\u7905\u78F9\u78FE\u7904\u79AB\u79A8\u7A5C\u7A5B\u7A56\u7A58\u7A54\u7A5A\u7ABE\u7AC0\u7AC1\u7C05\u7C0F\u7BF2\u7C00\u7BFF\u7BFB\u7C0E\u7BF4\u7C0B\u7BF3\u7C02\u7C09\u7C03\u7C01\u7BF8\u7BFD\u7C06\u7BF0\u7BF1\u7C10\u7C0A\u7CE8\u7E2D\u7E3C\u7E42\u7E33\u9848\u7E38\u7E2A\u7E49\u7E40\u7E47\u7E29\u7E4C\u7E30\u7E3B\u7E36\u7E44\u7E3A\u7F45\u7F7F\u7F7E\u7F7D\u7FF4\u7FF2\u802C\u81BB\u81C4\u81CC\u81CA\u81C5\u81C7\u81BC\u81E9\u825B\u825A\u825C\u8583\u8580\u858F\u85A7\u8595\u85A0\u858B\u85A3\u857B\u85A4\u859A\u859E"],
      ["ee40", "\u8577\u857C\u8589\u85A1\u857A\u8578\u8557\u858E\u8596\u8586\u858D\u8599\u859D\u8581\u85A2\u8582\u8588\u8585\u8579\u8576\u8598\u8590\u859F\u8668\u87BE\u87AA\u87AD\u87C5\u87B0\u87AC\u87B9\u87B5\u87BC\u87AE\u87C9\u87C3\u87C2\u87CC\u87B7\u87AF\u87C4\u87CA\u87B4\u87B6\u87BF\u87B8\u87BD\u87DE\u87B2\u8935\u8933\u893C\u893E\u8941\u8952\u8937\u8942\u89AD\u89AF\u89AE\u89F2\u89F3\u8B1E"],
      ["eea1", "\u8B18\u8B16\u8B11\u8B05\u8B0B\u8B22\u8B0F\u8B12\u8B15\u8B07\u8B0D\u8B08\u8B06\u8B1C\u8B13\u8B1A\u8C4F\u8C70\u8C72\u8C71\u8C6F\u8C95\u8C94\u8CF9\u8D6F\u8E4E\u8E4D\u8E53\u8E50\u8E4C\u8E47\u8F43\u8F40\u9085\u907E\u9138\u919A\u91A2\u919B\u9199\u919F\u91A1\u919D\u91A0\u93A1\u9383\u93AF\u9364\u9356\u9347\u937C\u9358\u935C\u9376\u9349\u9350\u9351\u9360\u936D\u938F\u934C\u936A\u9379\u9357\u9355\u9352\u934F\u9371\u9377\u937B\u9361\u935E\u9363\u9367\u9380\u934E\u9359\u95C7\u95C0\u95C9\u95C3\u95C5\u95B7\u96AE\u96B0\u96AC\u9720\u971F\u9718\u971D\u9719\u979A\u97A1\u979C"],
      ["ef40", "\u979E\u979D\u97D5\u97D4\u97F1\u9841\u9844\u984A\u9849\u9845\u9843\u9925\u992B\u992C\u992A\u9933\u9932\u992F\u992D\u9931\u9930\u9998\u99A3\u99A1\u9A02\u99FA\u99F4\u99F7\u99F9\u99F8\u99F6\u99FB\u99FD\u99FE\u99FC\u9A03\u9ABE\u9AFE\u9AFD\u9B01\u9AFC\u9B48\u9B9A\u9BA8\u9B9E\u9B9B\u9BA6\u9BA1\u9BA5\u9BA4\u9B86\u9BA2\u9BA0\u9BAF\u9D33\u9D41\u9D67\u9D36\u9D2E\u9D2F\u9D31\u9D38\u9D30"],
      ["efa1", "\u9D45\u9D42\u9D43\u9D3E\u9D37\u9D40\u9D3D\u7FF5\u9D2D\u9E8A\u9E89\u9E8D\u9EB0\u9EC8\u9EDA\u9EFB\u9EFF\u9F24\u9F23\u9F22\u9F54\u9FA0\u5131\u512D\u512E\u5698\u569C\u5697\u569A\u569D\u5699\u5970\u5B3C\u5C69\u5C6A\u5DC0\u5E6D\u5E6E\u61D8\u61DF\u61ED\u61EE\u61F1\u61EA\u61F0\u61EB\u61D6\u61E9\u64FF\u6504\u64FD\u64F8\u6501\u6503\u64FC\u6594\u65DB\u66DA\u66DB\u66D8\u6AC5\u6AB9\u6ABD\u6AE1\u6AC6\u6ABA\u6AB6\u6AB7\u6AC7\u6AB4\u6AAD\u6B5E\u6BC9\u6C0B\u7007\u700C\u700D\u7001\u7005\u7014\u700E\u6FFF\u7000\u6FFB\u7026\u6FFC\u6FF7\u700A\u7201\u71FF\u71F9\u7203\u71FD\u7376"],
      ["f040", "\u74B8\u74C0\u74B5\u74C1\u74BE\u74B6\u74BB\u74C2\u7514\u7513\u765C\u7664\u7659\u7650\u7653\u7657\u765A\u76A6\u76BD\u76EC\u77C2\u77BA\u78FF\u790C\u7913\u7914\u7909\u7910\u7912\u7911\u79AD\u79AC\u7A5F\u7C1C\u7C29\u7C19\u7C20\u7C1F\u7C2D\u7C1D\u7C26\u7C28\u7C22\u7C25\u7C30\u7E5C\u7E50\u7E56\u7E63\u7E58\u7E62\u7E5F\u7E51\u7E60\u7E57\u7E53\u7FB5\u7FB3\u7FF7\u7FF8\u8075\u81D1\u81D2"],
      ["f0a1", "\u81D0\u825F\u825E\u85B4\u85C6\u85C0\u85C3\u85C2\u85B3\u85B5\u85BD\u85C7\u85C4\u85BF\u85CB\u85CE\u85C8\u85C5\u85B1\u85B6\u85D2\u8624\u85B8\u85B7\u85BE\u8669\u87E7\u87E6\u87E2\u87DB\u87EB\u87EA\u87E5\u87DF\u87F3\u87E4\u87D4\u87DC\u87D3\u87ED\u87D8\u87E3\u87A4\u87D7\u87D9\u8801\u87F4\u87E8\u87DD\u8953\u894B\u894F\u894C\u8946\u8950\u8951\u8949\u8B2A\u8B27\u8B23\u8B33\u8B30\u8B35\u8B47\u8B2F\u8B3C\u8B3E\u8B31\u8B25\u8B37\u8B26\u8B36\u8B2E\u8B24\u8B3B\u8B3D\u8B3A\u8C42\u8C75\u8C99\u8C98\u8C97\u8CFE\u8D04\u8D02\u8D00\u8E5C\u8E62\u8E60\u8E57\u8E56\u8E5E\u8E65\u8E67"],
      ["f140", "\u8E5B\u8E5A\u8E61\u8E5D\u8E69\u8E54\u8F46\u8F47\u8F48\u8F4B\u9128\u913A\u913B\u913E\u91A8\u91A5\u91A7\u91AF\u91AA\u93B5\u938C\u9392\u93B7\u939B\u939D\u9389\u93A7\u938E\u93AA\u939E\u93A6\u9395\u9388\u9399\u939F\u938D\u93B1\u9391\u93B2\u93A4\u93A8\u93B4\u93A3\u93A5\u95D2\u95D3\u95D1\u96B3\u96D7\u96DA\u5DC2\u96DF\u96D8\u96DD\u9723\u9722\u9725\u97AC\u97AE\u97A8\u97AB\u97A4\u97AA"],
      ["f1a1", "\u97A2\u97A5\u97D7\u97D9\u97D6\u97D8\u97FA\u9850\u9851\u9852\u98B8\u9941\u993C\u993A\u9A0F\u9A0B\u9A09\u9A0D\u9A04\u9A11\u9A0A\u9A05\u9A07\u9A06\u9AC0\u9ADC\u9B08\u9B04\u9B05\u9B29\u9B35\u9B4A\u9B4C\u9B4B\u9BC7\u9BC6\u9BC3\u9BBF\u9BC1\u9BB5\u9BB8\u9BD3\u9BB6\u9BC4\u9BB9\u9BBD\u9D5C\u9D53\u9D4F\u9D4A\u9D5B\u9D4B\u9D59\u9D56\u9D4C\u9D57\u9D52\u9D54\u9D5F\u9D58\u9D5A\u9E8E\u9E8C\u9EDF\u9F01\u9F00\u9F16\u9F25\u9F2B\u9F2A\u9F29\u9F28\u9F4C\u9F55\u5134\u5135\u5296\u52F7\u53B4\u56AB\u56AD\u56A6\u56A7\u56AA\u56AC\u58DA\u58DD\u58DB\u5912\u5B3D\u5B3E\u5B3F\u5DC3\u5E70"],
      ["f240", "\u5FBF\u61FB\u6507\u6510\u650D\u6509\u650C\u650E\u6584\u65DE\u65DD\u66DE\u6AE7\u6AE0\u6ACC\u6AD1\u6AD9\u6ACB\u6ADF\u6ADC\u6AD0\u6AEB\u6ACF\u6ACD\u6ADE\u6B60\u6BB0\u6C0C\u7019\u7027\u7020\u7016\u702B\u7021\u7022\u7023\u7029\u7017\u7024\u701C\u702A\u720C\u720A\u7207\u7202\u7205\u72A5\u72A6\u72A4\u72A3\u72A1\u74CB\u74C5\u74B7\u74C3\u7516\u7660\u77C9\u77CA\u77C4\u77F1\u791D\u791B"],
      ["f2a1", "\u7921\u791C\u7917\u791E\u79B0\u7A67\u7A68\u7C33\u7C3C\u7C39\u7C2C\u7C3B\u7CEC\u7CEA\u7E76\u7E75\u7E78\u7E70\u7E77\u7E6F\u7E7A\u7E72\u7E74\u7E68\u7F4B\u7F4A\u7F83\u7F86\u7FB7\u7FFD\u7FFE\u8078\u81D7\u81D5\u8264\u8261\u8263\u85EB\u85F1\u85ED\u85D9\u85E1\u85E8\u85DA\u85D7\u85EC\u85F2\u85F8\u85D8\u85DF\u85E3\u85DC\u85D1\u85F0\u85E6\u85EF\u85DE\u85E2\u8800\u87FA\u8803\u87F6\u87F7\u8809\u880C\u880B\u8806\u87FC\u8808\u87FF\u880A\u8802\u8962\u895A\u895B\u8957\u8961\u895C\u8958\u895D\u8959\u8988\u89B7\u89B6\u89F6\u8B50\u8B48\u8B4A\u8B40\u8B53\u8B56\u8B54\u8B4B\u8B55"],
      ["f340", "\u8B51\u8B42\u8B52\u8B57\u8C43\u8C77\u8C76\u8C9A\u8D06\u8D07\u8D09\u8DAC\u8DAA\u8DAD\u8DAB\u8E6D\u8E78\u8E73\u8E6A\u8E6F\u8E7B\u8EC2\u8F52\u8F51\u8F4F\u8F50\u8F53\u8FB4\u9140\u913F\u91B0\u91AD\u93DE\u93C7\u93CF\u93C2\u93DA\u93D0\u93F9\u93EC\u93CC\u93D9\u93A9\u93E6\u93CA\u93D4\u93EE\u93E3\u93D5\u93C4\u93CE\u93C0\u93D2\u93E7\u957D\u95DA\u95DB\u96E1\u9729\u972B\u972C\u9728\u9726"],
      ["f3a1", "\u97B3\u97B7\u97B6\u97DD\u97DE\u97DF\u985C\u9859\u985D\u9857\u98BF\u98BD\u98BB\u98BE\u9948\u9947\u9943\u99A6\u99A7\u9A1A\u9A15\u9A25\u9A1D\u9A24\u9A1B\u9A22\u9A20\u9A27\u9A23\u9A1E\u9A1C\u9A14\u9AC2\u9B0B\u9B0A\u9B0E\u9B0C\u9B37\u9BEA\u9BEB\u9BE0\u9BDE\u9BE4\u9BE6\u9BE2\u9BF0\u9BD4\u9BD7\u9BEC\u9BDC\u9BD9\u9BE5\u9BD5\u9BE1\u9BDA\u9D77\u9D81\u9D8A\u9D84\u9D88\u9D71\u9D80\u9D78\u9D86\u9D8B\u9D8C\u9D7D\u9D6B\u9D74\u9D75\u9D70\u9D69\u9D85\u9D73\u9D7B\u9D82\u9D6F\u9D79\u9D7F\u9D87\u9D68\u9E94\u9E91\u9EC0\u9EFC\u9F2D\u9F40\u9F41\u9F4D\u9F56\u9F57\u9F58\u5337\u56B2"],
      ["f440", "\u56B5\u56B3\u58E3\u5B45\u5DC6\u5DC7\u5EEE\u5EEF\u5FC0\u5FC1\u61F9\u6517\u6516\u6515\u6513\u65DF\u66E8\u66E3\u66E4\u6AF3\u6AF0\u6AEA\u6AE8\u6AF9\u6AF1\u6AEE\u6AEF\u703C\u7035\u702F\u7037\u7034\u7031\u7042\u7038\u703F\u703A\u7039\u7040\u703B\u7033\u7041\u7213\u7214\u72A8\u737D\u737C\u74BA\u76AB\u76AA\u76BE\u76ED\u77CC\u77CE\u77CF\u77CD\u77F2\u7925\u7923\u7927\u7928\u7924\u7929"],
      ["f4a1", "\u79B2\u7A6E\u7A6C\u7A6D\u7AF7\u7C49\u7C48\u7C4A\u7C47\u7C45\u7CEE\u7E7B\u7E7E\u7E81\u7E80\u7FBA\u7FFF\u8079\u81DB\u81D9\u820B\u8268\u8269\u8622\u85FF\u8601\u85FE\u861B\u8600\u85F6\u8604\u8609\u8605\u860C\u85FD\u8819\u8810\u8811\u8817\u8813\u8816\u8963\u8966\u89B9\u89F7\u8B60\u8B6A\u8B5D\u8B68\u8B63\u8B65\u8B67\u8B6D\u8DAE\u8E86\u8E88\u8E84\u8F59\u8F56\u8F57\u8F55\u8F58\u8F5A\u908D\u9143\u9141\u91B7\u91B5\u91B2\u91B3\u940B\u9413\u93FB\u9420\u940F\u9414\u93FE\u9415\u9410\u9428\u9419\u940D\u93F5\u9400\u93F7\u9407\u940E\u9416\u9412\u93FA\u9409\u93F8\u940A\u93FF"],
      ["f540", "\u93FC\u940C\u93F6\u9411\u9406\u95DE\u95E0\u95DF\u972E\u972F\u97B9\u97BB\u97FD\u97FE\u9860\u9862\u9863\u985F\u98C1\u98C2\u9950\u994E\u9959\u994C\u994B\u9953\u9A32\u9A34\u9A31\u9A2C\u9A2A\u9A36\u9A29\u9A2E\u9A38\u9A2D\u9AC7\u9ACA\u9AC6\u9B10\u9B12\u9B11\u9C0B\u9C08\u9BF7\u9C05\u9C12\u9BF8\u9C40\u9C07\u9C0E\u9C06\u9C17\u9C14\u9C09\u9D9F\u9D99\u9DA4\u9D9D\u9D92\u9D98\u9D90\u9D9B"],
      ["f5a1", "\u9DA0\u9D94\u9D9C\u9DAA\u9D97\u9DA1\u9D9A\u9DA2\u9DA8\u9D9E\u9DA3\u9DBF\u9DA9\u9D96\u9DA6\u9DA7\u9E99\u9E9B\u9E9A\u9EE5\u9EE4\u9EE7\u9EE6\u9F30\u9F2E\u9F5B\u9F60\u9F5E\u9F5D\u9F59\u9F91\u513A\u5139\u5298\u5297\u56C3\u56BD\u56BE\u5B48\u5B47\u5DCB\u5DCF\u5EF1\u61FD\u651B\u6B02\u6AFC\u6B03\u6AF8\u6B00\u7043\u7044\u704A\u7048\u7049\u7045\u7046\u721D\u721A\u7219\u737E\u7517\u766A\u77D0\u792D\u7931\u792F\u7C54\u7C53\u7CF2\u7E8A\u7E87\u7E88\u7E8B\u7E86\u7E8D\u7F4D\u7FBB\u8030\u81DD\u8618\u862A\u8626\u861F\u8623\u861C\u8619\u8627\u862E\u8621\u8620\u8629\u861E\u8625"],
      ["f640", "\u8829\u881D\u881B\u8820\u8824\u881C\u882B\u884A\u896D\u8969\u896E\u896B\u89FA\u8B79\u8B78\u8B45\u8B7A\u8B7B\u8D10\u8D14\u8DAF\u8E8E\u8E8C\u8F5E\u8F5B\u8F5D\u9146\u9144\u9145\u91B9\u943F\u943B\u9436\u9429\u943D\u943C\u9430\u9439\u942A\u9437\u942C\u9440\u9431\u95E5\u95E4\u95E3\u9735\u973A\u97BF\u97E1\u9864\u98C9\u98C6\u98C0\u9958\u9956\u9A39\u9A3D\u9A46\u9A44\u9A42\u9A41\u9A3A"],
      ["f6a1", "\u9A3F\u9ACD\u9B15\u9B17\u9B18\u9B16\u9B3A\u9B52\u9C2B\u9C1D\u9C1C\u9C2C\u9C23\u9C28\u9C29\u9C24\u9C21\u9DB7\u9DB6\u9DBC\u9DC1\u9DC7\u9DCA\u9DCF\u9DBE\u9DC5\u9DC3\u9DBB\u9DB5\u9DCE\u9DB9\u9DBA\u9DAC\u9DC8\u9DB1\u9DAD\u9DCC\u9DB3\u9DCD\u9DB2\u9E7A\u9E9C\u9EEB\u9EEE\u9EED\u9F1B\u9F18\u9F1A\u9F31\u9F4E\u9F65\u9F64\u9F92\u4EB9\u56C6\u56C5\u56CB\u5971\u5B4B\u5B4C\u5DD5\u5DD1\u5EF2\u6521\u6520\u6526\u6522\u6B0B\u6B08\u6B09\u6C0D\u7055\u7056\u7057\u7052\u721E\u721F\u72A9\u737F\u74D8\u74D5\u74D9\u74D7\u766D\u76AD\u7935\u79B4\u7A70\u7A71\u7C57\u7C5C\u7C59\u7C5B\u7C5A"],
      ["f740", "\u7CF4\u7CF1\u7E91\u7F4F\u7F87\u81DE\u826B\u8634\u8635\u8633\u862C\u8632\u8636\u882C\u8828\u8826\u882A\u8825\u8971\u89BF\u89BE\u89FB\u8B7E\u8B84\u8B82\u8B86\u8B85\u8B7F\u8D15\u8E95\u8E94\u8E9A\u8E92\u8E90\u8E96\u8E97\u8F60\u8F62\u9147\u944C\u9450\u944A\u944B\u944F\u9447\u9445\u9448\u9449\u9446\u973F\u97E3\u986A\u9869\u98CB\u9954\u995B\u9A4E\u9A53\u9A54\u9A4C\u9A4F\u9A48\u9A4A"],
      ["f7a1", "\u9A49\u9A52\u9A50\u9AD0\u9B19\u9B2B\u9B3B\u9B56\u9B55\u9C46\u9C48\u9C3F\u9C44\u9C39\u9C33\u9C41\u9C3C\u9C37\u9C34\u9C32\u9C3D\u9C36\u9DDB\u9DD2\u9DDE\u9DDA\u9DCB\u9DD0\u9DDC\u9DD1\u9DDF\u9DE9\u9DD9\u9DD8\u9DD6\u9DF5\u9DD5\u9DDD\u9EB6\u9EF0\u9F35\u9F33\u9F32\u9F42\u9F6B\u9F95\u9FA2\u513D\u5299\u58E8\u58E7\u5972\u5B4D\u5DD8\u882F\u5F4F\u6201\u6203\u6204\u6529\u6525\u6596\u66EB\u6B11\u6B12\u6B0F\u6BCA\u705B\u705A\u7222\u7382\u7381\u7383\u7670\u77D4\u7C67\u7C66\u7E95\u826C\u863A\u8640\u8639\u863C\u8631\u863B\u863E\u8830\u8832\u882E\u8833\u8976\u8974\u8973\u89FE"],
      ["f840", "\u8B8C\u8B8E\u8B8B\u8B88\u8C45\u8D19\u8E98\u8F64\u8F63\u91BC\u9462\u9455\u945D\u9457\u945E\u97C4\u97C5\u9800\u9A56\u9A59\u9B1E\u9B1F\u9B20\u9C52\u9C58\u9C50\u9C4A\u9C4D\u9C4B\u9C55\u9C59\u9C4C\u9C4E\u9DFB\u9DF7\u9DEF\u9DE3\u9DEB\u9DF8\u9DE4\u9DF6\u9DE1\u9DEE\u9DE6\u9DF2\u9DF0\u9DE2\u9DEC\u9DF4\u9DF3\u9DE8\u9DED\u9EC2\u9ED0\u9EF2\u9EF3\u9F06\u9F1C\u9F38\u9F37\u9F36\u9F43\u9F4F"],
      ["f8a1", "\u9F71\u9F70\u9F6E\u9F6F\u56D3\u56CD\u5B4E\u5C6D\u652D\u66ED\u66EE\u6B13\u705F\u7061\u705D\u7060\u7223\u74DB\u74E5\u77D5\u7938\u79B7\u79B6\u7C6A\u7E97\u7F89\u826D\u8643\u8838\u8837\u8835\u884B\u8B94\u8B95\u8E9E\u8E9F\u8EA0\u8E9D\u91BE\u91BD\u91C2\u946B\u9468\u9469\u96E5\u9746\u9743\u9747\u97C7\u97E5\u9A5E\u9AD5\u9B59\u9C63\u9C67\u9C66\u9C62\u9C5E\u9C60\u9E02\u9DFE\u9E07\u9E03\u9E06\u9E05\u9E00\u9E01\u9E09\u9DFF\u9DFD\u9E04\u9EA0\u9F1E\u9F46\u9F74\u9F75\u9F76\u56D4\u652E\u65B8\u6B18\u6B19\u6B17\u6B1A\u7062\u7226\u72AA\u77D8\u77D9\u7939\u7C69\u7C6B\u7CF6\u7E9A"],
      ["f940", "\u7E98\u7E9B\u7E99\u81E0\u81E1\u8646\u8647\u8648\u8979\u897A\u897C\u897B\u89FF\u8B98\u8B99\u8EA5\u8EA4\u8EA3\u946E\u946D\u946F\u9471\u9473\u9749\u9872\u995F\u9C68\u9C6E\u9C6D\u9E0B\u9E0D\u9E10\u9E0F\u9E12\u9E11\u9EA1\u9EF5\u9F09\u9F47\u9F78\u9F7B\u9F7A\u9F79\u571E\u7066\u7C6F\u883C\u8DB2\u8EA6\u91C3\u9474\u9478\u9476\u9475\u9A60\u9C74\u9C73\u9C71\u9C75\u9E14\u9E13\u9EF6\u9F0A"],
      ["f9a1", "\u9FA4\u7068\u7065\u7CF7\u866A\u883E\u883D\u883F\u8B9E\u8C9C\u8EA9\u8EC9\u974B\u9873\u9874\u98CC\u9961\u99AB\u9A64\u9A66\u9A67\u9B24\u9E15\u9E17\u9F48\u6207\u6B1E\u7227\u864C\u8EA8\u9482\u9480\u9481\u9A69\u9A68\u9B2E\u9E19\u7229\u864B\u8B9F\u9483\u9C79\u9EB7\u7675\u9A6B\u9C7A\u9E1D\u7069\u706A\u9EA4\u9F7E\u9F49\u9F98\u7881\u92B9\u88CF\u58BB\u6052\u7CA7\u5AFA\u2554\u2566\u2557\u2560\u256C\u2563\u255A\u2569\u255D\u2552\u2564\u2555\u255E\u256A\u2561\u2558\u2567\u255B\u2553\u2565\u2556\u255F\u256B\u2562\u2559\u2568\u255C\u2551\u2550\u256D\u256E\u2570\u256F\u2593"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS({
  "node_modules/iconv-lite/encodings/tables/big5-added.json"(exports2, module2) {
    module2.exports = [
      ["8740", "\u43F0\u4C32\u4603\u45A6\u4578\u{27267}\u4D77\u45B3\u{27CB1}\u4CE2\u{27CC5}\u3B95\u4736\u4744\u4C47\u4C40\u{242BF}\u{23617}\u{27352}\u{26E8B}\u{270D2}\u4C57\u{2A351}\u474F\u45DA\u4C85\u{27C6C}\u4D07\u4AA4\u46A1\u{26B23}\u7225\u{25A54}\u{21A63}\u{23E06}\u{23F61}\u664D\u56FB"],
      ["8767", "\u7D95\u591D\u{28BB9}\u3DF4\u9734\u{27BEF}\u5BDB\u{21D5E}\u5AA4\u3625\u{29EB0}\u5AD1\u5BB7\u5CFC\u676E\u8593\u{29945}\u7461\u749D\u3875\u{21D53}\u{2369E}\u{26021}\u3EEC"],
      ["87a1", "\u{258DE}\u3AF5\u7AFC\u9F97\u{24161}\u{2890D}\u{231EA}\u{20A8A}\u{2325E}\u430A\u8484\u9F96\u942F\u4930\u8613\u5896\u974A\u9218\u79D0\u7A32\u6660\u6A29\u889D\u744C\u7BC5\u6782\u7A2C\u524F\u9046\u34E6\u73C4\u{25DB9}\u74C6\u9FC7\u57B3\u492F\u544C\u4131\u{2368E}\u5818\u7A72\u{27B65}\u8B8F\u46AE\u{26E88}\u4181\u{25D99}\u7BAE\u{224BC}\u9FC8\u{224C1}\u{224C9}\u{224CC}\u9FC9\u8504\u{235BB}\u40B4\u9FCA\u44E1\u{2ADFF}\u62C1\u706E\u9FCB"],
      ["8840", "\u31C0", 4, "\u{2010C}\u31C5\u{200D1}\u{200CD}\u31C6\u31C7\u{200CB}\u{21FE8}\u31C8\u{200CA}\u31C9\u31CA\u31CB\u31CC\u{2010E}\u31CD\u31CE\u0100\xC1\u01CD\xC0\u0112\xC9\u011A\xC8\u014C\xD3\u01D1\xD2\u0FFF\xCA\u0304\u1EBE\u0FFF\xCA\u030C\u1EC0\xCA\u0101\xE1\u01CE\xE0\u0251\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA"],
      ["88a1", "\u01DC\xFC\u0FFF\xEA\u0304\u1EBF\u0FFF\xEA\u030C\u1EC1\xEA\u0261\u23DA\u23DB"],
      ["8940", "\u{2A3A9}\u{21145}"],
      ["8943", "\u650A"],
      ["8946", "\u4E3D\u6EDD\u9D4E\u91DF"],
      ["894c", "\u{27735}\u6491\u4F1A\u4F28\u4FA8\u5156\u5174\u519C\u51E4\u52A1\u52A8\u533B\u534E\u53D1\u53D8\u56E2\u58F0\u5904\u5907\u5932\u5934\u5B66\u5B9E\u5B9F\u5C9A\u5E86\u603B\u6589\u67FE\u6804\u6865\u6D4E\u70BC\u7535\u7EA4\u7EAC\u7EBA\u7EC7\u7ECF\u7EDF\u7F06\u7F37\u827A\u82CF\u836F\u89C6\u8BBE\u8BE2\u8F66\u8F67\u8F6E"],
      ["89a1", "\u7411\u7CFC\u7DCD\u6946\u7AC9\u5227"],
      ["89ab", "\u918C\u78B8\u915E\u80BC"],
      ["89b0", "\u8D0B\u80F6\u{209E7}"],
      ["89b5", "\u809F\u9EC7\u4CCD\u9DC9\u9E0C\u4C3E\u{29DF6}\u{2700E}\u9E0A\u{2A133}\u35C1"],
      ["89c1", "\u6E9A\u823E\u7519"],
      ["89c5", "\u4911\u9A6C\u9A8F\u9F99\u7987\u{2846C}\u{21DCA}\u{205D0}\u{22AE6}\u4E24\u4E81\u4E80\u4E87\u4EBF\u4EEB\u4F37\u344C\u4FBD\u3E48\u5003\u5088\u347D\u3493\u34A5\u5186\u5905\u51DB\u51FC\u5205\u4E89\u5279\u5290\u5327\u35C7\u53A9\u3551\u53B0\u3553\u53C2\u5423\u356D\u3572\u3681\u5493\u54A3\u54B4\u54B9\u54D0\u54EF\u5518\u5523\u5528\u3598\u553F\u35A5\u35BF\u55D7\u35C5"],
      ["8a40", "\u{27D84}\u5525"],
      ["8a43", "\u{20C42}\u{20D15}\u{2512B}\u5590\u{22CC6}\u39EC\u{20341}\u8E46\u{24DB8}\u{294E5}\u4053\u{280BE}\u777A\u{22C38}\u3A34\u47D5\u{2815D}\u{269F2}\u{24DEA}\u64DD\u{20D7C}\u{20FB4}\u{20CD5}\u{210F4}\u648D\u8E7E\u{20E96}\u{20C0B}\u{20F64}\u{22CA9}\u{28256}\u{244D3}"],
      ["8a64", "\u{20D46}\u{29A4D}\u{280E9}\u47F4\u{24EA7}\u{22CC2}\u9AB2\u3A67\u{295F4}\u3FED\u3506\u{252C7}\u{297D4}\u{278C8}\u{22D44}\u9D6E\u9815"],
      ["8a76", "\u43D9\u{260A5}\u64B4\u54E3\u{22D4C}\u{22BCA}\u{21077}\u39FB\u{2106F}"],
      ["8aa1", "\u{266DA}\u{26716}\u{279A0}\u64EA\u{25052}\u{20C43}\u8E68\u{221A1}\u{28B4C}\u{20731}"],
      ["8aac", "\u480B\u{201A9}\u3FFA\u5873\u{22D8D}"],
      ["8ab2", "\u{245C8}\u{204FC}\u{26097}\u{20F4C}\u{20D96}\u5579\u40BB\u43BA"],
      ["8abb", "\u4AB4\u{22A66}\u{2109D}\u81AA\u98F5\u{20D9C}\u6379\u39FE\u{22775}\u8DC0\u56A1\u647C\u3E43"],
      ["8ac9", "\u{2A601}\u{20E09}\u{22ACF}\u{22CC9}"],
      ["8ace", "\u{210C8}\u{239C2}\u3992\u3A06\u{2829B}\u3578\u{25E49}\u{220C7}\u5652\u{20F31}\u{22CB2}\u{29720}\u34BC\u6C3D\u{24E3B}"],
      ["8adf", "\u{27574}\u{22E8B}\u{22208}\u{2A65B}\u{28CCD}\u{20E7A}\u{20C34}\u{2681C}\u7F93\u{210CF}\u{22803}\u{22939}\u35FB\u{251E3}\u{20E8C}\u{20F8D}\u{20EAA}\u3F93\u{20F30}\u{20D47}\u{2114F}\u{20E4C}"],
      ["8af6", "\u{20EAB}\u{20BA9}\u{20D48}\u{210C0}\u{2113D}\u3FF9\u{22696}\u6432\u{20FAD}"],
      ["8b40", "\u{233F4}\u{27639}\u{22BCE}\u{20D7E}\u{20D7F}\u{22C51}\u{22C55}\u3A18\u{20E98}\u{210C7}\u{20F2E}\u{2A632}\u{26B50}\u{28CD2}\u{28D99}\u{28CCA}\u95AA\u54CC\u82C4\u55B9"],
      ["8b55", "\u{29EC3}\u9C26\u9AB6\u{2775E}\u{22DEE}\u7140\u816D\u80EC\u5C1C\u{26572}\u8134\u3797\u535F\u{280BD}\u91B6\u{20EFA}\u{20E0F}\u{20E77}\u{20EFB}\u35DD\u{24DEB}\u3609\u{20CD6}\u56AF\u{227B5}\u{210C9}\u{20E10}\u{20E78}\u{21078}\u{21148}\u{28207}\u{21455}\u{20E79}\u{24E50}\u{22DA4}\u5A54\u{2101D}\u{2101E}\u{210F5}\u{210F6}\u579C\u{20E11}"],
      ["8ba1", "\u{27694}\u{282CD}\u{20FB5}\u{20E7B}\u{2517E}\u3703\u{20FB6}\u{21180}\u{252D8}\u{2A2BD}\u{249DA}\u{2183A}\u{24177}\u{2827C}\u5899\u5268\u361A\u{2573D}\u7BB2\u5B68\u4800\u4B2C\u9F27\u49E7\u9C1F\u9B8D\u{25B74}\u{2313D}\u55FB\u35F2\u5689\u4E28\u5902\u{21BC1}\u{2F878}\u9751\u{20086}\u4E5B\u4EBB\u353E\u5C23\u5F51\u5FC4\u38FA\u624C\u6535\u6B7A\u6C35\u6C3A\u706C\u722B\u4E2C\u72AD\u{248E9}\u7F52\u793B\u7CF9\u7F53\u{2626A}\u34C1"],
      ["8bde", "\u{2634B}\u8002\u8080\u{26612}\u{26951}\u535D\u8864\u89C1\u{278B2}\u8BA0\u8D1D\u9485\u9578\u957F\u95E8\u{28E0F}\u97E6\u9875\u98CE\u98DE\u9963\u{29810}\u9C7C\u9E1F\u9EC4\u6B6F\uF907\u4E37\u{20087}\u961D\u6237\u94A2"],
      ["8c40", "\u503B\u6DFE\u{29C73}\u9FA6\u3DC9\u888F\u{2414E}\u7077\u5CF5\u4B20\u{251CD}\u3559\u{25D30}\u6122\u{28A32}\u8FA7\u91F6\u7191\u6719\u73BA\u{23281}\u{2A107}\u3C8B\u{21980}\u4B10\u78E4\u7402\u51AE\u{2870F}\u4009\u6A63\u{2A2BA}\u4223\u860F\u{20A6F}\u7A2A\u{29947}\u{28AEA}\u9755\u704D\u5324\u{2207E}\u93F4\u76D9\u{289E3}\u9FA7\u77DD\u4EA3\u4FF0\u50BC\u4E2F\u4F17\u9FA8\u5434\u7D8B\u5892\u58D0\u{21DB6}\u5E92\u5E99\u5FC2\u{22712}\u658B"],
      ["8ca1", "\u{233F9}\u6919\u6A43\u{23C63}\u6CFF"],
      ["8ca7", "\u7200\u{24505}\u738C\u3EDB\u{24A13}\u5B15\u74B9\u8B83\u{25CA4}\u{25695}\u7A93\u7BEC\u7CC3\u7E6C\u82F8\u8597\u9FA9\u8890\u9FAA\u8EB9\u9FAB\u8FCF\u855F\u99E0\u9221\u9FAC\u{28DB9}\u{2143F}\u4071\u42A2\u5A1A"],
      ["8cc9", "\u9868\u676B\u4276\u573D"],
      ["8cce", "\u85D6\u{2497B}\u82BF\u{2710D}\u4C81\u{26D74}\u5D7B\u{26B15}\u{26FBE}\u9FAD\u9FAE\u5B96\u9FAF\u66E7\u7E5B\u6E57\u79CA\u3D88\u44C3\u{23256}\u{22796}\u439A\u4536"],
      ["8ce6", "\u5CD5\u{23B1A}\u8AF9\u5C78\u3D12\u{23551}\u5D78\u9FB2\u7157\u4558\u{240EC}\u{21E23}\u4C77\u3978\u344A\u{201A4}\u{26C41}\u8ACC\u4FB4\u{20239}\u59BF\u816C\u9856\u{298FA}\u5F3B"],
      ["8d40", "\u{20B9F}"],
      ["8d42", "\u{221C1}\u{2896D}\u4102\u46BB\u{29079}\u3F07\u9FB3\u{2A1B5}\u40F8\u37D6\u46F7\u{26C46}\u417C\u{286B2}\u{273FF}\u456D\u38D4\u{2549A}\u4561\u451B\u4D89\u4C7B\u4D76\u45EA\u3FC8\u{24B0F}\u3661\u44DE\u44BD\u41ED\u5D3E\u5D48\u5D56\u3DFC\u380F\u5DA4\u5DB9\u3820\u3838\u5E42\u5EBD\u5F25\u5F83\u3908\u3914\u393F\u394D\u60D7\u613D\u5CE5\u3989\u61B7\u61B9\u61CF\u39B8\u622C\u6290\u62E5\u6318\u39F8\u56B1"],
      ["8da1", "\u3A03\u63E2\u63FB\u6407\u645A\u3A4B\u64C0\u5D15\u5621\u9F9F\u3A97\u6586\u3ABD\u65FF\u6653\u3AF2\u6692\u3B22\u6716\u3B42\u67A4\u6800\u3B58\u684A\u6884\u3B72\u3B71\u3B7B\u6909\u6943\u725C\u6964\u699F\u6985\u3BBC\u69D6\u3BDD\u6A65\u6A74\u6A71\u6A82\u3BEC\u6A99\u3BF2\u6AAB\u6AB5\u6AD4\u6AF6\u6B81\u6BC1\u6BEA\u6C75\u6CAA\u3CCB\u6D02\u6D06\u6D26\u6D81\u3CEF\u6DA4\u6DB1\u6E15\u6E18\u6E29\u6E86\u{289C0}\u6EBB\u6EE2\u6EDA\u9F7F\u6EE8\u6EE9\u6F24\u6F34\u3D46\u{23F41}\u6F81\u6FBE\u3D6A\u3D75\u71B7\u5C99\u3D8A\u702C\u3D91\u7050\u7054\u706F\u707F\u7089\u{20325}\u43C1\u35F1\u{20ED8}"],
      ["8e40", "\u{23ED7}\u57BE\u{26ED3}\u713E\u{257E0}\u364E\u69A2\u{28BE9}\u5B74\u7A49\u{258E1}\u{294D9}\u7A65\u7A7D\u{259AC}\u7ABB\u7AB0\u7AC2\u7AC3\u71D1\u{2648D}\u41CA\u7ADA\u7ADD\u7AEA\u41EF\u54B2\u{25C01}\u7B0B\u7B55\u7B29\u{2530E}\u{25CFE}\u7BA2\u7B6F\u839C\u{25BB4}\u{26C7F}\u7BD0\u8421\u7B92\u7BB8\u{25D20}\u3DAD\u{25C65}\u8492\u7BFA\u7C06\u7C35\u{25CC1}\u7C44\u7C83\u{24882}\u7CA6\u667D\u{24578}\u7CC9\u7CC7\u7CE6\u7C74\u7CF3\u7CF5\u7CCE"],
      ["8ea1", "\u7E67\u451D\u{26E44}\u7D5D\u{26ED6}\u748D\u7D89\u7DAB\u7135\u7DB3\u7DD2\u{24057}\u{26029}\u7DE4\u3D13\u7DF5\u{217F9}\u7DE5\u{2836D}\u7E1D\u{26121}\u{2615A}\u7E6E\u7E92\u432B\u946C\u7E27\u7F40\u7F41\u7F47\u7936\u{262D0}\u99E1\u7F97\u{26351}\u7FA3\u{21661}\u{20068}\u455C\u{23766}\u4503\u{2833A}\u7FFA\u{26489}\u8005\u8008\u801D\u8028\u802F\u{2A087}\u{26CC3}\u803B\u803C\u8061\u{22714}\u4989\u{26626}\u{23DE3}\u{266E8}\u6725\u80A7\u{28A48}\u8107\u811A\u58B0\u{226F6}\u6C7F\u{26498}\u{24FB8}\u64E7\u{2148A}\u8218\u{2185E}\u6A53\u{24A65}\u{24A95}\u447A\u8229\u{20B0D}\u{26A52}\u{23D7E}\u4FF9\u{214FD}\u84E2\u8362\u{26B0A}\u{249A7}\u{23530}\u{21773}\u{23DF8}\u82AA\u691B\u{2F994}\u41DB"],
      ["8f40", "\u854B\u82D0\u831A\u{20E16}\u{217B4}\u36C1\u{2317D}\u{2355A}\u827B\u82E2\u8318\u{23E8B}\u{26DA3}\u{26B05}\u{26B97}\u{235CE}\u3DBF\u831D\u55EC\u8385\u450B\u{26DA5}\u83AC\u83C1\u83D3\u347E\u{26ED4}\u6A57\u855A\u3496\u{26E42}\u{22EEF}\u8458\u{25BE4}\u8471\u3DD3\u44E4\u6AA7\u844A\u{23CB5}\u7958\u84A8\u{26B96}\u{26E77}\u{26E43}\u84DE\u840F\u8391\u44A0\u8493\u84E4\u{25C91}\u4240\u{25CC0}\u4543\u8534\u5AF2\u{26E99}\u4527\u8573\u4516\u67BF\u8616"],
      ["8fa1", "\u{28625}\u{2863B}\u85C1\u{27088}\u8602\u{21582}\u{270CD}\u{2F9B2}\u456A\u8628\u3648\u{218A2}\u53F7\u{2739A}\u867E\u8771\u{2A0F8}\u87EE\u{22C27}\u87B1\u87DA\u880F\u5661\u866C\u6856\u460F\u8845\u8846\u{275E0}\u{23DB9}\u{275E4}\u885E\u889C\u465B\u88B4\u88B5\u63C1\u88C5\u7777\u{2770F}\u8987\u898A\u89A6\u89A9\u89A7\u89BC\u{28A25}\u89E7\u{27924}\u{27ABD}\u8A9C\u7793\u91FE\u8A90\u{27A59}\u7AE9\u{27B3A}\u{23F8F}\u4713\u{27B38}\u717C\u8B0C\u8B1F\u{25430}\u{25565}\u8B3F\u8B4C\u8B4D\u8AA9\u{24A7A}\u8B90\u8B9B\u8AAF\u{216DF}\u4615\u884F\u8C9B\u{27D54}\u{27D8F}\u{2F9D4}\u3725\u{27D53}\u8CD6\u{27D98}\u{27DBD}\u8D12\u8D03\u{21910}\u8CDB\u705C\u8D11\u{24CC9}\u3ED0\u8D77"],
      ["9040", "\u8DA9\u{28002}\u{21014}\u{2498A}\u3B7C\u{281BC}\u{2710C}\u7AE7\u8EAD\u8EB6\u8EC3\u92D4\u8F19\u8F2D\u{28365}\u{28412}\u8FA5\u9303\u{2A29F}\u{20A50}\u8FB3\u492A\u{289DE}\u{2853D}\u{23DBB}\u5EF8\u{23262}\u8FF9\u{2A014}\u{286BC}\u{28501}\u{22325}\u3980\u{26ED7}\u9037\u{2853C}\u{27ABE}\u9061\u{2856C}\u{2860B}\u90A8\u{28713}\u90C4\u{286E6}\u90AE\u90FD\u9167\u3AF0\u91A9\u91C4\u7CAC\u{28933}\u{21E89}\u920E\u6C9F\u9241\u9262\u{255B9}\u92B9\u{28AC6}\u{23C9B}\u{28B0C}\u{255DB}"],
      ["90a1", "\u{20D31}\u932C\u936B\u{28AE1}\u{28BEB}\u708F\u5AC3\u{28AE2}\u{28AE5}\u4965\u9244\u{28BEC}\u{28C39}\u{28BFF}\u9373\u945B\u8EBC\u9585\u95A6\u9426\u95A0\u6FF6\u42B9\u{2267A}\u{286D8}\u{2127C}\u{23E2E}\u49DF\u6C1C\u967B\u9696\u416C\u96A3\u{26ED5}\u61DA\u96B6\u78F5\u{28AE0}\u96BD\u53CC\u49A1\u{26CB8}\u{20274}\u{26410}\u{290AF}\u{290E5}\u{24AD1}\u{21915}\u{2330A}\u9731\u8642\u9736\u4A0F\u453D\u4585\u{24AE9}\u7075\u5B41\u971B\u975C\u{291D5}\u9757\u5B4A\u{291EB}\u975F\u9425\u50D0\u{230B7}\u{230BC}\u9789\u979F\u97B1\u97BE\u97C0\u97D2\u97E0\u{2546C}\u97EE\u741C\u{29433}\u97FF\u97F5\u{2941D}\u{2797A}\u4AD1\u9834\u9833\u984B\u9866\u3B0E\u{27175}\u3D51\u{20630}\u{2415C}"],
      ["9140", "\u{25706}\u98CA\u98B7\u98C8\u98C7\u4AFF\u{26D27}\u{216D3}\u55B0\u98E1\u98E6\u98EC\u9378\u9939\u{24A29}\u4B72\u{29857}\u{29905}\u99F5\u9A0C\u9A3B\u9A10\u9A58\u{25725}\u36C4\u{290B1}\u{29BD5}\u9AE0\u9AE2\u{29B05}\u9AF4\u4C0E\u9B14\u9B2D\u{28600}\u5034\u9B34\u{269A8}\u38C3\u{2307D}\u9B50\u9B40\u{29D3E}\u5A45\u{21863}\u9B8E\u{2424B}\u9C02\u9BFF\u9C0C\u{29E68}\u9DD4\u{29FB7}\u{2A192}\u{2A1AB}\u{2A0E1}\u{2A123}\u{2A1DF}\u9D7E\u9D83\u{2A134}\u9E0E\u6888"],
      ["91a1", "\u9DC4\u{2215B}\u{2A193}\u{2A220}\u{2193B}\u{2A233}\u9D39\u{2A0B9}\u{2A2B4}\u9E90\u9E95\u9E9E\u9EA2\u4D34\u9EAA\u9EAF\u{24364}\u9EC1\u3B60\u39E5\u3D1D\u4F32\u37BE\u{28C2B}\u9F02\u9F08\u4B96\u9424\u{26DA2}\u9F17\u9F16\u9F39\u569F\u568A\u9F45\u99B8\u{2908B}\u97F2\u847F\u9F62\u9F69\u7ADC\u9F8E\u7216\u4BBE\u{24975}\u{249BB}\u7177\u{249F8}\u{24348}\u{24A51}\u739E\u{28BDA}\u{218FA}\u799F\u{2897E}\u{28E36}\u9369\u93F3\u{28A44}\u92EC\u9381\u93CB\u{2896C}\u{244B9}\u7217\u3EEB\u7772\u7A43\u70D0\u{24473}\u{243F8}\u717E\u{217EF}\u70A3\u{218BE}\u{23599}\u3EC7\u{21885}\u{2542F}\u{217F8}\u3722\u{216FB}\u{21839}\u36E1\u{21774}\u{218D1}\u{25F4B}\u3723\u{216C0}\u575B\u{24A25}\u{213FE}\u{212A8}"],
      ["9240", "\u{213C6}\u{214B6}\u8503\u{236A6}\u8503\u8455\u{24994}\u{27165}\u{23E31}\u{2555C}\u{23EFB}\u{27052}\u44F4\u{236EE}\u{2999D}\u{26F26}\u67F9\u3733\u3C15\u3DE7\u586C\u{21922}\u6810\u4057\u{2373F}\u{240E1}\u{2408B}\u{2410F}\u{26C21}\u54CB\u569E\u{266B1}\u5692\u{20FDF}\u{20BA8}\u{20E0D}\u93C6\u{28B13}\u939C\u4EF8\u512B\u3819\u{24436}\u4EBC\u{20465}\u{2037F}\u4F4B\u4F8A\u{25651}\u5A68\u{201AB}\u{203CB}\u3999\u{2030A}\u{20414}\u3435\u4F29\u{202C0}\u{28EB3}\u{20275}\u8ADA\u{2020C}\u4E98"],
      ["92a1", "\u50CD\u510D\u4FA2\u4F03\u{24A0E}\u{23E8A}\u4F42\u502E\u506C\u5081\u4FCC\u4FE5\u5058\u50FC\u5159\u515B\u515D\u515E\u6E76\u{23595}\u{23E39}\u{23EBF}\u6D72\u{21884}\u{23E89}\u51A8\u51C3\u{205E0}\u44DD\u{204A3}\u{20492}\u{20491}\u8D7A\u{28A9C}\u{2070E}\u5259\u52A4\u{20873}\u52E1\u936E\u467A\u718C\u{2438C}\u{20C20}\u{249AC}\u{210E4}\u69D1\u{20E1D}\u7479\u3EDE\u7499\u7414\u7456\u7398\u4B8E\u{24ABC}\u{2408D}\u53D0\u3584\u720F\u{240C9}\u55B4\u{20345}\u54CD\u{20BC6}\u571D\u925D\u96F4\u9366\u57DD\u578D\u577F\u363E\u58CB\u5A99\u{28A46}\u{216FA}\u{2176F}\u{21710}\u5A2C\u59B8\u928F\u5A7E\u5ACF\u5A12\u{25946}\u{219F3}\u{21861}\u{24295}\u36F5\u6D05\u7443\u5A21\u{25E83}"],
      ["9340", "\u5A81\u{28BD7}\u{20413}\u93E0\u748C\u{21303}\u7105\u4972\u9408\u{289FB}\u93BD\u37A0\u5C1E\u5C9E\u5E5E\u5E48\u{21996}\u{2197C}\u{23AEE}\u5ECD\u5B4F\u{21903}\u{21904}\u3701\u{218A0}\u36DD\u{216FE}\u36D3\u812A\u{28A47}\u{21DBA}\u{23472}\u{289A8}\u5F0C\u5F0E\u{21927}\u{217AB}\u5A6B\u{2173B}\u5B44\u8614\u{275FD}\u8860\u607E\u{22860}\u{2262B}\u5FDB\u3EB8\u{225AF}\u{225BE}\u{29088}\u{26F73}\u61C0\u{2003E}\u{20046}\u{2261B}\u6199\u6198\u6075\u{22C9B}\u{22D07}\u{246D4}\u{2914D}"],
      ["93a1", "\u6471\u{24665}\u{22B6A}\u3A29\u{22B22}\u{23450}\u{298EA}\u{22E78}\u6337\u{2A45B}\u64B6\u6331\u63D1\u{249E3}\u{22D67}\u62A4\u{22CA1}\u643B\u656B\u6972\u3BF4\u{2308E}\u{232AD}\u{24989}\u{232AB}\u550D\u{232E0}\u{218D9}\u{2943F}\u66CE\u{23289}\u{231B3}\u3AE0\u4190\u{25584}\u{28B22}\u{2558F}\u{216FC}\u{2555B}\u{25425}\u78EE\u{23103}\u{2182A}\u{23234}\u3464\u{2320F}\u{23182}\u{242C9}\u668E\u{26D24}\u666B\u4B93\u6630\u{27870}\u{21DEB}\u6663\u{232D2}\u{232E1}\u661E\u{25872}\u38D1\u{2383A}\u{237BC}\u3B99\u{237A2}\u{233FE}\u74D0\u3B96\u678F\u{2462A}\u68B6\u681E\u3BC4\u6ABE\u3863\u{237D5}\u{24487}\u6A33\u6A52\u6AC9\u6B05\u{21912}\u6511\u6898\u6A4C\u3BD7\u6A7A\u6B57\u{23FC0}\u{23C9A}\u93A0\u92F2\u{28BEA}\u{28ACB}"],
      ["9440", "\u9289\u{2801E}\u{289DC}\u9467\u6DA5\u6F0B\u{249EC}\u6D67\u{23F7F}\u3D8F\u6E04\u{2403C}\u5A3D\u6E0A\u5847\u6D24\u7842\u713B\u{2431A}\u{24276}\u70F1\u7250\u7287\u7294\u{2478F}\u{24725}\u5179\u{24AA4}\u{205EB}\u747A\u{23EF8}\u{2365F}\u{24A4A}\u{24917}\u{25FE1}\u3F06\u3EB1\u{24ADF}\u{28C23}\u{23F35}\u60A7\u3EF3\u74CC\u743C\u9387\u7437\u449F\u{26DEA}\u4551\u7583\u3F63\u{24CD9}\u{24D06}\u3F58\u7555\u7673\u{2A5C6}\u3B19\u7468\u{28ACC}\u{249AB}\u{2498E}\u3AFB"],
      ["94a1", "\u3DCD\u{24A4E}\u3EFF\u{249C5}\u{248F3}\u91FA\u5732\u9342\u{28AE3}\u{21864}\u50DF\u{25221}\u{251E7}\u7778\u{23232}\u770E\u770F\u777B\u{24697}\u{23781}\u3A5E\u{248F0}\u7438\u749B\u3EBF\u{24ABA}\u{24AC7}\u40C8\u{24A96}\u{261AE}\u9307\u{25581}\u781E\u788D\u7888\u78D2\u73D0\u7959\u{27741}\u{256E3}\u410E\u799B\u8496\u79A5\u6A2D\u{23EFA}\u7A3A\u79F4\u416E\u{216E6}\u4132\u9235\u79F1\u{20D4C}\u{2498C}\u{20299}\u{23DBA}\u{2176E}\u3597\u556B\u3570\u36AA\u{201D4}\u{20C0D}\u7AE2\u5A59\u{226F5}\u{25AAF}\u{25A9C}\u5A0D\u{2025B}\u78F0\u5A2A\u{25BC6}\u7AFE\u41F9\u7C5D\u7C6D\u4211\u{25BB3}\u{25EBC}\u{25EA6}\u7CCD\u{249F9}\u{217B0}\u7C8E\u7C7C\u7CAE\u6AB2\u7DDC\u7E07\u7DD3\u7F4E\u{26261}"],
      ["9540", "\u{2615C}\u{27B48}\u7D97\u{25E82}\u426A\u{26B75}\u{20916}\u67D6\u{2004E}\u{235CF}\u57C4\u{26412}\u{263F8}\u{24962}\u7FDD\u7B27\u{2082C}\u{25AE9}\u{25D43}\u7B0C\u{25E0E}\u99E6\u8645\u9A63\u6A1C\u{2343F}\u39E2\u{249F7}\u{265AD}\u9A1F\u{265A0}\u8480\u{27127}\u{26CD1}\u44EA\u8137\u4402\u80C6\u8109\u8142\u{267B4}\u98C3\u{26A42}\u8262\u8265\u{26A51}\u8453\u{26DA7}\u8610\u{2721B}\u5A86\u417F\u{21840}\u5B2B\u{218A1}\u5AE4\u{218D8}\u86A0\u{2F9BC}\u{23D8F}\u882D\u{27422}\u5A02"],
      ["95a1", "\u886E\u4F45\u8887\u88BF\u88E6\u8965\u894D\u{25683}\u8954\u{27785}\u{27784}\u{28BF5}\u{28BD9}\u{28B9C}\u{289F9}\u3EAD\u84A3\u46F5\u46CF\u37F2\u8A3D\u8A1C\u{29448}\u5F4D\u922B\u{24284}\u65D4\u7129\u70C4\u{21845}\u9D6D\u8C9F\u8CE9\u{27DDC}\u599A\u77C3\u59F0\u436E\u36D4\u8E2A\u8EA7\u{24C09}\u8F30\u8F4A\u42F4\u6C58\u6FBB\u{22321}\u489B\u6F79\u6E8B\u{217DA}\u9BE9\u36B5\u{2492F}\u90BB\u9097\u5571\u4906\u91BB\u9404\u{28A4B}\u4062\u{28AFC}\u9427\u{28C1D}\u{28C3B}\u84E5\u8A2B\u9599\u95A7\u9597\u9596\u{28D34}\u7445\u3EC2\u{248FF}\u{24A42}\u{243EA}\u3EE7\u{23225}\u968F\u{28EE7}\u{28E66}\u{28E65}\u3ECC\u{249ED}\u{24A78}\u{23FEE}\u7412\u746B\u3EFC\u9741\u{290B0}"],
      ["9640", "\u6847\u4A1D\u{29093}\u{257DF}\u975D\u9368\u{28989}\u{28C26}\u{28B2F}\u{263BE}\u92BA\u5B11\u8B69\u493C\u73F9\u{2421B}\u979B\u9771\u9938\u{20F26}\u5DC1\u{28BC5}\u{24AB2}\u981F\u{294DA}\u92F6\u{295D7}\u91E5\u44C0\u{28B50}\u{24A67}\u{28B64}\u98DC\u{28A45}\u3F00\u922A\u4925\u8414\u993B\u994D\u{27B06}\u3DFD\u999B\u4B6F\u99AA\u9A5C\u{28B65}\u{258C8}\u6A8F\u9A21\u5AFE\u9A2F\u{298F1}\u4B90\u{29948}\u99BC\u4BBD\u4B97\u937D\u5872\u{21302}\u5822\u{249B8}"],
      ["96a1", "\u{214E8}\u7844\u{2271F}\u{23DB8}\u68C5\u3D7D\u9458\u3927\u6150\u{22781}\u{2296B}\u6107\u9C4F\u9C53\u9C7B\u9C35\u9C10\u9B7F\u9BCF\u{29E2D}\u9B9F\u{2A1F5}\u{2A0FE}\u9D21\u4CAE\u{24104}\u9E18\u4CB0\u9D0C\u{2A1B4}\u{2A0ED}\u{2A0F3}\u{2992F}\u9DA5\u84BD\u{26E12}\u{26FDF}\u{26B82}\u85FC\u4533\u{26DA4}\u{26E84}\u{26DF0}\u8420\u85EE\u{26E00}\u{237D7}\u{26064}\u79E2\u{2359C}\u{23640}\u492D\u{249DE}\u3D62\u93DB\u92BE\u9348\u{202BF}\u78B9\u9277\u944D\u4FE4\u3440\u9064\u{2555D}\u783D\u7854\u78B6\u784B\u{21757}\u{231C9}\u{24941}\u369A\u4F72\u6FDA\u6FD9\u701E\u701E\u5414\u{241B5}\u57BB\u58F3\u578A\u9D16\u57D7\u7134\u34AF\u{241AC}\u71EB\u{26C40}\u{24F97}\u5B28\u{217B5}\u{28A49}"],
      ["9740", "\u610C\u5ACE\u5A0B\u42BC\u{24488}\u372C\u4B7B\u{289FC}\u93BB\u93B8\u{218D6}\u{20F1D}\u8472\u{26CC0}\u{21413}\u{242FA}\u{22C26}\u{243C1}\u5994\u{23DB7}\u{26741}\u7DA8\u{2615B}\u{260A4}\u{249B9}\u{2498B}\u{289FA}\u92E5\u73E2\u3EE9\u74B4\u{28B63}\u{2189F}\u3EE1\u{24AB3}\u6AD8\u73F3\u73FB\u3ED6\u{24A3E}\u{24A94}\u{217D9}\u{24A66}\u{203A7}\u{21424}\u{249E5}\u7448\u{24916}\u70A5\u{24976}\u9284\u73E6\u935F\u{204FE}\u9331\u{28ACE}\u{28A16}\u9386\u{28BE7}\u{255D5}\u4935\u{28A82}\u716B"],
      ["97a1", "\u{24943}\u{20CFF}\u56A4\u{2061A}\u{20BEB}\u{20CB8}\u5502\u79C4\u{217FA}\u7DFE\u{216C2}\u{24A50}\u{21852}\u452E\u9401\u370A\u{28AC0}\u{249AD}\u59B0\u{218BF}\u{21883}\u{27484}\u5AA1\u36E2\u{23D5B}\u36B0\u925F\u5A79\u{28A81}\u{21862}\u9374\u3CCD\u{20AB4}\u4A96\u398A\u50F4\u3D69\u3D4C\u{2139C}\u7175\u42FB\u{28218}\u6E0F\u{290E4}\u44EB\u6D57\u{27E4F}\u7067\u6CAF\u3CD6\u{23FED}\u{23E2D}\u6E02\u6F0C\u3D6F\u{203F5}\u7551\u36BC\u34C8\u4680\u3EDA\u4871\u59C4\u926E\u493E\u8F41\u{28C1C}\u{26BC0}\u5812\u57C8\u36D6\u{21452}\u70FE\u{24362}\u{24A71}\u{22FE3}\u{212B0}\u{223BD}\u68B9\u6967\u{21398}\u{234E5}\u{27BF4}\u{236DF}\u{28A83}\u{237D6}\u{233FA}\u{24C9F}\u6A1A\u{236AD}\u{26CB7}\u843E\u44DF\u44CE"],
      ["9840", "\u{26D26}\u{26D51}\u{26C82}\u{26FDE}\u6F17\u{27109}\u833D\u{2173A}\u83ED\u{26C80}\u{27053}\u{217DB}\u5989\u5A82\u{217B3}\u5A61\u5A71\u{21905}\u{241FC}\u372D\u59EF\u{2173C}\u36C7\u718E\u9390\u669A\u{242A5}\u5A6E\u5A2B\u{24293}\u6A2B\u{23EF9}\u{27736}\u{2445B}\u{242CA}\u711D\u{24259}\u{289E1}\u4FB0\u{26D28}\u5CC2\u{244CE}\u{27E4D}\u{243BD}\u6A0C\u{24256}\u{21304}\u70A6\u7133\u{243E9}\u3DA5\u6CDF\u{2F825}\u{24A4F}\u7E65\u59EB\u5D2F\u3DF3\u5F5C\u{24A5D}\u{217DF}\u7DA4\u8426"],
      ["98a1", "\u5485\u{23AFA}\u{23300}\u{20214}\u577E\u{208D5}\u{20619}\u3FE5\u{21F9E}\u{2A2B6}\u7003\u{2915B}\u5D70\u738F\u7CD3\u{28A59}\u{29420}\u4FC8\u7FE7\u72CD\u7310\u{27AF4}\u7338\u7339\u{256F6}\u7341\u7348\u3EA9\u{27B18}\u906C\u71F5\u{248F2}\u73E1\u81F6\u3ECA\u770C\u3ED1\u6CA2\u56FD\u7419\u741E\u741F\u3EE2\u3EF0\u3EF4\u3EFA\u74D3\u3F0E\u3F53\u7542\u756D\u7572\u758D\u3F7C\u75C8\u75DC\u3FC0\u764D\u3FD7\u7674\u3FDC\u767A\u{24F5C}\u7188\u5623\u8980\u5869\u401D\u7743\u4039\u6761\u4045\u35DB\u7798\u406A\u406F\u5C5E\u77BE\u77CB\u58F2\u7818\u70B9\u781C\u40A8\u7839\u7847\u7851\u7866\u8448\u{25535}\u7933\u6803\u7932\u4103"],
      ["9940", "\u4109\u7991\u7999\u8FBB\u7A06\u8FBC\u4167\u7A91\u41B2\u7ABC\u8279\u41C4\u7ACF\u7ADB\u41CF\u4E21\u7B62\u7B6C\u7B7B\u7C12\u7C1B\u4260\u427A\u7C7B\u7C9C\u428C\u7CB8\u4294\u7CED\u8F93\u70C0\u{20CCF}\u7DCF\u7DD4\u7DD0\u7DFD\u7FAE\u7FB4\u729F\u4397\u8020\u8025\u7B39\u802E\u8031\u8054\u3DCC\u57B4\u70A0\u80B7\u80E9\u43ED\u810C\u732A\u810E\u8112\u7560\u8114\u4401\u3B39\u8156\u8159\u815A"],
      ["99a1", "\u4413\u583A\u817C\u8184\u4425\u8193\u442D\u81A5\u57EF\u81C1\u81E4\u8254\u448F\u82A6\u8276\u82CA\u82D8\u82FF\u44B0\u8357\u9669\u698A\u8405\u70F5\u8464\u60E3\u8488\u4504\u84BE\u84E1\u84F8\u8510\u8538\u8552\u453B\u856F\u8570\u85E0\u4577\u8672\u8692\u86B2\u86EF\u9645\u878B\u4606\u4617\u88AE\u88FF\u8924\u8947\u8991\u{27967}\u8A29\u8A38\u8A94\u8AB4\u8C51\u8CD4\u8CF2\u8D1C\u4798\u585F\u8DC3\u47ED\u4EEE\u8E3A\u55D8\u5754\u8E71\u55F5\u8EB0\u4837\u8ECE\u8EE2\u8EE4\u8EED\u8EF2\u8FB7\u8FC1\u8FCA\u8FCC\u9033\u99C4\u48AD\u98E0\u9213\u491E\u9228\u9258\u926B\u92B1\u92AE\u92BF"],
      ["9a40", "\u92E3\u92EB\u92F3\u92F4\u92FD\u9343\u9384\u93AD\u4945\u4951\u9EBF\u9417\u5301\u941D\u942D\u943E\u496A\u9454\u9479\u952D\u95A2\u49A7\u95F4\u9633\u49E5\u67A0\u4A24\u9740\u4A35\u97B2\u97C2\u5654\u4AE4\u60E8\u98B9\u4B19\u98F1\u5844\u990E\u9919\u51B4\u991C\u9937\u9942\u995D\u9962\u4B70\u99C5\u4B9D\u9A3C\u9B0F\u7A83\u9B69\u9B81\u9BDD\u9BF1\u9BF4\u4C6D\u9C20\u376F\u{21BC2}\u9D49\u9C3A"],
      ["9aa1", "\u9EFE\u5650\u9D93\u9DBD\u9DC0\u9DFC\u94F6\u8FB6\u9E7B\u9EAC\u9EB1\u9EBD\u9EC6\u94DC\u9EE2\u9EF1\u9EF8\u7AC8\u9F44\u{20094}\u{202B7}\u{203A0}\u691A\u94C3\u59AC\u{204D7}\u5840\u94C1\u37B9\u{205D5}\u{20615}\u{20676}\u{216BA}\u5757\u7173\u{20AC2}\u{20ACD}\u{20BBF}\u546A\u{2F83B}\u{20BCB}\u549E\u{20BFB}\u{20C3B}\u{20C53}\u{20C65}\u{20C7C}\u60E7\u{20C8D}\u567A\u{20CB5}\u{20CDD}\u{20CED}\u{20D6F}\u{20DB2}\u{20DC8}\u6955\u9C2F\u87A5\u{20E04}\u{20E0E}\u{20ED7}\u{20F90}\u{20F2D}\u{20E73}\u5C20\u{20FBC}\u5E0B\u{2105C}\u{2104F}\u{21076}\u671E\u{2107B}\u{21088}\u{21096}\u3647\u{210BF}\u{210D3}\u{2112F}\u{2113B}\u5364\u84AD\u{212E3}\u{21375}\u{21336}\u8B81\u{21577}\u{21619}\u{217C3}\u{217C7}\u4E78\u70BB\u{2182D}\u{2196A}"],
      ["9b40", "\u{21A2D}\u{21A45}\u{21C2A}\u{21C70}\u{21CAC}\u{21EC8}\u62C3\u{21ED5}\u{21F15}\u7198\u6855\u{22045}\u69E9\u36C8\u{2227C}\u{223D7}\u{223FA}\u{2272A}\u{22871}\u{2294F}\u82FD\u{22967}\u{22993}\u{22AD5}\u89A5\u{22AE8}\u8FA0\u{22B0E}\u97B8\u{22B3F}\u9847\u9ABD\u{22C4C}"],
      ["9b62", "\u{22C88}\u{22CB7}\u{25BE8}\u{22D08}\u{22D12}\u{22DB7}\u{22D95}\u{22E42}\u{22F74}\u{22FCC}\u{23033}\u{23066}\u{2331F}\u{233DE}\u5FB1\u6648\u66BF\u{27A79}\u{23567}\u{235F3}\u7201\u{249BA}\u77D7\u{2361A}\u{23716}\u7E87\u{20346}\u58B5\u670E"],
      ["9ba1", "\u6918\u{23AA7}\u{27657}\u{25FE2}\u{23E11}\u{23EB9}\u{275FE}\u{2209A}\u48D0\u4AB8\u{24119}\u{28A9A}\u{242EE}\u{2430D}\u{2403B}\u{24334}\u{24396}\u{24A45}\u{205CA}\u51D2\u{20611}\u599F\u{21EA8}\u3BBE\u{23CFF}\u{24404}\u{244D6}\u5788\u{24674}\u399B\u{2472F}\u{285E8}\u{299C9}\u3762\u{221C3}\u8B5E\u{28B4E}\u99D6\u{24812}\u{248FB}\u{24A15}\u7209\u{24AC0}\u{20C78}\u5965\u{24EA5}\u{24F86}\u{20779}\u8EDA\u{2502C}\u528F\u573F\u7171\u{25299}\u{25419}\u{23F4A}\u{24AA7}\u55BC\u{25446}\u{2546E}\u{26B52}\u91D4\u3473\u{2553F}\u{27632}\u{2555E}\u4718\u{25562}\u{25566}\u{257C7}\u{2493F}\u{2585D}\u5066\u34FB\u{233CC}\u60DE\u{25903}\u477C\u{28948}\u{25AAE}\u{25B89}\u{25C06}\u{21D90}\u57A1\u7151\u6FB6\u{26102}\u{27C12}\u9056\u{261B2}\u{24F9A}\u8B62\u{26402}\u{2644A}"],
      ["9c40", "\u5D5B\u{26BF7}\u8F36\u{26484}\u{2191C}\u8AEA\u{249F6}\u{26488}\u{23FEF}\u{26512}\u4BC0\u{265BF}\u{266B5}\u{2271B}\u9465\u{257E1}\u6195\u5A27\u{2F8CD}\u4FBB\u56B9\u{24521}\u{266FC}\u4E6A\u{24934}\u9656\u6D8F\u{26CBD}\u3618\u8977\u{26799}\u{2686E}\u{26411}\u{2685E}\u71DF\u{268C7}\u7B42\u{290C0}\u{20A11}\u{26926}\u9104\u{26939}\u7A45\u9DF0\u{269FA}\u9A26\u{26A2D}\u365F\u{26469}\u{20021}\u7983\u{26A34}\u{26B5B}\u5D2C\u{23519}\u83CF\u{26B9D}\u46D0\u{26CA4}\u753B\u8865\u{26DAE}\u58B6"],
      ["9ca1", "\u371C\u{2258D}\u{2704B}\u{271CD}\u3C54\u{27280}\u{27285}\u9281\u{2217A}\u{2728B}\u9330\u{272E6}\u{249D0}\u6C39\u949F\u{27450}\u{20EF8}\u8827\u88F5\u{22926}\u{28473}\u{217B1}\u6EB8\u{24A2A}\u{21820}\u39A4\u36B9\u5C10\u79E3\u453F\u66B6\u{29CAD}\u{298A4}\u8943\u{277CC}\u{27858}\u56D6\u40DF\u{2160A}\u39A1\u{2372F}\u{280E8}\u{213C5}\u71AD\u8366\u{279DD}\u{291A8}\u5A67\u4CB7\u{270AF}\u{289AB}\u{279FD}\u{27A0A}\u{27B0B}\u{27D66}\u{2417A}\u7B43\u797E\u{28009}\u6FB5\u{2A2DF}\u6A03\u{28318}\u53A2\u{26E07}\u93BF\u6836\u975D\u{2816F}\u{28023}\u{269B5}\u{213ED}\u{2322F}\u{28048}\u5D85\u{28C30}\u{28083}\u5715\u9823\u{28949}\u5DAB\u{24988}\u65BE\u69D5\u53D2\u{24AA5}\u{23F81}\u3C11\u6736\u{28090}\u{280F4}\u{2812E}\u{21FA1}\u{2814F}"],
      ["9d40", "\u{28189}\u{281AF}\u{2821A}\u{28306}\u{2832F}\u{2838A}\u35CA\u{28468}\u{286AA}\u48FA\u63E6\u{28956}\u7808\u9255\u{289B8}\u43F2\u{289E7}\u43DF\u{289E8}\u{28B46}\u{28BD4}\u59F8\u{28C09}\u8F0B\u{28FC5}\u{290EC}\u7B51\u{29110}\u{2913C}\u3DF7\u{2915E}\u{24ACA}\u8FD0\u728F\u568B\u{294E7}\u{295E9}\u{295B0}\u{295B8}\u{29732}\u{298D1}\u{29949}\u{2996A}\u{299C3}\u{29A28}\u{29B0E}\u{29D5A}\u{29D9B}\u7E9F\u{29EF8}\u{29F23}\u4CA4\u9547\u{2A293}\u71A2\u{2A2FF}\u4D91\u9012\u{2A5CB}\u4D9C\u{20C9C}\u8FBE\u55C1"],
      ["9da1", "\u8FBA\u{224B0}\u8FB9\u{24A93}\u4509\u7E7F\u6F56\u6AB1\u4EEA\u34E4\u{28B2C}\u{2789D}\u373A\u8E80\u{217F5}\u{28024}\u{28B6C}\u{28B99}\u{27A3E}\u{266AF}\u3DEB\u{27655}\u{23CB7}\u{25635}\u{25956}\u4E9A\u{25E81}\u{26258}\u56BF\u{20E6D}\u8E0E\u5B6D\u{23E88}\u{24C9E}\u63DE\u62D0\u{217F6}\u{2187B}\u6530\u562D\u{25C4A}\u541A\u{25311}\u3DC6\u{29D98}\u4C7D\u5622\u561E\u7F49\u{25ED8}\u5975\u{23D40}\u8770\u4E1C\u{20FEA}\u{20D49}\u{236BA}\u8117\u9D5E\u8D18\u763B\u9C45\u764E\u77B9\u9345\u5432\u8148\u82F7\u5625\u8132\u8418\u80BD\u55EA\u7962\u5643\u5416\u{20E9D}\u35CE\u5605\u55F1\u66F1\u{282E2}\u362D\u7534\u55F0\u55BA\u5497\u5572\u{20C41}\u{20C96}\u5ED0\u{25148}\u{20E76}\u{22C62}"],
      ["9e40", "\u{20EA2}\u9EAB\u7D5A\u55DE\u{21075}\u629D\u976D\u5494\u8CCD\u71F6\u9176\u63FC\u63B9\u63FE\u5569\u{22B43}\u9C72\u{22EB3}\u519A\u34DF\u{20DA7}\u51A7\u544D\u551E\u5513\u7666\u8E2D\u{2688A}\u75B1\u80B6\u8804\u8786\u88C7\u81B6\u841C\u{210C1}\u44EC\u7304\u{24706}\u5B90\u830B\u{26893}\u567B\u{226F4}\u{27D2F}\u{241A3}\u{27D73}\u{26ED0}\u{272B6}\u9170\u{211D9}\u9208\u{23CFC}\u{2A6A9}\u{20EAC}\u{20EF9}\u7266\u{21CA2}\u474E\u{24FC2}\u{27FF9}\u{20FEB}\u40FA"],
      ["9ea1", "\u9C5D\u651F\u{22DA0}\u48F3\u{247E0}\u{29D7C}\u{20FEC}\u{20E0A}\u6062\u{275A3}\u{20FED}"],
      ["9ead", "\u{26048}\u{21187}\u71A3\u7E8E\u9D50\u4E1A\u4E04\u3577\u5B0D\u6CB2\u5367\u36AC\u39DC\u537D\u36A5\u{24618}\u589A\u{24B6E}\u822D\u544B\u57AA\u{25A95}\u{20979}"],
      ["9ec5", "\u3A52\u{22465}\u7374\u{29EAC}\u4D09\u9BED\u{23CFE}\u{29F30}\u4C5B\u{24FA9}\u{2959E}\u{29FDE}\u845C\u{23DB6}\u{272B2}\u{267B3}\u{23720}\u632E\u7D25\u{23EF7}\u{23E2C}\u3A2A\u9008\u52CC\u3E74\u367A\u45E9\u{2048E}\u7640\u5AF0\u{20EB6}\u787A\u{27F2E}\u58A7\u40BF\u567C\u9B8B\u5D74\u7654\u{2A434}\u9E85\u4CE1\u75F9\u37FB\u6119\u{230DA}\u{243F2}"],
      ["9ef5", "\u565D\u{212A9}\u57A7\u{24963}\u{29E06}\u5234\u{270AE}\u35AD\u6C4A\u9D7C"],
      ["9f40", "\u7C56\u9B39\u57DE\u{2176C}\u5C53\u64D3\u{294D0}\u{26335}\u{27164}\u86AD\u{20D28}\u{26D22}\u{24AE2}\u{20D71}"],
      ["9f4f", "\u51FE\u{21F0F}\u5D8E\u9703\u{21DD1}\u9E81\u904C\u7B1F\u9B02\u5CD1\u7BA3\u6268\u6335\u9AFF\u7BCF\u9B2A\u7C7E\u9B2E\u7C42\u7C86\u9C15\u7BFC\u9B09\u9F17\u9C1B\u{2493E}\u9F5A\u5573\u5BC3\u4FFD\u9E98\u4FF2\u5260\u3E06\u52D1\u5767\u5056\u59B7\u5E12\u97C8\u9DAB\u8F5C\u5469\u97B4\u9940\u97BA\u532C\u6130"],
      ["9fa1", "\u692C\u53DA\u9C0A\u9D02\u4C3B\u9641\u6980\u50A6\u7546\u{2176D}\u99DA\u5273"],
      ["9fae", "\u9159\u9681\u915C"],
      ["9fb2", "\u9151\u{28E97}\u637F\u{26D23}\u6ACA\u5611\u918E\u757A\u6285\u{203FC}\u734F\u7C70\u{25C21}\u{23CFD}"],
      ["9fc1", "\u{24919}\u76D6\u9B9D\u4E2A\u{20CD4}\u83BE\u8842"],
      ["9fc9", "\u5C4A\u69C0\u50ED\u577A\u521F\u5DF5\u4ECE\u6C31\u{201F2}\u4F39\u549C\u54DA\u529A\u8D82\u35FE\u5F0C\u35F3"],
      ["9fdb", "\u6B52\u917C\u9FA5\u9B97\u982E\u98B4\u9ABA\u9EA8\u9E84\u717A\u7B14"],
      ["9fe7", "\u6BFA\u8818\u7F78"],
      ["9feb", "\u5620\u{2A64A}\u8E77\u9F53"],
      ["9ff0", "\u8DD4\u8E4F\u9E1C\u8E01\u6282\u{2837D}\u8E28\u8E75\u7AD3\u{24A77}\u7A3E\u78D8\u6CEA\u8A67\u7607"],
      ["a040", "\u{28A5A}\u9F26\u6CCE\u87D6\u75C3\u{2A2B2}\u7853\u{2F840}\u8D0C\u72E2\u7371\u8B2D\u7302\u74F1\u8CEB\u{24ABB}\u862F\u5FBA\u88A0\u44B7"],
      ["a055", "\u{2183B}\u{26E05}"],
      ["a058", "\u8A7E\u{2251B}"],
      ["a05b", "\u60FD\u7667\u9AD7\u9D44\u936E\u9B8F\u87F5"],
      ["a063", "\u880F\u8CF7\u732C\u9721\u9BB0\u35D6\u72B2\u4C07\u7C51\u994A\u{26159}\u6159\u4C04\u9E96\u617D"],
      ["a073", "\u575F\u616F\u62A6\u6239\u62CE\u3A5C\u61E2\u53AA\u{233F5}\u6364\u6802\u35D2"],
      ["a0a1", "\u5D57\u{28BC2}\u8FDA\u{28E39}"],
      ["a0a6", "\u50D9\u{21D46}\u7906\u5332\u9638\u{20F3B}\u4065"],
      ["a0ae", "\u77FE"],
      ["a0b0", "\u7CC2\u{25F1A}\u7CDA\u7A2D\u8066\u8063\u7D4D\u7505\u74F2\u8994\u821A\u670C\u8062\u{27486}\u805B\u74F0\u8103\u7724\u8989\u{267CC}\u7553\u{26ED1}\u87A9\u87CE\u81C8\u878C\u8A49\u8CAD\u8B43\u772B\u74F8\u84DA\u3635\u69B2\u8DA6"],
      ["a0d4", "\u89A9\u7468\u6DB9\u87C1\u{24011}\u74E7\u3DDB\u7176\u60A4\u619C\u3CD1\u7162\u6077"],
      ["a0e2", "\u7F71\u{28B2D}\u7250\u60E9\u4B7E\u5220\u3C18\u{23CC7}\u{25ED7}\u{27656}\u{25531}\u{21944}\u{212FE}\u{29903}\u{26DDC}\u{270AD}\u5CC1\u{261AD}\u{28A0F}\u{23677}\u{200EE}\u{26846}\u{24F0E}\u4562\u5B1F\u{2634C}\u9F50\u9EA6\u{2626B}"],
      ["a3c0", "\u2400", 31, "\u2421"],
      ["c6a1", "\u2460", 9, "\u2474", 9, "\u2170", 9, "\u4E36\u4E3F\u4E85\u4EA0\u5182\u5196\u51AB\u52F9\u5338\u5369\u53B6\u590A\u5B80\u5DDB\u2F33\u5E7F\u5EF4\u5F50\u5F61\u6534\u65E0\u7592\u7676\u8FB5\u96B6\xA8\u02C6\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\uFF3B\uFF3D\u273D\u3041", 23],
      ["c740", "\u3059", 58, "\u30A1\u30A2\u30A3\u30A4"],
      ["c7a1", "\u30A5", 81, "\u0410", 5, "\u0401\u0416", 4],
      ["c840", "\u041B", 26, "\u0451\u0436", 25, "\u21E7\u21B8\u21B9\u31CF\u{200CC}\u4E5A\u{2008A}\u5202\u4491"],
      ["c8a1", "\u9FB0\u5188\u9FB1\u{27607}"],
      ["c8cd", "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u309B\u309C\u2E80\u2E84\u2E86\u2E87\u2E88\u2E8A\u2E8C\u2E8D\u2E95\u2E9C\u2E9D\u2EA5\u2EA7\u2EAA\u2EAC\u2EAE\u2EB6\u2EBC\u2EBE\u2EC6\u2ECA\u2ECC\u2ECD\u2ECF\u2ED6\u2ED7\u2EDE\u2EE3"],
      ["c8f5", "\u0283\u0250\u025B\u0254\u0275\u0153\xF8\u014B\u028A\u026A"],
      ["f9fe", "\uFFED"],
      ["fa40", "\u{20547}\u92DB\u{205DF}\u{23FC5}\u854C\u42B5\u73EF\u51B5\u3649\u{24942}\u{289E4}\u9344\u{219DB}\u82EE\u{23CC8}\u783C\u6744\u62DF\u{24933}\u{289AA}\u{202A0}\u{26BB3}\u{21305}\u4FAB\u{224ED}\u5008\u{26D29}\u{27A84}\u{23600}\u{24AB1}\u{22513}\u5029\u{2037E}\u5FA4\u{20380}\u{20347}\u6EDB\u{2041F}\u507D\u5101\u347A\u510E\u986C\u3743\u8416\u{249A4}\u{20487}\u5160\u{233B4}\u516A\u{20BFF}\u{220FC}\u{202E5}\u{22530}\u{2058E}\u{23233}\u{21983}\u5B82\u877D\u{205B3}\u{23C99}\u51B2\u51B8"],
      ["faa1", "\u9D34\u51C9\u51CF\u51D1\u3CDC\u51D3\u{24AA6}\u51B3\u51E2\u5342\u51ED\u83CD\u693E\u{2372D}\u5F7B\u520B\u5226\u523C\u52B5\u5257\u5294\u52B9\u52C5\u7C15\u8542\u52E0\u860D\u{26B13}\u5305\u{28ADE}\u5549\u6ED9\u{23F80}\u{20954}\u{23FEC}\u5333\u5344\u{20BE2}\u6CCB\u{21726}\u681B\u73D5\u604A\u3EAA\u38CC\u{216E8}\u71DD\u44A2\u536D\u5374\u{286AB}\u537E\u537F\u{21596}\u{21613}\u77E6\u5393\u{28A9B}\u53A0\u53AB\u53AE\u73A7\u{25772}\u3F59\u739C\u53C1\u53C5\u6C49\u4E49\u57FE\u53D9\u3AAB\u{20B8F}\u53E0\u{23FEB}\u{22DA3}\u53F6\u{20C77}\u5413\u7079\u552B\u6657\u6D5B\u546D\u{26B53}\u{20D74}\u555D\u548F\u54A4\u47A6\u{2170D}\u{20EDD}\u3DB4\u{20D4D}"],
      ["fb40", "\u{289BC}\u{22698}\u5547\u4CED\u542F\u7417\u5586\u55A9\u5605\u{218D7}\u{2403A}\u4552\u{24435}\u66B3\u{210B4}\u5637\u66CD\u{2328A}\u66A4\u66AD\u564D\u564F\u78F1\u56F1\u9787\u53FE\u5700\u56EF\u56ED\u{28B66}\u3623\u{2124F}\u5746\u{241A5}\u6C6E\u708B\u5742\u36B1\u{26C7E}\u57E6\u{21416}\u5803\u{21454}\u{24363}\u5826\u{24BF5}\u585C\u58AA\u3561\u58E0\u58DC\u{2123C}\u58FB\u5BFF\u5743\u{2A150}\u{24278}\u93D3\u35A1\u591F\u68A6\u36C3\u6E59"],
      ["fba1", "\u{2163E}\u5A24\u5553\u{21692}\u8505\u59C9\u{20D4E}\u{26C81}\u{26D2A}\u{217DC}\u59D9\u{217FB}\u{217B2}\u{26DA6}\u6D71\u{21828}\u{216D5}\u59F9\u{26E45}\u5AAB\u5A63\u36E6\u{249A9}\u5A77\u3708\u5A96\u7465\u5AD3\u{26FA1}\u{22554}\u3D85\u{21911}\u3732\u{216B8}\u5E83\u52D0\u5B76\u6588\u5B7C\u{27A0E}\u4004\u485D\u{20204}\u5BD5\u6160\u{21A34}\u{259CC}\u{205A5}\u5BF3\u5B9D\u4D10\u5C05\u{21B44}\u5C13\u73CE\u5C14\u{21CA5}\u{26B28}\u5C49\u48DD\u5C85\u5CE9\u5CEF\u5D8B\u{21DF9}\u{21E37}\u5D10\u5D18\u5D46\u{21EA4}\u5CBA\u5DD7\u82FC\u382D\u{24901}\u{22049}\u{22173}\u8287\u3836\u3BC2\u5E2E\u6A8A\u5E75\u5E7A\u{244BC}\u{20CD3}\u53A6\u4EB7\u5ED0\u53A8\u{21771}\u5E09\u5EF4\u{28482}"],
      ["fc40", "\u5EF9\u5EFB\u38A0\u5EFC\u683E\u941B\u5F0D\u{201C1}\u{2F894}\u3ADE\u48AE\u{2133A}\u5F3A\u{26888}\u{223D0}\u5F58\u{22471}\u5F63\u97BD\u{26E6E}\u5F72\u9340\u{28A36}\u5FA7\u5DB6\u3D5F\u{25250}\u{21F6A}\u{270F8}\u{22668}\u91D6\u{2029E}\u{28A29}\u6031\u6685\u{21877}\u3963\u3DC7\u3639\u5790\u{227B4}\u7971\u3E40\u609E\u60A4\u60B3\u{24982}\u{2498F}\u{27A53}\u74A4\u50E1\u5AA0\u6164\u8424\u6142\u{2F8A6}\u{26ED2}\u6181\u51F4\u{20656}\u6187\u5BAA\u{23FB7}"],
      ["fca1", "\u{2285F}\u61D3\u{28B9D}\u{2995D}\u61D0\u3932\u{22980}\u{228C1}\u6023\u615C\u651E\u638B\u{20118}\u62C5\u{21770}\u62D5\u{22E0D}\u636C\u{249DF}\u3A17\u6438\u63F8\u{2138E}\u{217FC}\u6490\u6F8A\u{22E36}\u9814\u{2408C}\u{2571D}\u64E1\u64E5\u947B\u3A66\u643A\u3A57\u654D\u6F16\u{24A28}\u{24A23}\u6585\u656D\u655F\u{2307E}\u65B5\u{24940}\u4B37\u65D1\u40D8\u{21829}\u65E0\u65E3\u5FDF\u{23400}\u6618\u{231F7}\u{231F8}\u6644\u{231A4}\u{231A5}\u664B\u{20E75}\u6667\u{251E6}\u6673\u6674\u{21E3D}\u{23231}\u{285F4}\u{231C8}\u{25313}\u77C5\u{228F7}\u99A4\u6702\u{2439C}\u{24A21}\u3B2B\u69FA\u{237C2}\u675E\u6767\u6762\u{241CD}\u{290ED}\u67D7\u44E9\u6822\u6E50\u923C\u6801\u{233E6}\u{26DA0}\u685D"],
      ["fd40", "\u{2346F}\u69E1\u6A0B\u{28ADF}\u6973\u68C3\u{235CD}\u6901\u6900\u3D32\u3A01\u{2363C}\u3B80\u67AC\u6961\u{28A4A}\u42FC\u6936\u6998\u3BA1\u{203C9}\u8363\u5090\u69F9\u{23659}\u{2212A}\u6A45\u{23703}\u6A9D\u3BF3\u67B1\u6AC8\u{2919C}\u3C0D\u6B1D\u{20923}\u60DE\u6B35\u6B74\u{227CD}\u6EB5\u{23ADB}\u{203B5}\u{21958}\u3740\u5421\u{23B5A}\u6BE1\u{23EFC}\u6BDC\u6C37\u{2248B}\u{248F1}\u{26B51}\u6C5A\u8226\u6C79\u{23DBC}\u44C5\u{23DBD}\u{241A4}\u{2490C}\u{24900}"],
      ["fda1", "\u{23CC9}\u36E5\u3CEB\u{20D32}\u9B83\u{231F9}\u{22491}\u7F8F\u6837\u{26D25}\u{26DA1}\u{26DEB}\u6D96\u6D5C\u6E7C\u6F04\u{2497F}\u{24085}\u{26E72}\u8533\u{26F74}\u51C7\u6C9C\u6E1D\u842E\u{28B21}\u6E2F\u{23E2F}\u7453\u{23F82}\u79CC\u6E4F\u5A91\u{2304B}\u6FF8\u370D\u6F9D\u{23E30}\u6EFA\u{21497}\u{2403D}\u4555\u93F0\u6F44\u6F5C\u3D4E\u6F74\u{29170}\u3D3B\u6F9F\u{24144}\u6FD3\u{24091}\u{24155}\u{24039}\u{23FF0}\u{23FB4}\u{2413F}\u51DF\u{24156}\u{24157}\u{24140}\u{261DD}\u704B\u707E\u70A7\u7081\u70CC\u70D5\u70D6\u70DF\u4104\u3DE8\u71B4\u7196\u{24277}\u712B\u7145\u5A88\u714A\u716E\u5C9C\u{24365}\u714F\u9362\u{242C1}\u712C\u{2445A}\u{24A27}\u{24A22}\u71BA\u{28BE8}\u70BD\u720E"],
      ["fe40", "\u9442\u7215\u5911\u9443\u7224\u9341\u{25605}\u722E\u7240\u{24974}\u68BD\u7255\u7257\u3E55\u{23044}\u680D\u6F3D\u7282\u732A\u732B\u{24823}\u{2882B}\u48ED\u{28804}\u7328\u732E\u73CF\u73AA\u{20C3A}\u{26A2E}\u73C9\u7449\u{241E2}\u{216E7}\u{24A24}\u6623\u36C5\u{249B7}\u{2498D}\u{249FB}\u73F7\u7415\u6903\u{24A26}\u7439\u{205C3}\u3ED7\u745C\u{228AD}\u7460\u{28EB2}\u7447\u73E4\u7476\u83B9\u746C\u3730\u7474\u93F1\u6A2C\u7482\u4953\u{24A8C}"],
      ["fea1", "\u{2415F}\u{24A79}\u{28B8F}\u5B46\u{28C03}\u{2189E}\u74C8\u{21988}\u750E\u74E9\u751E\u{28ED9}\u{21A4B}\u5BD7\u{28EAC}\u9385\u754D\u754A\u7567\u756E\u{24F82}\u3F04\u{24D13}\u758E\u745D\u759E\u75B4\u7602\u762C\u7651\u764F\u766F\u7676\u{263F5}\u7690\u81EF\u37F8\u{26911}\u{2690E}\u76A1\u76A5\u76B7\u76CC\u{26F9F}\u8462\u{2509D}\u{2517D}\u{21E1C}\u771E\u7726\u7740\u64AF\u{25220}\u7758\u{232AC}\u77AF\u{28964}\u{28968}\u{216C1}\u77F4\u7809\u{21376}\u{24A12}\u68CA\u78AF\u78C7\u78D3\u96A5\u792E\u{255E0}\u78D7\u7934\u78B1\u{2760C}\u8FB8\u8884\u{28B2B}\u{26083}\u{2261C}\u7986\u8900\u6902\u7980\u{25857}\u799D\u{27B39}\u793C\u79A9\u6E2A\u{27126}\u3EA8\u79C6\u{2910D}\u79D4"]
    ];
  }
});

// node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS({
  "node_modules/iconv-lite/encodings/dbcs-data.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "shiftjis": {
        type: "_dbcs",
        table: function() {
          return require_shiftjis();
        },
        encodeAdd: { "\xA5": 92, "\u203E": 126 },
        encodeSkipVals: [{ from: 60736, to: 63808 }]
      },
      "csshiftjis": "shiftjis",
      "mskanji": "shiftjis",
      "sjis": "shiftjis",
      "windows31j": "shiftjis",
      "ms31j": "shiftjis",
      "xsjis": "shiftjis",
      "windows932": "shiftjis",
      "ms932": "shiftjis",
      "932": "shiftjis",
      "cp932": "shiftjis",
      "eucjp": {
        type: "_dbcs",
        table: function() {
          return require_eucjp();
        },
        encodeAdd: { "\xA5": 92, "\u203E": 126 }
      },
      "gb2312": "cp936",
      "gb231280": "cp936",
      "gb23121980": "cp936",
      "csgb2312": "cp936",
      "csiso58gb231280": "cp936",
      "euccn": "cp936",
      "windows936": "cp936",
      "ms936": "cp936",
      "936": "cp936",
      "cp936": {
        type: "_dbcs",
        table: function() {
          return require_cp936();
        }
      },
      "gbk": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        }
      },
      "xgbk": "gbk",
      "isoir58": "gbk",
      "gb18030": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        },
        gb18030: function() {
          return require_gb18030_ranges();
        },
        encodeSkipVals: [128],
        encodeAdd: { "\u20AC": 41699 }
      },
      "chinese": "gb18030",
      "windows949": "cp949",
      "ms949": "cp949",
      "949": "cp949",
      "cp949": {
        type: "_dbcs",
        table: function() {
          return require_cp949();
        }
      },
      "cseuckr": "cp949",
      "csksc56011987": "cp949",
      "euckr": "cp949",
      "isoir149": "cp949",
      "korean": "cp949",
      "ksc56011987": "cp949",
      "ksc56011989": "cp949",
      "ksc5601": "cp949",
      "windows950": "cp950",
      "ms950": "cp950",
      "950": "cp950",
      "cp950": {
        type: "_dbcs",
        table: function() {
          return require_cp950();
        }
      },
      "big5": "big5hkscs",
      "big5hkscs": {
        type: "_dbcs",
        table: function() {
          return require_cp950().concat(require_big5_added());
        },
        encodeSkipVals: [41676]
      },
      "cnbig5": "big5hkscs",
      "csbig5": "big5hkscs",
      "xxbig5": "big5hkscs"
    };
  }
});

// node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS({
  "node_modules/iconv-lite/encodings/index.js"(exports2, module2) {
    "use strict";
    var modules = [
      require_internal(),
      require_utf16(),
      require_utf7(),
      require_sbcs_codec(),
      require_sbcs_data(),
      require_sbcs_data_generated(),
      require_dbcs_codec(),
      require_dbcs_data()
    ];
    for (var i = 0; i < modules.length; i++) {
      module2 = modules[i];
      for (enc in module2)
        if (Object.prototype.hasOwnProperty.call(module2, enc))
          exports2[enc] = module2[enc];
    }
    var module2;
    var enc;
  }
});

// node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS({
  "node_modules/iconv-lite/lib/streams.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    var Transform = require("stream").Transform;
    module2.exports = function(iconv) {
      iconv.encodeStream = function encodeStream(encoding, options) {
        return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
      };
      iconv.decodeStream = function decodeStream(encoding, options) {
        return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
      };
      iconv.supportsStreams = true;
      iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
      iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
      iconv._collect = IconvLiteDecoderStream.prototype.collect;
    };
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteEncoderStream }
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
      if (typeof chunk != "string")
        return done(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length)
          this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length)
          this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer2.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteDecoderStream }
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
      if (!Buffer2.isBuffer(chunk))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length)
          this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length)
          this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
  }
});

// node_modules/iconv-lite/lib/extend-node.js
var require_extend_node = __commonJS({
  "node_modules/iconv-lite/lib/extend-node.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    module2.exports = function(iconv) {
      var original = void 0;
      iconv.supportsNodeEncodingsExtension = !(Buffer2.from || new Buffer2(0) instanceof Uint8Array);
      iconv.extendNodeEncodings = function extendNodeEncodings() {
        if (original)
          return;
        original = {};
        if (!iconv.supportsNodeEncodingsExtension) {
          console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
          console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
          return;
        }
        var nodeNativeEncodings = {
          "hex": true,
          "utf8": true,
          "utf-8": true,
          "ascii": true,
          "binary": true,
          "base64": true,
          "ucs2": true,
          "ucs-2": true,
          "utf16le": true,
          "utf-16le": true
        };
        Buffer2.isNativeEncoding = function(enc) {
          return enc && nodeNativeEncodings[enc.toLowerCase()];
        };
        var SlowBuffer = require("buffer").SlowBuffer;
        original.SlowBufferToString = SlowBuffer.prototype.toString;
        SlowBuffer.prototype.toString = function(encoding, start, end) {
          encoding = String(encoding || "utf8").toLowerCase();
          if (Buffer2.isNativeEncoding(encoding))
            return original.SlowBufferToString.call(this, encoding, start, end);
          if (typeof start == "undefined")
            start = 0;
          if (typeof end == "undefined")
            end = this.length;
          return iconv.decode(this.slice(start, end), encoding);
        };
        original.SlowBufferWrite = SlowBuffer.prototype.write;
        SlowBuffer.prototype.write = function(string, offset, length, encoding) {
          if (isFinite(offset)) {
            if (!isFinite(length)) {
              encoding = length;
              length = void 0;
            }
          } else {
            var swap = encoding;
            encoding = offset;
            offset = length;
            length = swap;
          }
          offset = +offset || 0;
          var remaining = this.length - offset;
          if (!length) {
            length = remaining;
          } else {
            length = +length;
            if (length > remaining) {
              length = remaining;
            }
          }
          encoding = String(encoding || "utf8").toLowerCase();
          if (Buffer2.isNativeEncoding(encoding))
            return original.SlowBufferWrite.call(this, string, offset, length, encoding);
          if (string.length > 0 && (length < 0 || offset < 0))
            throw new RangeError("attempt to write beyond buffer bounds");
          var buf = iconv.encode(string, encoding);
          if (buf.length < length)
            length = buf.length;
          buf.copy(this, offset, 0, length);
          return length;
        };
        original.BufferIsEncoding = Buffer2.isEncoding;
        Buffer2.isEncoding = function(encoding) {
          return Buffer2.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
        };
        original.BufferByteLength = Buffer2.byteLength;
        Buffer2.byteLength = SlowBuffer.byteLength = function(str, encoding) {
          encoding = String(encoding || "utf8").toLowerCase();
          if (Buffer2.isNativeEncoding(encoding))
            return original.BufferByteLength.call(this, str, encoding);
          return iconv.encode(str, encoding).length;
        };
        original.BufferToString = Buffer2.prototype.toString;
        Buffer2.prototype.toString = function(encoding, start, end) {
          encoding = String(encoding || "utf8").toLowerCase();
          if (Buffer2.isNativeEncoding(encoding))
            return original.BufferToString.call(this, encoding, start, end);
          if (typeof start == "undefined")
            start = 0;
          if (typeof end == "undefined")
            end = this.length;
          return iconv.decode(this.slice(start, end), encoding);
        };
        original.BufferWrite = Buffer2.prototype.write;
        Buffer2.prototype.write = function(string, offset, length, encoding) {
          var _offset = offset, _length = length, _encoding = encoding;
          if (isFinite(offset)) {
            if (!isFinite(length)) {
              encoding = length;
              length = void 0;
            }
          } else {
            var swap = encoding;
            encoding = offset;
            offset = length;
            length = swap;
          }
          encoding = String(encoding || "utf8").toLowerCase();
          if (Buffer2.isNativeEncoding(encoding))
            return original.BufferWrite.call(this, string, _offset, _length, _encoding);
          offset = +offset || 0;
          var remaining = this.length - offset;
          if (!length) {
            length = remaining;
          } else {
            length = +length;
            if (length > remaining) {
              length = remaining;
            }
          }
          if (string.length > 0 && (length < 0 || offset < 0))
            throw new RangeError("attempt to write beyond buffer bounds");
          var buf = iconv.encode(string, encoding);
          if (buf.length < length)
            length = buf.length;
          buf.copy(this, offset, 0, length);
          return length;
        };
        if (iconv.supportsStreams) {
          var Readable = require("stream").Readable;
          original.ReadableSetEncoding = Readable.prototype.setEncoding;
          Readable.prototype.setEncoding = function setEncoding(enc, options) {
            this._readableState.decoder = iconv.getDecoder(enc, options);
            this._readableState.encoding = enc;
          };
          Readable.prototype.collect = iconv._collect;
        }
      };
      iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
        if (!iconv.supportsNodeEncodingsExtension)
          return;
        if (!original)
          throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
        delete Buffer2.isNativeEncoding;
        var SlowBuffer = require("buffer").SlowBuffer;
        SlowBuffer.prototype.toString = original.SlowBufferToString;
        SlowBuffer.prototype.write = original.SlowBufferWrite;
        Buffer2.isEncoding = original.BufferIsEncoding;
        Buffer2.byteLength = original.BufferByteLength;
        Buffer2.prototype.toString = original.BufferToString;
        Buffer2.prototype.write = original.BufferWrite;
        if (iconv.supportsStreams) {
          var Readable = require("stream").Readable;
          Readable.prototype.setEncoding = original.ReadableSetEncoding;
          delete Readable.prototype.collect;
        }
        original = void 0;
      };
    };
  }
});

// node_modules/iconv-lite/lib/index.js
var require_lib = __commonJS({
  "node_modules/iconv-lite/lib/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    var bomHandling = require_bom_handling();
    var iconv = module2.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "\uFFFD";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode(str, encoding, options) {
      str = "" + (str || "");
      var encoder = iconv.getEncoder(encoding, options);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
      if (!iconv.encodings)
        iconv.encodings = require_encodings();
      var enc = iconv._canonicalizeEncoding(encoding);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding) {
      return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);
      return decoder;
    };
    var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
    if (nodeVer) {
      nodeVerArr = nodeVer.split(".").map(Number);
      if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        require_streams()(iconv);
      }
      require_extend_node()(iconv);
    }
    var nodeVerArr;
    if (false) {
      console.error("iconv-lite warning: javascript files use encoding different from utf-8. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
    }
  }
});

// node_modules/unpipe/index.js
var require_unpipe = __commonJS({
  "node_modules/unpipe/index.js"(exports2, module2) {
    "use strict";
    module2.exports = unpipe;
    function hasPipeDataListeners(stream) {
      var listeners = stream.listeners("data");
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i].name === "ondata") {
          return true;
        }
      }
      return false;
    }
    function unpipe(stream) {
      if (!stream) {
        throw new TypeError("argument stream is required");
      }
      if (typeof stream.unpipe === "function") {
        stream.unpipe();
        return;
      }
      if (!hasPipeDataListeners(stream)) {
        return;
      }
      var listener;
      var listeners = stream.listeners("close");
      for (var i = 0; i < listeners.length; i++) {
        listener = listeners[i];
        if (listener.name !== "cleanup" && listener.name !== "onclose") {
          continue;
        }
        listener.call(stream);
      }
    }
  }
});

// node_modules/raw-body/index.js
var require_raw_body = __commonJS({
  "node_modules/raw-body/index.js"(exports2, module2) {
    "use strict";
    var bytes = require_bytes();
    var createError = require_http_errors();
    var iconv = require_lib();
    var unpipe = require_unpipe();
    module2.exports = getRawBody;
    var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
    function getDecoder(encoding) {
      if (!encoding)
        return null;
      try {
        return iconv.getDecoder(encoding);
      } catch (e) {
        if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message))
          throw e;
        throw createError(415, "specified encoding unsupported", {
          encoding,
          type: "encoding.unsupported"
        });
      }
    }
    function getRawBody(stream, options, callback) {
      var done = callback;
      var opts = options || {};
      if (options === true || typeof options === "string") {
        opts = {
          encoding: options
        };
      }
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      if (done !== void 0 && typeof done !== "function") {
        throw new TypeError("argument callback must be a function");
      }
      if (!done && !global.Promise) {
        throw new TypeError("argument callback is required");
      }
      var encoding = opts.encoding !== true ? opts.encoding : "utf-8";
      var limit = bytes.parse(opts.limit);
      var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
      if (done) {
        return readStream(stream, encoding, length, limit, done);
      }
      return new Promise(function executor(resolve, reject) {
        readStream(stream, encoding, length, limit, function onRead(err, buf) {
          if (err)
            return reject(err);
          resolve(buf);
        });
      });
    }
    function halt(stream) {
      unpipe(stream);
      if (typeof stream.pause === "function") {
        stream.pause();
      }
    }
    function readStream(stream, encoding, length, limit, callback) {
      var complete = false;
      var sync = true;
      if (limit !== null && length !== null && length > limit) {
        return done(createError(413, "request entity too large", {
          expected: length,
          length,
          limit,
          type: "entity.too.large"
        }));
      }
      var state = stream._readableState;
      if (stream._decoder || state && (state.encoding || state.decoder)) {
        return done(createError(500, "stream encoding should not be set", {
          type: "stream.encoding.set"
        }));
      }
      var received = 0;
      var decoder;
      try {
        decoder = getDecoder(encoding);
      } catch (err) {
        return done(err);
      }
      var buffer = decoder ? "" : [];
      stream.on("aborted", onAborted);
      stream.on("close", cleanup);
      stream.on("data", onData);
      stream.on("end", onEnd);
      stream.on("error", onEnd);
      sync = false;
      function done() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        complete = true;
        if (sync) {
          process.nextTick(invokeCallback);
        } else {
          invokeCallback();
        }
        function invokeCallback() {
          cleanup();
          if (args[0]) {
            halt(stream);
          }
          callback.apply(null, args);
        }
      }
      function onAborted() {
        if (complete)
          return;
        done(createError(400, "request aborted", {
          code: "ECONNABORTED",
          expected: length,
          length,
          received,
          type: "request.aborted"
        }));
      }
      function onData(chunk) {
        if (complete)
          return;
        received += chunk.length;
        if (limit !== null && received > limit) {
          done(createError(413, "request entity too large", {
            limit,
            received,
            type: "entity.too.large"
          }));
        } else if (decoder) {
          buffer += decoder.write(chunk);
        } else {
          buffer.push(chunk);
        }
      }
      function onEnd(err) {
        if (complete)
          return;
        if (err)
          return done(err);
        if (length !== null && received !== length) {
          done(createError(400, "request size did not match content length", {
            expected: length,
            length,
            received,
            type: "request.size.invalid"
          }));
        } else {
          var string = decoder ? buffer + (decoder.end() || "") : Buffer.concat(buffer);
          done(null, string);
        }
      }
      function cleanup() {
        buffer = null;
        stream.removeListener("aborted", onAborted);
        stream.removeListener("data", onData);
        stream.removeListener("end", onEnd);
        stream.removeListener("error", onEnd);
        stream.removeListener("close", cleanup);
      }
    }
  }
});

// node_modules/ee-first/index.js
var require_ee_first = __commonJS({
  "node_modules/ee-first/index.js"(exports2, module2) {
    "use strict";
    module2.exports = first;
    function first(stuff, done) {
      if (!Array.isArray(stuff))
        throw new TypeError("arg must be an array of [ee, events...] arrays");
      var cleanups = [];
      for (var i = 0; i < stuff.length; i++) {
        var arr = stuff[i];
        if (!Array.isArray(arr) || arr.length < 2)
          throw new TypeError("each array member must be [ee, events...]");
        var ee = arr[0];
        for (var j = 1; j < arr.length; j++) {
          var event = arr[j];
          var fn = listener(event, callback);
          ee.on(event, fn);
          cleanups.push({
            ee,
            event,
            fn
          });
        }
      }
      function callback() {
        cleanup();
        done.apply(null, arguments);
      }
      function cleanup() {
        var x;
        for (var i2 = 0; i2 < cleanups.length; i2++) {
          x = cleanups[i2];
          x.ee.removeListener(x.event, x.fn);
        }
      }
      function thunk(fn2) {
        done = fn2;
      }
      thunk.cancel = cleanup;
      return thunk;
    }
    function listener(event, done) {
      return function onevent(arg1) {
        var args = new Array(arguments.length);
        var ee = this;
        var err = event === "error" ? arg1 : null;
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        done(err, ee, event, args);
      };
    }
  }
});

// node_modules/on-finished/index.js
var require_on_finished = __commonJS({
  "node_modules/on-finished/index.js"(exports2, module2) {
    "use strict";
    module2.exports = onFinished;
    module2.exports.isFinished = isFinished;
    var first = require_ee_first();
    var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    function onFinished(msg, listener) {
      if (isFinished(msg) !== false) {
        defer(listener, null, msg);
        return msg;
      }
      attachListener(msg, listener);
      return msg;
    }
    function isFinished(msg) {
      var socket = msg.socket;
      if (typeof msg.finished === "boolean") {
        return Boolean(msg.finished || socket && !socket.writable);
      }
      if (typeof msg.complete === "boolean") {
        return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
      }
      return void 0;
    }
    function attachFinishedListener(msg, callback) {
      var eeMsg;
      var eeSocket;
      var finished = false;
      function onFinish(error) {
        eeMsg.cancel();
        eeSocket.cancel();
        finished = true;
        callback(error);
      }
      eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
      function onSocket(socket) {
        msg.removeListener("socket", onSocket);
        if (finished)
          return;
        if (eeMsg !== eeSocket)
          return;
        eeSocket = first([[socket, "error", "close"]], onFinish);
      }
      if (msg.socket) {
        onSocket(msg.socket);
        return;
      }
      msg.on("socket", onSocket);
      if (msg.socket === void 0) {
        patchAssignSocket(msg, onSocket);
      }
    }
    function attachListener(msg, listener) {
      var attached = msg.__onFinished;
      if (!attached || !attached.queue) {
        attached = msg.__onFinished = createListener(msg);
        attachFinishedListener(msg, attached);
      }
      attached.queue.push(listener);
    }
    function createListener(msg) {
      function listener(err) {
        if (msg.__onFinished === listener)
          msg.__onFinished = null;
        if (!listener.queue)
          return;
        var queue = listener.queue;
        listener.queue = null;
        for (var i = 0; i < queue.length; i++) {
          queue[i](err, msg);
        }
      }
      listener.queue = [];
      return listener;
    }
    function patchAssignSocket(res, callback) {
      var assignSocket = res.assignSocket;
      if (typeof assignSocket !== "function")
        return;
      res.assignSocket = function _assignSocket(socket) {
        assignSocket.call(this, socket);
        callback(socket);
      };
    }
  }
});

// node_modules/body-parser/lib/read.js
var require_read = __commonJS({
  "node_modules/body-parser/lib/read.js"(exports2, module2) {
    "use strict";
    var createError = require_http_errors();
    var getBody = require_raw_body();
    var iconv = require_lib();
    var onFinished = require_on_finished();
    var zlib = require("zlib");
    module2.exports = read;
    function read(req, res, next, parse, debug, options) {
      var length;
      var opts = options;
      var stream;
      req._body = true;
      var encoding = opts.encoding !== null ? opts.encoding : null;
      var verify = opts.verify;
      try {
        stream = contentstream(req, debug, opts.inflate);
        length = stream.length;
        stream.length = void 0;
      } catch (err) {
        return next(err);
      }
      opts.length = length;
      opts.encoding = verify ? null : encoding;
      if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
        return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
          charset: encoding.toLowerCase(),
          type: "charset.unsupported"
        }));
      }
      debug("read body");
      getBody(stream, opts, function(error, body) {
        if (error) {
          var _error;
          if (error.type === "encoding.unsupported") {
            _error = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
              charset: encoding.toLowerCase(),
              type: "charset.unsupported"
            });
          } else {
            _error = createError(400, error);
          }
          stream.resume();
          onFinished(req, function onfinished() {
            next(createError(400, _error));
          });
          return;
        }
        if (verify) {
          try {
            debug("verify body");
            verify(req, res, body, encoding);
          } catch (err) {
            next(createError(403, err, {
              body,
              type: err.type || "entity.verify.failed"
            }));
            return;
          }
        }
        var str = body;
        try {
          debug("parse body");
          str = typeof body !== "string" && encoding !== null ? iconv.decode(body, encoding) : body;
          req.body = parse(str);
        } catch (err) {
          next(createError(400, err, {
            body: str,
            type: err.type || "entity.parse.failed"
          }));
          return;
        }
        next();
      });
    }
    function contentstream(req, debug, inflate) {
      var encoding = (req.headers["content-encoding"] || "identity").toLowerCase();
      var length = req.headers["content-length"];
      var stream;
      debug('content-encoding "%s"', encoding);
      if (inflate === false && encoding !== "identity") {
        throw createError(415, "content encoding unsupported", {
          encoding,
          type: "encoding.unsupported"
        });
      }
      switch (encoding) {
        case "deflate":
          stream = zlib.createInflate();
          debug("inflate body");
          req.pipe(stream);
          break;
        case "gzip":
          stream = zlib.createGunzip();
          debug("gunzip body");
          req.pipe(stream);
          break;
        case "identity":
          stream = req;
          stream.length = length;
          break;
        default:
          throw createError(415, 'unsupported content encoding "' + encoding + '"', {
            encoding,
            type: "encoding.unsupported"
          });
      }
      return stream;
    }
  }
});

// node_modules/media-typer/index.js
var require_media_typer = __commonJS({
  "node_modules/media-typer/index.js"(exports2) {
    var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
    var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
    var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
    var qescRegExp = /\\([\u0000-\u007f])/g;
    var quoteRegExp = /([\\"])/g;
    var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
    var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
    var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
    exports2.format = format;
    exports2.parse = parse;
    function format(obj) {
      if (!obj || typeof obj !== "object") {
        throw new TypeError("argument obj is required");
      }
      var parameters = obj.parameters;
      var subtype = obj.subtype;
      var suffix = obj.suffix;
      var type = obj.type;
      if (!type || !typeNameRegExp.test(type)) {
        throw new TypeError("invalid type");
      }
      if (!subtype || !subtypeNameRegExp.test(subtype)) {
        throw new TypeError("invalid subtype");
      }
      var string = type + "/" + subtype;
      if (suffix) {
        if (!typeNameRegExp.test(suffix)) {
          throw new TypeError("invalid suffix");
        }
        string += "+" + suffix;
      }
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          if (!tokenRegExp.test(param)) {
            throw new TypeError("invalid parameter name");
          }
          string += "; " + param + "=" + qstring(parameters[param]);
        }
      }
      return string;
    }
    function parse(string) {
      if (!string) {
        throw new TypeError("argument string is required");
      }
      if (typeof string === "object") {
        string = getcontenttype(string);
      }
      if (typeof string !== "string") {
        throw new TypeError("argument string is required to be a string");
      }
      var index = string.indexOf(";");
      var type = index !== -1 ? string.substr(0, index) : string;
      var key;
      var match;
      var obj = splitType(type);
      var params = {};
      var value;
      paramRegExp.lastIndex = index;
      while (match = paramRegExp.exec(string)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
        }
        params[key] = value;
      }
      if (index !== -1 && index !== string.length) {
        throw new TypeError("invalid parameter format");
      }
      obj.parameters = params;
      return obj;
    }
    function getcontenttype(obj) {
      if (typeof obj.getHeader === "function") {
        return obj.getHeader("content-type");
      }
      if (typeof obj.headers === "object") {
        return obj.headers && obj.headers["content-type"];
      }
    }
    function qstring(val) {
      var str = String(val);
      if (tokenRegExp.test(str)) {
        return str;
      }
      if (str.length > 0 && !textRegExp.test(str)) {
        throw new TypeError("invalid parameter value");
      }
      return '"' + str.replace(quoteRegExp, "\\$1") + '"';
    }
    function splitType(string) {
      var match = typeRegExp.exec(string.toLowerCase());
      if (!match) {
        throw new TypeError("invalid media type");
      }
      var type = match[1];
      var subtype = match[2];
      var suffix;
      var index = subtype.lastIndexOf("+");
      if (index !== -1) {
        suffix = subtype.substr(index + 1);
        subtype = subtype.substr(0, index);
      }
      var obj = {
        type,
        subtype,
        suffix
      };
      return obj;
    }
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana"
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana"
      },
      "image/avcs": {
        source: "iana"
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = Object.create(null);
    exports2.lookup = lookup;
    exports2.types = Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/type-is/index.js
var require_type_is = __commonJS({
  "node_modules/type-is/index.js"(exports2, module2) {
    "use strict";
    var typer = require_media_typer();
    var mime = require_mime_types();
    module2.exports = typeofrequest;
    module2.exports.is = typeis;
    module2.exports.hasBody = hasbody;
    module2.exports.normalize = normalize;
    module2.exports.match = mimeMatch;
    function typeis(value, types_) {
      var i;
      var types = types_;
      var val = tryNormalizeType(value);
      if (!val) {
        return false;
      }
      if (types && !Array.isArray(types)) {
        types = new Array(arguments.length - 1);
        for (i = 0; i < types.length; i++) {
          types[i] = arguments[i + 1];
        }
      }
      if (!types || !types.length) {
        return val;
      }
      var type;
      for (i = 0; i < types.length; i++) {
        if (mimeMatch(normalize(type = types[i]), val)) {
          return type[0] === "+" || type.indexOf("*") !== -1 ? val : type;
        }
      }
      return false;
    }
    function hasbody(req) {
      return req.headers["transfer-encoding"] !== void 0 || !isNaN(req.headers["content-length"]);
    }
    function typeofrequest(req, types_) {
      var types = types_;
      if (!hasbody(req)) {
        return null;
      }
      if (arguments.length > 2) {
        types = new Array(arguments.length - 1);
        for (var i = 0; i < types.length; i++) {
          types[i] = arguments[i + 1];
        }
      }
      var value = req.headers["content-type"];
      return typeis(value, types);
    }
    function normalize(type) {
      if (typeof type !== "string") {
        return false;
      }
      switch (type) {
        case "urlencoded":
          return "application/x-www-form-urlencoded";
        case "multipart":
          return "multipart/*";
      }
      if (type[0] === "+") {
        return "*/*" + type;
      }
      return type.indexOf("/") === -1 ? mime.lookup(type) : type;
    }
    function mimeMatch(expected, actual) {
      if (expected === false) {
        return false;
      }
      var actualParts = actual.split("/");
      var expectedParts = expected.split("/");
      if (actualParts.length !== 2 || expectedParts.length !== 2) {
        return false;
      }
      if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
        return false;
      }
      if (expectedParts[1].substr(0, 2) === "*+") {
        return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
      }
      if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
        return false;
      }
      return true;
    }
    function normalizeType(value) {
      var type = typer.parse(value);
      type.parameters = void 0;
      return typer.format(type);
    }
    function tryNormalizeType(value) {
      if (!value) {
        return null;
      }
      try {
        return normalizeType(value);
      } catch (err) {
        return null;
      }
    }
  }
});

// node_modules/body-parser/lib/types/json.js
var require_json = __commonJS({
  "node_modules/body-parser/lib/types/json.js"(exports2, module2) {
    "use strict";
    var bytes = require_bytes();
    var contentType = require_content_type();
    var createError = require_http_errors();
    var debug = require_src()("body-parser:json");
    var read = require_read();
    var typeis = require_type_is();
    module2.exports = json;
    var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*(.)/;
    function json(options) {
      var opts = options || {};
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var inflate = opts.inflate !== false;
      var reviver = opts.reviver;
      var strict = opts.strict !== false;
      var type = opts.type || "application/json";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse(body) {
        if (body.length === 0) {
          return {};
        }
        if (strict) {
          var first = firstchar(body);
          if (first !== "{" && first !== "[") {
            debug("strict violation");
            throw createStrictSyntaxError(body, first);
          }
        }
        try {
          debug("parse json");
          return JSON.parse(body, reviver);
        } catch (e) {
          throw normalizeJsonSyntaxError(e, {
            message: e.message,
            stack: e.stack
          });
        }
      }
      return function jsonParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        var charset = getCharset(req) || "utf-8";
        if (charset.substr(0, 4) !== "utf-") {
          debug("invalid charset");
          next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
            charset,
            type: "charset.unsupported"
          }));
          return;
        }
        read(req, res, next, parse, debug, {
          encoding: charset,
          inflate,
          limit,
          verify
        });
      };
    }
    function createStrictSyntaxError(str, char) {
      var index = str.indexOf(char);
      var partial = str.substring(0, index) + "#";
      try {
        JSON.parse(partial);
        throw new SyntaxError("strict violation");
      } catch (e) {
        return normalizeJsonSyntaxError(e, {
          message: e.message.replace("#", char),
          stack: e.stack
        });
      }
    }
    function firstchar(str) {
      return FIRST_CHAR_REGEXP.exec(str)[1];
    }
    function getCharset(req) {
      try {
        return (contentType.parse(req).parameters.charset || "").toLowerCase();
      } catch (e) {
        return void 0;
      }
    }
    function normalizeJsonSyntaxError(error, obj) {
      var keys = Object.getOwnPropertyNames(error);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key !== "stack" && key !== "message") {
          delete error[key];
        }
      }
      error.stack = obj.stack.replace(error.message, obj.message);
      error.message = obj.message;
      return error;
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// node_modules/body-parser/lib/types/raw.js
var require_raw = __commonJS({
  "node_modules/body-parser/lib/types/raw.js"(exports2, module2) {
    "use strict";
    var bytes = require_bytes();
    var debug = require_src()("body-parser:raw");
    var read = require_read();
    var typeis = require_type_is();
    module2.exports = raw;
    function raw(options) {
      var opts = options || {};
      var inflate = opts.inflate !== false;
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var type = opts.type || "application/octet-stream";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse(buf) {
        return buf;
      }
      return function rawParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        read(req, res, next, parse, debug, {
          encoding: null,
          inflate,
          limit,
          verify
        });
      };
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// node_modules/body-parser/lib/types/text.js
var require_text = __commonJS({
  "node_modules/body-parser/lib/types/text.js"(exports2, module2) {
    "use strict";
    var bytes = require_bytes();
    var contentType = require_content_type();
    var debug = require_src()("body-parser:text");
    var read = require_read();
    var typeis = require_type_is();
    module2.exports = text;
    function text(options) {
      var opts = options || {};
      var defaultCharset = opts.defaultCharset || "utf-8";
      var inflate = opts.inflate !== false;
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var type = opts.type || "text/plain";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse(buf) {
        return buf;
      }
      return function textParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        var charset = getCharset(req) || defaultCharset;
        read(req, res, next, parse, debug, {
          encoding: charset,
          inflate,
          limit,
          verify
        });
      };
    }
    function getCharset(req) {
      try {
        return (contentType.parse(req).parameters.charset || "").toLowerCase();
      } catch (e) {
        return void 0;
      }
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str, defaultEncoder, charset) {
      if (str.length === 0) {
        return str;
      }
      var string = typeof str === "string" ? str : String(str);
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      merge
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    module2.exports = {
      "default": "RFC3986",
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return value;
        }
      },
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils2.encode,
      encodeValuesOnly: false,
      formatter: formats.formatters[formats["default"]],
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var stringify = function stringify2(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset) {
      var obj = object;
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = obj.join(",");
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;
        }
        obj = "";
      }
      if (typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean" || utils2.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (skipNulls && obj[key] === null) {
          continue;
        }
        if (isArray(obj)) {
          pushToArray(values, stringify2(obj[key], typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix, key) : prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset));
        } else {
          pushToArray(values, stringify2(obj[key], prefix + (allowDots ? "." + key : "[" + key + "]"), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset));
        }
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && opts.encoder !== void 0 && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.formatter, options.encodeValuesOnly, options.charset));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils2.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset);
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset);
          val = options.decoder(part.slice(pos + 1), defaults.decoder, charset);
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (val && options.comma && val.indexOf(",") > -1) {
          val = val.split(",");
        }
        if (has.call(obj, key)) {
          obj[key] = utils2.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options) {
      var leaf = val;
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new Error("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils2.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        depth: typeof opts.depth === "number" ? opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils2.merge(obj, newObj, options);
      }
      return utils2.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var parse = require_parse();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// node_modules/body-parser/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/body-parser/lib/types/urlencoded.js"(exports2, module2) {
    "use strict";
    var bytes = require_bytes();
    var contentType = require_content_type();
    var createError = require_http_errors();
    var debug = require_src()("body-parser:urlencoded");
    var deprecate = require_depd()("body-parser");
    var read = require_read();
    var typeis = require_type_is();
    module2.exports = urlencoded;
    var parsers = Object.create(null);
    function urlencoded(options) {
      var opts = options || {};
      if (opts.extended === void 0) {
        deprecate("undefined extended: provide extended option");
      }
      var extended = opts.extended !== false;
      var inflate = opts.inflate !== false;
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var type = opts.type || "application/x-www-form-urlencoded";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse(body) {
        return body.length ? queryparse(body) : {};
      }
      return function urlencodedParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        var charset = getCharset(req) || "utf-8";
        if (charset !== "utf-8") {
          debug("invalid charset");
          next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
            charset,
            type: "charset.unsupported"
          }));
          return;
        }
        read(req, res, next, parse, debug, {
          debug,
          encoding: charset,
          inflate,
          limit,
          verify
        });
      };
    }
    function extendedparser(options) {
      var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
      var parse = parser("qs");
      if (isNaN(parameterLimit) || parameterLimit < 1) {
        throw new TypeError("option parameterLimit must be a positive number");
      }
      if (isFinite(parameterLimit)) {
        parameterLimit = parameterLimit | 0;
      }
      return function queryparse(body) {
        var paramCount = parameterCount(body, parameterLimit);
        if (paramCount === void 0) {
          debug("too many parameters");
          throw createError(413, "too many parameters", {
            type: "parameters.too.many"
          });
        }
        var arrayLimit = Math.max(100, paramCount);
        debug("parse extended urlencoding");
        return parse(body, {
          allowPrototypes: true,
          arrayLimit,
          depth: Infinity,
          parameterLimit
        });
      };
    }
    function getCharset(req) {
      try {
        return (contentType.parse(req).parameters.charset || "").toLowerCase();
      } catch (e) {
        return void 0;
      }
    }
    function parameterCount(body, limit) {
      var count = 0;
      var index = 0;
      while ((index = body.indexOf("&", index)) !== -1) {
        count++;
        index++;
        if (count === limit) {
          return void 0;
        }
      }
      return count;
    }
    function parser(name) {
      var mod = parsers[name];
      if (mod !== void 0) {
        return mod.parse;
      }
      switch (name) {
        case "qs":
          mod = require_lib2();
          break;
        case "querystring":
          mod = require("querystring");
          break;
      }
      parsers[name] = mod;
      return mod.parse;
    }
    function simpleparser(options) {
      var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
      var parse = parser("querystring");
      if (isNaN(parameterLimit) || parameterLimit < 1) {
        throw new TypeError("option parameterLimit must be a positive number");
      }
      if (isFinite(parameterLimit)) {
        parameterLimit = parameterLimit | 0;
      }
      return function queryparse(body) {
        var paramCount = parameterCount(body, parameterLimit);
        if (paramCount === void 0) {
          debug("too many parameters");
          throw createError(413, "too many parameters", {
            type: "parameters.too.many"
          });
        }
        debug("parse urlencoding");
        return parse(body, void 0, void 0, { maxKeys: parameterLimit });
      };
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// node_modules/body-parser/index.js
var require_body_parser = __commonJS({
  "node_modules/body-parser/index.js"(exports2, module2) {
    "use strict";
    var deprecate = require_depd()("body-parser");
    var parsers = Object.create(null);
    exports2 = module2.exports = deprecate.function(bodyParser, "bodyParser: use individual json/urlencoded middlewares");
    Object.defineProperty(exports2, "json", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("json")
    });
    Object.defineProperty(exports2, "raw", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("raw")
    });
    Object.defineProperty(exports2, "text", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("text")
    });
    Object.defineProperty(exports2, "urlencoded", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("urlencoded")
    });
    function bodyParser(options) {
      var opts = {};
      if (options) {
        for (var prop in options) {
          if (prop !== "type") {
            opts[prop] = options[prop];
          }
        }
      }
      var _urlencoded = exports2.urlencoded(opts);
      var _json = exports2.json(opts);
      return function bodyParser2(req, res, next) {
        _json(req, res, function(err) {
          if (err)
            return next(err);
          _urlencoded(req, res, next);
        });
      };
    }
    function createParserGetter(name) {
      return function get() {
        return loadParser(name);
      };
    }
    function loadParser(parserName) {
      var parser = parsers[parserName];
      if (parser !== void 0) {
        return parser;
      }
      switch (parserName) {
        case "json":
          parser = require_json();
          break;
        case "raw":
          parser = require_raw();
          break;
        case "text":
          parser = require_text();
          break;
        case "urlencoded":
          parser = require_urlencoded();
          break;
      }
      return parsers[parserName] = parser;
    }
  }
});

// node_modules/merge-descriptors/index.js
var require_merge_descriptors = __commonJS({
  "node_modules/merge-descriptors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = merge;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function merge(dest, src, redefine) {
      if (!dest) {
        throw new TypeError("argument dest is required");
      }
      if (!src) {
        throw new TypeError("argument src is required");
      }
      if (redefine === void 0) {
        redefine = true;
      }
      Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
        if (!redefine && hasOwnProperty.call(dest, name)) {
          return;
        }
        var descriptor = Object.getOwnPropertyDescriptor(src, name);
        Object.defineProperty(dest, name, descriptor);
      });
      return dest;
    }
  }
});

// node_modules/finalhandler/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/finalhandler/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/finalhandler/node_modules/debug/src/debug.js
var require_debug2 = __commonJS({
  "node_modules/finalhandler/node_modules/debug/src/debug.js"(exports2, module2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms2();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if (typeof formatter === "function") {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if (typeof exports2.init === "function") {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/finalhandler/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/finalhandler/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2 = module2.exports = require_debug2();
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log2() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/finalhandler/node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/finalhandler/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2 = module2.exports = require_debug2();
    exports2.init = init;
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (fd !== 1 && fd !== 2) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  [3" + c + ";1m" + name + " [0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("[3" + c + "m+" + exports2.humanize(this.diff) + "[0m");
      } else {
        args[0] = new Date().toUTCString() + " " + name + " " + args[0];
      }
    }
    function log2() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (namespaces == null) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs = require("fs");
          stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require("net");
          stream2 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    exports2.enable(load());
  }
});

// node_modules/finalhandler/node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/finalhandler/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/encodeurl/index.js
var require_encodeurl = __commonJS({
  "node_modules/encodeurl/index.js"(exports2, module2) {
    "use strict";
    module2.exports = encodeUrl;
    var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
    var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
    var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
    function encodeUrl(url) {
      return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
    }
  }
});

// node_modules/escape-html/index.js
var require_escape_html = __commonJS({
  "node_modules/escape-html/index.js"(exports2, module2) {
    "use strict";
    var matchHtmlRegExp = /["'&<>]/;
    module2.exports = escapeHtml;
    function escapeHtml(string) {
      var str = "" + string;
      var match = matchHtmlRegExp.exec(str);
      if (!match) {
        return str;
      }
      var escape2;
      var html = "";
      var index = 0;
      var lastIndex = 0;
      for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
          case 34:
            escape2 = "&quot;";
            break;
          case 38:
            escape2 = "&amp;";
            break;
          case 39:
            escape2 = "&#39;";
            break;
          case 60:
            escape2 = "&lt;";
            break;
          case 62:
            escape2 = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index) {
          html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escape2;
      }
      return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
    }
  }
});

// node_modules/parseurl/index.js
var require_parseurl = __commonJS({
  "node_modules/parseurl/index.js"(exports2, module2) {
    "use strict";
    var url = require("url");
    var parse = url.parse;
    var Url = url.Url;
    module2.exports = parseurl;
    module2.exports.original = originalurl;
    function parseurl(req) {
      var url2 = req.url;
      if (url2 === void 0) {
        return void 0;
      }
      var parsed = req._parsedUrl;
      if (fresh(url2, parsed)) {
        return parsed;
      }
      parsed = fastparse(url2);
      parsed._raw = url2;
      return req._parsedUrl = parsed;
    }
    function originalurl(req) {
      var url2 = req.originalUrl;
      if (typeof url2 !== "string") {
        return parseurl(req);
      }
      var parsed = req._parsedOriginalUrl;
      if (fresh(url2, parsed)) {
        return parsed;
      }
      parsed = fastparse(url2);
      parsed._raw = url2;
      return req._parsedOriginalUrl = parsed;
    }
    function fastparse(str) {
      if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
        return parse(str);
      }
      var pathname = str;
      var query = null;
      var search = null;
      for (var i = 1; i < str.length; i++) {
        switch (str.charCodeAt(i)) {
          case 63:
            if (search === null) {
              pathname = str.substring(0, i);
              query = str.substring(i + 1);
              search = str.substring(i);
            }
            break;
          case 9:
          case 10:
          case 12:
          case 13:
          case 32:
          case 35:
          case 160:
          case 65279:
            return parse(str);
        }
      }
      var url2 = Url !== void 0 ? new Url() : {};
      url2.path = str;
      url2.href = str;
      url2.pathname = pathname;
      if (search !== null) {
        url2.query = query;
        url2.search = search;
      }
      return url2;
    }
    function fresh(url2, parsedUrl) {
      return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
    }
  }
});

// node_modules/finalhandler/index.js
var require_finalhandler = __commonJS({
  "node_modules/finalhandler/index.js"(exports2, module2) {
    "use strict";
    var debug = require_src2()("finalhandler");
    var encodeUrl = require_encodeurl();
    var escapeHtml = require_escape_html();
    var onFinished = require_on_finished();
    var parseUrl = require_parseurl();
    var statuses = require_statuses();
    var unpipe = require_unpipe();
    var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
    var NEWLINE_REGEXP = /\n/g;
    var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    var isFinished = onFinished.isFinished;
    function createHtmlDocument(message) {
      var body = escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
      return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
    }
    module2.exports = finalhandler;
    function finalhandler(req, res, options) {
      var opts = options || {};
      var env2 = opts.env || process.env.NODE_ENV || "development";
      var onerror = opts.onerror;
      return function(err) {
        var headers;
        var msg;
        var status;
        if (!err && headersSent(res)) {
          debug("cannot 404 after headers sent");
          return;
        }
        if (err) {
          status = getErrorStatusCode(err);
          if (status === void 0) {
            status = getResponseStatusCode(res);
          } else {
            headers = getErrorHeaders(err);
          }
          msg = getErrorMessage(err, status, env2);
        } else {
          status = 404;
          msg = "Cannot " + req.method + " " + encodeUrl(getResourceName(req));
        }
        debug("default %s", status);
        if (err && onerror) {
          defer(onerror, err, req, res);
        }
        if (headersSent(res)) {
          debug("cannot %d after headers sent", status);
          req.socket.destroy();
          return;
        }
        send(req, res, status, headers, msg);
      };
    }
    function getErrorHeaders(err) {
      if (!err.headers || typeof err.headers !== "object") {
        return void 0;
      }
      var headers = Object.create(null);
      var keys = Object.keys(err.headers);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        headers[key] = err.headers[key];
      }
      return headers;
    }
    function getErrorMessage(err, status, env2) {
      var msg;
      if (env2 !== "production") {
        msg = err.stack;
        if (!msg && typeof err.toString === "function") {
          msg = err.toString();
        }
      }
      return msg || statuses[status];
    }
    function getErrorStatusCode(err) {
      if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
        return err.status;
      }
      if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
        return err.statusCode;
      }
      return void 0;
    }
    function getResourceName(req) {
      try {
        return parseUrl.original(req).pathname;
      } catch (e) {
        return "resource";
      }
    }
    function getResponseStatusCode(res) {
      var status = res.statusCode;
      if (typeof status !== "number" || status < 400 || status > 599) {
        status = 500;
      }
      return status;
    }
    function headersSent(res) {
      return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
    }
    function send(req, res, status, headers, message) {
      function write() {
        var body = createHtmlDocument(message);
        res.statusCode = status;
        res.statusMessage = statuses[status];
        setHeaders(res, headers);
        res.setHeader("Content-Security-Policy", "default-src 'none'");
        res.setHeader("X-Content-Type-Options", "nosniff");
        res.setHeader("Content-Type", "text/html; charset=utf-8");
        res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
        if (req.method === "HEAD") {
          res.end();
          return;
        }
        res.end(body, "utf8");
      }
      if (isFinished(req)) {
        write();
        return;
      }
      unpipe(req);
      onFinished(req, write);
      req.resume();
    }
    function setHeaders(res, headers) {
      if (!headers) {
        return;
      }
      var keys = Object.keys(headers);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        res.setHeader(key, headers[key]);
      }
    }
  }
});

// node_modules/express/node_modules/ms/index.js
var require_ms3 = __commonJS({
  "node_modules/express/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/express/node_modules/debug/src/debug.js
var require_debug3 = __commonJS({
  "node_modules/express/node_modules/debug/src/debug.js"(exports2, module2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms3();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if (typeof formatter === "function") {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if (typeof exports2.init === "function") {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/express/node_modules/debug/src/browser.js
var require_browser3 = __commonJS({
  "node_modules/express/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2 = module2.exports = require_debug3();
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log2() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/express/node_modules/debug/src/node.js
var require_node3 = __commonJS({
  "node_modules/express/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2 = module2.exports = require_debug3();
    exports2.init = init;
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (fd !== 1 && fd !== 2) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  [3" + c + ";1m" + name + " [0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("[3" + c + "m+" + exports2.humanize(this.diff) + "[0m");
      } else {
        args[0] = new Date().toUTCString() + " " + name + " " + args[0];
      }
    }
    function log2() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (namespaces == null) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs = require("fs");
          stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require("net");
          stream2 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    exports2.enable(load());
  }
});

// node_modules/express/node_modules/debug/src/index.js
var require_src3 = __commonJS({
  "node_modules/express/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser3();
    } else {
      module2.exports = require_node3();
    }
  }
});

// node_modules/array-flatten/array-flatten.js
var require_array_flatten = __commonJS({
  "node_modules/array-flatten/array-flatten.js"(exports2, module2) {
    "use strict";
    module2.exports = arrayFlatten;
    function flattenWithDepth(array, result, depth) {
      for (var i = 0; i < array.length; i++) {
        var value = array[i];
        if (depth > 0 && Array.isArray(value)) {
          flattenWithDepth(value, result, depth - 1);
        } else {
          result.push(value);
        }
      }
      return result;
    }
    function flattenForever(array, result) {
      for (var i = 0; i < array.length; i++) {
        var value = array[i];
        if (Array.isArray(value)) {
          flattenForever(value, result);
        } else {
          result.push(value);
        }
      }
      return result;
    }
    function arrayFlatten(array, depth) {
      if (depth == null) {
        return flattenForever(array, []);
      }
      return flattenWithDepth(array, [], depth);
    }
  }
});

// node_modules/path-to-regexp/index.js
var require_path_to_regexp = __commonJS({
  "node_modules/path-to-regexp/index.js"(exports2, module2) {
    module2.exports = pathtoRegexp;
    var MATCHING_GROUP_REGEXP = /\((?!\?)/g;
    function pathtoRegexp(path, keys, options) {
      options = options || {};
      keys = keys || [];
      var strict = options.strict;
      var end = options.end !== false;
      var flags = options.sensitive ? "" : "i";
      var extraOffset = 0;
      var keysOffset = keys.length;
      var i = 0;
      var name = 0;
      var m;
      if (path instanceof RegExp) {
        while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
          keys.push({
            name: name++,
            optional: false,
            offset: m.index
          });
        }
        return path;
      }
      if (Array.isArray(path)) {
        path = path.map(function(value) {
          return pathtoRegexp(value, keys, options).source;
        });
        return new RegExp("(?:" + path.join("|") + ")", flags);
      }
      path = ("^" + path + (strict ? "" : path[path.length - 1] === "/" ? "?" : "/?")).replace(/\/\(/g, "/(?:").replace(/([\/\.])/g, "\\$1").replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function(match, slash, format, key, capture, star, optional, offset) {
        slash = slash || "";
        format = format || "";
        capture = capture || "([^\\/" + format + "]+?)";
        optional = optional || "";
        keys.push({
          name: key,
          optional: !!optional,
          offset: offset + extraOffset
        });
        var result = "" + (optional ? "" : slash) + "(?:" + format + (optional ? slash : "") + capture + (star ? "((?:[\\/" + format + "].+?)?)" : "") + ")" + optional;
        extraOffset += result.length - match.length;
        return result;
      }).replace(/\*/g, function(star, index2) {
        var len = keys.length;
        while (len-- > keysOffset && keys[len].offset > index2) {
          keys[len].offset += 3;
        }
        return "(.*)";
      });
      while (m = MATCHING_GROUP_REGEXP.exec(path)) {
        var escapeCount = 0;
        var index = m.index;
        while (path.charAt(--index) === "\\") {
          escapeCount++;
        }
        if (escapeCount % 2 === 1) {
          continue;
        }
        if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
          keys.splice(keysOffset + i, 0, {
            name: name++,
            optional: false,
            offset: m.index
          });
        }
        i++;
      }
      path += end ? "$" : path[path.length - 1] === "/" ? "" : "(?=\\/|$)";
      return new RegExp(path, flags);
    }
  }
});

// node_modules/express/lib/router/layer.js
var require_layer = __commonJS({
  "node_modules/express/lib/router/layer.js"(exports2, module2) {
    "use strict";
    var pathRegexp = require_path_to_regexp();
    var debug = require_src3()("express:router:layer");
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    module2.exports = Layer;
    function Layer(path, options, fn) {
      if (!(this instanceof Layer)) {
        return new Layer(path, options, fn);
      }
      debug("new %o", path);
      var opts = options || {};
      this.handle = fn;
      this.name = fn.name || "<anonymous>";
      this.params = void 0;
      this.path = void 0;
      this.regexp = pathRegexp(path, this.keys = [], opts);
      this.regexp.fast_star = path === "*";
      this.regexp.fast_slash = path === "/" && opts.end === false;
    }
    Layer.prototype.handle_error = function handle_error(error, req, res, next) {
      var fn = this.handle;
      if (fn.length !== 4) {
        return next(error);
      }
      try {
        fn(error, req, res, next);
      } catch (err) {
        next(err);
      }
    };
    Layer.prototype.handle_request = function handle(req, res, next) {
      var fn = this.handle;
      if (fn.length > 3) {
        return next();
      }
      try {
        fn(req, res, next);
      } catch (err) {
        next(err);
      }
    };
    Layer.prototype.match = function match(path) {
      var match2;
      if (path != null) {
        if (this.regexp.fast_slash) {
          this.params = {};
          this.path = "";
          return true;
        }
        if (this.regexp.fast_star) {
          this.params = { "0": decode_param(path) };
          this.path = path;
          return true;
        }
        match2 = this.regexp.exec(path);
      }
      if (!match2) {
        this.params = void 0;
        this.path = void 0;
        return false;
      }
      this.params = {};
      this.path = match2[0];
      var keys = this.keys;
      var params = this.params;
      for (var i = 1; i < match2.length; i++) {
        var key = keys[i - 1];
        var prop = key.name;
        var val = decode_param(match2[i]);
        if (val !== void 0 || !hasOwnProperty.call(params, prop)) {
          params[prop] = val;
        }
      }
      return true;
    };
    function decode_param(val) {
      if (typeof val !== "string" || val.length === 0) {
        return val;
      }
      try {
        return decodeURIComponent(val);
      } catch (err) {
        if (err instanceof URIError) {
          err.message = "Failed to decode param '" + val + "'";
          err.status = err.statusCode = 400;
        }
        throw err;
      }
    }
  }
});

// node_modules/methods/index.js
var require_methods = __commonJS({
  "node_modules/methods/index.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    module2.exports = getCurrentNodeMethods() || getBasicNodeMethods();
    function getCurrentNodeMethods() {
      return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
        return method.toLowerCase();
      });
    }
    function getBasicNodeMethods() {
      return [
        "get",
        "post",
        "put",
        "head",
        "delete",
        "options",
        "trace",
        "copy",
        "lock",
        "mkcol",
        "move",
        "purge",
        "propfind",
        "proppatch",
        "unlock",
        "report",
        "mkactivity",
        "checkout",
        "merge",
        "m-search",
        "notify",
        "subscribe",
        "unsubscribe",
        "patch",
        "search",
        "connect"
      ];
    }
  }
});

// node_modules/express/lib/router/route.js
var require_route = __commonJS({
  "node_modules/express/lib/router/route.js"(exports2, module2) {
    "use strict";
    var debug = require_src3()("express:router:route");
    var flatten = require_array_flatten();
    var Layer = require_layer();
    var methods = require_methods();
    var slice = Array.prototype.slice;
    var toString = Object.prototype.toString;
    module2.exports = Route;
    function Route(path) {
      this.path = path;
      this.stack = [];
      debug("new %o", path);
      this.methods = {};
    }
    Route.prototype._handles_method = function _handles_method(method) {
      if (this.methods._all) {
        return true;
      }
      var name = method.toLowerCase();
      if (name === "head" && !this.methods["head"]) {
        name = "get";
      }
      return Boolean(this.methods[name]);
    };
    Route.prototype._options = function _options() {
      var methods2 = Object.keys(this.methods);
      if (this.methods.get && !this.methods.head) {
        methods2.push("head");
      }
      for (var i = 0; i < methods2.length; i++) {
        methods2[i] = methods2[i].toUpperCase();
      }
      return methods2;
    };
    Route.prototype.dispatch = function dispatch(req, res, done) {
      var idx = 0;
      var stack = this.stack;
      if (stack.length === 0) {
        return done();
      }
      var method = req.method.toLowerCase();
      if (method === "head" && !this.methods["head"]) {
        method = "get";
      }
      req.route = this;
      next();
      function next(err) {
        if (err && err === "route") {
          return done();
        }
        if (err && err === "router") {
          return done(err);
        }
        var layer = stack[idx++];
        if (!layer) {
          return done(err);
        }
        if (layer.method && layer.method !== method) {
          return next(err);
        }
        if (err) {
          layer.handle_error(err, req, res, next);
        } else {
          layer.handle_request(req, res, next);
        }
      }
    };
    Route.prototype.all = function all() {
      var handles = flatten(slice.call(arguments));
      for (var i = 0; i < handles.length; i++) {
        var handle = handles[i];
        if (typeof handle !== "function") {
          var type = toString.call(handle);
          var msg = "Route.all() requires a callback function but got a " + type;
          throw new TypeError(msg);
        }
        var layer = Layer("/", {}, handle);
        layer.method = void 0;
        this.methods._all = true;
        this.stack.push(layer);
      }
      return this;
    };
    methods.forEach(function(method) {
      Route.prototype[method] = function() {
        var handles = flatten(slice.call(arguments));
        for (var i = 0; i < handles.length; i++) {
          var handle = handles[i];
          if (typeof handle !== "function") {
            var type = toString.call(handle);
            var msg = "Route." + method + "() requires a callback function but got a " + type;
            throw new Error(msg);
          }
          debug("%s %o", method, this.path);
          var layer = Layer("/", {}, handle);
          layer.method = method;
          this.methods[method] = true;
          this.stack.push(layer);
        }
        return this;
      };
    });
  }
});

// node_modules/utils-merge/index.js
var require_utils_merge = __commonJS({
  "node_modules/utils-merge/index.js"(exports2, module2) {
    exports2 = module2.exports = function(a, b) {
      if (a && b) {
        for (var key in b) {
          a[key] = b[key];
        }
      }
      return a;
    };
  }
});

// node_modules/express/lib/router/index.js
var require_router = __commonJS({
  "node_modules/express/lib/router/index.js"(exports2, module2) {
    "use strict";
    var Route = require_route();
    var Layer = require_layer();
    var methods = require_methods();
    var mixin = require_utils_merge();
    var debug = require_src3()("express:router");
    var deprecate = require_depd()("express");
    var flatten = require_array_flatten();
    var parseUrl = require_parseurl();
    var setPrototypeOf = require_setprototypeof();
    var objectRegExp = /^\[object (\S+)\]$/;
    var slice = Array.prototype.slice;
    var toString = Object.prototype.toString;
    var proto = module2.exports = function(options) {
      var opts = options || {};
      function router2(req, res, next) {
        router2.handle(req, res, next);
      }
      setPrototypeOf(router2, proto);
      router2.params = {};
      router2._params = [];
      router2.caseSensitive = opts.caseSensitive;
      router2.mergeParams = opts.mergeParams;
      router2.strict = opts.strict;
      router2.stack = [];
      return router2;
    };
    proto.param = function param(name, fn) {
      if (typeof name === "function") {
        deprecate("router.param(fn): Refactor to use path params");
        this._params.push(name);
        return;
      }
      var params = this._params;
      var len = params.length;
      var ret2;
      if (name[0] === ":") {
        deprecate("router.param(" + JSON.stringify(name) + ", fn): Use router.param(" + JSON.stringify(name.substr(1)) + ", fn) instead");
        name = name.substr(1);
      }
      for (var i = 0; i < len; ++i) {
        if (ret2 = params[i](name, fn)) {
          fn = ret2;
        }
      }
      if (typeof fn !== "function") {
        throw new Error("invalid param() call for " + name + ", got " + fn);
      }
      (this.params[name] = this.params[name] || []).push(fn);
      return this;
    };
    proto.handle = function handle(req, res, out) {
      var self2 = this;
      debug("dispatching %s %s", req.method, req.url);
      var idx = 0;
      var protohost = getProtohost(req.url) || "";
      var removed = "";
      var slashAdded = false;
      var paramcalled = {};
      var options = [];
      var stack = self2.stack;
      var parentParams = req.params;
      var parentUrl = req.baseUrl || "";
      var done = restore(out, req, "baseUrl", "next", "params");
      req.next = next;
      if (req.method === "OPTIONS") {
        done = wrap(done, function(old, err) {
          if (err || options.length === 0)
            return old(err);
          sendOptionsResponse(res, options, old);
        });
      }
      req.baseUrl = parentUrl;
      req.originalUrl = req.originalUrl || req.url;
      next();
      function next(err) {
        var layerError = err === "route" ? null : err;
        if (slashAdded) {
          req.url = req.url.substr(1);
          slashAdded = false;
        }
        if (removed.length !== 0) {
          req.baseUrl = parentUrl;
          req.url = protohost + removed + req.url.substr(protohost.length);
          removed = "";
        }
        if (layerError === "router") {
          setImmediate(done, null);
          return;
        }
        if (idx >= stack.length) {
          setImmediate(done, layerError);
          return;
        }
        var path = getPathname(req);
        if (path == null) {
          return done(layerError);
        }
        var layer;
        var match;
        var route;
        while (match !== true && idx < stack.length) {
          layer = stack[idx++];
          match = matchLayer(layer, path);
          route = layer.route;
          if (typeof match !== "boolean") {
            layerError = layerError || match;
          }
          if (match !== true) {
            continue;
          }
          if (!route) {
            continue;
          }
          if (layerError) {
            match = false;
            continue;
          }
          var method = req.method;
          var has_method = route._handles_method(method);
          if (!has_method && method === "OPTIONS") {
            appendMethods(options, route._options());
          }
          if (!has_method && method !== "HEAD") {
            match = false;
            continue;
          }
        }
        if (match !== true) {
          return done(layerError);
        }
        if (route) {
          req.route = route;
        }
        req.params = self2.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
        var layerPath = layer.path;
        self2.process_params(layer, paramcalled, req, res, function(err2) {
          if (err2) {
            return next(layerError || err2);
          }
          if (route) {
            return layer.handle_request(req, res, next);
          }
          trim_prefix(layer, layerError, layerPath, path);
        });
      }
      function trim_prefix(layer, layerError, layerPath, path) {
        if (layerPath.length !== 0) {
          var c = path[layerPath.length];
          if (c && c !== "/" && c !== ".")
            return next(layerError);
          debug("trim prefix (%s) from url %s", layerPath, req.url);
          removed = layerPath;
          req.url = protohost + req.url.substr(protohost.length + removed.length);
          if (!protohost && req.url[0] !== "/") {
            req.url = "/" + req.url;
            slashAdded = true;
          }
          req.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
        }
        debug("%s %s : %s", layer.name, layerPath, req.originalUrl);
        if (layerError) {
          layer.handle_error(layerError, req, res, next);
        } else {
          layer.handle_request(req, res, next);
        }
      }
    };
    proto.process_params = function process_params(layer, called, req, res, done) {
      var params = this.params;
      var keys = layer.keys;
      if (!keys || keys.length === 0) {
        return done();
      }
      var i = 0;
      var name;
      var paramIndex = 0;
      var key;
      var paramVal;
      var paramCallbacks;
      var paramCalled;
      function param(err) {
        if (err) {
          return done(err);
        }
        if (i >= keys.length) {
          return done();
        }
        paramIndex = 0;
        key = keys[i++];
        name = key.name;
        paramVal = req.params[name];
        paramCallbacks = params[name];
        paramCalled = called[name];
        if (paramVal === void 0 || !paramCallbacks) {
          return param();
        }
        if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
          req.params[name] = paramCalled.value;
          return param(paramCalled.error);
        }
        called[name] = paramCalled = {
          error: null,
          match: paramVal,
          value: paramVal
        };
        paramCallback();
      }
      function paramCallback(err) {
        var fn = paramCallbacks[paramIndex++];
        paramCalled.value = req.params[key.name];
        if (err) {
          paramCalled.error = err;
          param(err);
          return;
        }
        if (!fn)
          return param();
        try {
          fn(req, res, paramCallback, paramVal, key.name);
        } catch (e) {
          paramCallback(e);
        }
      }
      param();
    };
    proto.use = function use(fn) {
      var offset = 0;
      var path = "/";
      if (typeof fn !== "function") {
        var arg = fn;
        while (Array.isArray(arg) && arg.length !== 0) {
          arg = arg[0];
        }
        if (typeof arg !== "function") {
          offset = 1;
          path = fn;
        }
      }
      var callbacks = flatten(slice.call(arguments, offset));
      if (callbacks.length === 0) {
        throw new TypeError("Router.use() requires a middleware function");
      }
      for (var i = 0; i < callbacks.length; i++) {
        var fn = callbacks[i];
        if (typeof fn !== "function") {
          throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn));
        }
        debug("use %o %s", path, fn.name || "<anonymous>");
        var layer = new Layer(path, {
          sensitive: this.caseSensitive,
          strict: false,
          end: false
        }, fn);
        layer.route = void 0;
        this.stack.push(layer);
      }
      return this;
    };
    proto.route = function route(path) {
      var route2 = new Route(path);
      var layer = new Layer(path, {
        sensitive: this.caseSensitive,
        strict: this.strict,
        end: true
      }, route2.dispatch.bind(route2));
      layer.route = route2;
      this.stack.push(layer);
      return route2;
    };
    methods.concat("all").forEach(function(method) {
      proto[method] = function(path) {
        var route = this.route(path);
        route[method].apply(route, slice.call(arguments, 1));
        return this;
      };
    });
    function appendMethods(list, addition) {
      for (var i = 0; i < addition.length; i++) {
        var method = addition[i];
        if (list.indexOf(method) === -1) {
          list.push(method);
        }
      }
    }
    function getPathname(req) {
      try {
        return parseUrl(req).pathname;
      } catch (err) {
        return void 0;
      }
    }
    function getProtohost(url) {
      if (typeof url !== "string" || url.length === 0 || url[0] === "/") {
        return void 0;
      }
      var searchIndex = url.indexOf("?");
      var pathLength = searchIndex !== -1 ? searchIndex : url.length;
      var fqdnIndex = url.substr(0, pathLength).indexOf("://");
      return fqdnIndex !== -1 ? url.substr(0, url.indexOf("/", 3 + fqdnIndex)) : void 0;
    }
    function gettype(obj) {
      var type = typeof obj;
      if (type !== "object") {
        return type;
      }
      return toString.call(obj).replace(objectRegExp, "$1");
    }
    function matchLayer(layer, path) {
      try {
        return layer.match(path);
      } catch (err) {
        return err;
      }
    }
    function mergeParams(params, parent) {
      if (typeof parent !== "object" || !parent) {
        return params;
      }
      var obj = mixin({}, parent);
      if (!(0 in params) || !(0 in parent)) {
        return mixin(obj, params);
      }
      var i = 0;
      var o = 0;
      while (i in params) {
        i++;
      }
      while (o in parent) {
        o++;
      }
      for (i--; i >= 0; i--) {
        params[i + o] = params[i];
        if (i < o) {
          delete params[i];
        }
      }
      return mixin(obj, params);
    }
    function restore(fn, obj) {
      var props = new Array(arguments.length - 2);
      var vals = new Array(arguments.length - 2);
      for (var i = 0; i < props.length; i++) {
        props[i] = arguments[i + 2];
        vals[i] = obj[props[i]];
      }
      return function() {
        for (var i2 = 0; i2 < props.length; i2++) {
          obj[props[i2]] = vals[i2];
        }
        return fn.apply(this, arguments);
      };
    }
    function sendOptionsResponse(res, options, next) {
      try {
        var body = options.join(",");
        res.set("Allow", body);
        res.send(body);
      } catch (err) {
        next(err);
      }
    }
    function wrap(old, fn) {
      return function proxy() {
        var args = new Array(arguments.length + 1);
        args[0] = old;
        for (var i = 0, len = arguments.length; i < len; i++) {
          args[i + 1] = arguments[i];
        }
        fn.apply(this, args);
      };
    }
  }
});

// node_modules/express/lib/middleware/init.js
var require_init = __commonJS({
  "node_modules/express/lib/middleware/init.js"(exports2) {
    "use strict";
    var setPrototypeOf = require_setprototypeof();
    exports2.init = function(app) {
      return function expressInit(req, res, next) {
        if (app.enabled("x-powered-by"))
          res.setHeader("X-Powered-By", "Express");
        req.res = res;
        res.req = req;
        req.next = next;
        setPrototypeOf(req, app.request);
        setPrototypeOf(res, app.response);
        res.locals = res.locals || Object.create(null);
        next();
      };
    };
  }
});

// node_modules/express/lib/middleware/query.js
var require_query = __commonJS({
  "node_modules/express/lib/middleware/query.js"(exports2, module2) {
    "use strict";
    var merge = require_utils_merge();
    var parseUrl = require_parseurl();
    var qs = require_lib2();
    module2.exports = function query(options) {
      var opts = merge({}, options);
      var queryparse = qs.parse;
      if (typeof options === "function") {
        queryparse = options;
        opts = void 0;
      }
      if (opts !== void 0 && opts.allowPrototypes === void 0) {
        opts.allowPrototypes = true;
      }
      return function query2(req, res, next) {
        if (!req.query) {
          var val = parseUrl(req).query;
          req.query = queryparse(val, opts);
        }
        next();
      };
    };
  }
});

// node_modules/express/lib/view.js
var require_view = __commonJS({
  "node_modules/express/lib/view.js"(exports2, module2) {
    "use strict";
    var debug = require_src3()("express:view");
    var path = require("path");
    var fs = require("fs");
    var dirname = path.dirname;
    var basename = path.basename;
    var extname = path.extname;
    var join = path.join;
    var resolve = path.resolve;
    module2.exports = View;
    function View(name, options) {
      var opts = options || {};
      this.defaultEngine = opts.defaultEngine;
      this.ext = extname(name);
      this.name = name;
      this.root = opts.root;
      if (!this.ext && !this.defaultEngine) {
        throw new Error("No default engine was specified and no extension was provided.");
      }
      var fileName = name;
      if (!this.ext) {
        this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
        fileName += this.ext;
      }
      if (!opts.engines[this.ext]) {
        var mod = this.ext.substr(1);
        debug('require "%s"', mod);
        var fn = require(mod).__express;
        if (typeof fn !== "function") {
          throw new Error('Module "' + mod + '" does not provide a view engine.');
        }
        opts.engines[this.ext] = fn;
      }
      this.engine = opts.engines[this.ext];
      this.path = this.lookup(fileName);
    }
    View.prototype.lookup = function lookup(name) {
      var path2;
      var roots = [].concat(this.root);
      debug('lookup "%s"', name);
      for (var i = 0; i < roots.length && !path2; i++) {
        var root = roots[i];
        var loc = resolve(root, name);
        var dir = dirname(loc);
        var file = basename(loc);
        path2 = this.resolve(dir, file);
      }
      return path2;
    };
    View.prototype.render = function render(options, callback) {
      debug('render "%s"', this.path);
      this.engine(this.path, options, callback);
    };
    View.prototype.resolve = function resolve2(dir, file) {
      var ext = this.ext;
      var path2 = join(dir, file);
      var stat = tryStat(path2);
      if (stat && stat.isFile()) {
        return path2;
      }
      path2 = join(dir, basename(file, ext), "index" + ext);
      stat = tryStat(path2);
      if (stat && stat.isFile()) {
        return path2;
      }
    };
    function tryStat(path2) {
      debug('stat "%s"', path2);
      try {
        return fs.statSync(path2);
      } catch (e) {
        return void 0;
      }
    }
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/content-disposition/index.js
var require_content_disposition = __commonJS({
  "node_modules/content-disposition/index.js"(exports2, module2) {
    "use strict";
    module2.exports = contentDisposition;
    module2.exports.parse = parse;
    var basename = require("path").basename;
    var Buffer2 = require_safe_buffer().Buffer;
    var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
    var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
    var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
    var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
    var QESC_REGEXP = /\\([\u0000-\u007f])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
    var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
    var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
    var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
    function contentDisposition(filename, options) {
      var opts = options || {};
      var type = opts.type || "attachment";
      var params = createparams(filename, opts.fallback);
      return format(new ContentDisposition(type, params));
    }
    function createparams(filename, fallback) {
      if (filename === void 0) {
        return;
      }
      var params = {};
      if (typeof filename !== "string") {
        throw new TypeError("filename must be a string");
      }
      if (fallback === void 0) {
        fallback = true;
      }
      if (typeof fallback !== "string" && typeof fallback !== "boolean") {
        throw new TypeError("fallback must be a string or boolean");
      }
      if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
        throw new TypeError("fallback must be ISO-8859-1 string");
      }
      var name = basename(filename);
      var isQuotedString = TEXT_REGEXP.test(name);
      var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
      var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
      if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
        params["filename*"] = name;
      }
      if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name;
      }
      return params;
    }
    function format(obj) {
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string = String(type).toLowerCase();
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
          string += "; " + param + "=" + val;
        }
      }
      return string;
    }
    function decodefield(str) {
      var match = EXT_VALUE_REGEXP.exec(str);
      if (!match) {
        throw new TypeError("invalid extended field value");
      }
      var charset = match[1].toLowerCase();
      var encoded = match[2];
      var value;
      var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
      switch (charset) {
        case "iso-8859-1":
          value = getlatin1(binary);
          break;
        case "utf-8":
          value = Buffer2.from(binary, "binary").toString("utf8");
          break;
        default:
          throw new TypeError("unsupported charset in extended field");
      }
      return value;
    }
    function getlatin1(val) {
      return String(val).replace(NON_LATIN1_REGEXP, "?");
    }
    function parse(string) {
      if (!string || typeof string !== "string") {
        throw new TypeError("argument string is required");
      }
      var match = DISPOSITION_TYPE_REGEXP.exec(string);
      if (!match) {
        throw new TypeError("invalid type format");
      }
      var index = match[0].length;
      var type = match[1].toLowerCase();
      var key;
      var names = [];
      var params = {};
      var value;
      index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
      while (match = PARAM_REGEXP.exec(string)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (names.indexOf(key) !== -1) {
          throw new TypeError("invalid duplicate parameter");
        }
        names.push(key);
        if (key.indexOf("*") + 1 === key.length) {
          key = key.slice(0, -1);
          value = decodefield(value);
          params[key] = value;
          continue;
        }
        if (typeof params[key] === "string") {
          continue;
        }
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
        }
        params[key] = value;
      }
      if (index !== -1 && index !== string.length) {
        throw new TypeError("invalid parameter format");
      }
      return new ContentDisposition(type, params);
    }
    function pdecode(str, hex) {
      return String.fromCharCode(parseInt(hex, 16));
    }
    function pencode(char) {
      return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
    }
    function qstring(val) {
      var str = String(val);
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ustring(val) {
      var str = String(val);
      var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
      return "UTF-8''" + encoded;
    }
    function ContentDisposition(type, parameters) {
      this.type = type;
      this.parameters = parameters;
    }
  }
});

// node_modules/send/node_modules/debug/node_modules/ms/index.js
var require_ms4 = __commonJS({
  "node_modules/send/node_modules/debug/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/send/node_modules/debug/src/debug.js
var require_debug4 = __commonJS({
  "node_modules/send/node_modules/debug/src/debug.js"(exports2, module2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms4();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if (typeof formatter === "function") {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if (typeof exports2.init === "function") {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/send/node_modules/debug/src/browser.js
var require_browser4 = __commonJS({
  "node_modules/send/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2 = module2.exports = require_debug4();
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log2() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/send/node_modules/debug/src/node.js
var require_node4 = __commonJS({
  "node_modules/send/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2 = module2.exports = require_debug4();
    exports2.init = init;
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (fd !== 1 && fd !== 2) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  [3" + c + ";1m" + name + " [0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("[3" + c + "m+" + exports2.humanize(this.diff) + "[0m");
      } else {
        args[0] = new Date().toUTCString() + " " + name + " " + args[0];
      }
    }
    function log2() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (namespaces == null) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs = require("fs");
          stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require("net");
          stream2 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    exports2.enable(load());
  }
});

// node_modules/send/node_modules/debug/src/index.js
var require_src4 = __commonJS({
  "node_modules/send/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser4();
    } else {
      module2.exports = require_node4();
    }
  }
});

// node_modules/destroy/index.js
var require_destroy = __commonJS({
  "node_modules/destroy/index.js"(exports2, module2) {
    "use strict";
    var ReadStream = require("fs").ReadStream;
    var Stream = require("stream");
    module2.exports = destroy;
    function destroy(stream) {
      if (stream instanceof ReadStream) {
        return destroyReadStream(stream);
      }
      if (!(stream instanceof Stream)) {
        return stream;
      }
      if (typeof stream.destroy === "function") {
        stream.destroy();
      }
      return stream;
    }
    function destroyReadStream(stream) {
      stream.destroy();
      if (typeof stream.close === "function") {
        stream.on("open", onOpenClose);
      }
      return stream;
    }
    function onOpenClose() {
      if (typeof this.fd === "number") {
        this.close();
      }
    }
  }
});

// node_modules/etag/index.js
var require_etag = __commonJS({
  "node_modules/etag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = etag;
    var crypto = require("crypto");
    var Stats = require("fs").Stats;
    var toString = Object.prototype.toString;
    function entitytag(entity) {
      if (entity.length === 0) {
        return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
      }
      var hash = crypto.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
      var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
      return '"' + len.toString(16) + "-" + hash + '"';
    }
    function etag(entity, options) {
      if (entity == null) {
        throw new TypeError("argument entity is required");
      }
      var isStats = isstats(entity);
      var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
      if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
        throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
      }
      var tag = isStats ? stattag(entity) : entitytag(entity);
      return weak ? "W/" + tag : tag;
    }
    function isstats(obj) {
      if (typeof Stats === "function" && obj instanceof Stats) {
        return true;
      }
      return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
    }
    function stattag(stat) {
      var mtime = stat.mtime.getTime().toString(16);
      var size = stat.size.toString(16);
      return '"' + size + "-" + mtime + '"';
    }
  }
});

// node_modules/fresh/index.js
var require_fresh = __commonJS({
  "node_modules/fresh/index.js"(exports2, module2) {
    "use strict";
    var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
    module2.exports = fresh;
    function fresh(reqHeaders, resHeaders) {
      var modifiedSince = reqHeaders["if-modified-since"];
      var noneMatch = reqHeaders["if-none-match"];
      if (!modifiedSince && !noneMatch) {
        return false;
      }
      var cacheControl = reqHeaders["cache-control"];
      if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
        return false;
      }
      if (noneMatch && noneMatch !== "*") {
        var etag = resHeaders["etag"];
        if (!etag) {
          return false;
        }
        var etagStale = true;
        var matches = parseTokenList(noneMatch);
        for (var i = 0; i < matches.length; i++) {
          var match = matches[i];
          if (match === etag || match === "W/" + etag || "W/" + match === etag) {
            etagStale = false;
            break;
          }
        }
        if (etagStale) {
          return false;
        }
      }
      if (modifiedSince) {
        var lastModified = resHeaders["last-modified"];
        var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
        if (modifiedStale) {
          return false;
        }
      }
      return true;
    }
    function parseHttpDate(date) {
      var timestamp = date && Date.parse(date);
      return typeof timestamp === "number" ? timestamp : NaN;
    }
    function parseTokenList(str) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i = 0, len = str.length; i < len; i++) {
        switch (str.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            list.push(str.substring(start, end));
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      list.push(str.substring(start, end));
      return list;
    }
  }
});

// node_modules/mime/types.json
var require_types = __commonJS({
  "node_modules/mime/types.json"(exports2, module2) {
    module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomsvc+xml": ["atomsvc"], "application/bdoc": ["bdoc"], "application/ccxml+xml": ["ccxml"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/font-tdpfr": ["pfr"], "application/font-woff": [], "application/font-woff2": [], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/prs.cww": ["cww"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": [], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": [], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": [], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": [], "application/x-msdownload": ["com", "bat"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["wmf", "emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": [], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "application/xaml+xml": ["xaml"], "application/xcap-diff+xml": ["xdf"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": [], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mp3": [], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/wav": ["wav"], "audio/wave": [], "audio/webm": ["weba"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": [], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": [], "audio/x-wav": [], "audio/xm": ["xm"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/apng": ["apng"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/ief": ["ief"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/ktx": ["ktx"], "image/png": ["png"], "image/prs.btif": ["btif"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/tiff": ["tiff", "tif"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": [], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/webp": ["webp"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": [], "image/x-pcx": ["pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/rfc822": ["eml", "mime"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.vtu": ["vtu"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["x3db", "x3dbz"], "model/x3d+vrml": ["x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/hjson": ["hjson"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/prs.lines.tag": ["dsc"], "text/richtext": ["rtx"], "text/rtf": [], "text/sgml": ["sgml", "sgm"], "text/slim": ["slim", "slm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/vtt": ["vtt"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": [], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "text/xml": [], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/webm": ["webm"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  }
});

// node_modules/mime/mime.js
var require_mime = __commonJS({
  "node_modules/mime/mime.js"(exports2, module2) {
    var path = require("path");
    var fs = require("fs");
    function Mime() {
      this.types = Object.create(null);
      this.extensions = Object.create(null);
    }
    Mime.prototype.define = function(map) {
      for (var type in map) {
        var exts = map[type];
        for (var i = 0; i < exts.length; i++) {
          if (process.env.DEBUG_MIME && this.types[exts[i]]) {
            console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + " to " + type);
          }
          this.types[exts[i]] = type;
        }
        if (!this.extensions[type]) {
          this.extensions[type] = exts[0];
        }
      }
    };
    Mime.prototype.load = function(file) {
      this._loading = file;
      var map = {}, content = fs.readFileSync(file, "ascii"), lines = content.split(/[\r\n]+/);
      lines.forEach(function(line) {
        var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
        map[fields.shift()] = fields;
      });
      this.define(map);
      this._loading = null;
    };
    Mime.prototype.lookup = function(path2, fallback) {
      var ext = path2.replace(/^.*[\.\/\\]/, "").toLowerCase();
      return this.types[ext] || fallback || this.default_type;
    };
    Mime.prototype.extension = function(mimeType) {
      var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
      return this.extensions[type];
    };
    var mime = new Mime();
    mime.define(require_types());
    mime.default_type = mime.lookup("bin");
    mime.Mime = Mime;
    mime.charsets = {
      lookup: function(mimeType, fallback) {
        return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
      }
    };
    module2.exports = mime;
  }
});

// node_modules/send/node_modules/ms/index.js
var require_ms5 = __commonJS({
  "node_modules/send/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/range-parser/index.js
var require_range_parser = __commonJS({
  "node_modules/range-parser/index.js"(exports2, module2) {
    "use strict";
    module2.exports = rangeParser;
    function rangeParser(size, str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var index = str.indexOf("=");
      if (index === -1) {
        return -2;
      }
      var arr = str.slice(index + 1).split(",");
      var ranges = [];
      ranges.type = str.slice(0, index);
      for (var i = 0; i < arr.length; i++) {
        var range = arr[i].split("-");
        var start = parseInt(range[0], 10);
        var end = parseInt(range[1], 10);
        if (isNaN(start)) {
          start = size - end;
          end = size - 1;
        } else if (isNaN(end)) {
          end = size - 1;
        }
        if (end > size - 1) {
          end = size - 1;
        }
        if (isNaN(start) || isNaN(end) || start > end || start < 0) {
          continue;
        }
        ranges.push({
          start,
          end
        });
      }
      if (ranges.length < 1) {
        return -1;
      }
      return options && options.combine ? combineRanges(ranges) : ranges;
    }
    function combineRanges(ranges) {
      var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
      for (var j = 0, i = 1; i < ordered.length; i++) {
        var range = ordered[i];
        var current = ordered[j];
        if (range.start > current.end + 1) {
          ordered[++j] = range;
        } else if (range.end > current.end) {
          current.end = range.end;
          current.index = Math.min(current.index, range.index);
        }
      }
      ordered.length = j + 1;
      var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
      combined.type = ranges.type;
      return combined;
    }
    function mapWithIndex(range, index) {
      return {
        start: range.start,
        end: range.end,
        index
      };
    }
    function mapWithoutIndex(range) {
      return {
        start: range.start,
        end: range.end
      };
    }
    function sortByRangeIndex(a, b) {
      return a.index - b.index;
    }
    function sortByRangeStart(a, b) {
      return a.start - b.start;
    }
  }
});

// node_modules/send/index.js
var require_send = __commonJS({
  "node_modules/send/index.js"(exports2, module2) {
    "use strict";
    var createError = require_http_errors();
    var debug = require_src4()("send");
    var deprecate = require_depd()("send");
    var destroy = require_destroy();
    var encodeUrl = require_encodeurl();
    var escapeHtml = require_escape_html();
    var etag = require_etag();
    var fresh = require_fresh();
    var fs = require("fs");
    var mime = require_mime();
    var ms = require_ms5();
    var onFinished = require_on_finished();
    var parseRange = require_range_parser();
    var path = require("path");
    var statuses = require_statuses();
    var Stream = require("stream");
    var util = require("util");
    var extname = path.extname;
    var join = path.join;
    var normalize = path.normalize;
    var resolve = path.resolve;
    var sep = path.sep;
    var BYTES_RANGE_REGEXP = /^ *bytes=/;
    var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1e3;
    var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
    module2.exports = send;
    module2.exports.mime = mime;
    function send(req, path2, options) {
      return new SendStream(req, path2, options);
    }
    function SendStream(req, path2, options) {
      Stream.call(this);
      var opts = options || {};
      this.options = opts;
      this.path = path2;
      this.req = req;
      this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
      this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
      this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
      this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
      if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") {
        throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
      }
      this._hidden = Boolean(opts.hidden);
      if (opts.hidden !== void 0) {
        deprecate("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead");
      }
      if (opts.dotfiles === void 0) {
        this._dotfiles = void 0;
      }
      this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
      this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
      this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
      this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
      this._maxage = opts.maxAge || opts.maxage;
      this._maxage = typeof this._maxage === "string" ? ms(this._maxage) : Number(this._maxage);
      this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
      this._root = opts.root ? resolve(opts.root) : null;
      if (!this._root && opts.from) {
        this.from(opts.from);
      }
    }
    util.inherits(SendStream, Stream);
    SendStream.prototype.etag = deprecate.function(function etag2(val) {
      this._etag = Boolean(val);
      debug("etag %s", this._etag);
      return this;
    }, "send.etag: pass etag as option");
    SendStream.prototype.hidden = deprecate.function(function hidden(val) {
      this._hidden = Boolean(val);
      this._dotfiles = void 0;
      debug("hidden %s", this._hidden);
      return this;
    }, "send.hidden: use dotfiles option");
    SendStream.prototype.index = deprecate.function(function index(paths) {
      var index2 = !paths ? [] : normalizeList(paths, "paths argument");
      debug("index %o", paths);
      this._index = index2;
      return this;
    }, "send.index: pass index as option");
    SendStream.prototype.root = function root(path2) {
      this._root = resolve(String(path2));
      debug("root %s", this._root);
      return this;
    };
    SendStream.prototype.from = deprecate.function(SendStream.prototype.root, "send.from: pass root as option");
    SendStream.prototype.root = deprecate.function(SendStream.prototype.root, "send.root: pass root as option");
    SendStream.prototype.maxage = deprecate.function(function maxage(maxAge) {
      this._maxage = typeof maxAge === "string" ? ms(maxAge) : Number(maxAge);
      this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
      debug("max-age %d", this._maxage);
      return this;
    }, "send.maxage: pass maxAge as option");
    SendStream.prototype.error = function error(status, err) {
      if (hasListeners(this, "error")) {
        return this.emit("error", createError(status, err, {
          expose: false
        }));
      }
      var res = this.res;
      var msg = statuses[status] || String(status);
      var doc = createHtmlDocument("Error", escapeHtml(msg));
      clearHeaders(res);
      if (err && err.headers) {
        setHeaders(res, err.headers);
      }
      res.statusCode = status;
      res.setHeader("Content-Type", "text/html; charset=UTF-8");
      res.setHeader("Content-Length", Buffer.byteLength(doc));
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.end(doc);
    };
    SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
      return this.path[this.path.length - 1] === "/";
    };
    SendStream.prototype.isConditionalGET = function isConditionalGET() {
      return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
    };
    SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
      var req = this.req;
      var res = this.res;
      var match = req.headers["if-match"];
      if (match) {
        var etag2 = res.getHeader("ETag");
        return !etag2 || match !== "*" && parseTokenList(match).every(function(match2) {
          return match2 !== etag2 && match2 !== "W/" + etag2 && "W/" + match2 !== etag2;
        });
      }
      var unmodifiedSince = parseHttpDate(req.headers["if-unmodified-since"]);
      if (!isNaN(unmodifiedSince)) {
        var lastModified = parseHttpDate(res.getHeader("Last-Modified"));
        return isNaN(lastModified) || lastModified > unmodifiedSince;
      }
      return false;
    };
    SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
      var res = this.res;
      var headers = getHeaderNames(res);
      for (var i = 0; i < headers.length; i++) {
        var header = headers[i];
        if (header.substr(0, 8) === "content-" && header !== "content-location") {
          res.removeHeader(header);
        }
      }
    };
    SendStream.prototype.notModified = function notModified() {
      var res = this.res;
      debug("not modified");
      this.removeContentHeaderFields();
      res.statusCode = 304;
      res.end();
    };
    SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
      var err = new Error("Can't set headers after they are sent.");
      debug("headers already sent");
      this.error(500, err);
    };
    SendStream.prototype.isCachable = function isCachable() {
      var statusCode = this.res.statusCode;
      return statusCode >= 200 && statusCode < 300 || statusCode === 304;
    };
    SendStream.prototype.onStatError = function onStatError(error) {
      switch (error.code) {
        case "ENAMETOOLONG":
        case "ENOENT":
        case "ENOTDIR":
          this.error(404, error);
          break;
        default:
          this.error(500, error);
          break;
      }
    };
    SendStream.prototype.isFresh = function isFresh() {
      return fresh(this.req.headers, {
        "etag": this.res.getHeader("ETag"),
        "last-modified": this.res.getHeader("Last-Modified")
      });
    };
    SendStream.prototype.isRangeFresh = function isRangeFresh() {
      var ifRange = this.req.headers["if-range"];
      if (!ifRange) {
        return true;
      }
      if (ifRange.indexOf('"') !== -1) {
        var etag2 = this.res.getHeader("ETag");
        return Boolean(etag2 && ifRange.indexOf(etag2) !== -1);
      }
      var lastModified = this.res.getHeader("Last-Modified");
      return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
    };
    SendStream.prototype.redirect = function redirect(path2) {
      var res = this.res;
      if (hasListeners(this, "directory")) {
        this.emit("directory", res, path2);
        return;
      }
      if (this.hasTrailingSlash()) {
        this.error(403);
        return;
      }
      var loc = encodeUrl(collapseLeadingSlashes(this.path + "/"));
      var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + "</a>");
      res.statusCode = 301;
      res.setHeader("Content-Type", "text/html; charset=UTF-8");
      res.setHeader("Content-Length", Buffer.byteLength(doc));
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Location", loc);
      res.end(doc);
    };
    SendStream.prototype.pipe = function pipe(res) {
      var root = this._root;
      this.res = res;
      var path2 = decode(this.path);
      if (path2 === -1) {
        this.error(400);
        return res;
      }
      if (~path2.indexOf("\0")) {
        this.error(400);
        return res;
      }
      var parts;
      if (root !== null) {
        if (path2) {
          path2 = normalize("." + sep + path2);
        }
        if (UP_PATH_REGEXP.test(path2)) {
          debug('malicious path "%s"', path2);
          this.error(403);
          return res;
        }
        parts = path2.split(sep);
        path2 = normalize(join(root, path2));
      } else {
        if (UP_PATH_REGEXP.test(path2)) {
          debug('malicious path "%s"', path2);
          this.error(403);
          return res;
        }
        parts = normalize(path2).split(sep);
        path2 = resolve(path2);
      }
      if (containsDotFile(parts)) {
        var access = this._dotfiles;
        if (access === void 0) {
          access = parts[parts.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow";
        }
        debug('%s dotfile "%s"', access, path2);
        switch (access) {
          case "allow":
            break;
          case "deny":
            this.error(403);
            return res;
          case "ignore":
          default:
            this.error(404);
            return res;
        }
      }
      if (this._index.length && this.hasTrailingSlash()) {
        this.sendIndex(path2);
        return res;
      }
      this.sendFile(path2);
      return res;
    };
    SendStream.prototype.send = function send2(path2, stat) {
      var len = stat.size;
      var options = this.options;
      var opts = {};
      var res = this.res;
      var req = this.req;
      var ranges = req.headers.range;
      var offset = options.start || 0;
      if (headersSent(res)) {
        this.headersAlreadySent();
        return;
      }
      debug('pipe "%s"', path2);
      this.setHeader(path2, stat);
      this.type(path2);
      if (this.isConditionalGET()) {
        if (this.isPreconditionFailure()) {
          this.error(412);
          return;
        }
        if (this.isCachable() && this.isFresh()) {
          this.notModified();
          return;
        }
      }
      len = Math.max(0, len - offset);
      if (options.end !== void 0) {
        var bytes = options.end - offset + 1;
        if (len > bytes)
          len = bytes;
      }
      if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
        ranges = parseRange(len, ranges, {
          combine: true
        });
        if (!this.isRangeFresh()) {
          debug("range stale");
          ranges = -2;
        }
        if (ranges === -1) {
          debug("range unsatisfiable");
          res.setHeader("Content-Range", contentRange("bytes", len));
          return this.error(416, {
            headers: { "Content-Range": res.getHeader("Content-Range") }
          });
        }
        if (ranges !== -2 && ranges.length === 1) {
          debug("range %j", ranges);
          res.statusCode = 206;
          res.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
          offset += ranges[0].start;
          len = ranges[0].end - ranges[0].start + 1;
        }
      }
      for (var prop in options) {
        opts[prop] = options[prop];
      }
      opts.start = offset;
      opts.end = Math.max(offset, offset + len - 1);
      res.setHeader("Content-Length", len);
      if (req.method === "HEAD") {
        res.end();
        return;
      }
      this.stream(path2, opts);
    };
    SendStream.prototype.sendFile = function sendFile(path2) {
      var i = 0;
      var self2 = this;
      debug('stat "%s"', path2);
      fs.stat(path2, function onstat(err, stat) {
        if (err && err.code === "ENOENT" && !extname(path2) && path2[path2.length - 1] !== sep) {
          return next(err);
        }
        if (err)
          return self2.onStatError(err);
        if (stat.isDirectory())
          return self2.redirect(path2);
        self2.emit("file", path2, stat);
        self2.send(path2, stat);
      });
      function next(err) {
        if (self2._extensions.length <= i) {
          return err ? self2.onStatError(err) : self2.error(404);
        }
        var p = path2 + "." + self2._extensions[i++];
        debug('stat "%s"', p);
        fs.stat(p, function(err2, stat) {
          if (err2)
            return next(err2);
          if (stat.isDirectory())
            return next();
          self2.emit("file", p, stat);
          self2.send(p, stat);
        });
      }
    };
    SendStream.prototype.sendIndex = function sendIndex(path2) {
      var i = -1;
      var self2 = this;
      function next(err) {
        if (++i >= self2._index.length) {
          if (err)
            return self2.onStatError(err);
          return self2.error(404);
        }
        var p = join(path2, self2._index[i]);
        debug('stat "%s"', p);
        fs.stat(p, function(err2, stat) {
          if (err2)
            return next(err2);
          if (stat.isDirectory())
            return next();
          self2.emit("file", p, stat);
          self2.send(p, stat);
        });
      }
      next();
    };
    SendStream.prototype.stream = function stream(path2, options) {
      var finished = false;
      var self2 = this;
      var res = this.res;
      var stream2 = fs.createReadStream(path2, options);
      this.emit("stream", stream2);
      stream2.pipe(res);
      onFinished(res, function onfinished() {
        finished = true;
        destroy(stream2);
      });
      stream2.on("error", function onerror(err) {
        if (finished)
          return;
        finished = true;
        destroy(stream2);
        self2.onStatError(err);
      });
      stream2.on("end", function onend() {
        self2.emit("end");
      });
    };
    SendStream.prototype.type = function type(path2) {
      var res = this.res;
      if (res.getHeader("Content-Type"))
        return;
      var type2 = mime.lookup(path2);
      if (!type2) {
        debug("no content-type");
        return;
      }
      var charset = mime.charsets.lookup(type2);
      debug("content-type %s", type2);
      res.setHeader("Content-Type", type2 + (charset ? "; charset=" + charset : ""));
    };
    SendStream.prototype.setHeader = function setHeader(path2, stat) {
      var res = this.res;
      this.emit("headers", res, path2, stat);
      if (this._acceptRanges && !res.getHeader("Accept-Ranges")) {
        debug("accept ranges");
        res.setHeader("Accept-Ranges", "bytes");
      }
      if (this._cacheControl && !res.getHeader("Cache-Control")) {
        var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
        if (this._immutable) {
          cacheControl += ", immutable";
        }
        debug("cache-control %s", cacheControl);
        res.setHeader("Cache-Control", cacheControl);
      }
      if (this._lastModified && !res.getHeader("Last-Modified")) {
        var modified = stat.mtime.toUTCString();
        debug("modified %s", modified);
        res.setHeader("Last-Modified", modified);
      }
      if (this._etag && !res.getHeader("ETag")) {
        var val = etag(stat);
        debug("etag %s", val);
        res.setHeader("ETag", val);
      }
    };
    function clearHeaders(res) {
      var headers = getHeaderNames(res);
      for (var i = 0; i < headers.length; i++) {
        res.removeHeader(headers[i]);
      }
    }
    function collapseLeadingSlashes(str) {
      for (var i = 0; i < str.length; i++) {
        if (str[i] !== "/") {
          break;
        }
      }
      return i > 1 ? "/" + str.substr(i) : str;
    }
    function containsDotFile(parts) {
      for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (part.length > 1 && part[0] === ".") {
          return true;
        }
      }
      return false;
    }
    function contentRange(type, size, range) {
      return type + " " + (range ? range.start + "-" + range.end : "*") + "/" + size;
    }
    function createHtmlDocument(title, body) {
      return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
    }
    function decode(path2) {
      try {
        return decodeURIComponent(path2);
      } catch (err) {
        return -1;
      }
    }
    function getHeaderNames(res) {
      return typeof res.getHeaderNames !== "function" ? Object.keys(res._headers || {}) : res.getHeaderNames();
    }
    function hasListeners(emitter, type) {
      var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type).length : emitter.listenerCount(type);
      return count > 0;
    }
    function headersSent(res) {
      return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
    }
    function normalizeList(val, name) {
      var list = [].concat(val || []);
      for (var i = 0; i < list.length; i++) {
        if (typeof list[i] !== "string") {
          throw new TypeError(name + " must be array of strings or false");
        }
      }
      return list;
    }
    function parseHttpDate(date) {
      var timestamp = date && Date.parse(date);
      return typeof timestamp === "number" ? timestamp : NaN;
    }
    function parseTokenList(str) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i = 0, len = str.length; i < len; i++) {
        switch (str.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            list.push(str.substring(start, end));
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      list.push(str.substring(start, end));
      return list;
    }
    function setHeaders(res, headers) {
      var keys = Object.keys(headers);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        res.setHeader(key, headers[key]);
      }
    }
  }
});

// node_modules/forwarded/index.js
var require_forwarded = __commonJS({
  "node_modules/forwarded/index.js"(exports2, module2) {
    "use strict";
    module2.exports = forwarded;
    function forwarded(req) {
      if (!req) {
        throw new TypeError("argument req is required");
      }
      var proxyAddrs = parse(req.headers["x-forwarded-for"] || "");
      var socketAddr = getSocketAddr(req);
      var addrs = [socketAddr].concat(proxyAddrs);
      return addrs;
    }
    function getSocketAddr(req) {
      return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
    }
    function parse(header) {
      var end = header.length;
      var list = [];
      var start = header.length;
      for (var i = header.length - 1; i >= 0; i--) {
        switch (header.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i;
            }
            break;
          case 44:
            if (start !== end) {
              list.push(header.substring(start, end));
            }
            start = end = i;
            break;
          default:
            start = i;
            break;
        }
      }
      if (start !== end) {
        list.push(header.substring(start, end));
      }
      return list;
    }
  }
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "node_modules/ipaddr.js/lib/ipaddr.js"(exports2, module2) {
    (function() {
      var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
      ipaddr = {};
      root = this;
      if (typeof module2 !== "undefined" && module2 !== null && module2.exports) {
        module2.exports = ipaddr;
      } else {
        root["ipaddr"] = ipaddr;
      }
      matchCIDR = function(first, second, partSize, cidrBits) {
        var part, shift;
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        part = 0;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      };
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        var k, len, rangeName, rangeSubnets, subnet;
        if (defaultName == null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (k = 0, len = rangeSubnets.length; k < len; k++) {
            subnet = rangeSubnets[k];
            if (address.kind() === subnet[0].kind()) {
              if (address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      ipaddr.IPv4 = function() {
        function IPv4(octets) {
          var k, len, octet;
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          for (k = 0, len = octets.length; k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.match = function(other, cidrRange) {
          var ref;
          if (cidrRange === void 0) {
            ref = other, other = ref[0], cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
          reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
        };
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse("::ffff:" + this.toString());
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, octet, stop, zeros, zerotable;
          zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 3; k >= 0; i = k += -1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        return IPv4;
      }();
      ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      ipv4Regexes = {
        fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
        longValue: new RegExp("^" + ipv4Part + "$", "i")
      };
      ipaddr.IPv4.parser = function(string) {
        var match, parseIntAuto, part, shift, value;
        parseIntAuto = function(string2) {
          if (string2[0] === "0" && string2[1] !== "x") {
            return parseInt(string2, 8);
          } else {
            return parseInt(string2);
          }
        };
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return function() {
            var k, len, ref, results;
            ref = match.slice(1, 6);
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            var k, results;
            results = [];
            for (shift = k = 0; k <= 24; shift = k += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else {
          return null;
        }
      };
      ipaddr.IPv6 = function() {
        function IPv6(parts, zoneId) {
          var i, k, l, len, part, ref;
          if (parts.length === 16) {
            this.parts = [];
            for (i = k = 0; k <= 14; i = k += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          ref = this.parts;
          for (l = 0, len = ref.length; l < len; l++) {
            part = ref[l];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        IPv6.prototype.toRFC5952String = function() {
          var bestMatchIndex, bestMatchLength, match, regex, string;
          regex = /((^|:)(0(:|$)){2,})/g;
          string = this.toNormalizedString();
          bestMatchIndex = 0;
          bestMatchLength = -1;
          while (match = regex.exec(string)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string;
          }
          return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
        };
        IPv6.prototype.toByteArray = function() {
          var bytes, k, len, part, ref;
          bytes = [];
          ref = this.parts;
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            bytes.push(part >> 8);
            bytes.push(part & 255);
          }
          return bytes;
        };
        IPv6.prototype.toNormalizedString = function() {
          var addr, part, suffix;
          addr = function() {
            var k, len, ref, results;
            ref = this.parts;
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(part.toString(16));
            }
            return results;
          }.call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.toFixedLengthString = function() {
          var addr, part, suffix;
          addr = function() {
            var k, len, ref, results;
            ref = this.parts;
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(part.toString(16).padStart(4, "0"));
            }
            return results;
          }.call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.match = function(other, cidrRange) {
          var ref;
          if (cidrRange === void 0) {
            ref = other, other = ref[0], cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.toIPv4Address = function() {
          var high, low, ref;
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          ref = this.parts.slice(-2), high = ref[0], low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, part, stop, zeros, zerotable;
          zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 7; k >= 0; i = k += -1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        return IPv6;
      }();
      ipv6Part = "(?:[0-9a-f]+::?)+";
      zoneIndex = "%[0-9a-z]{1,}";
      ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
        transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
      };
      expandIPv6 = function(string, parts) {
        var colonCount, lastColon, part, replacement, replacementCount, zoneId;
        if (string.indexOf("::") !== string.lastIndexOf("::")) {
          return null;
        }
        zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string = string.replace(/%.+$/, "");
        }
        colonCount = 0;
        lastColon = -1;
        while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string = string.replace("::", replacement);
        if (string[0] === ":") {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ":") {
          string = string.slice(0, -1);
        }
        parts = function() {
          var k, len, ref, results;
          ref = string.split(":");
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            results.push(parseInt(part, 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      };
      ipaddr.IPv6.parser = function(string) {
        var addr, k, len, match, octet, octets, zoneId;
        if (ipv6Regexes["native"].test(string)) {
          return expandIPv6(string, 8);
        } else if (match = string.match(ipv6Regexes["transitional"])) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
            for (k = 0, len = octets.length; k < len; k++) {
              octet = octets[k];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv4.isValid = function(string) {
        var e;
        try {
          new this(this.parser(string));
          return true;
        } catch (error1) {
          e = error1;
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function(string) {
        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv6.isValid = function(string) {
        var addr, e;
        if (typeof string === "string" && string.indexOf(":") === -1) {
          return false;
        }
        try {
          addr = this.parser(string);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (error1) {
          e = error1;
          return false;
        }
      };
      ipaddr.IPv4.parse = function(string) {
        var parts;
        parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(parts);
      };
      ipaddr.IPv6.parse = function(string) {
        var addr;
        addr = this.parser(string);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv4.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        var filledOctetCount, j, octets;
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        octets = [0, 0, 0, 0];
        j = 0;
        filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
        var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (error1) {
          error = error1;
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.networkAddressFromCIDR = function(string) {
        var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (error1) {
          error = error1;
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv6.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.isValid = function(string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
      };
      ipaddr.parse = function(string) {
        if (ipaddr.IPv6.isValid(string)) {
          return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isValid(string)) {
          return ipaddr.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function(string) {
        var e;
        try {
          return ipaddr.IPv6.parseCIDR(string);
        } catch (error1) {
          e = error1;
          try {
            return ipaddr.IPv4.parseCIDR(string);
          } catch (error12) {
            e = error12;
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.fromByteArray = function(bytes) {
        var length;
        length = bytes.length;
        if (length === 4) {
          return new ipaddr.IPv4(bytes);
        } else if (length === 16) {
          return new ipaddr.IPv6(bytes);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.process = function(string) {
        var addr;
        addr = this.parse(string);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
    }).call(exports2);
  }
});

// node_modules/proxy-addr/index.js
var require_proxy_addr = __commonJS({
  "node_modules/proxy-addr/index.js"(exports2, module2) {
    "use strict";
    module2.exports = proxyaddr;
    module2.exports.all = alladdrs;
    module2.exports.compile = compile;
    var forwarded = require_forwarded();
    var ipaddr = require_ipaddr();
    var DIGIT_REGEXP = /^[0-9]+$/;
    var isip = ipaddr.isValid;
    var parseip = ipaddr.parse;
    var IP_RANGES = {
      linklocal: ["169.254.0.0/16", "fe80::/10"],
      loopback: ["127.0.0.1/8", "::1/128"],
      uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
    };
    function alladdrs(req, trust) {
      var addrs = forwarded(req);
      if (!trust) {
        return addrs;
      }
      if (typeof trust !== "function") {
        trust = compile(trust);
      }
      for (var i = 0; i < addrs.length - 1; i++) {
        if (trust(addrs[i], i))
          continue;
        addrs.length = i + 1;
      }
      return addrs;
    }
    function compile(val) {
      if (!val) {
        throw new TypeError("argument is required");
      }
      var trust;
      if (typeof val === "string") {
        trust = [val];
      } else if (Array.isArray(val)) {
        trust = val.slice();
      } else {
        throw new TypeError("unsupported trust argument");
      }
      for (var i = 0; i < trust.length; i++) {
        val = trust[i];
        if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
          continue;
        }
        val = IP_RANGES[val];
        trust.splice.apply(trust, [i, 1].concat(val));
        i += val.length - 1;
      }
      return compileTrust(compileRangeSubnets(trust));
    }
    function compileRangeSubnets(arr) {
      var rangeSubnets = new Array(arr.length);
      for (var i = 0; i < arr.length; i++) {
        rangeSubnets[i] = parseipNotation(arr[i]);
      }
      return rangeSubnets;
    }
    function compileTrust(rangeSubnets) {
      var len = rangeSubnets.length;
      return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
    }
    function parseipNotation(note) {
      var pos = note.lastIndexOf("/");
      var str = pos !== -1 ? note.substring(0, pos) : note;
      if (!isip(str)) {
        throw new TypeError("invalid IP address: " + str);
      }
      var ip = parseip(str);
      if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
        ip = ip.toIPv4Address();
      }
      var max = ip.kind() === "ipv6" ? 128 : 32;
      var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
      if (range === null) {
        range = max;
      } else if (DIGIT_REGEXP.test(range)) {
        range = parseInt(range, 10);
      } else if (ip.kind() === "ipv4" && isip(range)) {
        range = parseNetmask(range);
      } else {
        range = null;
      }
      if (range <= 0 || range > max) {
        throw new TypeError("invalid range on address: " + note);
      }
      return [ip, range];
    }
    function parseNetmask(netmask) {
      var ip = parseip(netmask);
      var kind = ip.kind();
      return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
    }
    function proxyaddr(req, trust) {
      if (!req) {
        throw new TypeError("req argument is required");
      }
      if (!trust) {
        throw new TypeError("trust argument is required");
      }
      var addrs = alladdrs(req, trust);
      var addr = addrs[addrs.length - 1];
      return addr;
    }
    function trustNone() {
      return false;
    }
    function trustMulti(subnets) {
      return function trust(addr) {
        if (!isip(addr))
          return false;
        var ip = parseip(addr);
        var ipconv;
        var kind = ip.kind();
        for (var i = 0; i < subnets.length; i++) {
          var subnet = subnets[i];
          var subnetip = subnet[0];
          var subnetkind = subnetip.kind();
          var subnetrange = subnet[1];
          var trusted = ip;
          if (kind !== subnetkind) {
            if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
              continue;
            }
            if (!ipconv) {
              ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
            }
            trusted = ipconv;
          }
          if (trusted.match(subnetip, subnetrange)) {
            return true;
          }
        }
        return false;
      };
    }
    function trustSingle(subnet) {
      var subnetip = subnet[0];
      var subnetkind = subnetip.kind();
      var subnetisipv4 = subnetkind === "ipv4";
      var subnetrange = subnet[1];
      return function trust(addr) {
        if (!isip(addr))
          return false;
        var ip = parseip(addr);
        var kind = ip.kind();
        if (kind !== subnetkind) {
          if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
            return false;
          }
          ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
        }
        return ip.match(subnetip, subnetrange);
      };
    }
  }
});

// node_modules/express/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/express/lib/utils.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var contentDisposition = require_content_disposition();
    var contentType = require_content_type();
    var deprecate = require_depd()("express");
    var flatten = require_array_flatten();
    var mime = require_send().mime;
    var etag = require_etag();
    var proxyaddr = require_proxy_addr();
    var qs = require_lib2();
    var querystring = require("querystring");
    exports2.etag = createETagGenerator({ weak: false });
    exports2.wetag = createETagGenerator({ weak: true });
    exports2.isAbsolute = function(path) {
      if (path[0] === "/")
        return true;
      if (path[1] === ":" && (path[2] === "\\" || path[2] === "/"))
        return true;
      if (path.substring(0, 2) === "\\\\")
        return true;
    };
    exports2.flatten = deprecate.function(flatten, "utils.flatten: use array-flatten npm module instead");
    exports2.normalizeType = function(type) {
      return ~type.indexOf("/") ? acceptParams(type) : { value: mime.lookup(type), params: {} };
    };
    exports2.normalizeTypes = function(types) {
      var ret2 = [];
      for (var i = 0; i < types.length; ++i) {
        ret2.push(exports2.normalizeType(types[i]));
      }
      return ret2;
    };
    exports2.contentDisposition = deprecate.function(contentDisposition, "utils.contentDisposition: use content-disposition npm module instead");
    function acceptParams(str, index) {
      var parts = str.split(/ *; */);
      var ret2 = { value: parts[0], quality: 1, params: {}, originalIndex: index };
      for (var i = 1; i < parts.length; ++i) {
        var pms = parts[i].split(/ *= */);
        if (pms[0] === "q") {
          ret2.quality = parseFloat(pms[1]);
        } else {
          ret2.params[pms[0]] = pms[1];
        }
      }
      return ret2;
    }
    exports2.compileETag = function(val) {
      var fn;
      if (typeof val === "function") {
        return val;
      }
      switch (val) {
        case true:
          fn = exports2.wetag;
          break;
        case false:
          break;
        case "strong":
          fn = exports2.etag;
          break;
        case "weak":
          fn = exports2.wetag;
          break;
        default:
          throw new TypeError("unknown value for etag function: " + val);
      }
      return fn;
    };
    exports2.compileQueryParser = function compileQueryParser(val) {
      var fn;
      if (typeof val === "function") {
        return val;
      }
      switch (val) {
        case true:
          fn = querystring.parse;
          break;
        case false:
          fn = newObject;
          break;
        case "extended":
          fn = parseExtendedQueryString;
          break;
        case "simple":
          fn = querystring.parse;
          break;
        default:
          throw new TypeError("unknown value for query parser function: " + val);
      }
      return fn;
    };
    exports2.compileTrust = function(val) {
      if (typeof val === "function")
        return val;
      if (val === true) {
        return function() {
          return true;
        };
      }
      if (typeof val === "number") {
        return function(a, i) {
          return i < val;
        };
      }
      if (typeof val === "string") {
        val = val.split(/ *, */);
      }
      return proxyaddr.compile(val || []);
    };
    exports2.setCharset = function setCharset(type, charset) {
      if (!type || !charset) {
        return type;
      }
      var parsed = contentType.parse(type);
      parsed.parameters.charset = charset;
      return contentType.format(parsed);
    };
    function createETagGenerator(options) {
      return function generateETag(body, encoding) {
        var buf = !Buffer2.isBuffer(body) ? Buffer2.from(body, encoding) : body;
        return etag(buf, options);
      };
    }
    function parseExtendedQueryString(str) {
      return qs.parse(str, {
        allowPrototypes: true
      });
    }
    function newObject() {
      return {};
    }
  }
});

// node_modules/express/lib/application.js
var require_application = __commonJS({
  "node_modules/express/lib/application.js"(exports2, module2) {
    "use strict";
    var finalhandler = require_finalhandler();
    var Router2 = require_router();
    var methods = require_methods();
    var middleware = require_init();
    var query = require_query();
    var debug = require_src3()("express:application");
    var View = require_view();
    var http = require("http");
    var compileETag = require_utils2().compileETag;
    var compileQueryParser = require_utils2().compileQueryParser;
    var compileTrust = require_utils2().compileTrust;
    var deprecate = require_depd()("express");
    var flatten = require_array_flatten();
    var merge = require_utils_merge();
    var resolve = require("path").resolve;
    var setPrototypeOf = require_setprototypeof();
    var slice = Array.prototype.slice;
    var app = exports2 = module2.exports = {};
    var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
    app.init = function init() {
      this.cache = {};
      this.engines = {};
      this.settings = {};
      this.defaultConfiguration();
    };
    app.defaultConfiguration = function defaultConfiguration() {
      var env2 = process.env.NODE_ENV || "development";
      this.enable("x-powered-by");
      this.set("etag", "weak");
      this.set("env", env2);
      this.set("query parser", "extended");
      this.set("subdomain offset", 2);
      this.set("trust proxy", false);
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: true
      });
      debug("booting in %s mode", env2);
      this.on("mount", function onmount(parent) {
        if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
          delete this.settings["trust proxy"];
          delete this.settings["trust proxy fn"];
        }
        setPrototypeOf(this.request, parent.request);
        setPrototypeOf(this.response, parent.response);
        setPrototypeOf(this.engines, parent.engines);
        setPrototypeOf(this.settings, parent.settings);
      });
      this.locals = Object.create(null);
      this.mountpath = "/";
      this.locals.settings = this.settings;
      this.set("view", View);
      this.set("views", resolve("views"));
      this.set("jsonp callback name", "callback");
      if (env2 === "production") {
        this.enable("view cache");
      }
      Object.defineProperty(this, "router", {
        get: function() {
          throw new Error("'app.router' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.");
        }
      });
    };
    app.lazyrouter = function lazyrouter() {
      if (!this._router) {
        this._router = new Router2({
          caseSensitive: this.enabled("case sensitive routing"),
          strict: this.enabled("strict routing")
        });
        this._router.use(query(this.get("query parser fn")));
        this._router.use(middleware.init(this));
      }
    };
    app.handle = function handle(req, res, callback) {
      var router2 = this._router;
      var done = callback || finalhandler(req, res, {
        env: this.get("env"),
        onerror: logerror.bind(this)
      });
      if (!router2) {
        debug("no routes defined on app");
        done();
        return;
      }
      router2.handle(req, res, done);
    };
    app.use = function use(fn) {
      var offset = 0;
      var path = "/";
      if (typeof fn !== "function") {
        var arg = fn;
        while (Array.isArray(arg) && arg.length !== 0) {
          arg = arg[0];
        }
        if (typeof arg !== "function") {
          offset = 1;
          path = fn;
        }
      }
      var fns = flatten(slice.call(arguments, offset));
      if (fns.length === 0) {
        throw new TypeError("app.use() requires a middleware function");
      }
      this.lazyrouter();
      var router2 = this._router;
      fns.forEach(function(fn2) {
        if (!fn2 || !fn2.handle || !fn2.set) {
          return router2.use(path, fn2);
        }
        debug(".use app under %s", path);
        fn2.mountpath = path;
        fn2.parent = this;
        router2.use(path, function mounted_app(req, res, next) {
          var orig = req.app;
          fn2.handle(req, res, function(err) {
            setPrototypeOf(req, orig.request);
            setPrototypeOf(res, orig.response);
            next(err);
          });
        });
        fn2.emit("mount", this);
      }, this);
      return this;
    };
    app.route = function route(path) {
      this.lazyrouter();
      return this._router.route(path);
    };
    app.engine = function engine(ext, fn) {
      if (typeof fn !== "function") {
        throw new Error("callback function required");
      }
      var extension = ext[0] !== "." ? "." + ext : ext;
      this.engines[extension] = fn;
      return this;
    };
    app.param = function param(name, fn) {
      this.lazyrouter();
      if (Array.isArray(name)) {
        for (var i = 0; i < name.length; i++) {
          this.param(name[i], fn);
        }
        return this;
      }
      this._router.param(name, fn);
      return this;
    };
    app.set = function set(setting, val) {
      if (arguments.length === 1) {
        return this.settings[setting];
      }
      debug('set "%s" to %o', setting, val);
      this.settings[setting] = val;
      switch (setting) {
        case "etag":
          this.set("etag fn", compileETag(val));
          break;
        case "query parser":
          this.set("query parser fn", compileQueryParser(val));
          break;
        case "trust proxy":
          this.set("trust proxy fn", compileTrust(val));
          Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
            configurable: true,
            value: false
          });
          break;
      }
      return this;
    };
    app.path = function path() {
      return this.parent ? this.parent.path() + this.mountpath : "";
    };
    app.enabled = function enabled(setting) {
      return Boolean(this.set(setting));
    };
    app.disabled = function disabled(setting) {
      return !this.set(setting);
    };
    app.enable = function enable(setting) {
      return this.set(setting, true);
    };
    app.disable = function disable(setting) {
      return this.set(setting, false);
    };
    methods.forEach(function(method) {
      app[method] = function(path) {
        if (method === "get" && arguments.length === 1) {
          return this.set(path);
        }
        this.lazyrouter();
        var route = this._router.route(path);
        route[method].apply(route, slice.call(arguments, 1));
        return this;
      };
    });
    app.all = function all(path) {
      this.lazyrouter();
      var route = this._router.route(path);
      var args = slice.call(arguments, 1);
      for (var i = 0; i < methods.length; i++) {
        route[methods[i]].apply(route, args);
      }
      return this;
    };
    app.del = deprecate.function(app.delete, "app.del: Use app.delete instead");
    app.render = function render(name, options, callback) {
      var cache = this.cache;
      var done = callback;
      var engines = this.engines;
      var opts = options;
      var renderOptions = {};
      var view;
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      merge(renderOptions, this.locals);
      if (opts._locals) {
        merge(renderOptions, opts._locals);
      }
      merge(renderOptions, opts);
      if (renderOptions.cache == null) {
        renderOptions.cache = this.enabled("view cache");
      }
      if (renderOptions.cache) {
        view = cache[name];
      }
      if (!view) {
        var View2 = this.get("view");
        view = new View2(name, {
          defaultEngine: this.get("view engine"),
          root: this.get("views"),
          engines
        });
        if (!view.path) {
          var dirs = Array.isArray(view.root) && view.root.length > 1 ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"' : 'directory "' + view.root + '"';
          var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
          err.view = view;
          return done(err);
        }
        if (renderOptions.cache) {
          cache[name] = view;
        }
      }
      tryRender(view, renderOptions, done);
    };
    app.listen = function listen() {
      var server = http.createServer(this);
      return server.listen.apply(server, arguments);
    };
    function logerror(err) {
      if (this.get("env") !== "test")
        console.error(err.stack || err.toString());
    }
    function tryRender(view, options, callback) {
      try {
        view.render(options, callback);
      } catch (err) {
        callback(err);
      }
    }
  }
});

// node_modules/negotiator/lib/charset.js
var require_charset = __commonJS({
  "node_modules/negotiator/lib/charset.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredCharsets;
    module2.exports.preferredCharsets = preferredCharsets;
    var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptCharset(accept) {
      var accepts = accept.split(",");
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var charset = parseCharset(accepts[i].trim(), i);
        if (charset) {
          accepts[j++] = charset;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseCharset(str, i) {
      var match = simpleCharsetRegExp.exec(str);
      if (!match)
        return null;
      var charset = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split("=");
          if (p[0] === "q") {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
      return {
        charset,
        q,
        i
      };
    }
    function getCharsetPriority(charset, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(charset, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(charset, spec, index) {
      var s = 0;
      if (spec.charset.toLowerCase() === charset.toLowerCase()) {
        s |= 1;
      } else if (spec.charset !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredCharsets(accept, provided) {
      var accepts = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getCharsetPriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullCharset(spec) {
      return spec.charset;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// node_modules/negotiator/lib/encoding.js
var require_encoding = __commonJS({
  "node_modules/negotiator/lib/encoding.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredEncodings;
    module2.exports.preferredEncodings = preferredEncodings;
    var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptEncoding(accept) {
      var accepts = accept.split(",");
      var hasIdentity = false;
      var minQuality = 1;
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var encoding = parseEncoding(accepts[i].trim(), i);
        if (encoding) {
          accepts[j++] = encoding;
          hasIdentity = hasIdentity || specify("identity", encoding);
          minQuality = Math.min(minQuality, encoding.q || 1);
        }
      }
      if (!hasIdentity) {
        accepts[j++] = {
          encoding: "identity",
          q: minQuality,
          i
        };
      }
      accepts.length = j;
      return accepts;
    }
    function parseEncoding(str, i) {
      var match = simpleEncodingRegExp.exec(str);
      if (!match)
        return null;
      var encoding = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split("=");
          if (p[0] === "q") {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
      return {
        encoding,
        q,
        i
      };
    }
    function getEncodingPriority(encoding, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(encoding, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(encoding, spec, index) {
      var s = 0;
      if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
        s |= 1;
      } else if (spec.encoding !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredEncodings(accept, provided) {
      var accepts = parseAcceptEncoding(accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getEncodingPriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullEncoding(spec) {
      return spec.encoding;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// node_modules/negotiator/lib/language.js
var require_language = __commonJS({
  "node_modules/negotiator/lib/language.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredLanguages;
    module2.exports.preferredLanguages = preferredLanguages;
    var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
    function parseAcceptLanguage(accept) {
      var accepts = accept.split(",");
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var language = parseLanguage(accepts[i].trim(), i);
        if (language) {
          accepts[j++] = language;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseLanguage(str, i) {
      var match = simpleLanguageRegExp.exec(str);
      if (!match)
        return null;
      var prefix = match[1], suffix = match[2], full = prefix;
      if (suffix)
        full += "-" + suffix;
      var q = 1;
      if (match[3]) {
        var params = match[3].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].split("=");
          if (p[0] === "q")
            q = parseFloat(p[1]);
        }
      }
      return {
        prefix,
        suffix,
        q,
        i,
        full
      };
    }
    function getLanguagePriority(language, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(language, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(language, spec, index) {
      var p = parseLanguage(language);
      if (!p)
        return null;
      var s = 0;
      if (spec.full.toLowerCase() === p.full.toLowerCase()) {
        s |= 4;
      } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
        s |= 2;
      } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
        s |= 1;
      } else if (spec.full !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredLanguages(accept, provided) {
      var accepts = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getLanguagePriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullLanguage(spec) {
      return spec.full;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// node_modules/negotiator/lib/mediaType.js
var require_mediaType = __commonJS({
  "node_modules/negotiator/lib/mediaType.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredMediaTypes;
    module2.exports.preferredMediaTypes = preferredMediaTypes;
    var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
    function parseAccept(accept) {
      var accepts = splitMediaTypes(accept);
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var mediaType = parseMediaType(accepts[i].trim(), i);
        if (mediaType) {
          accepts[j++] = mediaType;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseMediaType(str, i) {
      var match = simpleMediaTypeRegExp.exec(str);
      if (!match)
        return null;
      var params = Object.create(null);
      var q = 1;
      var subtype = match[2];
      var type = match[1];
      if (match[3]) {
        var kvps = splitParameters(match[3]).map(splitKeyValuePair);
        for (var j = 0; j < kvps.length; j++) {
          var pair = kvps[j];
          var key = pair[0].toLowerCase();
          var val = pair[1];
          var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
          if (key === "q") {
            q = parseFloat(value);
            break;
          }
          params[key] = value;
        }
      }
      return {
        type,
        subtype,
        params,
        q,
        i
      };
    }
    function getMediaTypePriority(type, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(type, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(type, spec, index) {
      var p = parseMediaType(type);
      var s = 0;
      if (!p) {
        return null;
      }
      if (spec.type.toLowerCase() == p.type.toLowerCase()) {
        s |= 4;
      } else if (spec.type != "*") {
        return null;
      }
      if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
        s |= 2;
      } else if (spec.subtype != "*") {
        return null;
      }
      var keys = Object.keys(spec.params);
      if (keys.length > 0) {
        if (keys.every(function(k) {
          return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
        })) {
          s |= 1;
        } else {
          return null;
        }
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredMediaTypes(accept, provided) {
      var accepts = parseAccept(accept === void 0 ? "*/*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getMediaTypePriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullType(spec) {
      return spec.type + "/" + spec.subtype;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
    function quoteCount(string) {
      var count = 0;
      var index = 0;
      while ((index = string.indexOf('"', index)) !== -1) {
        count++;
        index++;
      }
      return count;
    }
    function splitKeyValuePair(str) {
      var index = str.indexOf("=");
      var key;
      var val;
      if (index === -1) {
        key = str;
      } else {
        key = str.substr(0, index);
        val = str.substr(index + 1);
      }
      return [key, val];
    }
    function splitMediaTypes(accept) {
      var accepts = accept.split(",");
      for (var i = 1, j = 0; i < accepts.length; i++) {
        if (quoteCount(accepts[j]) % 2 == 0) {
          accepts[++j] = accepts[i];
        } else {
          accepts[j] += "," + accepts[i];
        }
      }
      accepts.length = j + 1;
      return accepts;
    }
    function splitParameters(str) {
      var parameters = str.split(";");
      for (var i = 1, j = 0; i < parameters.length; i++) {
        if (quoteCount(parameters[j]) % 2 == 0) {
          parameters[++j] = parameters[i];
        } else {
          parameters[j] += ";" + parameters[i];
        }
      }
      parameters.length = j + 1;
      for (var i = 0; i < parameters.length; i++) {
        parameters[i] = parameters[i].trim();
      }
      return parameters;
    }
  }
});

// node_modules/negotiator/index.js
var require_negotiator = __commonJS({
  "node_modules/negotiator/index.js"(exports2, module2) {
    "use strict";
    var modules = Object.create(null);
    module2.exports = Negotiator;
    module2.exports.Negotiator = Negotiator;
    function Negotiator(request) {
      if (!(this instanceof Negotiator)) {
        return new Negotiator(request);
      }
      this.request = request;
    }
    Negotiator.prototype.charset = function charset(available) {
      var set = this.charsets(available);
      return set && set[0];
    };
    Negotiator.prototype.charsets = function charsets(available) {
      var preferredCharsets = loadModule("charset").preferredCharsets;
      return preferredCharsets(this.request.headers["accept-charset"], available);
    };
    Negotiator.prototype.encoding = function encoding(available) {
      var set = this.encodings(available);
      return set && set[0];
    };
    Negotiator.prototype.encodings = function encodings(available) {
      var preferredEncodings = loadModule("encoding").preferredEncodings;
      return preferredEncodings(this.request.headers["accept-encoding"], available);
    };
    Negotiator.prototype.language = function language(available) {
      var set = this.languages(available);
      return set && set[0];
    };
    Negotiator.prototype.languages = function languages(available) {
      var preferredLanguages = loadModule("language").preferredLanguages;
      return preferredLanguages(this.request.headers["accept-language"], available);
    };
    Negotiator.prototype.mediaType = function mediaType(available) {
      var set = this.mediaTypes(available);
      return set && set[0];
    };
    Negotiator.prototype.mediaTypes = function mediaTypes(available) {
      var preferredMediaTypes = loadModule("mediaType").preferredMediaTypes;
      return preferredMediaTypes(this.request.headers.accept, available);
    };
    Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
    Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
    Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
    Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
    Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
    Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
    Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
    Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
    function loadModule(moduleName) {
      var module3 = modules[moduleName];
      if (module3 !== void 0) {
        return module3;
      }
      switch (moduleName) {
        case "charset":
          module3 = require_charset();
          break;
        case "encoding":
          module3 = require_encoding();
          break;
        case "language":
          module3 = require_language();
          break;
        case "mediaType":
          module3 = require_mediaType();
          break;
        default:
          throw new Error("Cannot find module '" + moduleName + "'");
      }
      modules[moduleName] = module3;
      return module3;
    }
  }
});

// node_modules/accepts/index.js
var require_accepts = __commonJS({
  "node_modules/accepts/index.js"(exports2, module2) {
    "use strict";
    var Negotiator = require_negotiator();
    var mime = require_mime_types();
    module2.exports = Accepts;
    function Accepts(req) {
      if (!(this instanceof Accepts)) {
        return new Accepts(req);
      }
      this.headers = req.headers;
      this.negotiator = new Negotiator(req);
    }
    Accepts.prototype.type = Accepts.prototype.types = function(types_) {
      var types = types_;
      if (types && !Array.isArray(types)) {
        types = new Array(arguments.length);
        for (var i = 0; i < types.length; i++) {
          types[i] = arguments[i];
        }
      }
      if (!types || types.length === 0) {
        return this.negotiator.mediaTypes();
      }
      if (!this.headers.accept) {
        return types[0];
      }
      var mimes = types.map(extToMime);
      var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
      var first = accepts[0];
      return first ? types[mimes.indexOf(first)] : false;
    };
    Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
      var encodings = encodings_;
      if (encodings && !Array.isArray(encodings)) {
        encodings = new Array(arguments.length);
        for (var i = 0; i < encodings.length; i++) {
          encodings[i] = arguments[i];
        }
      }
      if (!encodings || encodings.length === 0) {
        return this.negotiator.encodings();
      }
      return this.negotiator.encodings(encodings)[0] || false;
    };
    Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
      var charsets = charsets_;
      if (charsets && !Array.isArray(charsets)) {
        charsets = new Array(arguments.length);
        for (var i = 0; i < charsets.length; i++) {
          charsets[i] = arguments[i];
        }
      }
      if (!charsets || charsets.length === 0) {
        return this.negotiator.charsets();
      }
      return this.negotiator.charsets(charsets)[0] || false;
    };
    Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
      var languages = languages_;
      if (languages && !Array.isArray(languages)) {
        languages = new Array(arguments.length);
        for (var i = 0; i < languages.length; i++) {
          languages[i] = arguments[i];
        }
      }
      if (!languages || languages.length === 0) {
        return this.negotiator.languages();
      }
      return this.negotiator.languages(languages)[0] || false;
    };
    function extToMime(type) {
      return type.indexOf("/") === -1 ? mime.lookup(type) : type;
    }
    function validMime(type) {
      return typeof type === "string";
    }
  }
});

// node_modules/express/lib/request.js
var require_request = __commonJS({
  "node_modules/express/lib/request.js"(exports2, module2) {
    "use strict";
    var accepts = require_accepts();
    var deprecate = require_depd()("express");
    var isIP = require("net").isIP;
    var typeis = require_type_is();
    var http = require("http");
    var fresh = require_fresh();
    var parseRange = require_range_parser();
    var parse = require_parseurl();
    var proxyaddr = require_proxy_addr();
    var req = Object.create(http.IncomingMessage.prototype);
    module2.exports = req;
    req.get = req.header = function header(name) {
      if (!name) {
        throw new TypeError("name argument is required to req.get");
      }
      if (typeof name !== "string") {
        throw new TypeError("name must be a string to req.get");
      }
      var lc = name.toLowerCase();
      switch (lc) {
        case "referer":
        case "referrer":
          return this.headers.referrer || this.headers.referer;
        default:
          return this.headers[lc];
      }
    };
    req.accepts = function() {
      var accept = accepts(this);
      return accept.types.apply(accept, arguments);
    };
    req.acceptsEncodings = function() {
      var accept = accepts(this);
      return accept.encodings.apply(accept, arguments);
    };
    req.acceptsEncoding = deprecate.function(req.acceptsEncodings, "req.acceptsEncoding: Use acceptsEncodings instead");
    req.acceptsCharsets = function() {
      var accept = accepts(this);
      return accept.charsets.apply(accept, arguments);
    };
    req.acceptsCharset = deprecate.function(req.acceptsCharsets, "req.acceptsCharset: Use acceptsCharsets instead");
    req.acceptsLanguages = function() {
      var accept = accepts(this);
      return accept.languages.apply(accept, arguments);
    };
    req.acceptsLanguage = deprecate.function(req.acceptsLanguages, "req.acceptsLanguage: Use acceptsLanguages instead");
    req.range = function range(size, options) {
      var range2 = this.get("Range");
      if (!range2)
        return;
      return parseRange(size, range2, options);
    };
    req.param = function param(name, defaultValue) {
      var params = this.params || {};
      var body = this.body || {};
      var query = this.query || {};
      var args = arguments.length === 1 ? "name" : "name, default";
      deprecate("req.param(" + args + "): Use req.params, req.body, or req.query instead");
      if (params[name] != null && params.hasOwnProperty(name))
        return params[name];
      if (body[name] != null)
        return body[name];
      if (query[name] != null)
        return query[name];
      return defaultValue;
    };
    req.is = function is(types) {
      var arr = types;
      if (!Array.isArray(types)) {
        arr = new Array(arguments.length);
        for (var i = 0; i < arr.length; i++) {
          arr[i] = arguments[i];
        }
      }
      return typeis(this, arr);
    };
    defineGetter(req, "protocol", function protocol() {
      var proto = this.connection.encrypted ? "https" : "http";
      var trust = this.app.get("trust proxy fn");
      if (!trust(this.connection.remoteAddress, 0)) {
        return proto;
      }
      var header = this.get("X-Forwarded-Proto") || proto;
      var index = header.indexOf(",");
      return index !== -1 ? header.substring(0, index).trim() : header.trim();
    });
    defineGetter(req, "secure", function secure() {
      return this.protocol === "https";
    });
    defineGetter(req, "ip", function ip() {
      var trust = this.app.get("trust proxy fn");
      return proxyaddr(this, trust);
    });
    defineGetter(req, "ips", function ips() {
      var trust = this.app.get("trust proxy fn");
      var addrs = proxyaddr.all(this, trust);
      addrs.reverse().pop();
      return addrs;
    });
    defineGetter(req, "subdomains", function subdomains() {
      var hostname = this.hostname;
      if (!hostname)
        return [];
      var offset = this.app.get("subdomain offset");
      var subdomains2 = !isIP(hostname) ? hostname.split(".").reverse() : [hostname];
      return subdomains2.slice(offset);
    });
    defineGetter(req, "path", function path() {
      return parse(this).pathname;
    });
    defineGetter(req, "hostname", function hostname() {
      var trust = this.app.get("trust proxy fn");
      var host = this.get("X-Forwarded-Host");
      if (!host || !trust(this.connection.remoteAddress, 0)) {
        host = this.get("Host");
      } else if (host.indexOf(",") !== -1) {
        host = host.substring(0, host.indexOf(",")).trimRight();
      }
      if (!host)
        return;
      var offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
      var index = host.indexOf(":", offset);
      return index !== -1 ? host.substring(0, index) : host;
    });
    defineGetter(req, "host", deprecate.function(function host() {
      return this.hostname;
    }, "req.host: Use req.hostname instead"));
    defineGetter(req, "fresh", function() {
      var method = this.method;
      var res = this.res;
      var status = res.statusCode;
      if (method !== "GET" && method !== "HEAD")
        return false;
      if (status >= 200 && status < 300 || status === 304) {
        return fresh(this.headers, {
          "etag": res.get("ETag"),
          "last-modified": res.get("Last-Modified")
        });
      }
      return false;
    });
    defineGetter(req, "stale", function stale() {
      return !this.fresh;
    });
    defineGetter(req, "xhr", function xhr() {
      var val = this.get("X-Requested-With") || "";
      return val.toLowerCase() === "xmlhttprequest";
    });
    function defineGetter(obj, name, getter) {
      Object.defineProperty(obj, name, {
        configurable: true,
        enumerable: true,
        get: getter
      });
    }
  }
});

// node_modules/cookie-signature/index.js
var require_cookie_signature = __commonJS({
  "node_modules/cookie-signature/index.js"(exports2) {
    var crypto = require("crypto");
    exports2.sign = function(val, secret) {
      if (typeof val != "string")
        throw new TypeError("Cookie value must be provided as a string.");
      if (typeof secret != "string")
        throw new TypeError("Secret string must be provided.");
      return val + "." + crypto.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
    };
    exports2.unsign = function(val, secret) {
      if (typeof val != "string")
        throw new TypeError("Signed cookie string must be provided.");
      if (typeof secret != "string")
        throw new TypeError("Secret string must be provided.");
      var str = val.slice(0, val.lastIndexOf(".")), mac = exports2.sign(str, secret);
      return sha1(mac) == sha1(val) ? str : false;
    };
    function sha1(str) {
      return crypto.createHash("sha1").update(str).digest("hex");
    }
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports2) {
    "use strict";
    exports2.parse = parse;
    exports2.serialize = serialize;
    var decode = decodeURIComponent;
    var encode = encodeURIComponent;
    var pairSplitRegExp = /; */;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var pairs = str.split(pairSplitRegExp);
      var dec = opt.decode || decode;
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        var eq_idx = pair.indexOf("=");
        if (eq_idx < 0) {
          continue;
        }
        var key = pair.substr(0, eq_idx).trim();
        var val = pair.substr(++eq_idx, pair.length).trim();
        if (val[0] == '"') {
          val = val.slice(1, -1);
        }
        if (obj[key] == void 0) {
          obj[key] = tryDecode(val, dec);
        }
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (opt.maxAge != null) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge))
          throw new Error("maxAge should be a Number");
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// node_modules/vary/index.js
var require_vary = __commonJS({
  "node_modules/vary/index.js"(exports2, module2) {
    "use strict";
    module2.exports = vary;
    module2.exports.append = append;
    var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
    function append(header, field) {
      if (typeof header !== "string") {
        throw new TypeError("header argument is required");
      }
      if (!field) {
        throw new TypeError("field argument is required");
      }
      var fields = !Array.isArray(field) ? parse(String(field)) : field;
      for (var j = 0; j < fields.length; j++) {
        if (!FIELD_NAME_REGEXP.test(fields[j])) {
          throw new TypeError("field argument contains an invalid header name");
        }
      }
      if (header === "*") {
        return header;
      }
      var val = header;
      var vals = parse(header.toLowerCase());
      if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
        return "*";
      }
      for (var i = 0; i < fields.length; i++) {
        var fld = fields[i].toLowerCase();
        if (vals.indexOf(fld) === -1) {
          vals.push(fld);
          val = val ? val + ", " + fields[i] : fields[i];
        }
      }
      return val;
    }
    function parse(header) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i = 0, len = header.length; i < len; i++) {
        switch (header.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            list.push(header.substring(start, end));
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      list.push(header.substring(start, end));
      return list;
    }
    function vary(res, field) {
      if (!res || !res.getHeader || !res.setHeader) {
        throw new TypeError("res argument is required");
      }
      var val = res.getHeader("Vary") || "";
      var header = Array.isArray(val) ? val.join(", ") : String(val);
      if (val = append(header, field)) {
        res.setHeader("Vary", val);
      }
    }
  }
});

// node_modules/express/lib/response.js
var require_response = __commonJS({
  "node_modules/express/lib/response.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var contentDisposition = require_content_disposition();
    var deprecate = require_depd()("express");
    var encodeUrl = require_encodeurl();
    var escapeHtml = require_escape_html();
    var http = require("http");
    var isAbsolute = require_utils2().isAbsolute;
    var onFinished = require_on_finished();
    var path = require("path");
    var statuses = require_statuses();
    var merge = require_utils_merge();
    var sign = require_cookie_signature().sign;
    var normalizeType = require_utils2().normalizeType;
    var normalizeTypes = require_utils2().normalizeTypes;
    var setCharset = require_utils2().setCharset;
    var cookie = require_cookie();
    var send = require_send();
    var extname = path.extname;
    var mime = send.mime;
    var resolve = path.resolve;
    var vary = require_vary();
    var res = Object.create(http.ServerResponse.prototype);
    module2.exports = res;
    var charsetRegExp = /;\s*charset\s*=/;
    res.status = function status(code) {
      this.statusCode = code;
      return this;
    };
    res.links = function(links) {
      var link = this.get("Link") || "";
      if (link)
        link += ", ";
      return this.set("Link", link + Object.keys(links).map(function(rel) {
        return "<" + links[rel] + '>; rel="' + rel + '"';
      }).join(", "));
    };
    res.send = function send2(body) {
      var chunk = body;
      var encoding;
      var req = this.req;
      var type;
      var app = this.app;
      if (arguments.length === 2) {
        if (typeof arguments[0] !== "number" && typeof arguments[1] === "number") {
          deprecate("res.send(body, status): Use res.status(status).send(body) instead");
          this.statusCode = arguments[1];
        } else {
          deprecate("res.send(status, body): Use res.status(status).send(body) instead");
          this.statusCode = arguments[0];
          chunk = arguments[1];
        }
      }
      if (typeof chunk === "number" && arguments.length === 1) {
        if (!this.get("Content-Type")) {
          this.type("txt");
        }
        deprecate("res.send(status): Use res.sendStatus(status) instead");
        this.statusCode = chunk;
        chunk = statuses[chunk];
      }
      switch (typeof chunk) {
        case "string":
          if (!this.get("Content-Type")) {
            this.type("html");
          }
          break;
        case "boolean":
        case "number":
        case "object":
          if (chunk === null) {
            chunk = "";
          } else if (Buffer2.isBuffer(chunk)) {
            if (!this.get("Content-Type")) {
              this.type("bin");
            }
          } else {
            return this.json(chunk);
          }
          break;
      }
      if (typeof chunk === "string") {
        encoding = "utf8";
        type = this.get("Content-Type");
        if (typeof type === "string") {
          this.set("Content-Type", setCharset(type, "utf-8"));
        }
      }
      var etagFn = app.get("etag fn");
      var generateETag = !this.get("ETag") && typeof etagFn === "function";
      var len;
      if (chunk !== void 0) {
        if (Buffer2.isBuffer(chunk)) {
          len = chunk.length;
        } else if (!generateETag && chunk.length < 1e3) {
          len = Buffer2.byteLength(chunk, encoding);
        } else {
          chunk = Buffer2.from(chunk, encoding);
          encoding = void 0;
          len = chunk.length;
        }
        this.set("Content-Length", len);
      }
      var etag;
      if (generateETag && len !== void 0) {
        if (etag = etagFn(chunk, encoding)) {
          this.set("ETag", etag);
        }
      }
      if (req.fresh)
        this.statusCode = 304;
      if (this.statusCode === 204 || this.statusCode === 304) {
        this.removeHeader("Content-Type");
        this.removeHeader("Content-Length");
        this.removeHeader("Transfer-Encoding");
        chunk = "";
      }
      if (req.method === "HEAD") {
        this.end();
      } else {
        this.end(chunk, encoding);
      }
      return this;
    };
    res.json = function json(obj) {
      var val = obj;
      if (arguments.length === 2) {
        if (typeof arguments[1] === "number") {
          deprecate("res.json(obj, status): Use res.status(status).json(obj) instead");
          this.statusCode = arguments[1];
        } else {
          deprecate("res.json(status, obj): Use res.status(status).json(obj) instead");
          this.statusCode = arguments[0];
          val = arguments[1];
        }
      }
      var app = this.app;
      var escape2 = app.get("json escape");
      var replacer = app.get("json replacer");
      var spaces = app.get("json spaces");
      var body = stringify(val, replacer, spaces, escape2);
      if (!this.get("Content-Type")) {
        this.set("Content-Type", "application/json");
      }
      return this.send(body);
    };
    res.jsonp = function jsonp(obj) {
      var val = obj;
      if (arguments.length === 2) {
        if (typeof arguments[1] === "number") {
          deprecate("res.jsonp(obj, status): Use res.status(status).json(obj) instead");
          this.statusCode = arguments[1];
        } else {
          deprecate("res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead");
          this.statusCode = arguments[0];
          val = arguments[1];
        }
      }
      var app = this.app;
      var escape2 = app.get("json escape");
      var replacer = app.get("json replacer");
      var spaces = app.get("json spaces");
      var body = stringify(val, replacer, spaces, escape2);
      var callback = this.req.query[app.get("jsonp callback name")];
      if (!this.get("Content-Type")) {
        this.set("X-Content-Type-Options", "nosniff");
        this.set("Content-Type", "application/json");
      }
      if (Array.isArray(callback)) {
        callback = callback[0];
      }
      if (typeof callback === "string" && callback.length !== 0) {
        this.set("X-Content-Type-Options", "nosniff");
        this.set("Content-Type", "text/javascript");
        callback = callback.replace(/[^\[\]\w$.]/g, "");
        body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
        body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
      }
      return this.send(body);
    };
    res.sendStatus = function sendStatus(statusCode) {
      var body = statuses[statusCode] || String(statusCode);
      this.statusCode = statusCode;
      this.type("txt");
      return this.send(body);
    };
    res.sendFile = function sendFile(path2, options, callback) {
      var done = callback;
      var req = this.req;
      var res2 = this;
      var next = req.next;
      var opts = options || {};
      if (!path2) {
        throw new TypeError("path argument is required to res.sendFile");
      }
      if (typeof path2 !== "string") {
        throw new TypeError("path must be a string to res.sendFile");
      }
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      if (!opts.root && !isAbsolute(path2)) {
        throw new TypeError("path must be absolute or specify root to res.sendFile");
      }
      var pathname = encodeURI(path2);
      var file = send(req, pathname, opts);
      sendfile(res2, file, opts, function(err) {
        if (done)
          return done(err);
        if (err && err.code === "EISDIR")
          return next();
        if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
          next(err);
        }
      });
    };
    res.sendfile = function(path2, options, callback) {
      var done = callback;
      var req = this.req;
      var res2 = this;
      var next = req.next;
      var opts = options || {};
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      var file = send(req, path2, opts);
      sendfile(res2, file, opts, function(err) {
        if (done)
          return done(err);
        if (err && err.code === "EISDIR")
          return next();
        if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
          next(err);
        }
      });
    };
    res.sendfile = deprecate.function(res.sendfile, "res.sendfile: Use res.sendFile instead");
    res.download = function download(path2, filename, options, callback) {
      var done = callback;
      var name = filename;
      var opts = options || null;
      if (typeof filename === "function") {
        done = filename;
        name = null;
        opts = null;
      } else if (typeof options === "function") {
        done = options;
        opts = null;
      }
      var headers = {
        "Content-Disposition": contentDisposition(name || path2)
      };
      if (opts && opts.headers) {
        var keys = Object.keys(opts.headers);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (key.toLowerCase() !== "content-disposition") {
            headers[key] = opts.headers[key];
          }
        }
      }
      opts = Object.create(opts);
      opts.headers = headers;
      var fullPath = resolve(path2);
      return this.sendFile(fullPath, opts, done);
    };
    res.contentType = res.type = function contentType(type) {
      var ct = type.indexOf("/") === -1 ? mime.lookup(type) : type;
      return this.set("Content-Type", ct);
    };
    res.format = function(obj) {
      var req = this.req;
      var next = req.next;
      var fn = obj.default;
      if (fn)
        delete obj.default;
      var keys = Object.keys(obj);
      var key = keys.length > 0 ? req.accepts(keys) : false;
      this.vary("Accept");
      if (key) {
        this.set("Content-Type", normalizeType(key).value);
        obj[key](req, this, next);
      } else if (fn) {
        fn();
      } else {
        var err = new Error("Not Acceptable");
        err.status = err.statusCode = 406;
        err.types = normalizeTypes(keys).map(function(o) {
          return o.value;
        });
        next(err);
      }
      return this;
    };
    res.attachment = function attachment(filename) {
      if (filename) {
        this.type(extname(filename));
      }
      this.set("Content-Disposition", contentDisposition(filename));
      return this;
    };
    res.append = function append(field, val) {
      var prev = this.get(field);
      var value = val;
      if (prev) {
        value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
      }
      return this.set(field, value);
    };
    res.set = res.header = function header(field, val) {
      if (arguments.length === 2) {
        var value = Array.isArray(val) ? val.map(String) : String(val);
        if (field.toLowerCase() === "content-type") {
          if (Array.isArray(value)) {
            throw new TypeError("Content-Type cannot be set to an Array");
          }
          if (!charsetRegExp.test(value)) {
            var charset = mime.charsets.lookup(value.split(";")[0]);
            if (charset)
              value += "; charset=" + charset.toLowerCase();
          }
        }
        this.setHeader(field, value);
      } else {
        for (var key in field) {
          this.set(key, field[key]);
        }
      }
      return this;
    };
    res.get = function(field) {
      return this.getHeader(field);
    };
    res.clearCookie = function clearCookie(name, options) {
      var opts = merge({ expires: new Date(1), path: "/" }, options);
      return this.cookie(name, "", opts);
    };
    res.cookie = function(name, value, options) {
      var opts = merge({}, options);
      var secret = this.req.secret;
      var signed = opts.signed;
      if (signed && !secret) {
        throw new Error('cookieParser("secret") required for signed cookies');
      }
      var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
      if (signed) {
        val = "s:" + sign(val, secret);
      }
      if ("maxAge" in opts) {
        opts.expires = new Date(Date.now() + opts.maxAge);
        opts.maxAge /= 1e3;
      }
      if (opts.path == null) {
        opts.path = "/";
      }
      this.append("Set-Cookie", cookie.serialize(name, String(val), opts));
      return this;
    };
    res.location = function location(url) {
      var loc = url;
      if (url === "back") {
        loc = this.req.get("Referrer") || "/";
      }
      return this.set("Location", encodeUrl(loc));
    };
    res.redirect = function redirect(url) {
      var address = url;
      var body;
      var status = 302;
      if (arguments.length === 2) {
        if (typeof arguments[0] === "number") {
          status = arguments[0];
          address = arguments[1];
        } else {
          deprecate("res.redirect(url, status): Use res.redirect(status, url) instead");
          status = arguments[1];
        }
      }
      address = this.location(address).get("Location");
      this.format({
        text: function() {
          body = statuses[status] + ". Redirecting to " + address;
        },
        html: function() {
          var u = escapeHtml(address);
          body = "<p>" + statuses[status] + '. Redirecting to <a href="' + u + '">' + u + "</a></p>";
        },
        default: function() {
          body = "";
        }
      });
      this.statusCode = status;
      this.set("Content-Length", Buffer2.byteLength(body));
      if (this.req.method === "HEAD") {
        this.end();
      } else {
        this.end(body);
      }
    };
    res.vary = function(field) {
      if (!field || Array.isArray(field) && !field.length) {
        deprecate("res.vary(): Provide a field name");
        return this;
      }
      vary(this, field);
      return this;
    };
    res.render = function render(view, options, callback) {
      var app = this.req.app;
      var done = callback;
      var opts = options || {};
      var req = this.req;
      var self2 = this;
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      opts._locals = self2.locals;
      done = done || function(err, str) {
        if (err)
          return req.next(err);
        self2.send(str);
      };
      app.render(view, opts, done);
    };
    function sendfile(res2, file, options, callback) {
      var done = false;
      var streaming;
      function onaborted() {
        if (done)
          return;
        done = true;
        var err = new Error("Request aborted");
        err.code = "ECONNABORTED";
        callback(err);
      }
      function ondirectory() {
        if (done)
          return;
        done = true;
        var err = new Error("EISDIR, read");
        err.code = "EISDIR";
        callback(err);
      }
      function onerror(err) {
        if (done)
          return;
        done = true;
        callback(err);
      }
      function onend() {
        if (done)
          return;
        done = true;
        callback();
      }
      function onfile() {
        streaming = false;
      }
      function onfinish(err) {
        if (err && err.code === "ECONNRESET")
          return onaborted();
        if (err)
          return onerror(err);
        if (done)
          return;
        setImmediate(function() {
          if (streaming !== false && !done) {
            onaborted();
            return;
          }
          if (done)
            return;
          done = true;
          callback();
        });
      }
      function onstream() {
        streaming = true;
      }
      file.on("directory", ondirectory);
      file.on("end", onend);
      file.on("error", onerror);
      file.on("file", onfile);
      file.on("stream", onstream);
      onFinished(res2, onfinish);
      if (options.headers) {
        file.on("headers", function headers(res3) {
          var obj = options.headers;
          var keys = Object.keys(obj);
          for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            res3.setHeader(k, obj[k]);
          }
        });
      }
      file.pipe(res2);
    }
    function stringify(value, replacer, spaces, escape2) {
      var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
      if (escape2) {
        json = json.replace(/[<>&]/g, function(c) {
          switch (c.charCodeAt(0)) {
            case 60:
              return "\\u003c";
            case 62:
              return "\\u003e";
            case 38:
              return "\\u0026";
            default:
              return c;
          }
        });
      }
      return json;
    }
  }
});

// node_modules/serve-static/index.js
var require_serve_static = __commonJS({
  "node_modules/serve-static/index.js"(exports2, module2) {
    "use strict";
    var encodeUrl = require_encodeurl();
    var escapeHtml = require_escape_html();
    var parseUrl = require_parseurl();
    var resolve = require("path").resolve;
    var send = require_send();
    var url = require("url");
    module2.exports = serveStatic;
    module2.exports.mime = send.mime;
    function serveStatic(root, options) {
      if (!root) {
        throw new TypeError("root path required");
      }
      if (typeof root !== "string") {
        throw new TypeError("root path must be a string");
      }
      var opts = Object.create(options || null);
      var fallthrough = opts.fallthrough !== false;
      var redirect = opts.redirect !== false;
      var setHeaders = opts.setHeaders;
      if (setHeaders && typeof setHeaders !== "function") {
        throw new TypeError("option setHeaders must be function");
      }
      opts.maxage = opts.maxage || opts.maxAge || 0;
      opts.root = resolve(root);
      var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
      return function serveStatic2(req, res, next) {
        if (req.method !== "GET" && req.method !== "HEAD") {
          if (fallthrough) {
            return next();
          }
          res.statusCode = 405;
          res.setHeader("Allow", "GET, HEAD");
          res.setHeader("Content-Length", "0");
          res.end();
          return;
        }
        var forwardError = !fallthrough;
        var originalUrl = parseUrl.original(req);
        var path = parseUrl(req).pathname;
        if (path === "/" && originalUrl.pathname.substr(-1) !== "/") {
          path = "";
        }
        var stream = send(req, path, opts);
        stream.on("directory", onDirectory);
        if (setHeaders) {
          stream.on("headers", setHeaders);
        }
        if (fallthrough) {
          stream.on("file", function onFile() {
            forwardError = true;
          });
        }
        stream.on("error", function error(err) {
          if (forwardError || !(err.statusCode < 500)) {
            next(err);
            return;
          }
          next();
        });
        stream.pipe(res);
      };
    }
    function collapseLeadingSlashes(str) {
      for (var i = 0; i < str.length; i++) {
        if (str.charCodeAt(i) !== 47) {
          break;
        }
      }
      return i > 1 ? "/" + str.substr(i) : str;
    }
    function createHtmlDocument(title, body) {
      return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
    }
    function createNotFoundDirectoryListener() {
      return function notFound() {
        this.error(404);
      };
    }
    function createRedirectDirectoryListener() {
      return function redirect(res) {
        if (this.hasTrailingSlash()) {
          this.error(404);
          return;
        }
        var originalUrl = parseUrl.original(this.req);
        originalUrl.path = null;
        originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + "/");
        var loc = encodeUrl(url.format(originalUrl));
        var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + "</a>");
        res.statusCode = 301;
        res.setHeader("Content-Type", "text/html; charset=UTF-8");
        res.setHeader("Content-Length", Buffer.byteLength(doc));
        res.setHeader("Content-Security-Policy", "default-src 'none'");
        res.setHeader("X-Content-Type-Options", "nosniff");
        res.setHeader("Location", loc);
        res.end(doc);
      };
    }
  }
});

// node_modules/express/lib/express.js
var require_express = __commonJS({
  "node_modules/express/lib/express.js"(exports2, module2) {
    "use strict";
    var bodyParser = require_body_parser();
    var EventEmitter = require("events").EventEmitter;
    var mixin = require_merge_descriptors();
    var proto = require_application();
    var Route = require_route();
    var Router2 = require_router();
    var req = require_request();
    var res = require_response();
    exports2 = module2.exports = createApplication;
    function createApplication() {
      var app = function(req2, res2, next) {
        app.handle(req2, res2, next);
      };
      mixin(app, EventEmitter.prototype, false);
      mixin(app, proto, false);
      app.request = Object.create(req, {
        app: { configurable: true, enumerable: true, writable: true, value: app }
      });
      app.response = Object.create(res, {
        app: { configurable: true, enumerable: true, writable: true, value: app }
      });
      app.init();
      return app;
    }
    exports2.application = proto;
    exports2.request = req;
    exports2.response = res;
    exports2.Route = Route;
    exports2.Router = Router2;
    exports2.json = bodyParser.json;
    exports2.query = require_query();
    exports2.raw = bodyParser.raw;
    exports2.static = require_serve_static();
    exports2.text = bodyParser.text;
    exports2.urlencoded = bodyParser.urlencoded;
    var removedMiddlewares = [
      "bodyParser",
      "compress",
      "cookieSession",
      "session",
      "logger",
      "cookieParser",
      "favicon",
      "responseTime",
      "errorHandler",
      "timeout",
      "methodOverride",
      "vhost",
      "csrf",
      "directory",
      "limit",
      "multipart",
      "staticCache"
    ];
    removedMiddlewares.forEach(function(name) {
      Object.defineProperty(exports2, name, {
        get: function() {
          throw new Error("Most middleware (like " + name + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
        },
        configurable: true
      });
    });
  }
});

// node_modules/express/index.js
var require_express2 = __commonJS({
  "node_modules/express/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_express();
  }
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/jws/lib/data-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream = require("stream");
    var util = require("util");
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util.inherits(DataStream, Stream);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module2.exports = DataStream;
  }
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "node_modules/buffer-equal-constant-time/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    var SlowBuffer = require("buffer").SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports2, module2) {
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module2.exports = getParamBytesForAlg;
  }
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if (typeof signature === "string") {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});

// node_modules/jwa/index.js
var require_jwa = __commonJS({
  "node_modules/jwa/index.js"(exports2, module2) {
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto = require("crypto");
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require("util");
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module2.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/jws/lib/tostring.js"(exports2, module2) {
    var Buffer2 = require("buffer").Buffer;
    module2.exports = function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "node_modules/jws/lib/sign-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util = require("util");
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util.inherits(SignStream, Stream);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "node_modules/jws/lib/verify-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util = require("util");
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject2(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject2(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});

// node_modules/jws/index.js
var require_jws = __commonJS({
  "node_modules/jws/index.js"(exports2) {
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports2.ALGORITHMS = ALGORITHMS;
    exports2.sign = SignStream.sign;
    exports2.verify = VerifyStream.verify;
    exports2.decode = VerifyStream.decode;
    exports2.isValid = VerifyStream.isValid;
    exports2.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports2.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "node_modules/jsonwebtoken/decode.js"(exports2, module2) {
    var jws = require_jws();
    module2.exports = function(jwt3, options) {
      options = options || {};
      var decoded = jws.decode(jwt3, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports2, module2) {
    var JsonWebTokenError = function(message, error) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error)
        this.inner = error;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module2.exports = JsonWebTokenError;
  }
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module2.exports = NotBeforeError;
  }
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module2.exports = TokenExpiredError;
  }
});

// node_modules/ms/index.js
var require_ms6 = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "node_modules/jsonwebtoken/lib/timespan.js"(exports2, module2) {
    var ms = require_ms6();
    module2.exports = function(time, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time === "string") {
        var milliseconds = ms(time);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time === "number") {
        return timestamp + time;
      } else {
        return;
      }
    };
  }
});

// node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (var i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    exports2.parse = parse;
    function parse(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret2;
        if (isX(M)) {
          ret2 = "";
        } else if (isX(m)) {
          ret2 = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret2 = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret2 = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret2);
        return ret2;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret2;
        if (isX(M)) {
          ret2 = "";
        } else if (isX(m)) {
          ret2 = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret2 = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret2 = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret2 = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret2 = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret2 = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret2);
        return ret2;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret2, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret2, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret2 = "<0.0.0";
          } else {
            ret2 = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret2 = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret2 = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret2 = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret2);
        return ret2;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      var match = version.match(re[COERCE]);
      if (match == null) {
        return null;
      }
      return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/psSupported.js"(exports2, module2) {
    var semver = require_semver();
    module2.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "node_modules/jsonwebtoken/verify.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    module2.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      var done;
      if (callback) {
        done = callback;
      } else {
        done = function(err, data) {
          if (err)
            throw err;
          return data;
        };
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      var parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      var decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      var header = decodedToken.header;
      var getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        var hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          options.algorithms = ["none"];
        }
        if (!options.algorithms) {
          options.algorithms = ~secretOrPublicKey2.toString().indexOf("BEGIN CERTIFICATE") || ~secretOrPublicKey2.toString().indexOf("BEGIN PUBLIC KEY") ? PUB_KEY_ALGS : ~secretOrPublicKey2.toString().indexOf("BEGIN RSA PUBLIC KEY") ? RSA_KEY_ALGS : HS_ALGS;
        }
        if (!~options.algorithms.indexOf(decodedToken.header.alg)) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        var valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        var payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          var match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          var invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          var maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          var signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.includes/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    module2.exports = includes;
  }
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isboolean/index.js"(exports2, module2) {
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isBoolean;
  }
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isinteger/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = isInteger;
  }
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.isnumber/index.js"(exports2, module2) {
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isNumber(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    module2.exports = isNumber;
  }
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports2, module2) {
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS({
  "node_modules/lodash.isstring/index.js"(exports2, module2) {
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS({
  "node_modules/lodash.once/index.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once(func) {
      return before(2, func);
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = once;
  }
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS({
  "node_modules/jsonwebtoken/sign.js"(exports2, module2) {
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var includes = require_lodash();
    var isBoolean = require_lodash2();
    var isInteger = require_lodash3();
    var isNumber = require_lodash4();
    var isPlainObject = require_lodash5();
    var isString = require_lodash6();
    var once = require_lodash7();
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: function(value) {
        return isString(value) || Array.isArray(value);
      }, message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject, message: '"header" must be an object' },
      encoding: { isValid: isString, message: '"encoding" must be a string' },
      issuer: { isValid: isString, message: '"issuer" must be a string' },
      subject: { isValid: isString, message: '"subject" must be a string' },
      jwtid: { isValid: isString, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
    };
    function validate(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key) {
        var validator = schema[key];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key])) {
          throw new Error(validator.message);
        }
      });
    }
    function validateOptions(options) {
      return validate(sign_options_schema, false, options, "options");
    }
    function validatePayload(payload) {
      return validate(registered_claims_schema, true, payload, "payload");
    }
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module2.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      var isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      var header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error) {
          return failure(error);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        var invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error) {
        return failure(error);
      }
      var timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        var claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key];
        }
      });
      var encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          callback(null, signature);
        });
      } else {
        return jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
      }
    };
  }
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "node_modules/jsonwebtoken/index.js"(exports2, module2) {
    module2.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// node_modules/mongoose/lib/driver.js
var require_driver = __commonJS({
  "node_modules/mongoose/lib/driver.js"(exports2, module2) {
    "use strict";
    var driver = null;
    module2.exports.get = function() {
      return driver;
    };
    module2.exports.set = function(v) {
      driver = v;
    };
  }
});

// node_modules/bson/lib/bson/map.js
var require_map = __commonJS({
  "node_modules/bson/lib/bson/map.js"(exports2, module2) {
    "use strict";
    if (typeof global.Map !== "undefined") {
      module2.exports = global.Map;
      module2.exports.Map = global.Map;
    } else {
      Map2 = function(array) {
        this._keys = [];
        this._values = {};
        for (var i = 0; i < array.length; i++) {
          if (array[i] == null)
            continue;
          var entry = array[i];
          var key = entry[0];
          var value = entry[1];
          this._keys.push(key);
          this._values[key] = { v: value, i: this._keys.length - 1 };
        }
      };
      Map2.prototype.clear = function() {
        this._keys = [];
        this._values = {};
      };
      Map2.prototype.delete = function(key) {
        var value = this._values[key];
        if (value == null)
          return false;
        delete this._values[key];
        this._keys.splice(value.i, 1);
        return true;
      };
      Map2.prototype.entries = function() {
        var self2 = this;
        var index = 0;
        return {
          next: function() {
            var key = self2._keys[index++];
            return {
              value: key !== void 0 ? [key, self2._values[key].v] : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Map2.prototype.forEach = function(callback, self2) {
        self2 = self2 || this;
        for (var i = 0; i < this._keys.length; i++) {
          var key = this._keys[i];
          callback.call(self2, this._values[key].v, key, self2);
        }
      };
      Map2.prototype.get = function(key) {
        return this._values[key] ? this._values[key].v : void 0;
      };
      Map2.prototype.has = function(key) {
        return this._values[key] != null;
      };
      Map2.prototype.keys = function() {
        var self2 = this;
        var index = 0;
        return {
          next: function() {
            var key = self2._keys[index++];
            return {
              value: key !== void 0 ? key : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Map2.prototype.set = function(key, value) {
        if (this._values[key]) {
          this._values[key].v = value;
          return this;
        }
        this._keys.push(key);
        this._values[key] = { v: value, i: this._keys.length - 1 };
        return this;
      };
      Map2.prototype.values = function() {
        var self2 = this;
        var index = 0;
        return {
          next: function() {
            var key = self2._keys[index++];
            return {
              value: key !== void 0 ? self2._values[key].v : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Object.defineProperty(Map2.prototype, "size", {
        enumerable: true,
        get: function() {
          return this._keys.length;
        }
      });
      module2.exports = Map2;
      module2.exports.Map = Map2;
    }
    var Map2;
  }
});

// node_modules/bson/lib/bson/long.js
var require_long = __commonJS({
  "node_modules/bson/lib/bson/long.js"(exports2, module2) {
    function Long2(low, high) {
      if (!(this instanceof Long2))
        return new Long2(low, high);
      this._bsontype = "Long";
      this.low_ = low | 0;
      this.high_ = high | 0;
    }
    Long2.prototype.toInt = function() {
      return this.low_;
    };
    Long2.prototype.toNumber = function() {
      return this.high_ * Long2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };
    Long2.prototype.toBigInt = function() {
      return BigInt(this.toString());
    };
    Long2.prototype.toJSON = function() {
      return this.toString();
    };
    Long2.prototype.toString = function(opt_radix) {
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (this.isZero()) {
        return "0";
      }
      if (this.isNegative()) {
        if (this.equals(Long2.MIN_VALUE)) {
          var radixLong = Long2.fromNumber(radix);
          var div = this.div(radixLong);
          var rem = div.multiply(radixLong).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return "-" + this.negate().toString(radix);
        }
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 6));
      rem = this;
      var result = "";
      while (!rem.isZero()) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = "0" + digits;
          }
          result = "" + digits + result;
        }
      }
    };
    Long2.prototype.getHighBits = function() {
      return this.high_;
    };
    Long2.prototype.getLowBits = function() {
      return this.low_;
    };
    Long2.prototype.getLowBitsUnsigned = function() {
      return this.low_ >= 0 ? this.low_ : Long2.TWO_PWR_32_DBL_ + this.low_;
    };
    Long2.prototype.getNumBitsAbs = function() {
      if (this.isNegative()) {
        if (this.equals(Long2.MIN_VALUE)) {
          return 64;
        } else {
          return this.negate().getNumBitsAbs();
        }
      } else {
        var val = this.high_ !== 0 ? this.high_ : this.low_;
        for (var bit = 31; bit > 0; bit--) {
          if ((val & 1 << bit) !== 0) {
            break;
          }
        }
        return this.high_ !== 0 ? bit + 33 : bit + 1;
      }
    };
    Long2.prototype.isZero = function() {
      return this.high_ === 0 && this.low_ === 0;
    };
    Long2.prototype.isNegative = function() {
      return this.high_ < 0;
    };
    Long2.prototype.isOdd = function() {
      return (this.low_ & 1) === 1;
    };
    Long2.prototype.equals = function(other) {
      return this.high_ === other.high_ && this.low_ === other.low_;
    };
    Long2.prototype.notEquals = function(other) {
      return this.high_ !== other.high_ || this.low_ !== other.low_;
    };
    Long2.prototype.lessThan = function(other) {
      return this.compare(other) < 0;
    };
    Long2.prototype.lessThanOrEqual = function(other) {
      return this.compare(other) <= 0;
    };
    Long2.prototype.greaterThan = function(other) {
      return this.compare(other) > 0;
    };
    Long2.prototype.greaterThanOrEqual = function(other) {
      return this.compare(other) >= 0;
    };
    Long2.prototype.compare = function(other) {
      if (this.equals(other)) {
        return 0;
      }
      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) {
        return -1;
      }
      if (!thisNeg && otherNeg) {
        return 1;
      }
      if (this.subtract(other).isNegative()) {
        return -1;
      } else {
        return 1;
      }
    };
    Long2.prototype.negate = function() {
      if (this.equals(Long2.MIN_VALUE)) {
        return Long2.MIN_VALUE;
      } else {
        return this.not().add(Long2.ONE);
      }
    };
    Long2.prototype.add = function(other) {
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Long2.prototype.subtract = function(other) {
      return this.add(other.negate());
    };
    Long2.prototype.multiply = function(other) {
      if (this.isZero()) {
        return Long2.ZERO;
      } else if (other.isZero()) {
        return Long2.ZERO;
      }
      if (this.equals(Long2.MIN_VALUE)) {
        return other.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      } else if (other.equals(Long2.MIN_VALUE)) {
        return this.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().multiply(other.negate());
        } else {
          return this.negate().multiply(other).negate();
        }
      } else if (other.isNegative()) {
        return this.multiply(other.negate()).negate();
      }
      if (this.lessThan(Long2.TWO_PWR_24_) && other.lessThan(Long2.TWO_PWR_24_)) {
        return Long2.fromNumber(this.toNumber() * other.toNumber());
      }
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Long2.prototype.div = function(other) {
      if (other.isZero()) {
        throw Error("division by zero");
      } else if (this.isZero()) {
        return Long2.ZERO;
      }
      if (this.equals(Long2.MIN_VALUE)) {
        if (other.equals(Long2.ONE) || other.equals(Long2.NEG_ONE)) {
          return Long2.MIN_VALUE;
        } else if (other.equals(Long2.MIN_VALUE)) {
          return Long2.ONE;
        } else {
          var halfThis = this.shiftRight(1);
          var approx = halfThis.div(other).shiftLeft(1);
          if (approx.equals(Long2.ZERO)) {
            return other.isNegative() ? Long2.ONE : Long2.NEG_ONE;
          } else {
            var rem = this.subtract(other.multiply(approx));
            var result = approx.add(rem.div(other));
            return result;
          }
        }
      } else if (other.equals(Long2.MIN_VALUE)) {
        return Long2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().div(other.negate());
        } else {
          return this.negate().div(other).negate();
        }
      } else if (other.isNegative()) {
        return this.div(other.negate()).negate();
      }
      var res = Long2.ZERO;
      rem = this;
      while (rem.greaterThanOrEqual(other)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Long2.fromNumber(approx);
        var approxRem = approxRes.multiply(other);
        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Long2.fromNumber(approx);
          approxRem = approxRes.multiply(other);
        }
        if (approxRes.isZero()) {
          approxRes = Long2.ONE;
        }
        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }
      return res;
    };
    Long2.prototype.modulo = function(other) {
      return this.subtract(this.div(other).multiply(other));
    };
    Long2.prototype.not = function() {
      return Long2.fromBits(~this.low_, ~this.high_);
    };
    Long2.prototype.and = function(other) {
      return Long2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };
    Long2.prototype.or = function(other) {
      return Long2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };
    Long2.prototype.xor = function(other) {
      return Long2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
    };
    Long2.prototype.shiftLeft = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var low = this.low_;
        if (numBits < 32) {
          var high = this.high_;
          return Long2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
        } else {
          return Long2.fromBits(0, low << numBits - 32);
        }
      }
    };
    Long2.prototype.shiftRight = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
        } else {
          return Long2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
        }
      }
    };
    Long2.prototype.shiftRightUnsigned = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
        } else if (numBits === 32) {
          return Long2.fromBits(high, 0);
        } else {
          return Long2.fromBits(high >>> numBits - 32, 0);
        }
      }
    };
    Long2.fromInt = function(value) {
      if (-128 <= value && value < 128) {
        var cachedObj = Long2.INT_CACHE_[value];
        if (cachedObj) {
          return cachedObj;
        }
      }
      var obj = new Long2(value | 0, value < 0 ? -1 : 0);
      if (-128 <= value && value < 128) {
        Long2.INT_CACHE_[value] = obj;
      }
      return obj;
    };
    Long2.fromNumber = function(value) {
      if (isNaN(value) || !isFinite(value)) {
        return Long2.ZERO;
      } else if (value <= -Long2.TWO_PWR_63_DBL_) {
        return Long2.MIN_VALUE;
      } else if (value + 1 >= Long2.TWO_PWR_63_DBL_) {
        return Long2.MAX_VALUE;
      } else if (value < 0) {
        return Long2.fromNumber(-value).negate();
      } else {
        return new Long2(value % Long2.TWO_PWR_32_DBL_ | 0, value / Long2.TWO_PWR_32_DBL_ | 0);
      }
    };
    Long2.fromBigInt = function(value) {
      return Long2.fromString(value.toString(10), 10);
    };
    Long2.fromBits = function(lowBits, highBits) {
      return new Long2(lowBits, highBits);
    };
    Long2.fromString = function(str, opt_radix) {
      if (str.length === 0) {
        throw Error("number format error: empty string");
      }
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (str.charAt(0) === "-") {
        return Long2.fromString(str.substring(1), radix).negate();
      } else if (str.indexOf("-") >= 0) {
        throw Error('number format error: interior "-" character: ' + str);
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 8));
      var result = Long2.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Long2.fromNumber(Math.pow(radix, size));
          result = result.multiply(power).add(Long2.fromNumber(value));
        } else {
          result = result.multiply(radixToPower);
          result = result.add(Long2.fromNumber(value));
        }
      }
      return result;
    };
    Long2.INT_CACHE_ = {};
    Long2.TWO_PWR_16_DBL_ = 1 << 16;
    Long2.TWO_PWR_24_DBL_ = 1 << 24;
    Long2.TWO_PWR_32_DBL_ = Long2.TWO_PWR_16_DBL_ * Long2.TWO_PWR_16_DBL_;
    Long2.TWO_PWR_31_DBL_ = Long2.TWO_PWR_32_DBL_ / 2;
    Long2.TWO_PWR_48_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_16_DBL_;
    Long2.TWO_PWR_64_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_32_DBL_;
    Long2.TWO_PWR_63_DBL_ = Long2.TWO_PWR_64_DBL_ / 2;
    Long2.ZERO = Long2.fromInt(0);
    Long2.ONE = Long2.fromInt(1);
    Long2.NEG_ONE = Long2.fromInt(-1);
    Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0);
    Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0);
    Long2.TWO_PWR_24_ = Long2.fromInt(1 << 24);
    module2.exports = Long2;
    module2.exports.Long = Long2;
  }
});

// node_modules/bson/lib/bson/double.js
var require_double = __commonJS({
  "node_modules/bson/lib/bson/double.js"(exports2, module2) {
    function Double2(value) {
      if (!(this instanceof Double2))
        return new Double2(value);
      this._bsontype = "Double";
      this.value = value;
    }
    Double2.prototype.valueOf = function() {
      return this.value;
    };
    Double2.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Double2;
    module2.exports.Double = Double2;
  }
});

// node_modules/bson/lib/bson/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/bson/lib/bson/timestamp.js"(exports2, module2) {
    function Timestamp2(low, high) {
      if (!(this instanceof Timestamp2))
        return new Timestamp2(low, high);
      this._bsontype = "Timestamp";
      this.low_ = low | 0;
      this.high_ = high | 0;
    }
    Timestamp2.prototype.toInt = function() {
      return this.low_;
    };
    Timestamp2.prototype.toNumber = function() {
      return this.high_ * Timestamp2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };
    Timestamp2.prototype.toJSON = function() {
      return this.toString();
    };
    Timestamp2.prototype.toString = function(opt_radix) {
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (this.isZero()) {
        return "0";
      }
      if (this.isNegative()) {
        if (this.equals(Timestamp2.MIN_VALUE)) {
          var radixTimestamp = Timestamp2.fromNumber(radix);
          var div = this.div(radixTimestamp);
          var rem = div.multiply(radixTimestamp).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return "-" + this.negate().toString(radix);
        }
      }
      var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 6));
      rem = this;
      var result = "";
      while (!rem.isZero()) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = "0" + digits;
          }
          result = "" + digits + result;
        }
      }
    };
    Timestamp2.prototype.getHighBits = function() {
      return this.high_;
    };
    Timestamp2.prototype.getLowBits = function() {
      return this.low_;
    };
    Timestamp2.prototype.getLowBitsUnsigned = function() {
      return this.low_ >= 0 ? this.low_ : Timestamp2.TWO_PWR_32_DBL_ + this.low_;
    };
    Timestamp2.prototype.getNumBitsAbs = function() {
      if (this.isNegative()) {
        if (this.equals(Timestamp2.MIN_VALUE)) {
          return 64;
        } else {
          return this.negate().getNumBitsAbs();
        }
      } else {
        var val = this.high_ !== 0 ? this.high_ : this.low_;
        for (var bit = 31; bit > 0; bit--) {
          if ((val & 1 << bit) !== 0) {
            break;
          }
        }
        return this.high_ !== 0 ? bit + 33 : bit + 1;
      }
    };
    Timestamp2.prototype.isZero = function() {
      return this.high_ === 0 && this.low_ === 0;
    };
    Timestamp2.prototype.isNegative = function() {
      return this.high_ < 0;
    };
    Timestamp2.prototype.isOdd = function() {
      return (this.low_ & 1) === 1;
    };
    Timestamp2.prototype.equals = function(other) {
      return this.high_ === other.high_ && this.low_ === other.low_;
    };
    Timestamp2.prototype.notEquals = function(other) {
      return this.high_ !== other.high_ || this.low_ !== other.low_;
    };
    Timestamp2.prototype.lessThan = function(other) {
      return this.compare(other) < 0;
    };
    Timestamp2.prototype.lessThanOrEqual = function(other) {
      return this.compare(other) <= 0;
    };
    Timestamp2.prototype.greaterThan = function(other) {
      return this.compare(other) > 0;
    };
    Timestamp2.prototype.greaterThanOrEqual = function(other) {
      return this.compare(other) >= 0;
    };
    Timestamp2.prototype.compare = function(other) {
      if (this.equals(other)) {
        return 0;
      }
      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) {
        return -1;
      }
      if (!thisNeg && otherNeg) {
        return 1;
      }
      if (this.subtract(other).isNegative()) {
        return -1;
      } else {
        return 1;
      }
    };
    Timestamp2.prototype.negate = function() {
      if (this.equals(Timestamp2.MIN_VALUE)) {
        return Timestamp2.MIN_VALUE;
      } else {
        return this.not().add(Timestamp2.ONE);
      }
    };
    Timestamp2.prototype.add = function(other) {
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Timestamp2.prototype.subtract = function(other) {
      return this.add(other.negate());
    };
    Timestamp2.prototype.multiply = function(other) {
      if (this.isZero()) {
        return Timestamp2.ZERO;
      } else if (other.isZero()) {
        return Timestamp2.ZERO;
      }
      if (this.equals(Timestamp2.MIN_VALUE)) {
        return other.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
      } else if (other.equals(Timestamp2.MIN_VALUE)) {
        return this.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().multiply(other.negate());
        } else {
          return this.negate().multiply(other).negate();
        }
      } else if (other.isNegative()) {
        return this.multiply(other.negate()).negate();
      }
      if (this.lessThan(Timestamp2.TWO_PWR_24_) && other.lessThan(Timestamp2.TWO_PWR_24_)) {
        return Timestamp2.fromNumber(this.toNumber() * other.toNumber());
      }
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Timestamp2.prototype.div = function(other) {
      if (other.isZero()) {
        throw Error("division by zero");
      } else if (this.isZero()) {
        return Timestamp2.ZERO;
      }
      if (this.equals(Timestamp2.MIN_VALUE)) {
        if (other.equals(Timestamp2.ONE) || other.equals(Timestamp2.NEG_ONE)) {
          return Timestamp2.MIN_VALUE;
        } else if (other.equals(Timestamp2.MIN_VALUE)) {
          return Timestamp2.ONE;
        } else {
          var halfThis = this.shiftRight(1);
          var approx = halfThis.div(other).shiftLeft(1);
          if (approx.equals(Timestamp2.ZERO)) {
            return other.isNegative() ? Timestamp2.ONE : Timestamp2.NEG_ONE;
          } else {
            var rem = this.subtract(other.multiply(approx));
            var result = approx.add(rem.div(other));
            return result;
          }
        }
      } else if (other.equals(Timestamp2.MIN_VALUE)) {
        return Timestamp2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().div(other.negate());
        } else {
          return this.negate().div(other).negate();
        }
      } else if (other.isNegative()) {
        return this.div(other.negate()).negate();
      }
      var res = Timestamp2.ZERO;
      rem = this;
      while (rem.greaterThanOrEqual(other)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Timestamp2.fromNumber(approx);
        var approxRem = approxRes.multiply(other);
        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Timestamp2.fromNumber(approx);
          approxRem = approxRes.multiply(other);
        }
        if (approxRes.isZero()) {
          approxRes = Timestamp2.ONE;
        }
        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }
      return res;
    };
    Timestamp2.prototype.modulo = function(other) {
      return this.subtract(this.div(other).multiply(other));
    };
    Timestamp2.prototype.not = function() {
      return Timestamp2.fromBits(~this.low_, ~this.high_);
    };
    Timestamp2.prototype.and = function(other) {
      return Timestamp2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };
    Timestamp2.prototype.or = function(other) {
      return Timestamp2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };
    Timestamp2.prototype.xor = function(other) {
      return Timestamp2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
    };
    Timestamp2.prototype.shiftLeft = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var low = this.low_;
        if (numBits < 32) {
          var high = this.high_;
          return Timestamp2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
        } else {
          return Timestamp2.fromBits(0, low << numBits - 32);
        }
      }
    };
    Timestamp2.prototype.shiftRight = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
        } else {
          return Timestamp2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
        }
      }
    };
    Timestamp2.prototype.shiftRightUnsigned = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
        } else if (numBits === 32) {
          return Timestamp2.fromBits(high, 0);
        } else {
          return Timestamp2.fromBits(high >>> numBits - 32, 0);
        }
      }
    };
    Timestamp2.fromInt = function(value) {
      if (-128 <= value && value < 128) {
        var cachedObj = Timestamp2.INT_CACHE_[value];
        if (cachedObj) {
          return cachedObj;
        }
      }
      var obj = new Timestamp2(value | 0, value < 0 ? -1 : 0);
      if (-128 <= value && value < 128) {
        Timestamp2.INT_CACHE_[value] = obj;
      }
      return obj;
    };
    Timestamp2.fromNumber = function(value) {
      if (isNaN(value) || !isFinite(value)) {
        return Timestamp2.ZERO;
      } else if (value <= -Timestamp2.TWO_PWR_63_DBL_) {
        return Timestamp2.MIN_VALUE;
      } else if (value + 1 >= Timestamp2.TWO_PWR_63_DBL_) {
        return Timestamp2.MAX_VALUE;
      } else if (value < 0) {
        return Timestamp2.fromNumber(-value).negate();
      } else {
        return new Timestamp2(value % Timestamp2.TWO_PWR_32_DBL_ | 0, value / Timestamp2.TWO_PWR_32_DBL_ | 0);
      }
    };
    Timestamp2.fromBits = function(lowBits, highBits) {
      return new Timestamp2(lowBits, highBits);
    };
    Timestamp2.fromString = function(str, opt_radix) {
      if (str.length === 0) {
        throw Error("number format error: empty string");
      }
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (str.charAt(0) === "-") {
        return Timestamp2.fromString(str.substring(1), radix).negate();
      } else if (str.indexOf("-") >= 0) {
        throw Error('number format error: interior "-" character: ' + str);
      }
      var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 8));
      var result = Timestamp2.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Timestamp2.fromNumber(Math.pow(radix, size));
          result = result.multiply(power).add(Timestamp2.fromNumber(value));
        } else {
          result = result.multiply(radixToPower);
          result = result.add(Timestamp2.fromNumber(value));
        }
      }
      return result;
    };
    Timestamp2.INT_CACHE_ = {};
    Timestamp2.TWO_PWR_16_DBL_ = 1 << 16;
    Timestamp2.TWO_PWR_24_DBL_ = 1 << 24;
    Timestamp2.TWO_PWR_32_DBL_ = Timestamp2.TWO_PWR_16_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
    Timestamp2.TWO_PWR_31_DBL_ = Timestamp2.TWO_PWR_32_DBL_ / 2;
    Timestamp2.TWO_PWR_48_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
    Timestamp2.TWO_PWR_64_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_32_DBL_;
    Timestamp2.TWO_PWR_63_DBL_ = Timestamp2.TWO_PWR_64_DBL_ / 2;
    Timestamp2.ZERO = Timestamp2.fromInt(0);
    Timestamp2.ONE = Timestamp2.fromInt(1);
    Timestamp2.NEG_ONE = Timestamp2.fromInt(-1);
    Timestamp2.MAX_VALUE = Timestamp2.fromBits(4294967295 | 0, 2147483647 | 0);
    Timestamp2.MIN_VALUE = Timestamp2.fromBits(0, 2147483648 | 0);
    Timestamp2.TWO_PWR_24_ = Timestamp2.fromInt(1 << 24);
    module2.exports = Timestamp2;
    module2.exports.Timestamp = Timestamp2;
  }
});

// node_modules/bson/lib/bson/parser/utils.js
var require_utils3 = __commonJS({
  "node_modules/bson/lib/bson/parser/utils.js"(exports2, module2) {
    "use strict";
    function normalizedFunctionString(fn) {
      return fn.toString().replace(/function *\(/, "function (");
    }
    function newBuffer(item, encoding) {
      return new Buffer(item, encoding);
    }
    function allocBuffer() {
      return Buffer.alloc.apply(Buffer, arguments);
    }
    function toBuffer() {
      return Buffer.from.apply(Buffer, arguments);
    }
    module2.exports = {
      normalizedFunctionString,
      allocBuffer: typeof Buffer.alloc === "function" ? allocBuffer : newBuffer,
      toBuffer: typeof Buffer.from === "function" ? toBuffer : newBuffer
    };
  }
});

// node_modules/bson/lib/bson/objectid.js
var require_objectid = __commonJS({
  "node_modules/bson/lib/bson/objectid.js"(exports2, module2) {
    var inspect = "inspect";
    var utils2 = require_utils3();
    var MACHINE_ID = parseInt(Math.random() * 16777215, 10);
    var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
    try {
      if (Buffer && Buffer.from) {
        hasBufferType = true;
        inspect = require("util").inspect.custom || "inspect";
      }
    } catch (err) {
      hasBufferType = false;
    }
    var hasBufferType;
    var ObjectID2 = function ObjectID3(id) {
      if (id instanceof ObjectID3)
        return id;
      if (!(this instanceof ObjectID3))
        return new ObjectID3(id);
      this._bsontype = "ObjectID";
      if (id == null || typeof id === "number") {
        this.id = this.generate(id);
        if (ObjectID3.cacheHexString)
          this.__id = this.toString("hex");
        return;
      }
      var valid = ObjectID3.isValid(id);
      if (!valid && id != null) {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      } else if (valid && typeof id === "string" && id.length === 24 && hasBufferType) {
        return new ObjectID3(utils2.toBuffer(id, "hex"));
      } else if (valid && typeof id === "string" && id.length === 24) {
        return ObjectID3.createFromHexString(id);
      } else if (id != null && id.length === 12) {
        this.id = id;
      } else if (id != null && typeof id.toHexString === "function") {
        return id;
      } else {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      }
      if (ObjectID3.cacheHexString)
        this.__id = this.toString("hex");
    };
    var hexTable = [];
    for (var i = 0; i < 256; i++) {
      hexTable[i] = (i <= 15 ? "0" : "") + i.toString(16);
    }
    ObjectID2.prototype.toHexString = function() {
      if (ObjectID2.cacheHexString && this.__id)
        return this.__id;
      var hexString = "";
      if (!this.id || !this.id.length) {
        throw new Error("invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [" + JSON.stringify(this.id) + "]");
      }
      if (this.id instanceof _Buffer) {
        hexString = convertToHex(this.id);
        if (ObjectID2.cacheHexString)
          this.__id = hexString;
        return hexString;
      }
      for (var i2 = 0; i2 < this.id.length; i2++) {
        hexString += hexTable[this.id.charCodeAt(i2)];
      }
      if (ObjectID2.cacheHexString)
        this.__id = hexString;
      return hexString;
    };
    ObjectID2.prototype.get_inc = function() {
      return ObjectID2.index = (ObjectID2.index + 1) % 16777215;
    };
    ObjectID2.prototype.getInc = function() {
      return this.get_inc();
    };
    ObjectID2.prototype.generate = function(time) {
      if (typeof time !== "number") {
        time = ~~(Date.now() / 1e3);
      }
      var pid = (typeof process === "undefined" || process.pid === 1 ? Math.floor(Math.random() * 1e5) : process.pid) % 65535;
      var inc = this.get_inc();
      var buffer = utils2.allocBuffer(12);
      buffer[3] = time & 255;
      buffer[2] = time >> 8 & 255;
      buffer[1] = time >> 16 & 255;
      buffer[0] = time >> 24 & 255;
      buffer[6] = MACHINE_ID & 255;
      buffer[5] = MACHINE_ID >> 8 & 255;
      buffer[4] = MACHINE_ID >> 16 & 255;
      buffer[8] = pid & 255;
      buffer[7] = pid >> 8 & 255;
      buffer[11] = inc & 255;
      buffer[10] = inc >> 8 & 255;
      buffer[9] = inc >> 16 & 255;
      return buffer;
    };
    ObjectID2.prototype.toString = function(format) {
      if (this.id && this.id.copy) {
        return this.id.toString(typeof format === "string" ? format : "hex");
      }
      return this.toHexString();
    };
    ObjectID2.prototype[inspect] = ObjectID2.prototype.toString;
    ObjectID2.prototype.toJSON = function() {
      return this.toHexString();
    };
    ObjectID2.prototype.equals = function equals(otherId) {
      if (otherId instanceof ObjectID2) {
        return this.toString() === otherId.toString();
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12 && this.id instanceof _Buffer) {
        return otherId === this.id.toString("binary");
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 24) {
        return otherId.toLowerCase() === this.toHexString();
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12) {
        return otherId === this.id;
      } else if (otherId != null && (otherId instanceof ObjectID2 || otherId.toHexString)) {
        return otherId.toHexString() === this.toHexString();
      } else {
        return false;
      }
    };
    ObjectID2.prototype.getTimestamp = function() {
      var timestamp = new Date();
      var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      timestamp.setTime(Math.floor(time) * 1e3);
      return timestamp;
    };
    ObjectID2.index = ~~(Math.random() * 16777215);
    ObjectID2.createPk = function createPk() {
      return new ObjectID2();
    };
    ObjectID2.createFromTime = function createFromTime(time) {
      var buffer = utils2.toBuffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      buffer[3] = time & 255;
      buffer[2] = time >> 8 & 255;
      buffer[1] = time >> 16 & 255;
      buffer[0] = time >> 24 & 255;
      return new ObjectID2(buffer);
    };
    var decodeLookup = [];
    i = 0;
    while (i < 10)
      decodeLookup[48 + i] = i++;
    while (i < 16)
      decodeLookup[65 - 10 + i] = decodeLookup[97 - 10 + i] = i++;
    var _Buffer = Buffer;
    var convertToHex = function(bytes) {
      return bytes.toString("hex");
    };
    ObjectID2.createFromHexString = function createFromHexString(string) {
      if (typeof string === "undefined" || string != null && string.length !== 24) {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      }
      if (hasBufferType)
        return new ObjectID2(utils2.toBuffer(string, "hex"));
      var array = new _Buffer(12);
      var n = 0;
      var i2 = 0;
      while (i2 < 24) {
        array[n++] = decodeLookup[string.charCodeAt(i2++)] << 4 | decodeLookup[string.charCodeAt(i2++)];
      }
      return new ObjectID2(array);
    };
    ObjectID2.isValid = function isValid(id) {
      if (id == null)
        return false;
      if (typeof id === "number") {
        return true;
      }
      if (typeof id === "string") {
        return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);
      }
      if (id instanceof ObjectID2) {
        return true;
      }
      if (id instanceof _Buffer) {
        return true;
      }
      if (typeof id.toHexString === "function" && (id.id instanceof _Buffer || typeof id.id === "string")) {
        return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);
      }
      return false;
    };
    Object.defineProperty(ObjectID2.prototype, "generationTime", {
      enumerable: true,
      get: function() {
        return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      },
      set: function(value) {
        this.id[3] = value & 255;
        this.id[2] = value >> 8 & 255;
        this.id[1] = value >> 16 & 255;
        this.id[0] = value >> 24 & 255;
      }
    });
    module2.exports = ObjectID2;
    module2.exports.ObjectID = ObjectID2;
    module2.exports.ObjectId = ObjectID2;
  }
});

// node_modules/bson/lib/bson/regexp.js
var require_regexp = __commonJS({
  "node_modules/bson/lib/bson/regexp.js"(exports2, module2) {
    function BSONRegExp2(pattern, options) {
      if (!(this instanceof BSONRegExp2))
        return new BSONRegExp2();
      this._bsontype = "BSONRegExp";
      this.pattern = pattern || "";
      this.options = options || "";
      for (var i = 0; i < this.options.length; i++) {
        if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
          throw new Error("the regular expression options [" + this.options[i] + "] is not supported");
        }
      }
    }
    module2.exports = BSONRegExp2;
    module2.exports.BSONRegExp = BSONRegExp2;
  }
});

// node_modules/bson/lib/bson/symbol.js
var require_symbol = __commonJS({
  "node_modules/bson/lib/bson/symbol.js"(exports2, module2) {
    var inspect = Buffer ? require("util").inspect.custom || "inspect" : "inspect";
    function Symbol2(value) {
      if (!(this instanceof Symbol2))
        return new Symbol2(value);
      this._bsontype = "Symbol";
      this.value = value;
    }
    Symbol2.prototype.valueOf = function() {
      return this.value;
    };
    Symbol2.prototype.toString = function() {
      return this.value;
    };
    Symbol2.prototype[inspect] = function() {
      return this.value;
    };
    Symbol2.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Symbol2;
    module2.exports.Symbol = Symbol2;
  }
});

// node_modules/bson/lib/bson/int_32.js
var require_int_32 = __commonJS({
  "node_modules/bson/lib/bson/int_32.js"(exports2, module2) {
    var Int322 = function(value) {
      if (!(this instanceof Int322))
        return new Int322(value);
      this._bsontype = "Int32";
      this.value = value;
    };
    Int322.prototype.valueOf = function() {
      return this.value;
    };
    Int322.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Int322;
    module2.exports.Int32 = Int322;
  }
});

// node_modules/bson/lib/bson/code.js
var require_code = __commonJS({
  "node_modules/bson/lib/bson/code.js"(exports2, module2) {
    var Code2 = function Code3(code, scope) {
      if (!(this instanceof Code3))
        return new Code3(code, scope);
      this._bsontype = "Code";
      this.code = code;
      this.scope = scope;
    };
    Code2.prototype.toJSON = function() {
      return { scope: this.scope, code: this.code };
    };
    module2.exports = Code2;
    module2.exports.Code = Code2;
  }
});

// node_modules/bson/lib/bson/decimal128.js
var require_decimal128 = __commonJS({
  "node_modules/bson/lib/bson/decimal128.js"(exports2, module2) {
    "use strict";
    var Long2 = require_long();
    var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
    var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
    var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
    var EXPONENT_MAX = 6111;
    var EXPONENT_MIN = -6176;
    var EXPONENT_BIAS = 6176;
    var MAX_DIGITS = 34;
    var NAN_BUFFER = [
      124,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var INF_NEGATIVE_BUFFER = [
      248,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var INF_POSITIVE_BUFFER = [
      120,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
    var utils2 = require_utils3();
    var isDigit = function(value) {
      return !isNaN(parseInt(value, 10));
    };
    var divideu128 = function(value) {
      var DIVISOR = Long2.fromNumber(1e3 * 1e3 * 1e3);
      var _rem = Long2.fromNumber(0);
      var i = 0;
      if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
        return { quotient: value, rem: _rem };
      }
      for (i = 0; i <= 3; i++) {
        _rem = _rem.shiftLeft(32);
        _rem = _rem.add(new Long2(value.parts[i], 0));
        value.parts[i] = _rem.div(DIVISOR).low_;
        _rem = _rem.modulo(DIVISOR);
      }
      return { quotient: value, rem: _rem };
    };
    var multiply64x2 = function(left, right) {
      if (!left && !right) {
        return { high: Long2.fromNumber(0), low: Long2.fromNumber(0) };
      }
      var leftHigh = left.shiftRightUnsigned(32);
      var leftLow = new Long2(left.getLowBits(), 0);
      var rightHigh = right.shiftRightUnsigned(32);
      var rightLow = new Long2(right.getLowBits(), 0);
      var productHigh = leftHigh.multiply(rightHigh);
      var productMid = leftHigh.multiply(rightLow);
      var productMid2 = leftLow.multiply(rightHigh);
      var productLow = leftLow.multiply(rightLow);
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productMid = new Long2(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productLow = productMid.shiftLeft(32).add(new Long2(productLow.getLowBits(), 0));
      return { high: productHigh, low: productLow };
    };
    var lessThan = function(left, right) {
      var uhleft = left.high_ >>> 0;
      var uhright = right.high_ >>> 0;
      if (uhleft < uhright) {
        return true;
      } else if (uhleft === uhright) {
        var ulleft = left.low_ >>> 0;
        var ulright = right.low_ >>> 0;
        if (ulleft < ulright)
          return true;
      }
      return false;
    };
    var Decimal1282 = function(bytes) {
      this._bsontype = "Decimal128";
      this.bytes = bytes;
    };
    Decimal1282.fromString = function(string) {
      var isNegative = false;
      var sawRadix = false;
      var foundNonZero = false;
      var significantDigits = 0;
      var nDigitsRead = 0;
      var nDigits = 0;
      var radixPosition = 0;
      var firstNonZero = 0;
      var digits = [0];
      var nDigitsStored = 0;
      var digitsInsert = 0;
      var firstDigit = 0;
      var lastDigit = 0;
      var exponent = 0;
      var i = 0;
      var significandHigh = [0, 0];
      var significandLow = [0, 0];
      var biasedExponent = 0;
      var index = 0;
      string = string.trim();
      if (string.length >= 7e3) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      var stringMatch = string.match(PARSE_STRING_REGEXP);
      var infMatch = string.match(PARSE_INF_REGEXP);
      var nanMatch = string.match(PARSE_NAN_REGEXP);
      if (!stringMatch && !infMatch && !nanMatch || string.length === 0) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (stringMatch && stringMatch[4] && stringMatch[2] === void 0) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (string[index] === "+" || string[index] === "-") {
        isNegative = string[index++] === "-";
      }
      if (!isDigit(string[index]) && string[index] !== ".") {
        if (string[index] === "i" || string[index] === "I") {
          return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
        } else if (string[index] === "N") {
          return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
        }
      }
      while (isDigit(string[index]) || string[index] === ".") {
        if (string[index] === ".") {
          if (sawRadix) {
            return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
          }
          sawRadix = true;
          index = index + 1;
          continue;
        }
        if (nDigitsStored < 34) {
          if (string[index] !== "0" || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(string[index], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero) {
          nDigits = nDigits + 1;
        }
        if (sawRadix) {
          radixPosition = radixPosition + 1;
        }
        nDigitsRead = nDigitsRead + 1;
        index = index + 1;
      }
      if (sawRadix && !nDigitsRead) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (string[index] === "e" || string[index] === "E") {
        var match = string.substr(++index).match(EXPONENT_REGEX);
        if (!match || !match[2]) {
          return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
        }
        exponent = parseInt(match[0], 10);
        index = index + match[0].length;
      }
      if (string[index]) {
        return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
      }
      firstDigit = 0;
      if (!nDigitsStored) {
        firstDigit = 0;
        lastDigit = 0;
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (exponent !== 0 && significantDigits !== 1) {
          while (string[firstNonZero + significantDigits - 1] === "0") {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit - firstDigit > MAX_DIGITS) {
          var digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          } else {
            return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
          }
        }
        exponent = exponent - 1;
      }
      while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
        if (lastDigit === 0) {
          exponent = EXPONENT_MIN;
          significantDigits = 0;
          break;
        }
        if (nDigitsStored < nDigits) {
          nDigits = nDigits - 1;
        } else {
          lastDigit = lastDigit - 1;
        }
        if (exponent < EXPONENT_MAX) {
          exponent = exponent + 1;
        } else {
          digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          } else {
            return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
          }
        }
      }
      if (lastDigit - firstDigit + 1 < significantDigits && string[significantDigits] !== "0") {
        var endOfString = nDigitsRead;
        if (sawRadix && exponent === EXPONENT_MIN) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        var roundDigit = parseInt(string[firstNonZero + lastDigit + 1], 10);
        var roundBit = 0;
        if (roundDigit >= 5) {
          roundBit = 1;
          if (roundDigit === 5) {
            roundBit = digits[lastDigit] % 2 === 1;
            for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
              if (parseInt(string[i], 10)) {
                roundBit = 1;
                break;
              }
            }
          }
        }
        if (roundBit) {
          var dIdx = lastDigit;
          for (; dIdx >= 0; dIdx--) {
            if (++digits[dIdx] > 9) {
              digits[dIdx] = 0;
              if (dIdx === 0) {
                if (exponent < EXPONENT_MAX) {
                  exponent = exponent + 1;
                  digits[dIdx] = 1;
                } else {
                  return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
                }
              }
            } else {
              break;
            }
          }
        }
      }
      significandHigh = Long2.fromNumber(0);
      significandLow = Long2.fromNumber(0);
      if (significantDigits === 0) {
        significandHigh = Long2.fromNumber(0);
        significandLow = Long2.fromNumber(0);
      } else if (lastDigit - firstDigit < 17) {
        dIdx = firstDigit;
        significandLow = Long2.fromNumber(digits[dIdx++]);
        significandHigh = new Long2(0, 0);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long2.fromNumber(10));
          significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
        }
      } else {
        dIdx = firstDigit;
        significandHigh = Long2.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit - 17; dIdx++) {
          significandHigh = significandHigh.multiply(Long2.fromNumber(10));
          significandHigh = significandHigh.add(Long2.fromNumber(digits[dIdx]));
        }
        significandLow = Long2.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long2.fromNumber(10));
          significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
        }
      }
      var significand = multiply64x2(significandHigh, Long2.fromString("100000000000000000"));
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(Long2.fromNumber(1));
      }
      biasedExponent = exponent + EXPONENT_BIAS;
      var dec = { low: Long2.fromNumber(0), high: Long2.fromNumber(0) };
      if (significand.high.shiftRightUnsigned(49).and(Long2.fromNumber(1)).equals(Long2.fromNumber)) {
        dec.high = dec.high.or(Long2.fromNumber(3).shiftLeft(61));
        dec.high = dec.high.or(Long2.fromNumber(biasedExponent).and(Long2.fromNumber(16383).shiftLeft(47)));
        dec.high = dec.high.or(significand.high.and(Long2.fromNumber(140737488355327)));
      } else {
        dec.high = dec.high.or(Long2.fromNumber(biasedExponent & 16383).shiftLeft(49));
        dec.high = dec.high.or(significand.high.and(Long2.fromNumber(562949953421311)));
      }
      dec.low = significand.low;
      if (isNegative) {
        dec.high = dec.high.or(Long2.fromString("9223372036854775808"));
      }
      var buffer = utils2.allocBuffer(16);
      index = 0;
      buffer[index++] = dec.low.low_ & 255;
      buffer[index++] = dec.low.low_ >> 8 & 255;
      buffer[index++] = dec.low.low_ >> 16 & 255;
      buffer[index++] = dec.low.low_ >> 24 & 255;
      buffer[index++] = dec.low.high_ & 255;
      buffer[index++] = dec.low.high_ >> 8 & 255;
      buffer[index++] = dec.low.high_ >> 16 & 255;
      buffer[index++] = dec.low.high_ >> 24 & 255;
      buffer[index++] = dec.high.low_ & 255;
      buffer[index++] = dec.high.low_ >> 8 & 255;
      buffer[index++] = dec.high.low_ >> 16 & 255;
      buffer[index++] = dec.high.low_ >> 24 & 255;
      buffer[index++] = dec.high.high_ & 255;
      buffer[index++] = dec.high.high_ >> 8 & 255;
      buffer[index++] = dec.high.high_ >> 16 & 255;
      buffer[index++] = dec.high.high_ >> 24 & 255;
      return new Decimal1282(buffer);
    };
    var COMBINATION_MASK = 31;
    var EXPONENT_MASK = 16383;
    var COMBINATION_INFINITY = 30;
    var COMBINATION_NAN = 31;
    EXPONENT_BIAS = 6176;
    Decimal1282.prototype.toString = function() {
      var high;
      var midh;
      var midl;
      var low;
      var combination;
      var biased_exponent;
      var significand_digits = 0;
      var significand = new Array(36);
      for (var i = 0; i < significand.length; i++)
        significand[i] = 0;
      var index = 0;
      var exponent;
      var scientific_exponent;
      var is_zero = false;
      var significand_msb;
      var significand128 = { parts: new Array(4) };
      i;
      var j, k;
      var string = [];
      index = 0;
      var buffer = this.bytes;
      low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      index = 0;
      var dec = {
        low: new Long2(low, midl),
        high: new Long2(midh, high)
      };
      if (dec.high.lessThan(Long2.ZERO)) {
        string.push("-");
      }
      combination = high >> 26 & COMBINATION_MASK;
      if (combination >> 3 === 3) {
        if (combination === COMBINATION_INFINITY) {
          return string.join("") + "Infinity";
        } else if (combination === COMBINATION_NAN) {
          return "NaN";
        } else {
          biased_exponent = high >> 15 & EXPONENT_MASK;
          significand_msb = 8 + (high >> 14 & 1);
        }
      } else {
        significand_msb = high >> 14 & 7;
        biased_exponent = high >> 17 & EXPONENT_MASK;
      }
      exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
        is_zero = true;
      } else {
        for (k = 3; k >= 0; k--) {
          var least_digits = 0;
          var result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low_;
          if (!least_digits)
            continue;
          for (j = 8; j >= 0; j--) {
            significand[k * 9 + j] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index] = 0;
      } else {
        significand_digits = 36;
        i = 0;
        while (!significand[index]) {
          i++;
          significand_digits = significand_digits - 1;
          index = index + 1;
        }
      }
      scientific_exponent = significand_digits - 1 + exponent;
      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
        string.push(significand[index++]);
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string.push(".");
        }
        for (i = 0; i < significand_digits; i++) {
          string.push(significand[index++]);
        }
        string.push("E");
        if (scientific_exponent > 0) {
          string.push("+" + scientific_exponent);
        } else {
          string.push(scientific_exponent);
        }
      } else {
        if (exponent >= 0) {
          for (i = 0; i < significand_digits; i++) {
            string.push(significand[index++]);
          }
        } else {
          var radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (i = 0; i < radix_position; i++) {
              string.push(significand[index++]);
            }
          } else {
            string.push("0");
          }
          string.push(".");
          while (radix_position++ < 0) {
            string.push("0");
          }
          for (i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
            string.push(significand[index++]);
          }
        }
      }
      return string.join("");
    };
    Decimal1282.prototype.toJSON = function() {
      return { $numberDecimal: this.toString() };
    };
    module2.exports = Decimal1282;
    module2.exports.Decimal128 = Decimal1282;
  }
});

// node_modules/bson/lib/bson/min_key.js
var require_min_key = __commonJS({
  "node_modules/bson/lib/bson/min_key.js"(exports2, module2) {
    function MinKey2() {
      if (!(this instanceof MinKey2))
        return new MinKey2();
      this._bsontype = "MinKey";
    }
    module2.exports = MinKey2;
    module2.exports.MinKey = MinKey2;
  }
});

// node_modules/bson/lib/bson/max_key.js
var require_max_key = __commonJS({
  "node_modules/bson/lib/bson/max_key.js"(exports2, module2) {
    function MaxKey2() {
      if (!(this instanceof MaxKey2))
        return new MaxKey2();
      this._bsontype = "MaxKey";
    }
    module2.exports = MaxKey2;
    module2.exports.MaxKey = MaxKey2;
  }
});

// node_modules/bson/lib/bson/db_ref.js
var require_db_ref = __commonJS({
  "node_modules/bson/lib/bson/db_ref.js"(exports2, module2) {
    function DBRef2(namespace, oid, db) {
      if (!(this instanceof DBRef2))
        return new DBRef2(namespace, oid, db);
      this._bsontype = "DBRef";
      this.namespace = namespace;
      this.oid = oid;
      this.db = db;
    }
    DBRef2.prototype.toJSON = function() {
      return {
        $ref: this.namespace,
        $id: this.oid,
        $db: this.db == null ? "" : this.db
      };
    };
    module2.exports = DBRef2;
    module2.exports.DBRef = DBRef2;
  }
});

// node_modules/bson/lib/bson/binary.js
var require_binary = __commonJS({
  "node_modules/bson/lib/bson/binary.js"(exports2, module2) {
    if (typeof global !== "undefined") {
      Buffer2 = require("buffer").Buffer;
    }
    var Buffer2;
    var utils2 = require_utils3();
    function Binary2(buffer, subType) {
      if (!(this instanceof Binary2))
        return new Binary2(buffer, subType);
      if (buffer != null && !(typeof buffer === "string") && !Buffer2.isBuffer(buffer) && !(buffer instanceof Uint8Array) && !Array.isArray(buffer)) {
        throw new Error("only String, Buffer, Uint8Array or Array accepted");
      }
      this._bsontype = "Binary";
      if (buffer instanceof Number) {
        this.sub_type = buffer;
        this.position = 0;
      } else {
        this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
        this.position = 0;
      }
      if (buffer != null && !(buffer instanceof Number)) {
        if (typeof buffer === "string") {
          if (typeof Buffer2 !== "undefined") {
            this.buffer = utils2.toBuffer(buffer);
          } else if (typeof Uint8Array !== "undefined" || Object.prototype.toString.call(buffer) === "[object Array]") {
            this.buffer = writeStringToArray(buffer);
          } else {
            throw new Error("only String, Buffer, Uint8Array or Array accepted");
          }
        } else {
          this.buffer = buffer;
        }
        this.position = buffer.length;
      } else {
        if (typeof Buffer2 !== "undefined") {
          this.buffer = utils2.allocBuffer(Binary2.BUFFER_SIZE);
        } else if (typeof Uint8Array !== "undefined") {
          this.buffer = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE));
        } else {
          this.buffer = new Array(Binary2.BUFFER_SIZE);
        }
        this.position = 0;
      }
    }
    Binary2.prototype.put = function put(byte_value) {
      if (byte_value["length"] != null && typeof byte_value !== "number" && byte_value.length !== 1)
        throw new Error("only accepts single character String, Uint8Array or Array");
      if (typeof byte_value !== "number" && byte_value < 0 || byte_value > 255)
        throw new Error("only accepts number in a valid unsigned byte range 0-255");
      var decoded_byte = null;
      if (typeof byte_value === "string") {
        decoded_byte = byte_value.charCodeAt(0);
      } else if (byte_value["length"] != null) {
        decoded_byte = byte_value[0];
      } else {
        decoded_byte = byte_value;
      }
      if (this.buffer.length > this.position) {
        this.buffer[this.position++] = decoded_byte;
      } else {
        if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
          var buffer = utils2.allocBuffer(Binary2.BUFFER_SIZE + this.buffer.length);
          this.buffer.copy(buffer, 0, 0, this.buffer.length);
          this.buffer = buffer;
          this.buffer[this.position++] = decoded_byte;
        } else {
          buffer = null;
          if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
            buffer = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE + this.buffer.length));
          } else {
            buffer = new Array(Binary2.BUFFER_SIZE + this.buffer.length);
          }
          for (var i = 0; i < this.buffer.length; i++) {
            buffer[i] = this.buffer[i];
          }
          this.buffer = buffer;
          this.buffer[this.position++] = decoded_byte;
        }
      }
    };
    Binary2.prototype.write = function write(string, offset) {
      offset = typeof offset === "number" ? offset : this.position;
      if (this.buffer.length < offset + string.length) {
        var buffer = null;
        if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
          buffer = utils2.allocBuffer(this.buffer.length + string.length);
          this.buffer.copy(buffer, 0, 0, this.buffer.length);
        } else if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
          buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length));
          for (var i = 0; i < this.position; i++) {
            buffer[i] = this.buffer[i];
          }
        }
        this.buffer = buffer;
      }
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(string) && Buffer2.isBuffer(this.buffer)) {
        string.copy(this.buffer, offset, 0, string.length);
        this.position = offset + string.length > this.position ? offset + string.length : this.position;
      } else if (typeof Buffer2 !== "undefined" && typeof string === "string" && Buffer2.isBuffer(this.buffer)) {
        this.buffer.write(string, offset, "binary");
        this.position = offset + string.length > this.position ? offset + string.length : this.position;
      } else if (Object.prototype.toString.call(string) === "[object Uint8Array]" || Object.prototype.toString.call(string) === "[object Array]" && typeof string !== "string") {
        for (i = 0; i < string.length; i++) {
          this.buffer[offset++] = string[i];
        }
        this.position = offset > this.position ? offset : this.position;
      } else if (typeof string === "string") {
        for (i = 0; i < string.length; i++) {
          this.buffer[offset++] = string.charCodeAt(i);
        }
        this.position = offset > this.position ? offset : this.position;
      }
    };
    Binary2.prototype.read = function read(position, length) {
      length = length && length > 0 ? length : this.position;
      if (this.buffer["slice"]) {
        return this.buffer.slice(position, position + length);
      } else {
        var buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
        for (var i = 0; i < length; i++) {
          buffer[i] = this.buffer[position++];
        }
      }
      return buffer;
    };
    Binary2.prototype.value = function value(asRaw) {
      asRaw = asRaw == null ? false : asRaw;
      if (asRaw && typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer) && this.buffer.length === this.position)
        return this.buffer;
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
        return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString("binary", 0, this.position);
      } else {
        if (asRaw) {
          if (this.buffer["slice"] != null) {
            return this.buffer.slice(0, this.position);
          } else {
            var newBuffer = Object.prototype.toString.call(this.buffer) === "[object Uint8Array]" ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);
            for (var i = 0; i < this.position; i++) {
              newBuffer[i] = this.buffer[i];
            }
            return newBuffer;
          }
        } else {
          return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
        }
      }
    };
    Binary2.prototype.length = function length() {
      return this.position;
    };
    Binary2.prototype.toJSON = function() {
      return this.buffer != null ? this.buffer.toString("base64") : "";
    };
    Binary2.prototype.toString = function(format) {
      return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : "";
    };
    var BSON_BINARY_SUBTYPE_DEFAULT = 0;
    var writeStringToArray = function(data) {
      var buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        buffer[i] = data.charCodeAt(i);
      }
      return buffer;
    };
    var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
      var result = "";
      for (var i = startIndex; i < endIndex; i++) {
        result = result + String.fromCharCode(byteArray[i]);
      }
      return result;
    };
    Binary2.BUFFER_SIZE = 256;
    Binary2.SUBTYPE_DEFAULT = 0;
    Binary2.SUBTYPE_FUNCTION = 1;
    Binary2.SUBTYPE_BYTE_ARRAY = 2;
    Binary2.SUBTYPE_UUID_OLD = 3;
    Binary2.SUBTYPE_UUID = 4;
    Binary2.SUBTYPE_MD5 = 5;
    Binary2.SUBTYPE_USER_DEFINED = 128;
    module2.exports = Binary2;
    module2.exports.Binary = Binary2;
  }
});

// node_modules/bson/lib/bson/parser/deserializer.js
var require_deserializer = __commonJS({
  "node_modules/bson/lib/bson/parser/deserializer.js"(exports, module) {
    "use strict";
    var Long = require_long().Long;
    var Double = require_double().Double;
    var Timestamp = require_timestamp().Timestamp;
    var ObjectID = require_objectid().ObjectID;
    var Symbol = require_symbol().Symbol;
    var Code = require_code().Code;
    var MinKey = require_min_key().MinKey;
    var MaxKey = require_max_key().MaxKey;
    var Decimal128 = require_decimal128();
    var Int32 = require_int_32();
    var DBRef = require_db_ref().DBRef;
    var BSONRegExp = require_regexp().BSONRegExp;
    var Binary = require_binary().Binary;
    var utils = require_utils3();
    var deserialize = function(buffer, options, isArray) {
      options = options == null ? {} : options;
      var index = options && options.index ? options.index : 0;
      var size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
      if (size < 5 || buffer.length < size || size + index > buffer.length) {
        throw new Error("corrupt bson message");
      }
      if (buffer[index + size - 1] !== 0) {
        throw new Error("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
      }
      return deserializeObject(buffer, index, options, isArray);
    };
    var deserializeObject = function(buffer, index, options, isArray) {
      var evalFunctions = options["evalFunctions"] == null ? false : options["evalFunctions"];
      var cacheFunctions = options["cacheFunctions"] == null ? false : options["cacheFunctions"];
      var cacheFunctionsCrc32 = options["cacheFunctionsCrc32"] == null ? false : options["cacheFunctionsCrc32"];
      if (!cacheFunctionsCrc32)
        var crc32 = null;
      var fieldsAsRaw = options["fieldsAsRaw"] == null ? null : options["fieldsAsRaw"];
      var raw = options["raw"] == null ? false : options["raw"];
      var bsonRegExp = typeof options["bsonRegExp"] === "boolean" ? options["bsonRegExp"] : false;
      var promoteBuffers = options["promoteBuffers"] == null ? false : options["promoteBuffers"];
      var promoteLongs = options["promoteLongs"] == null ? true : options["promoteLongs"];
      var promoteValues = options["promoteValues"] == null ? true : options["promoteValues"];
      var startIndex = index;
      if (buffer.length < 5)
        throw new Error("corrupt bson message < 5 bytes long");
      var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      if (size < 5 || size > buffer.length)
        throw new Error("corrupt bson message");
      var object = isArray ? [] : {};
      var arrayIndex = 0;
      var done = false;
      while (!done) {
        var elementType = buffer[index++];
        if (elementType === 0)
          break;
        var i = index;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error("Bad BSON Document: illegal CString");
        var name = isArray ? arrayIndex++ : buffer.toString("utf8", index, i);
        index = i + 1;
        if (elementType === BSON.BSON_DATA_STRING) {
          var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          object[name] = buffer.toString("utf8", index, index + stringSize - 1);
          index = index + stringSize;
        } else if (elementType === BSON.BSON_DATA_OID) {
          var oid = utils.allocBuffer(12);
          buffer.copy(oid, 0, index, index + 12);
          object[name] = new ObjectID(oid);
          index = index + 12;
        } else if (elementType === BSON.BSON_DATA_INT && promoteValues === false) {
          object[name] = new Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);
        } else if (elementType === BSON.BSON_DATA_INT) {
          object[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        } else if (elementType === BSON.BSON_DATA_NUMBER && promoteValues === false) {
          object[name] = new Double(buffer.readDoubleLE(index));
          index = index + 8;
        } else if (elementType === BSON.BSON_DATA_NUMBER) {
          object[name] = buffer.readDoubleLE(index);
          index = index + 8;
        } else if (elementType === BSON.BSON_DATA_DATE) {
          var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          object[name] = new Date(new Long(lowBits, highBits).toNumber());
        } else if (elementType === BSON.BSON_DATA_BOOLEAN) {
          if (buffer[index] !== 0 && buffer[index] !== 1)
            throw new Error("illegal boolean type value");
          object[name] = buffer[index++] === 1;
        } else if (elementType === BSON.BSON_DATA_OBJECT) {
          var _index = index;
          var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
          if (objectSize <= 0 || objectSize > buffer.length - index)
            throw new Error("bad embedded document length in bson");
          if (raw) {
            object[name] = buffer.slice(index, index + objectSize);
          } else {
            object[name] = deserializeObject(buffer, _index, options, false);
          }
          index = index + objectSize;
        } else if (elementType === BSON.BSON_DATA_ARRAY) {
          _index = index;
          objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
          var arrayOptions = options;
          var stopIndex = index + objectSize;
          if (fieldsAsRaw && fieldsAsRaw[name]) {
            arrayOptions = {};
            for (var n in options)
              arrayOptions[n] = options[n];
            arrayOptions["raw"] = true;
          }
          object[name] = deserializeObject(buffer, _index, arrayOptions, true);
          index = index + objectSize;
          if (buffer[index - 1] !== 0)
            throw new Error("invalid array terminator byte");
          if (index !== stopIndex)
            throw new Error("corrupted array bson");
        } else if (elementType === BSON.BSON_DATA_UNDEFINED) {
          object[name] = void 0;
        } else if (elementType === BSON.BSON_DATA_NULL) {
          object[name] = null;
        } else if (elementType === BSON.BSON_DATA_LONG) {
          lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var long = new Long(lowBits, highBits);
          if (promoteLongs && promoteValues === true) {
            object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
          } else {
            object[name] = long;
          }
        } else if (elementType === BSON.BSON_DATA_DECIMAL128) {
          var bytes = utils.allocBuffer(16);
          buffer.copy(bytes, 0, index, index + 16);
          index = index + 16;
          var decimal128 = new Decimal128(bytes);
          object[name] = decimal128.toObject ? decimal128.toObject() : decimal128;
        } else if (elementType === BSON.BSON_DATA_BINARY) {
          var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var totalBinarySize = binarySize;
          var subType = buffer[index++];
          if (binarySize < 0)
            throw new Error("Negative binary type element size found");
          if (binarySize > buffer.length)
            throw new Error("Binary type size larger than document size");
          if (buffer["slice"] != null) {
            if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
              if (binarySize < 0)
                throw new Error("Negative binary type element size found for subtype 0x02");
              if (binarySize > totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to long binary size");
              if (binarySize < totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to short binary size");
            }
            if (promoteBuffers && promoteValues) {
              object[name] = buffer.slice(index, index + binarySize);
            } else {
              object[name] = new Binary(buffer.slice(index, index + binarySize), subType);
            }
          } else {
            var _buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);
            if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
              if (binarySize < 0)
                throw new Error("Negative binary type element size found for subtype 0x02");
              if (binarySize > totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to long binary size");
              if (binarySize < totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to short binary size");
            }
            for (i = 0; i < binarySize; i++) {
              _buffer[i] = buffer[index + i];
            }
            if (promoteBuffers && promoteValues) {
              object[name] = _buffer;
            } else {
              object[name] = new Binary(_buffer, subType);
            }
          }
          index = index + binarySize;
        } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === false) {
          i = index;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          var source = buffer.toString("utf8", index, i);
          index = i + 1;
          i = index;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          var regExpOptions = buffer.toString("utf8", index, i);
          index = i + 1;
          var optionsArray = new Array(regExpOptions.length);
          for (i = 0; i < regExpOptions.length; i++) {
            switch (regExpOptions[i]) {
              case "m":
                optionsArray[i] = "m";
                break;
              case "s":
                optionsArray[i] = "g";
                break;
              case "i":
                optionsArray[i] = "i";
                break;
            }
          }
          object[name] = new RegExp(source, optionsArray.join(""));
        } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === true) {
          i = index;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          source = buffer.toString("utf8", index, i);
          index = i + 1;
          i = index;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          regExpOptions = buffer.toString("utf8", index, i);
          index = i + 1;
          object[name] = new BSONRegExp(source, regExpOptions);
        } else if (elementType === BSON.BSON_DATA_SYMBOL) {
          stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          object[name] = new Symbol(buffer.toString("utf8", index, index + stringSize - 1));
          index = index + stringSize;
        } else if (elementType === BSON.BSON_DATA_TIMESTAMP) {
          lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          object[name] = new Timestamp(lowBits, highBits);
        } else if (elementType === BSON.BSON_DATA_MIN_KEY) {
          object[name] = new MinKey();
        } else if (elementType === BSON.BSON_DATA_MAX_KEY) {
          object[name] = new MaxKey();
        } else if (elementType === BSON.BSON_DATA_CODE) {
          stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          var functionString = buffer.toString("utf8", index, index + stringSize - 1);
          if (evalFunctions) {
            if (cacheFunctions) {
              var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
              object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
            } else {
              object[name] = isolateEval(functionString);
            }
          } else {
            object[name] = new Code(functionString);
          }
          index = index + stringSize;
        } else if (elementType === BSON.BSON_DATA_CODE_W_SCOPE) {
          var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (totalSize < 4 + 4 + 4 + 1) {
            throw new Error("code_w_scope total size shorter minimum expected length");
          }
          stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          functionString = buffer.toString("utf8", index, index + stringSize - 1);
          index = index + stringSize;
          _index = index;
          objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
          var scopeObject = deserializeObject(buffer, _index, options, false);
          index = index + objectSize;
          if (totalSize < 4 + 4 + objectSize + stringSize) {
            throw new Error("code_w_scope total size is to short, truncating scope");
          }
          if (totalSize > 4 + 4 + objectSize + stringSize) {
            throw new Error("code_w_scope total size is to long, clips outer document");
          }
          if (evalFunctions) {
            if (cacheFunctions) {
              hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
              object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
            } else {
              object[name] = isolateEval(functionString);
            }
            object[name].scope = scopeObject;
          } else {
            object[name] = new Code(functionString, scopeObject);
          }
        } else if (elementType === BSON.BSON_DATA_DBPOINTER) {
          stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          var namespace = buffer.toString("utf8", index, index + stringSize - 1);
          index = index + stringSize;
          var oidBuffer = utils.allocBuffer(12);
          buffer.copy(oidBuffer, 0, index, index + 12);
          oid = new ObjectID(oidBuffer);
          index = index + 12;
          var parts = namespace.split(".");
          var db = parts.shift();
          var collection = parts.join(".");
          object[name] = new DBRef(collection, oid, db);
        } else {
          throw new Error("Detected unknown BSON type " + elementType.toString(16) + ' for fieldname "' + name + '", are you using the latest BSON parser');
        }
      }
      if (size !== index - startIndex) {
        if (isArray)
          throw new Error("corrupt array bson");
        throw new Error("corrupt object bson");
      }
      if (object["$id"] != null)
        object = new DBRef(object["$ref"], object["$id"], object["$db"]);
      return object;
    };
    var isolateEvalWithHash = function(functionCache, hash, functionString, object) {
      var value = null;
      if (functionCache[hash] == null) {
        eval("value = " + functionString);
        functionCache[hash] = value;
      }
      return functionCache[hash].bind(object);
    };
    var isolateEval = function(functionString) {
      var value = null;
      eval("value = " + functionString);
      return value;
    };
    var BSON = {};
    var functionCache = BSON.functionCache = {};
    BSON.BSON_DATA_NUMBER = 1;
    BSON.BSON_DATA_STRING = 2;
    BSON.BSON_DATA_OBJECT = 3;
    BSON.BSON_DATA_ARRAY = 4;
    BSON.BSON_DATA_BINARY = 5;
    BSON.BSON_DATA_UNDEFINED = 6;
    BSON.BSON_DATA_OID = 7;
    BSON.BSON_DATA_BOOLEAN = 8;
    BSON.BSON_DATA_DATE = 9;
    BSON.BSON_DATA_NULL = 10;
    BSON.BSON_DATA_REGEXP = 11;
    BSON.BSON_DATA_DBPOINTER = 12;
    BSON.BSON_DATA_CODE = 13;
    BSON.BSON_DATA_SYMBOL = 14;
    BSON.BSON_DATA_CODE_W_SCOPE = 15;
    BSON.BSON_DATA_INT = 16;
    BSON.BSON_DATA_TIMESTAMP = 17;
    BSON.BSON_DATA_LONG = 18;
    BSON.BSON_DATA_DECIMAL128 = 19;
    BSON.BSON_DATA_MIN_KEY = 255;
    BSON.BSON_DATA_MAX_KEY = 127;
    BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    BSON.BSON_INT32_MAX = 2147483647;
    BSON.BSON_INT32_MIN = -2147483648;
    BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON.JS_INT_MAX = 9007199254740992;
    BSON.JS_INT_MIN = -9007199254740992;
    var JS_INT_MAX_LONG = Long.fromNumber(9007199254740992);
    var JS_INT_MIN_LONG = Long.fromNumber(-9007199254740992);
    module.exports = deserialize;
  }
});

// node_modules/bson/lib/bson/float_parser.js
var require_float_parser = __commonJS({
  "node_modules/bson/lib/bson/float_parser.js"(exports2) {
    var readIEEE754 = function(buffer, offset, endian, mLen, nBytes) {
      var e, m, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = bBE ? 0 : nBytes - 1, d = bBE ? 1 : -1, s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8)
        ;
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8)
        ;
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    var writeIEEE754 = function(buffer, value, offset, endian, mLen, nBytes) {
      var e, m, c, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = bBE ? nBytes - 1 : 0, d = bBE ? -1 : 1, s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8)
        ;
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8)
        ;
      buffer[offset + i - d] |= s * 128;
    };
    exports2.readIEEE754 = readIEEE754;
    exports2.writeIEEE754 = writeIEEE754;
  }
});

// node_modules/bson/lib/bson/parser/serializer.js
var require_serializer = __commonJS({
  "node_modules/bson/lib/bson/parser/serializer.js"(exports2, module2) {
    "use strict";
    var writeIEEE754 = require_float_parser().writeIEEE754;
    var Long2 = require_long().Long;
    var Map2 = require_map();
    var Binary2 = require_binary().Binary;
    var normalizedFunctionString = require_utils3().normalizedFunctionString;
    var regexp = /\x00/;
    var ignoreKeys = ["$db", "$ref", "$id", "$clusterTime"];
    var isDate = function isDate2(d) {
      return typeof d === "object" && Object.prototype.toString.call(d) === "[object Date]";
    };
    var isRegExp = function isRegExp2(d) {
      return Object.prototype.toString.call(d) === "[object RegExp]";
    };
    var serializeString = function(buffer, key, value, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_STRING;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes + 1;
      buffer[index - 1] = 0;
      var size = buffer.write(value, index + 4, "utf8");
      buffer[index + 3] = size + 1 >> 24 & 255;
      buffer[index + 2] = size + 1 >> 16 & 255;
      buffer[index + 1] = size + 1 >> 8 & 255;
      buffer[index] = size + 1 & 255;
      index = index + 4 + size;
      buffer[index++] = 0;
      return index;
    };
    var serializeNumber = function(buffer, key, value, index, isArray) {
      if (Math.floor(value) === value && value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
        if (value >= BSON2.BSON_INT32_MIN && value <= BSON2.BSON_INT32_MAX) {
          buffer[index++] = BSON2.BSON_DATA_INT;
          var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
          index = index + numberOfWrittenBytes;
          buffer[index++] = 0;
          buffer[index++] = value & 255;
          buffer[index++] = value >> 8 & 255;
          buffer[index++] = value >> 16 & 255;
          buffer[index++] = value >> 24 & 255;
        } else if (value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
          buffer[index++] = BSON2.BSON_DATA_NUMBER;
          numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
          index = index + numberOfWrittenBytes;
          buffer[index++] = 0;
          writeIEEE754(buffer, value, index, "little", 52, 8);
          index = index + 8;
        } else {
          buffer[index++] = BSON2.BSON_DATA_LONG;
          numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
          index = index + numberOfWrittenBytes;
          buffer[index++] = 0;
          var longVal = Long2.fromNumber(value);
          var lowBits = longVal.getLowBits();
          var highBits = longVal.getHighBits();
          buffer[index++] = lowBits & 255;
          buffer[index++] = lowBits >> 8 & 255;
          buffer[index++] = lowBits >> 16 & 255;
          buffer[index++] = lowBits >> 24 & 255;
          buffer[index++] = highBits & 255;
          buffer[index++] = highBits >> 8 & 255;
          buffer[index++] = highBits >> 16 & 255;
          buffer[index++] = highBits >> 24 & 255;
        }
      } else {
        buffer[index++] = BSON2.BSON_DATA_NUMBER;
        numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        writeIEEE754(buffer, value, index, "little", 52, 8);
        index = index + 8;
      }
      return index;
    };
    var serializeNull = function(buffer, key, value, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_NULL;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      return index;
    };
    var serializeBoolean = function(buffer, key, value, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_BOOLEAN;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      buffer[index++] = value ? 1 : 0;
      return index;
    };
    var serializeDate = function(buffer, key, value, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_DATE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var dateInMilis = Long2.fromNumber(value.getTime());
      var lowBits = dateInMilis.getLowBits();
      var highBits = dateInMilis.getHighBits();
      buffer[index++] = lowBits & 255;
      buffer[index++] = lowBits >> 8 & 255;
      buffer[index++] = lowBits >> 16 & 255;
      buffer[index++] = lowBits >> 24 & 255;
      buffer[index++] = highBits & 255;
      buffer[index++] = highBits >> 8 & 255;
      buffer[index++] = highBits >> 16 & 255;
      buffer[index++] = highBits >> 24 & 255;
      return index;
    };
    var serializeRegExp = function(buffer, key, value, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      if (value.source && value.source.match(regexp) != null) {
        throw Error("value " + value.source + " must not contain null bytes");
      }
      index = index + buffer.write(value.source, index, "utf8");
      buffer[index++] = 0;
      if (value.global)
        buffer[index++] = 115;
      if (value.ignoreCase)
        buffer[index++] = 105;
      if (value.multiline)
        buffer[index++] = 109;
      buffer[index++] = 0;
      return index;
    };
    var serializeBSONRegExp = function(buffer, key, value, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      if (value.pattern.match(regexp) != null) {
        throw Error("pattern " + value.pattern + " must not contain null bytes");
      }
      index = index + buffer.write(value.pattern, index, "utf8");
      buffer[index++] = 0;
      index = index + buffer.write(value.options.split("").sort().join(""), index, "utf8");
      buffer[index++] = 0;
      return index;
    };
    var serializeMinMax = function(buffer, key, value, index, isArray) {
      if (value === null) {
        buffer[index++] = BSON2.BSON_DATA_NULL;
      } else if (value._bsontype === "MinKey") {
        buffer[index++] = BSON2.BSON_DATA_MIN_KEY;
      } else {
        buffer[index++] = BSON2.BSON_DATA_MAX_KEY;
      }
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      return index;
    };
    var serializeObjectId = function(buffer, key, value, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_OID;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      if (typeof value.id === "string") {
        buffer.write(value.id, index, "binary");
      } else if (value.id && value.id.copy) {
        value.id.copy(buffer, index, 0, 12);
      } else {
        throw new Error("object [" + JSON.stringify(value) + "] is not a valid ObjectId");
      }
      return index + 12;
    };
    var serializeBuffer = function(buffer, key, value, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var size = value.length;
      buffer[index++] = size & 255;
      buffer[index++] = size >> 8 & 255;
      buffer[index++] = size >> 16 & 255;
      buffer[index++] = size >> 24 & 255;
      buffer[index++] = BSON2.BSON_BINARY_SUBTYPE_DEFAULT;
      value.copy(buffer, index, 0, size);
      index = index + size;
      return index;
    };
    var serializeObject = function(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {
      for (var i = 0; i < path.length; i++) {
        if (path[i] === value)
          throw new Error("cyclic dependency detected");
      }
      path.push(value);
      buffer[index++] = Array.isArray(value) ? BSON2.BSON_DATA_ARRAY : BSON2.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
      path.pop();
      return endIndex;
    };
    var serializeDecimal128 = function(buffer, key, value, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_DECIMAL128;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      value.bytes.copy(buffer, index, 0, 16);
      return index + 16;
    };
    var serializeLong = function(buffer, key, value, index, isArray) {
      buffer[index++] = value._bsontype === "Long" ? BSON2.BSON_DATA_LONG : BSON2.BSON_DATA_TIMESTAMP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var lowBits = value.getLowBits();
      var highBits = value.getHighBits();
      buffer[index++] = lowBits & 255;
      buffer[index++] = lowBits >> 8 & 255;
      buffer[index++] = lowBits >> 16 & 255;
      buffer[index++] = lowBits >> 24 & 255;
      buffer[index++] = highBits & 255;
      buffer[index++] = highBits >> 8 & 255;
      buffer[index++] = highBits >> 16 & 255;
      buffer[index++] = highBits >> 24 & 255;
      return index;
    };
    var serializeInt32 = function(buffer, key, value, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_INT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      buffer[index++] = value & 255;
      buffer[index++] = value >> 8 & 255;
      buffer[index++] = value >> 16 & 255;
      buffer[index++] = value >> 24 & 255;
      return index;
    };
    var serializeDouble = function(buffer, key, value, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_NUMBER;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      writeIEEE754(buffer, value, index, "little", 52, 8);
      index = index + 8;
      return index;
    };
    var serializeFunction = function(buffer, key, value, index, checkKeys, depth, isArray) {
      buffer[index++] = BSON2.BSON_DATA_CODE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var functionString = normalizedFunctionString(value);
      var size = buffer.write(functionString, index + 4, "utf8") + 1;
      buffer[index] = size & 255;
      buffer[index + 1] = size >> 8 & 255;
      buffer[index + 2] = size >> 16 & 255;
      buffer[index + 3] = size >> 24 & 255;
      index = index + 4 + size - 1;
      buffer[index++] = 0;
      return index;
    };
    var serializeCode = function(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {
      if (value.scope && typeof value.scope === "object") {
        buffer[index++] = BSON2.BSON_DATA_CODE_W_SCOPE;
        var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        var startIndex = index;
        var functionString = typeof value.code === "string" ? value.code : value.code.toString();
        index = index + 4;
        var codeSize = buffer.write(functionString, index + 4, "utf8") + 1;
        buffer[index] = codeSize & 255;
        buffer[index + 1] = codeSize >> 8 & 255;
        buffer[index + 2] = codeSize >> 16 & 255;
        buffer[index + 3] = codeSize >> 24 & 255;
        buffer[index + 4 + codeSize - 1] = 0;
        index = index + codeSize + 4;
        var endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined);
        index = endIndex - 1;
        var totalSize = endIndex - startIndex;
        buffer[startIndex++] = totalSize & 255;
        buffer[startIndex++] = totalSize >> 8 & 255;
        buffer[startIndex++] = totalSize >> 16 & 255;
        buffer[startIndex++] = totalSize >> 24 & 255;
        buffer[index++] = 0;
      } else {
        buffer[index++] = BSON2.BSON_DATA_CODE;
        numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        functionString = value.code.toString();
        var size = buffer.write(functionString, index + 4, "utf8") + 1;
        buffer[index] = size & 255;
        buffer[index + 1] = size >> 8 & 255;
        buffer[index + 2] = size >> 16 & 255;
        buffer[index + 3] = size >> 24 & 255;
        index = index + 4 + size - 1;
        buffer[index++] = 0;
      }
      return index;
    };
    var serializeBinary = function(buffer, key, value, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var data = value.value(true);
      var size = value.position;
      if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY)
        size = size + 4;
      buffer[index++] = size & 255;
      buffer[index++] = size >> 8 & 255;
      buffer[index++] = size >> 16 & 255;
      buffer[index++] = size >> 24 & 255;
      buffer[index++] = value.sub_type;
      if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
        size = size - 4;
        buffer[index++] = size & 255;
        buffer[index++] = size >> 8 & 255;
        buffer[index++] = size >> 16 & 255;
        buffer[index++] = size >> 24 & 255;
      }
      data.copy(buffer, index, 0, value.position);
      index = index + value.position;
      return index;
    };
    var serializeSymbol = function(buffer, key, value, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_SYMBOL;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var size = buffer.write(value.value, index + 4, "utf8") + 1;
      buffer[index] = size & 255;
      buffer[index + 1] = size >> 8 & 255;
      buffer[index + 2] = size >> 16 & 255;
      buffer[index + 3] = size >> 24 & 255;
      index = index + 4 + size - 1;
      buffer[index++] = 0;
      return index;
    };
    var serializeDBRef = function(buffer, key, value, index, depth, serializeFunctions, isArray) {
      buffer[index++] = BSON2.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var startIndex = index;
      var endIndex;
      if (value.db != null) {
        endIndex = serializeInto(buffer, {
          $ref: value.namespace,
          $id: value.oid,
          $db: value.db
        }, false, index, depth + 1, serializeFunctions);
      } else {
        endIndex = serializeInto(buffer, {
          $ref: value.namespace,
          $id: value.oid
        }, false, index, depth + 1, serializeFunctions);
      }
      var size = endIndex - startIndex;
      buffer[startIndex++] = size & 255;
      buffer[startIndex++] = size >> 8 & 255;
      buffer[startIndex++] = size >> 16 & 255;
      buffer[startIndex++] = size >> 24 & 255;
      return endIndex;
    };
    var serializeInto = function serializeInto2(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
      startingIndex = startingIndex || 0;
      path = path || [];
      path.push(object);
      var index = startingIndex + 4;
      if (Array.isArray(object)) {
        for (var i = 0; i < object.length; i++) {
          var key = "" + i;
          var value = object[i];
          if (value && value.toBSON) {
            if (typeof value.toBSON !== "function")
              throw new Error("toBSON is not a function");
            value = value.toBSON();
          }
          var type = typeof value;
          if (type === "string") {
            index = serializeString(buffer, key, value, index, true);
          } else if (type === "number") {
            index = serializeNumber(buffer, key, value, index, true);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index = serializeBoolean(buffer, key, value, index, true);
          } else if (value instanceof Date || isDate(value)) {
            index = serializeDate(buffer, key, value, index, true);
          } else if (value === void 0) {
            index = serializeNull(buffer, key, value, index, true);
          } else if (value === null) {
            index = serializeNull(buffer, key, value, index, true);
          } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            index = serializeObjectId(buffer, key, value, index, true);
          } else if (Buffer.isBuffer(value)) {
            index = serializeBuffer(buffer, key, value, index, true);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index = serializeRegExp(buffer, key, value, index, true);
          } else if (type === "object" && value["_bsontype"] == null) {
            index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index = serializeDecimal128(buffer, key, value, index, true);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index = serializeLong(buffer, key, value, index, true);
          } else if (value["_bsontype"] === "Double") {
            index = serializeDouble(buffer, key, value, index, true);
          } else if (typeof value === "function" && serializeFunctions) {
            index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions, true);
          } else if (value["_bsontype"] === "Code") {
            index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true);
          } else if (value["_bsontype"] === "Binary") {
            index = serializeBinary(buffer, key, value, index, true);
          } else if (value["_bsontype"] === "Symbol") {
            index = serializeSymbol(buffer, key, value, index, true);
          } else if (value["_bsontype"] === "DBRef") {
            index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, true);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index = serializeBSONRegExp(buffer, key, value, index, true);
          } else if (value["_bsontype"] === "Int32") {
            index = serializeInt32(buffer, key, value, index, true);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index = serializeMinMax(buffer, key, value, index, true);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
          }
        }
      } else if (object instanceof Map2) {
        var iterator = object.entries();
        var done = false;
        while (!done) {
          var entry = iterator.next();
          done = entry.done;
          if (done)
            continue;
          key = entry.value[0];
          value = entry.value[1];
          type = typeof value;
          if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if (key[0] === "$") {
                throw Error("key " + key + " must not start with '$'");
              } else if (~key.indexOf(".")) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type === "string") {
            index = serializeString(buffer, key, value, index);
          } else if (type === "number") {
            index = serializeNumber(buffer, key, value, index);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index = serializeBoolean(buffer, key, value, index);
          } else if (value instanceof Date || isDate(value)) {
            index = serializeDate(buffer, key, value, index);
          } else if (value === null || value === void 0 && ignoreUndefined === false) {
            index = serializeNull(buffer, key, value, index);
          } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            index = serializeObjectId(buffer, key, value, index);
          } else if (Buffer.isBuffer(value)) {
            index = serializeBuffer(buffer, key, value, index);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index = serializeRegExp(buffer, key, value, index);
          } else if (type === "object" && value["_bsontype"] == null) {
            index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index = serializeDecimal128(buffer, key, value, index);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index = serializeLong(buffer, key, value, index);
          } else if (value["_bsontype"] === "Double") {
            index = serializeDouble(buffer, key, value, index);
          } else if (value["_bsontype"] === "Code") {
            index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
          } else if (typeof value === "function" && serializeFunctions) {
            index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
          } else if (value["_bsontype"] === "Binary") {
            index = serializeBinary(buffer, key, value, index);
          } else if (value["_bsontype"] === "Symbol") {
            index = serializeSymbol(buffer, key, value, index);
          } else if (value["_bsontype"] === "DBRef") {
            index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index = serializeBSONRegExp(buffer, key, value, index);
          } else if (value["_bsontype"] === "Int32") {
            index = serializeInt32(buffer, key, value, index);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index = serializeMinMax(buffer, key, value, index);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
          }
        }
      } else {
        if (object.toBSON) {
          if (typeof object.toBSON !== "function")
            throw new Error("toBSON is not a function");
          object = object.toBSON();
          if (object != null && typeof object !== "object")
            throw new Error("toBSON function did not return an object");
        }
        for (key in object) {
          value = object[key];
          if (value && value.toBSON) {
            if (typeof value.toBSON !== "function")
              throw new Error("toBSON is not a function");
            value = value.toBSON();
          }
          type = typeof value;
          if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if (key[0] === "$") {
                throw Error("key " + key + " must not start with '$'");
              } else if (~key.indexOf(".")) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type === "string") {
            index = serializeString(buffer, key, value, index);
          } else if (type === "number") {
            index = serializeNumber(buffer, key, value, index);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index = serializeBoolean(buffer, key, value, index);
          } else if (value instanceof Date || isDate(value)) {
            index = serializeDate(buffer, key, value, index);
          } else if (value === void 0) {
            if (ignoreUndefined === false)
              index = serializeNull(buffer, key, value, index);
          } else if (value === null) {
            index = serializeNull(buffer, key, value, index);
          } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            index = serializeObjectId(buffer, key, value, index);
          } else if (Buffer.isBuffer(value)) {
            index = serializeBuffer(buffer, key, value, index);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index = serializeRegExp(buffer, key, value, index);
          } else if (type === "object" && value["_bsontype"] == null) {
            index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index = serializeDecimal128(buffer, key, value, index);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index = serializeLong(buffer, key, value, index);
          } else if (value["_bsontype"] === "Double") {
            index = serializeDouble(buffer, key, value, index);
          } else if (value["_bsontype"] === "Code") {
            index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
          } else if (typeof value === "function" && serializeFunctions) {
            index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
          } else if (value["_bsontype"] === "Binary") {
            index = serializeBinary(buffer, key, value, index);
          } else if (value["_bsontype"] === "Symbol") {
            index = serializeSymbol(buffer, key, value, index);
          } else if (value["_bsontype"] === "DBRef") {
            index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index = serializeBSONRegExp(buffer, key, value, index);
          } else if (value["_bsontype"] === "Int32") {
            index = serializeInt32(buffer, key, value, index);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index = serializeMinMax(buffer, key, value, index);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
          }
        }
      }
      path.pop();
      buffer[index++] = 0;
      var size = index - startingIndex;
      buffer[startingIndex++] = size & 255;
      buffer[startingIndex++] = size >> 8 & 255;
      buffer[startingIndex++] = size >> 16 & 255;
      buffer[startingIndex++] = size >> 24 & 255;
      return index;
    };
    var BSON2 = {};
    BSON2.BSON_DATA_NUMBER = 1;
    BSON2.BSON_DATA_STRING = 2;
    BSON2.BSON_DATA_OBJECT = 3;
    BSON2.BSON_DATA_ARRAY = 4;
    BSON2.BSON_DATA_BINARY = 5;
    BSON2.BSON_DATA_UNDEFINED = 6;
    BSON2.BSON_DATA_OID = 7;
    BSON2.BSON_DATA_BOOLEAN = 8;
    BSON2.BSON_DATA_DATE = 9;
    BSON2.BSON_DATA_NULL = 10;
    BSON2.BSON_DATA_REGEXP = 11;
    BSON2.BSON_DATA_CODE = 13;
    BSON2.BSON_DATA_SYMBOL = 14;
    BSON2.BSON_DATA_CODE_W_SCOPE = 15;
    BSON2.BSON_DATA_INT = 16;
    BSON2.BSON_DATA_TIMESTAMP = 17;
    BSON2.BSON_DATA_LONG = 18;
    BSON2.BSON_DATA_DECIMAL128 = 19;
    BSON2.BSON_DATA_MIN_KEY = 255;
    BSON2.BSON_DATA_MAX_KEY = 127;
    BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    module2.exports = serializeInto;
  }
});

// node_modules/bson/lib/bson/parser/calculate_size.js
var require_calculate_size = __commonJS({
  "node_modules/bson/lib/bson/parser/calculate_size.js"(exports2, module2) {
    "use strict";
    var Long2 = require_long().Long;
    var Double2 = require_double().Double;
    var Timestamp2 = require_timestamp().Timestamp;
    var ObjectID2 = require_objectid().ObjectID;
    var Symbol2 = require_symbol().Symbol;
    var BSONRegExp2 = require_regexp().BSONRegExp;
    var Code2 = require_code().Code;
    var Decimal1282 = require_decimal128();
    var MinKey2 = require_min_key().MinKey;
    var MaxKey2 = require_max_key().MaxKey;
    var DBRef2 = require_db_ref().DBRef;
    var Binary2 = require_binary().Binary;
    var normalizedFunctionString = require_utils3().normalizedFunctionString;
    var isDate = function isDate2(d) {
      return typeof d === "object" && Object.prototype.toString.call(d) === "[object Date]";
    };
    var calculateObjectSize = function calculateObjectSize2(object, serializeFunctions, ignoreUndefined) {
      var totalLength = 4 + 1;
      if (Array.isArray(object)) {
        for (var i = 0; i < object.length; i++) {
          totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
        }
      } else {
        if (object.toBSON) {
          object = object.toBSON();
        }
        for (var key in object) {
          totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
        }
      }
      return totalLength;
    };
    function calculateElement(name, value, serializeFunctions, isArray, ignoreUndefined) {
      if (value && value.toBSON) {
        value = value.toBSON();
      }
      switch (typeof value) {
        case "string":
          return 1 + Buffer.byteLength(name, "utf8") + 1 + 4 + Buffer.byteLength(value, "utf8") + 1;
        case "number":
          if (Math.floor(value) === value && value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
            if (value >= BSON2.BSON_INT32_MIN && value <= BSON2.BSON_INT32_MAX) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (4 + 1);
            } else {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
            }
          } else {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          }
        case "undefined":
          if (isArray || !ignoreUndefined)
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1;
          return 0;
        case "boolean":
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 1);
        case "object":
          if (value == null || value instanceof MinKey2 || value instanceof MaxKey2 || value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1;
          } else if (value instanceof ObjectID2 || value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (12 + 1);
          } else if (value instanceof Date || isDate(value)) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          } else if (typeof Buffer !== "undefined" && Buffer.isBuffer(value)) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 4 + 1) + value.length;
          } else if (value instanceof Long2 || value instanceof Double2 || value instanceof Timestamp2 || value["_bsontype"] === "Long" || value["_bsontype"] === "Double" || value["_bsontype"] === "Timestamp") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          } else if (value instanceof Decimal1282 || value["_bsontype"] === "Decimal128") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (16 + 1);
          } else if (value instanceof Code2 || value["_bsontype"] === "Code") {
            if (value.scope != null && Object.keys(value.scope).length > 0) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(value.code.toString(), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(value.code.toString(), "utf8") + 1;
            }
          } else if (value instanceof Binary2 || value["_bsontype"] === "Binary") {
            if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1 + 4);
            } else {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1);
            }
          } else if (value instanceof Symbol2 || value["_bsontype"] === "Symbol") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + Buffer.byteLength(value.value, "utf8") + 4 + 1 + 1;
          } else if (value instanceof DBRef2 || value["_bsontype"] === "DBRef") {
            var ordered_values = {
              $ref: value.namespace,
              $id: value.oid
            };
            if (value.db != null) {
              ordered_values["$db"] = value.db;
            }
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + calculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
          } else if (value instanceof RegExp || Object.prototype.toString.call(value) === "[object RegExp]") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else if (value instanceof BSONRegExp2 || value["_bsontype"] === "BSONRegExp") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.pattern, "utf8") + 1 + Buffer.byteLength(value.options, "utf8") + 1;
          } else {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + calculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
          }
        case "function":
          if (value instanceof RegExp || Object.prototype.toString.call(value) === "[object RegExp]" || String.call(value) === "[object RegExp]") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else {
            if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(normalizedFunctionString(value), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else if (serializeFunctions) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(normalizedFunctionString(value), "utf8") + 1;
            }
          }
      }
      return 0;
    }
    var BSON2 = {};
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    module2.exports = calculateObjectSize;
  }
});

// node_modules/bson/lib/bson/bson.js
var require_bson = __commonJS({
  "node_modules/bson/lib/bson/bson.js"(exports2, module2) {
    "use strict";
    var Map2 = require_map();
    var Long2 = require_long();
    var Double2 = require_double();
    var Timestamp2 = require_timestamp();
    var ObjectID2 = require_objectid();
    var BSONRegExp2 = require_regexp();
    var Symbol2 = require_symbol();
    var Int322 = require_int_32();
    var Code2 = require_code();
    var Decimal1282 = require_decimal128();
    var MinKey2 = require_min_key();
    var MaxKey2 = require_max_key();
    var DBRef2 = require_db_ref();
    var Binary2 = require_binary();
    var deserialize2 = require_deserializer();
    var serializer = require_serializer();
    var calculateObjectSize = require_calculate_size();
    var utils2 = require_utils3();
    var MAXSIZE = 1024 * 1024 * 17;
    var buffer = utils2.allocBuffer(MAXSIZE);
    var BSON2 = function() {
    };
    BSON2.prototype.serialize = function serialize(object, options) {
      options = options || {};
      var checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
      var minInternalBufferSize = typeof options.minInternalBufferSize === "number" ? options.minInternalBufferSize : MAXSIZE;
      if (buffer.length < minInternalBufferSize) {
        buffer = utils2.allocBuffer(minInternalBufferSize);
      }
      var serializationIndex = serializer(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []);
      var finishedBuffer = utils2.allocBuffer(serializationIndex);
      buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);
      return finishedBuffer;
    };
    BSON2.prototype.serializeWithBufferAndIndex = function(object, finalBuffer, options) {
      options = options || {};
      var checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
      var startIndex = typeof options.index === "number" ? options.index : 0;
      var serializationIndex = serializer(finalBuffer, object, checkKeys, startIndex || 0, 0, serializeFunctions, ignoreUndefined);
      return serializationIndex - 1;
    };
    BSON2.prototype.deserialize = function(buffer2, options) {
      return deserialize2(buffer2, options);
    };
    BSON2.prototype.calculateObjectSize = function(object, options) {
      options = options || {};
      var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
      return calculateObjectSize(object, serializeFunctions, ignoreUndefined);
    };
    BSON2.prototype.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
      options = options != null ? options : {};
      var index = startIndex;
      for (var i = 0; i < numberOfDocuments; i++) {
        var size = data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24;
        options["index"] = index;
        documents[docStartIndex + i] = this.deserialize(data, options);
        index = index + size;
      }
      return index;
    };
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    BSON2.BSON_DATA_NUMBER = 1;
    BSON2.BSON_DATA_STRING = 2;
    BSON2.BSON_DATA_OBJECT = 3;
    BSON2.BSON_DATA_ARRAY = 4;
    BSON2.BSON_DATA_BINARY = 5;
    BSON2.BSON_DATA_OID = 7;
    BSON2.BSON_DATA_BOOLEAN = 8;
    BSON2.BSON_DATA_DATE = 9;
    BSON2.BSON_DATA_NULL = 10;
    BSON2.BSON_DATA_REGEXP = 11;
    BSON2.BSON_DATA_CODE = 13;
    BSON2.BSON_DATA_SYMBOL = 14;
    BSON2.BSON_DATA_CODE_W_SCOPE = 15;
    BSON2.BSON_DATA_INT = 16;
    BSON2.BSON_DATA_TIMESTAMP = 17;
    BSON2.BSON_DATA_LONG = 18;
    BSON2.BSON_DATA_MIN_KEY = 255;
    BSON2.BSON_DATA_MAX_KEY = 127;
    BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    module2.exports = BSON2;
    module2.exports.Code = Code2;
    module2.exports.Map = Map2;
    module2.exports.Symbol = Symbol2;
    module2.exports.BSON = BSON2;
    module2.exports.DBRef = DBRef2;
    module2.exports.Binary = Binary2;
    module2.exports.ObjectID = ObjectID2;
    module2.exports.Long = Long2;
    module2.exports.Timestamp = Timestamp2;
    module2.exports.Double = Double2;
    module2.exports.Int32 = Int322;
    module2.exports.MinKey = MinKey2;
    module2.exports.MaxKey = MaxKey2;
    module2.exports.BSONRegExp = BSONRegExp2;
    module2.exports.Decimal128 = Decimal1282;
  }
});

// node_modules/bson/index.js
var require_bson2 = __commonJS({
  "node_modules/bson/index.js"(exports2, module2) {
    var BSON2 = require_bson();
    var Binary2 = require_binary();
    var Code2 = require_code();
    var DBRef2 = require_db_ref();
    var Decimal1282 = require_decimal128();
    var Double2 = require_double();
    var Int322 = require_int_32();
    var Long2 = require_long();
    var Map2 = require_map();
    var MaxKey2 = require_max_key();
    var MinKey2 = require_min_key();
    var ObjectId2 = require_objectid();
    var BSONRegExp2 = require_regexp();
    var Symbol2 = require_symbol();
    var Timestamp2 = require_timestamp();
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    BSON2.Binary = Binary2;
    BSON2.Code = Code2;
    BSON2.DBRef = DBRef2;
    BSON2.Decimal128 = Decimal1282;
    BSON2.Double = Double2;
    BSON2.Int32 = Int322;
    BSON2.Long = Long2;
    BSON2.Map = Map2;
    BSON2.MaxKey = MaxKey2;
    BSON2.MinKey = MinKey2;
    BSON2.ObjectId = ObjectId2;
    BSON2.ObjectID = ObjectId2;
    BSON2.BSONRegExp = BSONRegExp2;
    BSON2.Symbol = Symbol2;
    BSON2.Timestamp = Timestamp2;
    module2.exports = BSON2;
  }
});

// node_modules/optional-require/index.js
var require_optional_require = __commonJS({
  "node_modules/optional-require/index.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    function findModuleNotFound(err, name) {
      const msg = err.message.split("\n")[0];
      return msg && (msg.includes(`'${name}'`) || msg.includes(` ${name} `) || msg.includes(` ${name}. `) || msg.includes(` ${name}, `));
    }
    function _optionalRequire(callerRequire, resolve, path, message) {
      let opts;
      if (typeof message === "object") {
        opts = message;
        assert(!(opts.hasOwnProperty("notFound") && opts.hasOwnProperty("default")), "optionalRequire: options set with both `notFound` and `default`");
      } else {
        opts = { message };
      }
      try {
        return resolve ? callerRequire.resolve(path) : callerRequire(path);
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND" || !findModuleNotFound(e, path)) {
          if (typeof opts.fail === "function") {
            return opts.fail(e);
          }
          throw e;
        }
        if (opts.message) {
          const message2 = typeof opts.message === "string" ? `${opts.message} - ` : "";
          const r = resolve ? "resolved" : "found";
          optionalRequire.log(`${message2}optional module not ${r}`, path);
        }
        if (typeof opts.notFound === "function") {
          return opts.notFound(e);
        }
        return opts.default;
      }
    }
    var tryRequire = (callerRequire, path, message) => _optionalRequire(callerRequire, false, path, message);
    var tryResolve = (callerRequire, path, message) => _optionalRequire(callerRequire, true, path, message);
    function optionalRequire(callerRequire) {
      const x = (path, message) => tryRequire(callerRequire, path, message);
      x.resolve = (path, message) => tryResolve(callerRequire, path, message);
      return x;
    }
    optionalRequire.try = tryRequire;
    optionalRequire.tryResolve = tryResolve;
    optionalRequire.resolve = tryResolve;
    optionalRequire.log = (message, path) => console.log(`Just FYI: ${message}; Path "${path}"`);
    module2.exports = optionalRequire;
  }
});

// node_modules/mongodb/package.json
var require_package = __commonJS({
  "node_modules/mongodb/package.json"(exports2, module2) {
    module2.exports = {
      _args: [
        [
          "mongodb@3.6.11",
          "D:\\D_Documents\\Imagine Apps\\Ada\\Proyecto\\ada-back"
        ]
      ],
      _from: "mongodb@3.6.11",
      _id: "mongodb@3.6.11",
      _inBundle: false,
      _integrity: "sha512-4Y4lTFHDHZZdgMaHmojtNAlqkvddX2QQBEN0K//GzxhGwlI9tZ9R0vhbjr1Decw+TF7qK0ZLjQT292XgHRRQgw==",
      _location: "/mongodb",
      _phantomChildren: {},
      _requested: {
        type: "version",
        registry: true,
        raw: "mongodb@3.6.11",
        name: "mongodb",
        escapedName: "mongodb",
        rawSpec: "3.6.11",
        saveSpec: null,
        fetchSpec: "3.6.11"
      },
      _requiredBy: [
        "/mongoose"
      ],
      _resolved: "https://registry.npmjs.org/mongodb/-/mongodb-3.6.11.tgz",
      _spec: "3.6.11",
      _where: "D:\\D_Documents\\Imagine Apps\\Ada\\Proyecto\\ada-back",
      author: {
        name: "The MongoDB NodeJS Team",
        email: "dbx-node@mongodb.com"
      },
      bugs: {
        url: "https://jira.mongodb.org/projects/NODE/issues/"
      },
      dependencies: {
        bl: "^2.2.1",
        bson: "^1.1.4",
        denque: "^1.4.1",
        "optional-require": "^1.0.3",
        "safe-buffer": "^5.1.2",
        saslprep: "^1.0.0"
      },
      description: "The official MongoDB driver for Node.js",
      devDependencies: {
        "@types/chai": "^4.2.16",
        "@types/mocha": "^8.2.2",
        "@types/node": "^14.14.37",
        "array-includes": "^3.1.3",
        chai: "^4.1.1",
        "chai-subset": "^1.6.0",
        chalk: "^2.4.2",
        co: "4.6.0",
        eslint: "^7.10.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-es": "^3.0.1",
        "eslint-plugin-prettier": "^3.1.3",
        jsdoc: "^3.5.5",
        "lodash.camelcase": "^4.3.0",
        mocha: "5.2.0",
        "mocha-sinon": "^2.1.0",
        "mongodb-extjson": "^2.1.1",
        "mongodb-mock-server": "^1.0.1",
        nyc: "^15.1.0",
        "object.entries": "^1.1.3",
        prettier: "^1.19.1",
        semver: "^5.5.0",
        sinon: "^4.3.0",
        "sinon-chai": "^3.2.0",
        snappy: "^6.3.4",
        "spec-xunit-file": "0.0.1-3",
        "standard-version": "^9.2.0",
        tslib: "^2.2.0",
        typescript: "^4.2.4",
        "util.promisify": "^1.0.1",
        "worker-farm": "^1.5.0",
        wtfnode: "^0.8.0",
        yargs: "^14.2.0"
      },
      engines: {
        node: ">=4"
      },
      files: [
        "index.js",
        "lib"
      ],
      homepage: "https://github.com/mongodb/node-mongodb-native",
      keywords: [
        "mongodb",
        "driver",
        "official"
      ],
      license: "Apache-2.0",
      main: "index.js",
      name: "mongodb",
      optionalDependencies: {
        saslprep: "^1.0.0"
      },
      peerDependenciesMeta: {
        kerberos: {
          optional: true
        },
        "mongodb-client-encryption": {
          optional: true
        },
        "mongodb-extjson": {
          optional: true
        },
        snappy: {
          optional: true
        },
        "bson-ext": {
          optional: true
        },
        aws4: {
          optional: true
        }
      },
      repository: {
        type: "git",
        url: "git+ssh://git@github.com/mongodb/node-mongodb-native.git"
      },
      scripts: {
        "build:evergreen": "node .evergreen/generate_evergreen_tasks.js",
        "build:unified": "tsc -p test/functional/unified-spec-runner/tsconfig.unified.json",
        "check:atlas": "mocha --opts '{}' ./test/manual/atlas_connectivity.test.js",
        "check:bench": "node test/benchmarks/driverBench/",
        "check:coverage": "nyc npm run check:test",
        "check:kerberos": "mocha --opts '{}' -t 60000 test/manual/kerberos.test.js",
        "check:ldap": "mocha --opts '{}' test/manual/ldap.test.js",
        "check:lint": "eslint -v && eslint lib test",
        "check:test": "mocha --recursive test/functional test/unit",
        "check:tls": "mocha --opts '{}' test/manual/tls_support.test.js",
        format: "npm run check:lint -- --fix",
        release: "standard-version -i HISTORY.md",
        test: "npm run lint && mocha --recursive test/functional test/unit"
      },
      version: "3.6.11"
    };
  }
});

// node_modules/mongodb/lib/core/utils.js
var require_utils4 = __commonJS({
  "node_modules/mongodb/lib/core/utils.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var crypto = require("crypto");
    var requireOptional = require_optional_require()(require);
    var uuidV4 = () => {
      const result = crypto.randomBytes(16);
      result[6] = result[6] & 15 | 64;
      result[8] = result[8] & 63 | 128;
      return result;
    };
    function relayEvents(listener, emitter, events) {
      events.forEach((eventName) => listener.on(eventName, (event) => emitter.emit(eventName, event)));
    }
    function retrieveKerberos() {
      let kerberos;
      try {
        kerberos = requireOptional("kerberos");
      } catch (err) {
        if (err.code === "MODULE_NOT_FOUND") {
          throw new Error("The `kerberos` module was not found. Please install it and try again.");
        }
        throw err;
      }
      return kerberos;
    }
    var noEJSONError = function() {
      throw new Error("The `mongodb-extjson` module was not found. Please install it and try again.");
    };
    function retrieveEJSON() {
      let EJSON = requireOptional("mongodb-extjson");
      if (!EJSON) {
        EJSON = {
          parse: noEJSONError,
          deserialize: noEJSONError,
          serialize: noEJSONError,
          stringify: noEJSONError,
          setBSONModule: noEJSONError,
          BSON: noEJSONError
        };
      }
      return EJSON;
    }
    function maxWireVersion(topologyOrServer) {
      if (topologyOrServer) {
        if (topologyOrServer.ismaster) {
          return topologyOrServer.ismaster.maxWireVersion;
        }
        if (typeof topologyOrServer.lastIsMaster === "function") {
          const lastIsMaster = topologyOrServer.lastIsMaster();
          if (lastIsMaster) {
            return lastIsMaster.maxWireVersion;
          }
        }
        if (topologyOrServer.description) {
          return topologyOrServer.description.maxWireVersion;
        }
      }
      return 0;
    }
    function collationNotSupported(server, cmd) {
      return cmd && cmd.collation && maxWireVersion(server) < 5;
    }
    function isPromiseLike(maybePromise) {
      return maybePromise && typeof maybePromise.then === "function";
    }
    function eachAsync(arr, eachFn, callback) {
      arr = arr || [];
      let idx = 0;
      let awaiting = 0;
      for (idx = 0; idx < arr.length; ++idx) {
        awaiting++;
        eachFn(arr[idx], eachCallback);
      }
      if (awaiting === 0) {
        callback();
        return;
      }
      function eachCallback(err) {
        awaiting--;
        if (err) {
          callback(err);
          return;
        }
        if (idx === arr.length && awaiting <= 0) {
          callback();
        }
      }
    }
    function eachAsyncSeries(arr, eachFn, callback) {
      arr = arr || [];
      let idx = 0;
      let awaiting = arr.length;
      if (awaiting === 0) {
        callback();
        return;
      }
      function eachCallback(err) {
        idx++;
        awaiting--;
        if (err) {
          callback(err);
          return;
        }
        if (idx === arr.length && awaiting <= 0) {
          callback();
          return;
        }
        eachFn(arr[idx], eachCallback);
      }
      eachFn(arr[idx], eachCallback);
    }
    function isUnifiedTopology(topology) {
      return topology.description != null;
    }
    function arrayStrictEqual(arr, arr2) {
      if (!Array.isArray(arr) || !Array.isArray(arr2)) {
        return false;
      }
      return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
    }
    function tagsStrictEqual(tags, tags2) {
      const tagsKeys = Object.keys(tags);
      const tags2Keys = Object.keys(tags2);
      return tagsKeys.length === tags2Keys.length && tagsKeys.every((key) => tags2[key] === tags[key]);
    }
    function errorStrictEqual(lhs, rhs) {
      if (lhs === rhs) {
        return true;
      }
      if (lhs == null && rhs != null || lhs != null && rhs == null) {
        return false;
      }
      if (lhs.constructor.name !== rhs.constructor.name) {
        return false;
      }
      if (lhs.message !== rhs.message) {
        return false;
      }
      return true;
    }
    function makeStateMachine(stateTable) {
      return function stateTransition(target, newState) {
        const legalStates = stateTable[target.s.state];
        if (legalStates && legalStates.indexOf(newState) < 0) {
          throw new TypeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);
        }
        target.emit("stateChanged", target.s.state, newState);
        target.s.state = newState;
      };
    }
    function makeClientMetadata(options) {
      options = options || {};
      const metadata = {
        driver: {
          name: "nodejs",
          version: require_package().version
        },
        os: {
          type: os.type(),
          name: process.platform,
          architecture: process.arch,
          version: os.release()
        },
        platform: `'Node.js ${process.version}, ${os.endianness} (${options.useUnifiedTopology ? "unified" : "legacy"})`
      };
      if (options.driverInfo) {
        if (options.driverInfo.name) {
          metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;
        }
        if (options.driverInfo.version) {
          metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;
        }
        if (options.driverInfo.platform) {
          metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;
        }
      }
      if (options.appname) {
        const buffer = Buffer.from(options.appname);
        metadata.application = {
          name: buffer.length > 128 ? buffer.slice(0, 128).toString("utf8") : options.appname
        };
      }
      return metadata;
    }
    var noop = () => {
    };
    module2.exports = {
      uuidV4,
      relayEvents,
      collationNotSupported,
      retrieveEJSON,
      retrieveKerberos,
      maxWireVersion,
      isPromiseLike,
      eachAsync,
      eachAsyncSeries,
      isUnifiedTopology,
      arrayStrictEqual,
      tagsStrictEqual,
      errorStrictEqual,
      makeStateMachine,
      makeClientMetadata,
      noop
    };
  }
});

// node_modules/mongodb/lib/core/error.js
var require_error = __commonJS({
  "node_modules/mongodb/lib/core/error.js"(exports2, module2) {
    "use strict";
    var kErrorLabels = Symbol("errorLabels");
    var MongoError = class extends Error {
      constructor(message) {
        if (message instanceof Error) {
          super(message.message);
          this.stack = message.stack;
        } else {
          if (typeof message === "string") {
            super(message);
          } else {
            super(message.message || message.errmsg || message.$err || "n/a");
            if (message.errorLabels) {
              this[kErrorLabels] = new Set(message.errorLabels);
            }
            for (var name in message) {
              if (name === "errorLabels" || name === "errmsg") {
                continue;
              }
              this[name] = message[name];
            }
          }
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "MongoError";
      }
      get errmsg() {
        return this.message;
      }
      static create(options) {
        return new MongoError(options);
      }
      hasErrorLabel(label) {
        if (this[kErrorLabels] == null) {
          return false;
        }
        return this[kErrorLabels].has(label);
      }
      addErrorLabel(label) {
        if (this[kErrorLabels] == null) {
          this[kErrorLabels] = new Set();
        }
        this[kErrorLabels].add(label);
      }
      get errorLabels() {
        return this[kErrorLabels] ? Array.from(this[kErrorLabels]) : [];
      }
    };
    var kBeforeHandshake = Symbol("beforeHandshake");
    function isNetworkErrorBeforeHandshake(err) {
      return err[kBeforeHandshake] === true;
    }
    var MongoNetworkError = class extends MongoError {
      constructor(message, options) {
        super(message);
        this.name = "MongoNetworkError";
        if (options && typeof options.beforeHandshake === "boolean") {
          this[kBeforeHandshake] = options.beforeHandshake;
        }
      }
    };
    var MongoNetworkTimeoutError = class extends MongoNetworkError {
      constructor(message, options) {
        super(message, options);
        this.name = "MongoNetworkTimeoutError";
      }
    };
    var MongoParseError = class extends MongoError {
      constructor(message) {
        super(message);
        this.name = "MongoParseError";
      }
    };
    var MongoTimeoutError = class extends MongoError {
      constructor(message, reason) {
        if (reason && reason.error) {
          super(reason.error.message || reason.error);
        } else {
          super(message);
        }
        this.name = "MongoTimeoutError";
        if (reason) {
          this.reason = reason;
        }
      }
    };
    var MongoServerSelectionError = class extends MongoTimeoutError {
      constructor(message, reason) {
        super(message, reason);
        this.name = "MongoServerSelectionError";
      }
    };
    function makeWriteConcernResultObject(input) {
      const output = Object.assign({}, input);
      if (output.ok === 0) {
        output.ok = 1;
        delete output.errmsg;
        delete output.code;
        delete output.codeName;
      }
      return output;
    }
    var MongoWriteConcernError = class extends MongoError {
      constructor(message, result) {
        super(message);
        this.name = "MongoWriteConcernError";
        if (result && Array.isArray(result.errorLabels)) {
          this[kErrorLabels] = new Set(result.errorLabels);
        }
        if (result != null) {
          this.result = makeWriteConcernResultObject(result);
        }
      }
    };
    var RETRYABLE_ERROR_CODES = new Set([
      6,
      7,
      89,
      91,
      189,
      9001,
      10107,
      11600,
      11602,
      13435,
      13436
    ]);
    var RETRYABLE_WRITE_ERROR_CODES = new Set([
      11600,
      11602,
      10107,
      13435,
      13436,
      189,
      91,
      7,
      6,
      89,
      9001,
      262
    ]);
    function isRetryableWriteError(error) {
      if (error instanceof MongoWriteConcernError) {
        return RETRYABLE_WRITE_ERROR_CODES.has(error.code) || RETRYABLE_WRITE_ERROR_CODES.has(error.result.code);
      }
      return RETRYABLE_WRITE_ERROR_CODES.has(error.code);
    }
    function isRetryableError(error) {
      return RETRYABLE_ERROR_CODES.has(error.code) || error instanceof MongoNetworkError || error.message.match(/not master/) || error.message.match(/node is recovering/);
    }
    var SDAM_RECOVERING_CODES = new Set([
      91,
      189,
      11600,
      11602,
      13436
    ]);
    var SDAM_NOTMASTER_CODES = new Set([
      10107,
      13435
    ]);
    var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([
      11600,
      91
    ]);
    function isRecoveringError(err) {
      if (err.code && SDAM_RECOVERING_CODES.has(err.code)) {
        return true;
      }
      return err.message.match(/not master or secondary/) || err.message.match(/node is recovering/);
    }
    function isNotMasterError(err) {
      if (err.code && SDAM_NOTMASTER_CODES.has(err.code)) {
        return true;
      }
      if (isRecoveringError(err)) {
        return false;
      }
      return err.message.match(/not master/);
    }
    function isNodeShuttingDownError(err) {
      return err.code && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code);
    }
    function isSDAMUnrecoverableError(error) {
      if (error instanceof MongoParseError || error == null) {
        return true;
      }
      if (isRecoveringError(error) || isNotMasterError(error)) {
        return true;
      }
      return false;
    }
    module2.exports = {
      MongoError,
      MongoNetworkError,
      MongoNetworkTimeoutError,
      MongoParseError,
      MongoTimeoutError,
      MongoServerSelectionError,
      MongoWriteConcernError,
      isRetryableError,
      isSDAMUnrecoverableError,
      isNodeShuttingDownError,
      isRetryableWriteError,
      isNetworkErrorBeforeHandshake
    };
  }
});

// node_modules/mongodb/lib/core/connection/utils.js
var require_utils5 = __commonJS({
  "node_modules/mongodb/lib/core/connection/utils.js"(exports2, module2) {
    "use strict";
    var require_optional = require_optional_require()(require);
    function debugOptions(debugFields, options) {
      const finaloptions = {};
      debugFields.forEach(function(n) {
        finaloptions[n] = options[n];
      });
      return finaloptions;
    }
    function retrieveBSON() {
      const BSON2 = require_bson2();
      BSON2.native = false;
      const optionalBSON = require_optional("bson-ext");
      if (optionalBSON) {
        optionalBSON.native = true;
        return optionalBSON;
      }
      return BSON2;
    }
    function noSnappyWarning() {
      throw new Error("Attempted to use Snappy compression, but Snappy is not installed. Install or disable Snappy compression and try again.");
    }
    function retrieveSnappy() {
      let snappy = require_optional("snappy");
      if (!snappy) {
        snappy = {
          compress: noSnappyWarning,
          uncompress: noSnappyWarning,
          compressSync: noSnappyWarning,
          uncompressSync: noSnappyWarning
        };
      }
      return snappy;
    }
    module2.exports = {
      debugOptions,
      retrieveBSON,
      retrieveSnappy
    };
  }
});

// node_modules/mongodb/lib/write_concern.js
var require_write_concern = __commonJS({
  "node_modules/mongodb/lib/write_concern.js"(exports2, module2) {
    "use strict";
    var kWriteConcernKeys = new Set(["w", "wtimeout", "j", "journal", "fsync"]);
    var utils2;
    var WriteConcern = class {
      constructor(w, wtimeout, j, fsync) {
        if (w != null) {
          this.w = w;
        }
        if (wtimeout != null) {
          this.wtimeout = wtimeout;
        }
        if (j != null) {
          this.j = j;
        }
        if (fsync != null) {
          this.fsync = fsync;
        }
      }
      static fromOptions(options) {
        if (options == null || options.writeConcern == null && options.w == null && options.wtimeout == null && options.j == null && options.journal == null && options.fsync == null) {
          return;
        }
        if (options.writeConcern) {
          if (typeof options.writeConcern === "string") {
            return new WriteConcern(options.writeConcern);
          }
          if (!Object.keys(options.writeConcern).some((key) => kWriteConcernKeys.has(key))) {
            return;
          }
          return new WriteConcern(options.writeConcern.w, options.writeConcern.wtimeout, options.writeConcern.j || options.writeConcern.journal, options.writeConcern.fsync);
        }
        if (!utils2)
          utils2 = require_utils6();
        utils2.emitWarningOnce(`Top-level use of w, wtimeout, j, and fsync is deprecated. Use writeConcern instead.`);
        return new WriteConcern(options.w, options.wtimeout, options.j || options.journal, options.fsync);
      }
    };
    module2.exports = WriteConcern;
  }
});

// node_modules/mongodb/lib/async/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/mongodb/lib/async/async_iterator.js"(exports2) {
    "use strict";
    function asyncIterator() {
      const cursor = this;
      return {
        next: function() {
          return Promise.resolve().then(() => cursor.next()).then((value) => {
            if (!value) {
              return cursor.close().then(() => ({ value, done: true }));
            }
            return { value, done: false };
          });
        }
      };
    }
    exports2.asyncIterator = asyncIterator;
  }
});

// node_modules/mongodb/lib/utils.js
var require_utils6 = __commonJS({
  "node_modules/mongodb/lib/utils.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var WriteConcern = require_write_concern();
    var shallowClone = function(obj) {
      var copy = {};
      for (var name in obj)
        copy[name] = obj[name];
      return copy;
    };
    var getSingleProperty = function(obj, name, value) {
      Object.defineProperty(obj, name, {
        enumerable: true,
        get: function() {
          return value;
        }
      });
    };
    var formatSortValue = exports2.formatSortValue = function(sortDirection) {
      var value = ("" + sortDirection).toLowerCase();
      switch (value) {
        case "ascending":
        case "asc":
        case "1":
          return 1;
        case "descending":
        case "desc":
        case "-1":
          return -1;
        default:
          throw new Error("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
      }
    };
    var formattedOrderClause = exports2.formattedOrderClause = function(sortValue) {
      var orderBy = new Map();
      if (sortValue == null)
        return null;
      if (Array.isArray(sortValue)) {
        if (sortValue.length === 0) {
          return null;
        }
        for (var i = 0; i < sortValue.length; i++) {
          if (sortValue[i].constructor === String) {
            orderBy.set(`${sortValue[i]}`, 1);
          } else {
            orderBy.set(`${sortValue[i][0]}`, formatSortValue(sortValue[i][1]));
          }
        }
      } else if (sortValue != null && typeof sortValue === "object") {
        if (sortValue instanceof Map) {
          orderBy = sortValue;
        } else {
          var sortKeys = Object.keys(sortValue);
          for (var k of sortKeys) {
            orderBy.set(k, sortValue[k]);
          }
        }
      } else if (typeof sortValue === "string") {
        orderBy.set(`${sortValue}`, 1);
      } else {
        throw new Error("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
      }
      return orderBy;
    };
    var checkCollectionName = function checkCollectionName2(collectionName) {
      if (typeof collectionName !== "string") {
        throw new MongoError("collection name must be a String");
      }
      if (!collectionName || collectionName.indexOf("..") !== -1) {
        throw new MongoError("collection names cannot be empty");
      }
      if (collectionName.indexOf("$") !== -1 && collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
        throw new MongoError("collection names must not contain '$'");
      }
      if (collectionName.match(/^\.|\.$/) != null) {
        throw new MongoError("collection names must not start or end with '.'");
      }
      if (collectionName.indexOf("\0") !== -1) {
        throw new MongoError("collection names cannot contain a null character");
      }
    };
    var handleCallback = function(callback, err, value1, value2) {
      try {
        if (callback == null)
          return;
        if (callback) {
          return value2 ? callback(err, value1, value2) : callback(err, value1);
        }
      } catch (err2) {
        process.nextTick(function() {
          throw err2;
        });
        return false;
      }
      return true;
    };
    var toError = function(error) {
      if (error instanceof Error)
        return error;
      var msg = error.err || error.errmsg || error.errMessage || error;
      var e = MongoError.create({ message: msg, driver: true });
      var keys = typeof error === "object" ? Object.keys(error) : [];
      for (var i = 0; i < keys.length; i++) {
        try {
          e[keys[i]] = error[keys[i]];
        } catch (err) {
        }
      }
      return e;
    };
    var normalizeHintField = function normalizeHintField2(hint) {
      var finalHint = null;
      if (typeof hint === "string") {
        finalHint = hint;
      } else if (Array.isArray(hint)) {
        finalHint = {};
        hint.forEach(function(param) {
          finalHint[param] = 1;
        });
      } else if (hint != null && typeof hint === "object") {
        finalHint = {};
        for (var name in hint) {
          finalHint[name] = hint[name];
        }
      }
      return finalHint;
    };
    var parseIndexOptions = function(fieldOrSpec) {
      var fieldHash = {};
      var indexes = [];
      var keys;
      if (typeof fieldOrSpec === "string") {
        indexes.push(fieldOrSpec + "_" + 1);
        fieldHash[fieldOrSpec] = 1;
      } else if (Array.isArray(fieldOrSpec)) {
        fieldOrSpec.forEach(function(f) {
          if (typeof f === "string") {
            indexes.push(f + "_" + 1);
            fieldHash[f] = 1;
          } else if (Array.isArray(f)) {
            indexes.push(f[0] + "_" + (f[1] || 1));
            fieldHash[f[0]] = f[1] || 1;
          } else if (isObject2(f)) {
            keys = Object.keys(f);
            keys.forEach(function(k) {
              indexes.push(k + "_" + f[k]);
              fieldHash[k] = f[k];
            });
          } else {
          }
        });
      } else if (isObject2(fieldOrSpec)) {
        keys = Object.keys(fieldOrSpec);
        keys.forEach(function(key) {
          indexes.push(key + "_" + fieldOrSpec[key]);
          fieldHash[key] = fieldOrSpec[key];
        });
      }
      return {
        name: indexes.join("_"),
        keys,
        fieldHash
      };
    };
    var isObject2 = exports2.isObject = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Object]";
    };
    var debugOptions = function(debugFields, options) {
      var finaloptions = {};
      debugFields.forEach(function(n) {
        finaloptions[n] = options[n];
      });
      return finaloptions;
    };
    var decorateCommand = function(command, options, exclude) {
      for (var name in options) {
        if (exclude.indexOf(name) === -1)
          command[name] = options[name];
      }
      return command;
    };
    var mergeOptions = function(target, source) {
      for (var name in source) {
        target[name] = source[name];
      }
      return target;
    };
    var translateOptions = function(target, source) {
      var translations = {
        sslCA: "ca",
        sslCRL: "crl",
        sslValidate: "rejectUnauthorized",
        sslKey: "key",
        sslCert: "cert",
        sslPass: "passphrase",
        socketTimeoutMS: "socketTimeout",
        connectTimeoutMS: "connectionTimeout",
        replicaSet: "setName",
        rs_name: "setName",
        secondaryAcceptableLatencyMS: "acceptableLatency",
        connectWithNoPrimary: "secondaryOnlyConnectionAllowed",
        acceptableLatencyMS: "localThresholdMS"
      };
      for (var name in source) {
        if (translations[name]) {
          target[translations[name]] = source[name];
        } else {
          target[name] = source[name];
        }
      }
      return target;
    };
    var filterOptions = function(options, names) {
      var filterOptions2 = {};
      for (var name in options) {
        if (names.indexOf(name) !== -1)
          filterOptions2[name] = options[name];
      }
      return filterOptions2;
    };
    var WRITE_CONCERN_KEYS = ["w", "j", "wtimeout", "fsync", "writeConcern"];
    function conditionallyMergeWriteConcern(target, source) {
      let found = false;
      for (const wcKey of WRITE_CONCERN_KEYS) {
        if (wcKey in target) {
          found = true;
          break;
        }
      }
      if (!found) {
        for (const wcKey of WRITE_CONCERN_KEYS) {
          if (source[wcKey]) {
            if (!("writeConcern" in target)) {
              target.writeConcern = {};
            }
            target.writeConcern[wcKey] = source[wcKey];
          }
        }
      }
      return target;
    }
    var executeLegacyOperation = (topology, operation, args, options) => {
      if (topology == null) {
        throw new TypeError("This method requires a valid topology instance");
      }
      if (!Array.isArray(args)) {
        throw new TypeError("This method requires an array of arguments to apply");
      }
      options = options || {};
      const Promise2 = topology.s.promiseLibrary;
      let callback = args[args.length - 1];
      let session, opOptions, owner;
      if (!options.skipSessions && topology.hasSessionSupport()) {
        opOptions = args[args.length - 2];
        if (opOptions == null || opOptions.session == null) {
          owner = Symbol();
          session = topology.startSession({ owner });
          const optionsIndex = args.length - 2;
          args[optionsIndex] = Object.assign({}, args[optionsIndex], { session });
        } else if (opOptions.session && opOptions.session.hasEnded) {
          throw new MongoError("Use of expired sessions is not permitted");
        }
      }
      const makeExecuteCallback = (resolve, reject) => function executeCallback(err, result) {
        if (session && session.owner === owner && !options.returnsCursor) {
          session.endSession(() => {
            delete opOptions.session;
            if (err)
              return reject(err);
            resolve(result);
          });
        } else {
          if (err)
            return reject(err);
          resolve(result);
        }
      };
      if (typeof callback === "function") {
        callback = args.pop();
        const handler = makeExecuteCallback((result) => callback(null, result), (err) => callback(err, null));
        args.push(handler);
        try {
          return operation.apply(null, args);
        } catch (e) {
          handler(e);
          throw e;
        }
      }
      if (args[args.length - 1] != null) {
        throw new TypeError("final argument to `executeLegacyOperation` must be a callback");
      }
      return new Promise2(function(resolve, reject) {
        const handler = makeExecuteCallback(resolve, reject);
        args[args.length - 1] = handler;
        try {
          return operation.apply(null, args);
        } catch (e) {
          handler(e);
        }
      });
    };
    function applyRetryableWrites(target, db) {
      if (db && db.s.options.retryWrites) {
        target.retryWrites = true;
      }
      return target;
    }
    function applyWriteConcern(target, sources, options) {
      options = options || {};
      const db = sources.db;
      const coll = sources.collection;
      if (options.session && options.session.inTransaction()) {
        if (target.writeConcern) {
          delete target.writeConcern;
        }
        return target;
      }
      const writeConcern = WriteConcern.fromOptions(options);
      if (writeConcern) {
        return Object.assign(target, { writeConcern });
      }
      if (coll && coll.writeConcern) {
        return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });
      }
      if (db && db.writeConcern) {
        return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });
      }
      return target;
    }
    function isPromiseLike(maybePromise2) {
      return maybePromise2 && typeof maybePromise2.then === "function";
    }
    function decorateWithCollation(command, target, options) {
      const topology = target.s && target.s.topology || target.topology;
      if (!topology) {
        throw new TypeError('parameter "target" is missing a topology');
      }
      const capabilities = topology.capabilities();
      if (options.collation && typeof options.collation === "object") {
        if (capabilities && capabilities.commandsTakeCollation) {
          command.collation = options.collation;
        } else {
          throw new MongoError(`Current topology does not support collation`);
        }
      }
    }
    function decorateWithReadConcern(command, coll, options) {
      if (options && options.session && options.session.inTransaction()) {
        return;
      }
      let readConcern = Object.assign({}, command.readConcern || {});
      if (coll.s.readConcern) {
        Object.assign(readConcern, coll.s.readConcern);
      }
      if (Object.keys(readConcern).length > 0) {
        Object.assign(command, { readConcern });
      }
    }
    function decorateWithExplain(command, explain) {
      if (command.explain) {
        return command;
      }
      return { explain: command, verbosity: explain.verbosity };
    }
    var nodejsMajorVersion = +process.version.split(".")[0].substring(1);
    var emitProcessWarning = (msg) => nodejsMajorVersion <= 6 ? process.emitWarning(msg, "DeprecationWarning", MONGODB_WARNING_CODE) : process.emitWarning(msg, { type: "DeprecationWarning", code: MONGODB_WARNING_CODE });
    var emitConsoleWarning = (msg) => console.error(msg);
    var emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;
    function defaultMsgHandler(name, option) {
      return `${name} option [${option}] is deprecated and will be removed in a later version.`;
    }
    function deprecateOptions(config, fn) {
      if (process.noDeprecation === true) {
        return fn;
      }
      const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;
      const optionsWarned = new Set();
      function deprecated() {
        const options = arguments[config.optionsIndex];
        if (!isObject2(options) || Object.keys(options).length === 0) {
          return fn.apply(this, arguments);
        }
        config.deprecatedOptions.forEach((deprecatedOption) => {
          if (Object.prototype.hasOwnProperty.call(options, deprecatedOption) && !optionsWarned.has(deprecatedOption)) {
            optionsWarned.add(deprecatedOption);
            const msg = msgHandler(config.name, deprecatedOption);
            emitDeprecationWarning(msg);
            if (this && this.getLogger) {
              const logger = this.getLogger();
              if (logger) {
                logger.warn(msg);
              }
            }
          }
        });
        return fn.apply(this, arguments);
      }
      Object.setPrototypeOf(deprecated, fn);
      if (fn.prototype) {
        deprecated.prototype = fn.prototype;
      }
      return deprecated;
    }
    var SUPPORTS = {};
    try {
      require_async_iterator();
      SUPPORTS.ASYNC_ITERATOR = true;
    } catch (e) {
      SUPPORTS.ASYNC_ITERATOR = false;
    }
    var MongoDBNamespace = class {
      constructor(db, collection) {
        this.db = db;
        this.collection = collection;
      }
      toString() {
        return this.collection ? `${this.db}.${this.collection}` : this.db;
      }
      withCollection(collection) {
        return new MongoDBNamespace(this.db, collection);
      }
      static fromString(namespace) {
        if (!namespace) {
          throw new Error(`Cannot parse namespace from "${namespace}"`);
        }
        const index = namespace.indexOf(".");
        return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));
      }
    };
    function* makeCounter(seed) {
      let count = seed || 0;
      while (true) {
        const newCount = count;
        count += 1;
        yield newCount;
      }
    }
    function maybePromise(parent, callback, fn) {
      const PromiseLibrary = parent && parent.s && parent.s.promiseLibrary || Promise;
      let result;
      if (typeof callback !== "function") {
        result = new PromiseLibrary((resolve, reject) => {
          callback = (err, res) => {
            if (err)
              return reject(err);
            resolve(res);
          };
        });
      }
      fn(function(err, res) {
        if (err != null) {
          try {
            callback(err);
          } catch (error) {
            return process.nextTick(() => {
              throw error;
            });
          }
          return;
        }
        callback(err, res);
      });
      return result;
    }
    function now() {
      const hrtime = process.hrtime();
      return Math.floor(hrtime[0] * 1e3 + hrtime[1] / 1e6);
    }
    function calculateDurationInMs(started) {
      if (typeof started !== "number") {
        throw TypeError("numeric value required to calculate duration");
      }
      const elapsed = now() - started;
      return elapsed < 0 ? 0 : elapsed;
    }
    function makeInterruptableAsyncInterval(fn, options) {
      let timerId;
      let lastCallTime;
      let lastWakeTime;
      let stopped = false;
      options = options || {};
      const interval = options.interval || 1e3;
      const minInterval = options.minInterval || 500;
      const immediate = typeof options.immediate === "boolean" ? options.immediate : false;
      const clock = typeof options.clock === "function" ? options.clock : now;
      function wake() {
        const currentTime = clock();
        const timeSinceLastWake = currentTime - lastWakeTime;
        const timeSinceLastCall = currentTime - lastCallTime;
        const timeUntilNextCall = interval - timeSinceLastCall;
        lastWakeTime = currentTime;
        if (timeSinceLastWake < minInterval) {
          return;
        }
        if (timeUntilNextCall > minInterval) {
          reschedule(minInterval);
        }
        if (timeUntilNextCall < 0) {
          executeAndReschedule();
        }
      }
      function stop() {
        stopped = true;
        if (timerId) {
          clearTimeout(timerId);
          timerId = null;
        }
        lastCallTime = 0;
        lastWakeTime = 0;
      }
      function reschedule(ms) {
        if (stopped)
          return;
        clearTimeout(timerId);
        timerId = setTimeout(executeAndReschedule, ms || interval);
      }
      function executeAndReschedule() {
        lastWakeTime = 0;
        lastCallTime = clock();
        fn((err) => {
          if (err)
            throw err;
          reschedule(interval);
        });
      }
      if (immediate) {
        executeAndReschedule();
      } else {
        lastCallTime = clock();
        reschedule();
      }
      return { wake, stop };
    }
    function hasAtomicOperators(doc) {
      if (Array.isArray(doc)) {
        return doc.reduce((err, u) => err || hasAtomicOperators(u), null);
      }
      return Object.keys(typeof doc.toBSON !== "function" ? doc : doc.toBSON()).map((k) => k[0]).indexOf("$") >= 0;
    }
    var MONGODB_WARNING_CODE = "MONGODB DRIVER";
    function emitWarning(message) {
      if (process.emitWarning) {
        return nodejsMajorVersion <= 6 ? process.emitWarning(message, void 0, MONGODB_WARNING_CODE) : process.emitWarning(message, { code: MONGODB_WARNING_CODE });
      } else {
        return console.error(`[${MONGODB_WARNING_CODE}] Warning:`, message);
      }
    }
    var emittedWarnings = new Set();
    function emitWarningOnce(message) {
      if (!emittedWarnings.has(message)) {
        emittedWarnings.add(message);
        return emitWarning(message);
      }
    }
    function isSuperset(set, subset) {
      set = Array.isArray(set) ? new Set(set) : set;
      subset = Array.isArray(subset) ? new Set(subset) : subset;
      for (const elem of subset) {
        if (!set.has(elem)) {
          return false;
        }
      }
      return true;
    }
    function isRecord(value, requiredKeys) {
      const toString = Object.prototype.toString;
      const hasOwnProperty = Object.prototype.hasOwnProperty;
      const isObject3 = (v) => toString.call(v) === "[object Object]";
      if (!isObject3(value)) {
        return false;
      }
      const ctor = value.constructor;
      if (ctor && ctor.prototype) {
        if (!isObject3(ctor.prototype)) {
          return false;
        }
        if (!hasOwnProperty.call(ctor.prototype, "isPrototypeOf")) {
          return false;
        }
      }
      if (requiredKeys) {
        const keys = Object.keys(value);
        return isSuperset(keys, requiredKeys);
      }
      return true;
    }
    function deepCopy(value) {
      if (value == null) {
        return value;
      } else if (Array.isArray(value)) {
        return value.map((item) => deepCopy(item));
      } else if (isRecord(value)) {
        const res = {};
        for (const key in value) {
          res[key] = deepCopy(value[key]);
        }
        return res;
      }
      const ctor = value.constructor;
      if (ctor) {
        switch (ctor.name.toLowerCase()) {
          case "date":
            return new ctor(Number(value));
          case "map":
            return new Map(value);
          case "set":
            return new Set(value);
          case "buffer":
            return Buffer.from(value);
        }
      }
      return value;
    }
    module2.exports = {
      filterOptions,
      mergeOptions,
      translateOptions,
      shallowClone,
      getSingleProperty,
      checkCollectionName,
      toError,
      formattedOrderClause,
      parseIndexOptions,
      normalizeHintField,
      handleCallback,
      decorateCommand,
      isObject: isObject2,
      debugOptions,
      MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,
      conditionallyMergeWriteConcern,
      executeLegacyOperation,
      applyRetryableWrites,
      applyWriteConcern,
      isPromiseLike,
      decorateWithCollation,
      decorateWithReadConcern,
      decorateWithExplain,
      deprecateOptions,
      SUPPORTS,
      MongoDBNamespace,
      emitDeprecationWarning,
      makeCounter,
      maybePromise,
      now,
      calculateDurationInMs,
      makeInterruptableAsyncInterval,
      hasAtomicOperators,
      MONGODB_WARNING_CODE,
      emitWarning,
      emitWarningOnce,
      deepCopy
    };
  }
});

// node_modules/mongodb/lib/core/topologies/read_preference.js
var require_read_preference = __commonJS({
  "node_modules/mongodb/lib/core/topologies/read_preference.js"(exports2, module2) {
    "use strict";
    var emitWarningOnce = require_utils6().emitWarningOnce;
    var ReadPreference = function(mode, tags, options) {
      if (!ReadPreference.isValid(mode)) {
        throw new TypeError(`Invalid read preference mode ${mode}`);
      }
      if (tags && !Array.isArray(tags)) {
        emitWarningOnce("ReadPreference tags must be an array, this will change in the next major version");
        const tagsHasMaxStalenessSeconds = typeof tags.maxStalenessSeconds !== "undefined";
        const tagsHasHedge = typeof tags.hedge !== "undefined";
        const tagsHasOptions = tagsHasMaxStalenessSeconds || tagsHasHedge;
        if (tagsHasOptions) {
          options = tags;
          tags = void 0;
        } else {
          tags = [tags];
        }
      }
      this.mode = mode;
      this.tags = tags;
      this.hedge = options && options.hedge;
      options = options || {};
      if (options.maxStalenessSeconds != null) {
        if (options.maxStalenessSeconds <= 0) {
          throw new TypeError("maxStalenessSeconds must be a positive integer");
        }
        this.maxStalenessSeconds = options.maxStalenessSeconds;
        this.minWireVersion = 5;
      }
      if (this.mode === ReadPreference.PRIMARY) {
        if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
          throw new TypeError("Primary read preference cannot be combined with tags");
        }
        if (this.maxStalenessSeconds) {
          throw new TypeError("Primary read preference cannot be combined with maxStalenessSeconds");
        }
        if (this.hedge) {
          throw new TypeError("Primary read preference cannot be combined with hedge");
        }
      }
    };
    Object.defineProperty(ReadPreference.prototype, "preference", {
      enumerable: true,
      get: function() {
        return this.mode;
      }
    });
    ReadPreference.PRIMARY = "primary";
    ReadPreference.PRIMARY_PREFERRED = "primaryPreferred";
    ReadPreference.SECONDARY = "secondary";
    ReadPreference.SECONDARY_PREFERRED = "secondaryPreferred";
    ReadPreference.NEAREST = "nearest";
    var VALID_MODES = [
      ReadPreference.PRIMARY,
      ReadPreference.PRIMARY_PREFERRED,
      ReadPreference.SECONDARY,
      ReadPreference.SECONDARY_PREFERRED,
      ReadPreference.NEAREST,
      null
    ];
    ReadPreference.fromOptions = function(options) {
      if (!options)
        return null;
      const readPreference = options.readPreference;
      if (!readPreference)
        return null;
      const readPreferenceTags = options.readPreferenceTags;
      const maxStalenessSeconds = options.maxStalenessSeconds;
      if (typeof readPreference === "string") {
        return new ReadPreference(readPreference, readPreferenceTags);
      } else if (!(readPreference instanceof ReadPreference) && typeof readPreference === "object") {
        const mode = readPreference.mode || readPreference.preference;
        if (mode && typeof mode === "string") {
          return new ReadPreference(mode, readPreference.tags, {
            maxStalenessSeconds: readPreference.maxStalenessSeconds || maxStalenessSeconds,
            hedge: readPreference.hedge
          });
        }
      }
      return readPreference;
    };
    ReadPreference.resolve = function(parent, options) {
      options = options || {};
      const session = options.session;
      const inheritedReadPreference = parent && parent.readPreference;
      let readPreference;
      if (options.readPreference) {
        readPreference = ReadPreference.fromOptions(options);
      } else if (session && session.inTransaction() && session.transaction.options.readPreference) {
        readPreference = session.transaction.options.readPreference;
      } else if (inheritedReadPreference != null) {
        readPreference = inheritedReadPreference;
      } else {
        readPreference = ReadPreference.primary;
      }
      return typeof readPreference === "string" ? new ReadPreference(readPreference) : readPreference;
    };
    ReadPreference.translate = function(options) {
      if (options.readPreference == null)
        return options;
      const r = options.readPreference;
      if (typeof r === "string") {
        options.readPreference = new ReadPreference(r);
      } else if (r && !(r instanceof ReadPreference) && typeof r === "object") {
        const mode = r.mode || r.preference;
        if (mode && typeof mode === "string") {
          options.readPreference = new ReadPreference(mode, r.tags, {
            maxStalenessSeconds: r.maxStalenessSeconds
          });
        }
      } else if (!(r instanceof ReadPreference)) {
        throw new TypeError("Invalid read preference: " + r);
      }
      return options;
    };
    ReadPreference.isValid = function(mode) {
      return VALID_MODES.indexOf(mode) !== -1;
    };
    ReadPreference.prototype.isValid = function(mode) {
      return ReadPreference.isValid(typeof mode === "string" ? mode : this.mode);
    };
    var needSlaveOk = ["primaryPreferred", "secondary", "secondaryPreferred", "nearest"];
    ReadPreference.prototype.slaveOk = function() {
      return needSlaveOk.indexOf(this.mode) !== -1;
    };
    ReadPreference.prototype.equals = function(readPreference) {
      return readPreference.mode === this.mode;
    };
    ReadPreference.prototype.toJSON = function() {
      const readPreference = { mode: this.mode };
      if (Array.isArray(this.tags))
        readPreference.tags = this.tags;
      if (this.maxStalenessSeconds)
        readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
      if (this.hedge)
        readPreference.hedge = this.hedge;
      return readPreference;
    };
    ReadPreference.primary = new ReadPreference("primary");
    ReadPreference.primaryPreferred = new ReadPreference("primaryPreferred");
    ReadPreference.secondary = new ReadPreference("secondary");
    ReadPreference.secondaryPreferred = new ReadPreference("secondaryPreferred");
    ReadPreference.nearest = new ReadPreference("nearest");
    module2.exports = ReadPreference;
  }
});

// node_modules/mongodb/lib/core/sdam/common.js
var require_common = __commonJS({
  "node_modules/mongodb/lib/core/sdam/common.js"(exports2, module2) {
    "use strict";
    var STATE_CLOSING = "closing";
    var STATE_CLOSED = "closed";
    var STATE_CONNECTING = "connecting";
    var STATE_CONNECTED = "connected";
    var TopologyType = {
      Single: "Single",
      ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
      ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
      Sharded: "Sharded",
      Unknown: "Unknown"
    };
    var ServerType = {
      Standalone: "Standalone",
      Mongos: "Mongos",
      PossiblePrimary: "PossiblePrimary",
      RSPrimary: "RSPrimary",
      RSSecondary: "RSSecondary",
      RSArbiter: "RSArbiter",
      RSOther: "RSOther",
      RSGhost: "RSGhost",
      Unknown: "Unknown"
    };
    function serverType(server) {
      let description = server.s.description || server.s.serverDescription;
      if (description.topologyType === TopologyType.Single)
        return description.servers[0].type;
      return description.type;
    }
    var TOPOLOGY_DEFAULTS = {
      useUnifiedTopology: true,
      localThresholdMS: 15,
      serverSelectionTimeoutMS: 3e4,
      heartbeatFrequencyMS: 1e4,
      minHeartbeatFrequencyMS: 500
    };
    function drainTimerQueue(queue) {
      queue.forEach(clearTimeout);
      queue.clear();
    }
    function clearAndRemoveTimerFrom(timer, timers) {
      clearTimeout(timer);
      return timers.delete(timer);
    }
    module2.exports = {
      STATE_CLOSING,
      STATE_CLOSED,
      STATE_CONNECTING,
      STATE_CONNECTED,
      TOPOLOGY_DEFAULTS,
      TopologyType,
      ServerType,
      serverType,
      drainTimerQueue,
      clearAndRemoveTimerFrom
    };
  }
});

// node_modules/mongodb/lib/core/sdam/server_description.js
var require_server_description = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server_description.js"(exports2, module2) {
    "use strict";
    var arrayStrictEqual = require_utils4().arrayStrictEqual;
    var tagsStrictEqual = require_utils4().tagsStrictEqual;
    var errorStrictEqual = require_utils4().errorStrictEqual;
    var ServerType = require_common().ServerType;
    var now = require_utils6().now;
    var WRITABLE_SERVER_TYPES = new Set([
      ServerType.RSPrimary,
      ServerType.Standalone,
      ServerType.Mongos
    ]);
    var DATA_BEARING_SERVER_TYPES = new Set([
      ServerType.RSPrimary,
      ServerType.RSSecondary,
      ServerType.Mongos,
      ServerType.Standalone
    ]);
    var ISMASTER_FIELDS = [
      "minWireVersion",
      "maxWireVersion",
      "maxBsonObjectSize",
      "maxMessageSizeBytes",
      "maxWriteBatchSize",
      "compression",
      "me",
      "hosts",
      "passives",
      "arbiters",
      "tags",
      "setName",
      "setVersion",
      "electionId",
      "primary",
      "logicalSessionTimeoutMinutes",
      "saslSupportedMechs",
      "__nodejs_mock_server__",
      "$clusterTime"
    ];
    var ServerDescription = class {
      constructor(address, ismaster, options) {
        options = options || {};
        ismaster = Object.assign({
          minWireVersion: 0,
          maxWireVersion: 0,
          hosts: [],
          passives: [],
          arbiters: [],
          tags: []
        }, ismaster);
        this.address = address;
        this.error = options.error;
        this.roundTripTime = options.roundTripTime || -1;
        this.lastUpdateTime = now();
        this.lastWriteDate = ismaster.lastWrite ? ismaster.lastWrite.lastWriteDate : null;
        this.opTime = ismaster.lastWrite ? ismaster.lastWrite.opTime : null;
        this.type = parseServerType(ismaster);
        this.topologyVersion = options.topologyVersion || ismaster.topologyVersion;
        ISMASTER_FIELDS.forEach((field) => {
          if (typeof ismaster[field] !== "undefined")
            this[field] = ismaster[field];
        });
        if (this.me)
          this.me = this.me.toLowerCase();
        this.hosts = this.hosts.map((host) => host.toLowerCase());
        this.passives = this.passives.map((host) => host.toLowerCase());
        this.arbiters = this.arbiters.map((host) => host.toLowerCase());
      }
      get allHosts() {
        return this.hosts.concat(this.arbiters).concat(this.passives);
      }
      get isReadable() {
        return this.type === ServerType.RSSecondary || this.isWritable;
      }
      get isDataBearing() {
        return DATA_BEARING_SERVER_TYPES.has(this.type);
      }
      get isWritable() {
        return WRITABLE_SERVER_TYPES.has(this.type);
      }
      get host() {
        const chopLength = `:${this.port}`.length;
        return this.address.slice(0, -chopLength);
      }
      get port() {
        const port = this.address.split(":").pop();
        return port ? Number.parseInt(port, 10) : port;
      }
      equals(other) {
        const topologyVersionsEqual = this.topologyVersion === other.topologyVersion || compareTopologyVersion(this.topologyVersion, other.topologyVersion) === 0;
        return other != null && errorStrictEqual(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && this.me === other.me && arrayStrictEqual(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && (this.electionId ? other.electionId && this.electionId.equals(other.electionId) : this.electionId === other.electionId) && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
      }
    };
    function parseServerType(ismaster) {
      if (!ismaster || !ismaster.ok) {
        return ServerType.Unknown;
      }
      if (ismaster.isreplicaset) {
        return ServerType.RSGhost;
      }
      if (ismaster.msg && ismaster.msg === "isdbgrid") {
        return ServerType.Mongos;
      }
      if (ismaster.setName) {
        if (ismaster.hidden) {
          return ServerType.RSOther;
        } else if (ismaster.ismaster) {
          return ServerType.RSPrimary;
        } else if (ismaster.secondary) {
          return ServerType.RSSecondary;
        } else if (ismaster.arbiterOnly) {
          return ServerType.RSArbiter;
        } else {
          return ServerType.RSOther;
        }
      }
      return ServerType.Standalone;
    }
    function compareTopologyVersion(lhs, rhs) {
      if (lhs == null || rhs == null) {
        return -1;
      }
      if (lhs.processId.equals(rhs.processId)) {
        if (lhs.counter === rhs.counter) {
          return 0;
        } else if (lhs.counter < rhs.counter) {
          return -1;
        }
        return 1;
      }
      return -1;
    }
    module2.exports = {
      ServerDescription,
      parseServerType,
      compareTopologyVersion
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/constants.js
var require_constants = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/constants.js"(exports2, module2) {
    "use strict";
    var MIN_SUPPORTED_SERVER_VERSION = "2.6";
    var MAX_SUPPORTED_SERVER_VERSION = "5.0";
    var MIN_SUPPORTED_WIRE_VERSION = 2;
    var MAX_SUPPORTED_WIRE_VERSION = 13;
    module2.exports = {
      MIN_SUPPORTED_SERVER_VERSION,
      MAX_SUPPORTED_SERVER_VERSION,
      MIN_SUPPORTED_WIRE_VERSION,
      MAX_SUPPORTED_WIRE_VERSION
    };
  }
});

// node_modules/mongodb/lib/core/sdam/topology_description.js
var require_topology_description = __commonJS({
  "node_modules/mongodb/lib/core/sdam/topology_description.js"(exports2, module2) {
    "use strict";
    var ServerType = require_common().ServerType;
    var ServerDescription = require_server_description().ServerDescription;
    var WIRE_CONSTANTS = require_constants();
    var TopologyType = require_common().TopologyType;
    var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
    var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
    var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
    var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
    var TopologyDescription = class {
      constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {
        options = options || {};
        this.type = topologyType || TopologyType.Unknown;
        this.setName = setName || null;
        this.maxSetVersion = maxSetVersion || null;
        this.maxElectionId = maxElectionId || null;
        this.servers = serverDescriptions || new Map();
        this.stale = false;
        this.compatible = true;
        this.compatibilityError = null;
        this.logicalSessionTimeoutMinutes = null;
        this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;
        this.localThresholdMS = options.localThresholdMS || 0;
        this.commonWireVersion = commonWireVersion || null;
        Object.defineProperty(this, "options", { value: options, enumberable: false });
        for (const serverDescription of this.servers.values()) {
          if (serverDescription.type === ServerType.Unknown)
            continue;
          if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
          }
          if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
            break;
          }
        }
        this.logicalSessionTimeoutMinutes = null;
        for (const addressServerTuple of this.servers) {
          const server = addressServerTuple[1];
          if (server.isReadable) {
            if (server.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = null;
              break;
            }
            if (this.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
              continue;
            }
            this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);
          }
        }
      }
      updateFromSrvPollingEvent(ev) {
        const newAddresses = ev.addresses();
        const serverDescriptions = new Map(this.servers);
        for (const server of this.servers) {
          if (newAddresses.has(server[0])) {
            newAddresses.delete(server[0]);
          } else {
            serverDescriptions.delete(server[0]);
          }
        }
        if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {
          return this;
        }
        for (const address of newAddresses) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
        return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, this.options, null);
      }
      update(serverDescription) {
        const address = serverDescription.address;
        let topologyType = this.type;
        let setName = this.setName;
        let maxSetVersion = this.maxSetVersion;
        let maxElectionId = this.maxElectionId;
        let commonWireVersion = this.commonWireVersion;
        if (serverDescription.setName && setName && serverDescription.setName !== setName) {
          serverDescription = new ServerDescription(address, null);
        }
        const serverType = serverDescription.type;
        let serverDescriptions = new Map(this.servers);
        if (serverDescription.maxWireVersion !== 0) {
          if (commonWireVersion == null) {
            commonWireVersion = serverDescription.maxWireVersion;
          } else {
            commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
          }
        }
        serverDescriptions.set(address, serverDescription);
        if (topologyType === TopologyType.Single) {
          return new TopologyDescription(TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);
        }
        if (topologyType === TopologyType.Unknown) {
          if (serverType === ServerType.Standalone && this.servers.size !== 1) {
            serverDescriptions.delete(address);
          } else {
            topologyType = topologyTypeForServerType(serverType);
          }
        }
        if (topologyType === TopologyType.Sharded) {
          if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {
            serverDescriptions.delete(address);
          }
        }
        if (topologyType === TopologyType.ReplicaSetNoPrimary) {
          if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
            serverDescriptions.delete(address);
          }
          if (serverType === ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);
            topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
          } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
            const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);
            topologyType = result[0], setName = result[1];
          }
        }
        if (topologyType === TopologyType.ReplicaSetWithPrimary) {
          if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
            serverDescriptions.delete(address);
            topologyType = checkHasPrimary(serverDescriptions);
          } else if (serverType === ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);
            topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
          } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
            topologyType = updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription);
          } else {
            topologyType = checkHasPrimary(serverDescriptions);
          }
        }
        return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);
      }
      get error() {
        const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
        if (descriptionsWithError.length > 0) {
          return descriptionsWithError[0].error;
        }
        return void 0;
      }
      get hasKnownServers() {
        return Array.from(this.servers.values()).some((sd) => sd.type !== ServerType.Unknown);
      }
      get hasDataBearingServers() {
        return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
      }
      hasServer(address) {
        return this.servers.has(address);
      }
    };
    function topologyTypeForServerType(serverType) {
      if (serverType === ServerType.Standalone) {
        return TopologyType.Single;
      }
      if (serverType === ServerType.Mongos) {
        return TopologyType.Sharded;
      }
      if (serverType === ServerType.RSPrimary) {
        return TopologyType.ReplicaSetWithPrimary;
      }
      if (serverType === ServerType.RSGhost || serverType === ServerType.Unknown) {
        return TopologyType.Unknown;
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    function compareObjectId(oid1, oid2) {
      if (oid1 == null) {
        return -1;
      }
      if (oid2 == null) {
        return 1;
      }
      if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {
        const oid1Buffer = oid1.id;
        const oid2Buffer = oid2.id;
        return oid1Buffer.compare(oid2Buffer);
      }
      const oid1String = oid1.toString();
      const oid2String = oid2.toString();
      return oid1String.localeCompare(oid2String);
    }
    function updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId) {
      setName = setName || serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
      }
      const electionId = serverDescription.electionId ? serverDescription.electionId : null;
      if (serverDescription.setVersion && electionId) {
        if (maxSetVersion && maxElectionId) {
          if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {
            serverDescriptions.set(serverDescription.address, new ServerDescription(serverDescription.address));
            return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
          }
        }
        maxElectionId = serverDescription.electionId;
      }
      if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
        maxSetVersion = serverDescription.setVersion;
      }
      for (const address of serverDescriptions.keys()) {
        const server = serverDescriptions.get(address);
        if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {
          serverDescriptions.set(address, new ServerDescription(server.address));
          break;
        }
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
      });
      const currentAddresses = Array.from(serverDescriptions.keys());
      const responseAddresses = serverDescription.allHosts;
      currentAddresses.filter((addr) => responseAddresses.indexOf(addr) === -1).forEach((address) => {
        serverDescriptions.delete(address);
      });
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    function updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {
      if (setName == null) {
        throw new TypeError("setName is required");
      }
      if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return checkHasPrimary(serverDescriptions);
    }
    function updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {
      let topologyType = TopologyType.ReplicaSetNoPrimary;
      setName = setName || serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [topologyType, setName];
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
      });
      if (serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return [topologyType, setName];
    }
    function checkHasPrimary(serverDescriptions) {
      for (const addr of serverDescriptions.keys()) {
        if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {
          return TopologyType.ReplicaSetWithPrimary;
        }
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    module2.exports = {
      TopologyDescription
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/shared.js
var require_shared = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/shared.js"(exports2, module2) {
    "use strict";
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var ServerType = require_common().ServerType;
    var TopologyDescription = require_topology_description().TopologyDescription;
    var MESSAGE_HEADER_SIZE = 16;
    var COMPRESSION_DETAILS_SIZE = 9;
    var opcodes = {
      OP_REPLY: 1,
      OP_UPDATE: 2001,
      OP_INSERT: 2002,
      OP_QUERY: 2004,
      OP_GETMORE: 2005,
      OP_DELETE: 2006,
      OP_KILL_CURSORS: 2007,
      OP_COMPRESSED: 2012,
      OP_MSG: 2013
    };
    var getReadPreference = function(cmd, options) {
      var readPreference = cmd.readPreference || new ReadPreference("primary");
      if (options.readPreference) {
        readPreference = options.readPreference;
      }
      if (typeof readPreference === "string") {
        readPreference = new ReadPreference(readPreference);
      }
      if (!(readPreference instanceof ReadPreference)) {
        throw new MongoError("read preference must be a ReadPreference instance");
      }
      return readPreference;
    };
    var parseHeader = function(message) {
      return {
        length: message.readInt32LE(0),
        requestId: message.readInt32LE(4),
        responseTo: message.readInt32LE(8),
        opCode: message.readInt32LE(12)
      };
    };
    function applyCommonQueryOptions(queryOptions, options) {
      Object.assign(queryOptions, {
        raw: typeof options.raw === "boolean" ? options.raw : false,
        promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
        promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
        promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false,
        bsonRegExp: typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : false,
        monitoring: typeof options.monitoring === "boolean" ? options.monitoring : false,
        fullResult: typeof options.fullResult === "boolean" ? options.fullResult : false
      });
      if (typeof options.socketTimeout === "number") {
        queryOptions.socketTimeout = options.socketTimeout;
      }
      if (options.session) {
        queryOptions.session = options.session;
      }
      if (typeof options.documentsReturnedIn === "string") {
        queryOptions.documentsReturnedIn = options.documentsReturnedIn;
      }
      return queryOptions;
    }
    function isSharded(topologyOrServer) {
      if (topologyOrServer.type === "mongos")
        return true;
      if (topologyOrServer.description && topologyOrServer.description.type === ServerType.Mongos) {
        return true;
      }
      if (topologyOrServer.description && topologyOrServer.description instanceof TopologyDescription) {
        const servers = Array.from(topologyOrServer.description.servers.values());
        return servers.some((server) => server.type === ServerType.Mongos);
      }
      return false;
    }
    function databaseNamespace(ns) {
      return ns.split(".")[0];
    }
    function collectionNamespace(ns) {
      return ns.split(".").slice(1).join(".");
    }
    module2.exports = {
      getReadPreference,
      MESSAGE_HEADER_SIZE,
      COMPRESSION_DETAILS_SIZE,
      opcodes,
      parseHeader,
      applyCommonQueryOptions,
      isSharded,
      databaseNamespace,
      collectionNamespace
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/compression.js
var require_compression = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/compression.js"(exports2, module2) {
    "use strict";
    var Snappy = require_utils5().retrieveSnappy();
    var zlib = require("zlib");
    var compressorIDs = {
      snappy: 1,
      zlib: 2
    };
    var uncompressibleCommands = new Set([
      "ismaster",
      "saslStart",
      "saslContinue",
      "getnonce",
      "authenticate",
      "createUser",
      "updateUser",
      "copydbSaslStart",
      "copydbgetnonce",
      "copydb"
    ]);
    function compress(self2, dataToBeCompressed, callback) {
      switch (self2.options.agreedCompressor) {
        case "snappy":
          Snappy.compress(dataToBeCompressed, callback);
          break;
        case "zlib":
          var zlibOptions = {};
          if (self2.options.zlibCompressionLevel) {
            zlibOptions.level = self2.options.zlibCompressionLevel;
          }
          zlib.deflate(dataToBeCompressed, zlibOptions, callback);
          break;
        default:
          throw new Error('Attempt to compress message using unknown compressor "' + self2.options.agreedCompressor + '".');
      }
    }
    function decompress(compressorID, compressedData, callback) {
      if (compressorID < 0 || compressorID > compressorIDs.length) {
        throw new Error("Server sent message compressed using an unsupported compressor. (Received compressor ID " + compressorID + ")");
      }
      switch (compressorID) {
        case compressorIDs.snappy:
          Snappy.uncompress(compressedData, callback);
          break;
        case compressorIDs.zlib:
          zlib.inflate(compressedData, callback);
          break;
        default:
          callback(null, compressedData);
      }
    }
    module2.exports = {
      compressorIDs,
      uncompressibleCommands,
      compress,
      decompress
    };
  }
});

// node_modules/mongodb/lib/core/connection/commands.js
var require_commands = __commonJS({
  "node_modules/mongodb/lib/core/connection/commands.js"(exports2, module2) {
    "use strict";
    var retrieveBSON = require_utils5().retrieveBSON;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var Buffer2 = require_safe_buffer().Buffer;
    var _requestId = 0;
    var opcodes = require_shared().opcodes;
    var OPTS_TAILABLE_CURSOR = 2;
    var OPTS_SLAVE = 4;
    var OPTS_OPLOG_REPLAY = 8;
    var OPTS_NO_CURSOR_TIMEOUT = 16;
    var OPTS_AWAIT_DATA = 32;
    var OPTS_EXHAUST = 64;
    var OPTS_PARTIAL = 128;
    var CURSOR_NOT_FOUND = 1;
    var QUERY_FAILURE = 2;
    var SHARD_CONFIG_STALE = 4;
    var AWAIT_CAPABLE = 8;
    var Query = function(bson, ns, query, options) {
      var self2 = this;
      if (ns == null)
        throw new Error("ns must be specified for query");
      if (query == null)
        throw new Error("query must be specified for query");
      if (ns.indexOf("\0") !== -1) {
        throw new Error("namespace cannot contain a null character");
      }
      this.bson = bson;
      this.ns = ns;
      this.query = query;
      this.numberToSkip = options.numberToSkip || 0;
      this.numberToReturn = options.numberToReturn || 0;
      this.returnFieldSelector = options.returnFieldSelector || null;
      this.requestId = Query.getRequestId();
      this.pre32Limit = options.pre32Limit;
      this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
      this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
      this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : true;
      this.batchSize = self2.numberToReturn;
      this.tailable = false;
      this.slaveOk = typeof options.slaveOk === "boolean" ? options.slaveOk : false;
      this.oplogReplay = false;
      this.noCursorTimeout = false;
      this.awaitData = false;
      this.exhaust = false;
      this.partial = false;
    };
    Query.prototype.incRequestId = function() {
      this.requestId = _requestId++;
    };
    Query.nextRequestId = function() {
      return _requestId + 1;
    };
    Query.prototype.toBin = function() {
      var self2 = this;
      var buffers = [];
      var projection = null;
      var flags = 0;
      if (this.tailable) {
        flags |= OPTS_TAILABLE_CURSOR;
      }
      if (this.slaveOk) {
        flags |= OPTS_SLAVE;
      }
      if (this.oplogReplay) {
        flags |= OPTS_OPLOG_REPLAY;
      }
      if (this.noCursorTimeout) {
        flags |= OPTS_NO_CURSOR_TIMEOUT;
      }
      if (this.awaitData) {
        flags |= OPTS_AWAIT_DATA;
      }
      if (this.exhaust) {
        flags |= OPTS_EXHAUST;
      }
      if (this.partial) {
        flags |= OPTS_PARTIAL;
      }
      if (self2.batchSize !== self2.numberToReturn)
        self2.numberToReturn = self2.batchSize;
      var header = Buffer2.alloc(4 * 4 + 4 + Buffer2.byteLength(self2.ns) + 1 + 4 + 4);
      buffers.push(header);
      var query = self2.bson.serialize(this.query, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
      buffers.push(query);
      if (self2.returnFieldSelector && Object.keys(self2.returnFieldSelector).length > 0) {
        projection = self2.bson.serialize(this.returnFieldSelector, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
        buffers.push(projection);
      }
      var totalLength = header.length + query.length + (projection ? projection.length : 0);
      var index = 4;
      header[3] = totalLength >> 24 & 255;
      header[2] = totalLength >> 16 & 255;
      header[1] = totalLength >> 8 & 255;
      header[0] = totalLength & 255;
      header[index + 3] = this.requestId >> 24 & 255;
      header[index + 2] = this.requestId >> 16 & 255;
      header[index + 1] = this.requestId >> 8 & 255;
      header[index] = this.requestId & 255;
      index = index + 4;
      header[index + 3] = 0 >> 24 & 255;
      header[index + 2] = 0 >> 16 & 255;
      header[index + 1] = 0 >> 8 & 255;
      header[index] = 0 & 255;
      index = index + 4;
      header[index + 3] = opcodes.OP_QUERY >> 24 & 255;
      header[index + 2] = opcodes.OP_QUERY >> 16 & 255;
      header[index + 1] = opcodes.OP_QUERY >> 8 & 255;
      header[index] = opcodes.OP_QUERY & 255;
      index = index + 4;
      header[index + 3] = flags >> 24 & 255;
      header[index + 2] = flags >> 16 & 255;
      header[index + 1] = flags >> 8 & 255;
      header[index] = flags & 255;
      index = index + 4;
      index = index + header.write(this.ns, index, "utf8") + 1;
      header[index - 1] = 0;
      header[index + 3] = this.numberToSkip >> 24 & 255;
      header[index + 2] = this.numberToSkip >> 16 & 255;
      header[index + 1] = this.numberToSkip >> 8 & 255;
      header[index] = this.numberToSkip & 255;
      index = index + 4;
      header[index + 3] = this.numberToReturn >> 24 & 255;
      header[index + 2] = this.numberToReturn >> 16 & 255;
      header[index + 1] = this.numberToReturn >> 8 & 255;
      header[index] = this.numberToReturn & 255;
      index = index + 4;
      return buffers;
    };
    Query.getRequestId = function() {
      return ++_requestId;
    };
    var GetMore = function(bson, ns, cursorId, opts) {
      opts = opts || {};
      this.numberToReturn = opts.numberToReturn || 0;
      this.requestId = _requestId++;
      this.bson = bson;
      this.ns = ns;
      this.cursorId = cursorId;
    };
    GetMore.prototype.toBin = function() {
      var length = 4 + Buffer2.byteLength(this.ns) + 1 + 4 + 8 + 4 * 4;
      var index = 0;
      var _buffer = Buffer2.alloc(length);
      _buffer[index + 3] = length >> 24 & 255;
      _buffer[index + 2] = length >> 16 & 255;
      _buffer[index + 1] = length >> 8 & 255;
      _buffer[index] = length & 255;
      index = index + 4;
      _buffer[index + 3] = this.requestId >> 24 & 255;
      _buffer[index + 2] = this.requestId >> 16 & 255;
      _buffer[index + 1] = this.requestId >> 8 & 255;
      _buffer[index] = this.requestId & 255;
      index = index + 4;
      _buffer[index + 3] = 0 >> 24 & 255;
      _buffer[index + 2] = 0 >> 16 & 255;
      _buffer[index + 1] = 0 >> 8 & 255;
      _buffer[index] = 0 & 255;
      index = index + 4;
      _buffer[index + 3] = opcodes.OP_GETMORE >> 24 & 255;
      _buffer[index + 2] = opcodes.OP_GETMORE >> 16 & 255;
      _buffer[index + 1] = opcodes.OP_GETMORE >> 8 & 255;
      _buffer[index] = opcodes.OP_GETMORE & 255;
      index = index + 4;
      _buffer[index + 3] = 0 >> 24 & 255;
      _buffer[index + 2] = 0 >> 16 & 255;
      _buffer[index + 1] = 0 >> 8 & 255;
      _buffer[index] = 0 & 255;
      index = index + 4;
      index = index + _buffer.write(this.ns, index, "utf8") + 1;
      _buffer[index - 1] = 0;
      _buffer[index + 3] = this.numberToReturn >> 24 & 255;
      _buffer[index + 2] = this.numberToReturn >> 16 & 255;
      _buffer[index + 1] = this.numberToReturn >> 8 & 255;
      _buffer[index] = this.numberToReturn & 255;
      index = index + 4;
      _buffer[index + 3] = this.cursorId.getLowBits() >> 24 & 255;
      _buffer[index + 2] = this.cursorId.getLowBits() >> 16 & 255;
      _buffer[index + 1] = this.cursorId.getLowBits() >> 8 & 255;
      _buffer[index] = this.cursorId.getLowBits() & 255;
      index = index + 4;
      _buffer[index + 3] = this.cursorId.getHighBits() >> 24 & 255;
      _buffer[index + 2] = this.cursorId.getHighBits() >> 16 & 255;
      _buffer[index + 1] = this.cursorId.getHighBits() >> 8 & 255;
      _buffer[index] = this.cursorId.getHighBits() & 255;
      index = index + 4;
      return _buffer;
    };
    var KillCursor = function(bson, ns, cursorIds) {
      this.ns = ns;
      this.requestId = _requestId++;
      this.cursorIds = cursorIds;
    };
    KillCursor.prototype.toBin = function() {
      var length = 4 + 4 + 4 * 4 + this.cursorIds.length * 8;
      var index = 0;
      var _buffer = Buffer2.alloc(length);
      _buffer[index + 3] = length >> 24 & 255;
      _buffer[index + 2] = length >> 16 & 255;
      _buffer[index + 1] = length >> 8 & 255;
      _buffer[index] = length & 255;
      index = index + 4;
      _buffer[index + 3] = this.requestId >> 24 & 255;
      _buffer[index + 2] = this.requestId >> 16 & 255;
      _buffer[index + 1] = this.requestId >> 8 & 255;
      _buffer[index] = this.requestId & 255;
      index = index + 4;
      _buffer[index + 3] = 0 >> 24 & 255;
      _buffer[index + 2] = 0 >> 16 & 255;
      _buffer[index + 1] = 0 >> 8 & 255;
      _buffer[index] = 0 & 255;
      index = index + 4;
      _buffer[index + 3] = opcodes.OP_KILL_CURSORS >> 24 & 255;
      _buffer[index + 2] = opcodes.OP_KILL_CURSORS >> 16 & 255;
      _buffer[index + 1] = opcodes.OP_KILL_CURSORS >> 8 & 255;
      _buffer[index] = opcodes.OP_KILL_CURSORS & 255;
      index = index + 4;
      _buffer[index + 3] = 0 >> 24 & 255;
      _buffer[index + 2] = 0 >> 16 & 255;
      _buffer[index + 1] = 0 >> 8 & 255;
      _buffer[index] = 0 & 255;
      index = index + 4;
      _buffer[index + 3] = this.cursorIds.length >> 24 & 255;
      _buffer[index + 2] = this.cursorIds.length >> 16 & 255;
      _buffer[index + 1] = this.cursorIds.length >> 8 & 255;
      _buffer[index] = this.cursorIds.length & 255;
      index = index + 4;
      for (var i = 0; i < this.cursorIds.length; i++) {
        _buffer[index + 3] = this.cursorIds[i].getLowBits() >> 24 & 255;
        _buffer[index + 2] = this.cursorIds[i].getLowBits() >> 16 & 255;
        _buffer[index + 1] = this.cursorIds[i].getLowBits() >> 8 & 255;
        _buffer[index] = this.cursorIds[i].getLowBits() & 255;
        index = index + 4;
        _buffer[index + 3] = this.cursorIds[i].getHighBits() >> 24 & 255;
        _buffer[index + 2] = this.cursorIds[i].getHighBits() >> 16 & 255;
        _buffer[index + 1] = this.cursorIds[i].getHighBits() >> 8 & 255;
        _buffer[index] = this.cursorIds[i].getHighBits() & 255;
        index = index + 4;
      }
      return _buffer;
    };
    var Response = function(bson, message, msgHeader, msgBody, opts) {
      opts = opts || {
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false
      };
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.bson = bson;
      this.opts = opts;
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.responseFlags = msgBody.readInt32LE(0);
      this.cursorId = new Long2(msgBody.readInt32LE(4), msgBody.readInt32LE(8));
      this.startingFrom = msgBody.readInt32LE(12);
      this.numberReturned = msgBody.readInt32LE(16);
      this.documents = new Array(this.numberReturned);
      this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
      this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
      this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
      this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
      this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
      this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
      this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
      this.bsonRegExp = typeof opts.bsonRegExp === "boolean" ? opts.bsonRegExp : false;
    };
    Response.prototype.isParsed = function() {
      return this.parsed;
    };
    Response.prototype.parse = function(options) {
      if (this.parsed)
        return;
      options = options || {};
      var raw = options.raw || false;
      var documentsReturnedIn = options.documentsReturnedIn || null;
      var promoteLongs = typeof options.promoteLongs === "boolean" ? options.promoteLongs : this.opts.promoteLongs;
      var promoteValues = typeof options.promoteValues === "boolean" ? options.promoteValues : this.opts.promoteValues;
      var promoteBuffers = typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : this.opts.promoteBuffers;
      var bsonRegExp = typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : this.opts.bsonRegExp;
      var bsonSize, _options;
      _options = {
        promoteLongs,
        promoteValues,
        promoteBuffers,
        bsonRegExp
      };
      this.index = 20;
      for (var i = 0; i < this.numberReturned; i++) {
        bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
        if (raw) {
          this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
        } else {
          this.documents[i] = this.bson.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
        }
        this.index = this.index + bsonSize;
      }
      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        const fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        _options.fieldsAsRaw = fieldsAsRaw;
        const doc = this.bson.deserialize(this.documents[0], _options);
        this.documents = [doc];
      }
      this.parsed = true;
    };
    module2.exports = {
      Query,
      GetMore,
      Response,
      KillCursor
    };
  }
});

// node_modules/mongodb/lib/core/connection/msg.js
var require_msg = __commonJS({
  "node_modules/mongodb/lib/core/connection/msg.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var opcodes = require_shared().opcodes;
    var databaseNamespace = require_shared().databaseNamespace;
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var _requestId = 0;
    var OPTS_CHECKSUM_PRESENT = 1;
    var OPTS_MORE_TO_COME = 2;
    var OPTS_EXHAUST_ALLOWED = 1 << 16;
    var Msg = class {
      constructor(bson, ns, command, options) {
        if (command == null)
          throw new Error("query must be specified for query");
        this.bson = bson;
        this.ns = ns;
        this.command = command;
        this.command.$db = databaseNamespace(ns);
        if (options.readPreference && options.readPreference.mode !== ReadPreference.PRIMARY) {
          this.command.$readPreference = options.readPreference.toJSON();
        }
        this.options = options || {};
        this.requestId = options.requestId ? options.requestId : Msg.getRequestId();
        this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
        this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
        this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
        this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
        this.checksumPresent = false;
        this.moreToCome = options.moreToCome || false;
        this.exhaustAllowed = typeof options.exhaustAllowed === "boolean" ? options.exhaustAllowed : false;
      }
      toBin() {
        const buffers = [];
        let flags = 0;
        if (this.checksumPresent) {
          flags |= OPTS_CHECKSUM_PRESENT;
        }
        if (this.moreToCome) {
          flags |= OPTS_MORE_TO_COME;
        }
        if (this.exhaustAllowed) {
          flags |= OPTS_EXHAUST_ALLOWED;
        }
        const header = Buffer2.alloc(4 * 4 + 4);
        buffers.push(header);
        let totalLength = header.length;
        const command = this.command;
        totalLength += this.makeDocumentSegment(buffers, command);
        header.writeInt32LE(totalLength, 0);
        header.writeInt32LE(this.requestId, 4);
        header.writeInt32LE(0, 8);
        header.writeInt32LE(opcodes.OP_MSG, 12);
        header.writeUInt32LE(flags, 16);
        return buffers;
      }
      makeDocumentSegment(buffers, document2) {
        const payloadTypeBuffer = Buffer2.alloc(1);
        payloadTypeBuffer[0] = 0;
        const documentBuffer = this.serializeBson(document2);
        buffers.push(payloadTypeBuffer);
        buffers.push(documentBuffer);
        return payloadTypeBuffer.length + documentBuffer.length;
      }
      serializeBson(document2) {
        return this.bson.serialize(document2, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
      }
    };
    Msg.getRequestId = function() {
      _requestId = _requestId + 1 & 2147483647;
      return _requestId;
    };
    var BinMsg = class {
      constructor(bson, message, msgHeader, msgBody, opts) {
        opts = opts || {
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: false,
          bsonRegExp: false
        };
        this.parsed = false;
        this.raw = message;
        this.data = msgBody;
        this.bson = bson;
        this.opts = opts;
        this.length = msgHeader.length;
        this.requestId = msgHeader.requestId;
        this.responseTo = msgHeader.responseTo;
        this.opCode = msgHeader.opCode;
        this.fromCompressed = msgHeader.fromCompressed;
        this.responseFlags = msgBody.readInt32LE(0);
        this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
        this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
        this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
        this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
        this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
        this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
        this.bsonRegExp = typeof opts.bsonRegExp === "boolean" ? opts.bsonRegExp : false;
        this.documents = [];
      }
      isParsed() {
        return this.parsed;
      }
      parse(options) {
        if (this.parsed)
          return;
        options = options || {};
        this.index = 4;
        const raw = options.raw || false;
        const documentsReturnedIn = options.documentsReturnedIn || null;
        const promoteLongs = typeof options.promoteLongs === "boolean" ? options.promoteLongs : this.opts.promoteLongs;
        const promoteValues = typeof options.promoteValues === "boolean" ? options.promoteValues : this.opts.promoteValues;
        const promoteBuffers = typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : this.opts.promoteBuffers;
        const bsonRegExp = typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : this.opts.bsonRegExp;
        const _options = {
          promoteLongs,
          promoteValues,
          promoteBuffers,
          bsonRegExp
        };
        while (this.index < this.data.length) {
          const payloadType = this.data.readUInt8(this.index++);
          if (payloadType === 1) {
            throw new MongoError("OP_MSG Payload Type 1 detected unsupported protocol");
          } else if (payloadType === 0) {
            const bsonSize = this.data.readUInt32LE(this.index);
            const bin = this.data.slice(this.index, this.index + bsonSize);
            this.documents.push(raw ? bin : this.bson.deserialize(bin, _options));
            this.index += bsonSize;
          }
        }
        if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
          const fieldsAsRaw = {};
          fieldsAsRaw[documentsReturnedIn] = true;
          _options.fieldsAsRaw = fieldsAsRaw;
          const doc = this.bson.deserialize(this.documents[0], _options);
          this.documents = [doc];
        }
        this.parsed = true;
      }
    };
    module2.exports = { Msg, BinMsg };
  }
});

// node_modules/mongodb/lib/core/connection/logger.js
var require_logger = __commonJS({
  "node_modules/mongodb/lib/core/connection/logger.js"(exports2, module2) {
    "use strict";
    var f = require("util").format;
    var MongoError = require_error().MongoError;
    var classFilters = {};
    var filteredClasses = {};
    var level = null;
    var pid = process.pid;
    var currentLogger = null;
    var Logger = function(className, options) {
      if (!(this instanceof Logger))
        return new Logger(className, options);
      options = options || {};
      this.className = className;
      if (options.logger) {
        currentLogger = options.logger;
      } else if (currentLogger == null) {
        currentLogger = console.log;
      }
      if (options.loggerLevel) {
        level = options.loggerLevel || "error";
      }
      if (filteredClasses[this.className] == null)
        classFilters[this.className] = true;
    };
    Logger.prototype.debug = function(message, object) {
      if (this.isDebug() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "DEBUG", this.className, pid, dateTime, message);
        var state = {
          type: "debug",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    };
    Logger.prototype.warn = function(message, object) {
      if (this.isWarn() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "WARN", this.className, pid, dateTime, message);
        var state = {
          type: "warn",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.info = function(message, object) {
      if (this.isInfo() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "INFO", this.className, pid, dateTime, message);
        var state = {
          type: "info",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.error = function(message, object) {
      if (this.isError() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "ERROR", this.className, pid, dateTime, message);
        var state = {
          type: "error",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.isInfo = function() {
      return level === "info" || level === "debug";
    }, Logger.prototype.isError = function() {
      return level === "error" || level === "info" || level === "debug";
    }, Logger.prototype.isWarn = function() {
      return level === "error" || level === "warn" || level === "info" || level === "debug";
    }, Logger.prototype.isDebug = function() {
      return level === "debug";
    };
    Logger.reset = function() {
      level = "error";
      filteredClasses = {};
    };
    Logger.currentLogger = function() {
      return currentLogger;
    };
    Logger.setCurrentLogger = function(logger) {
      if (typeof logger !== "function")
        throw new MongoError("current logger must be a function");
      currentLogger = logger;
    };
    Logger.filter = function(type, values) {
      if (type === "class" && Array.isArray(values)) {
        filteredClasses = {};
        values.forEach(function(x) {
          filteredClasses[x] = true;
        });
      }
    };
    Logger.setLevel = function(_level) {
      if (_level !== "info" && _level !== "error" && _level !== "debug" && _level !== "warn") {
        throw new Error(f("%s is an illegal logging level", _level));
      }
      level = _level;
    };
    module2.exports = Logger;
  }
});

// node_modules/mongodb/lib/core/connection/command_result.js
var require_command_result = __commonJS({
  "node_modules/mongodb/lib/core/connection/command_result.js"(exports2, module2) {
    "use strict";
    var CommandResult = function(result, connection, message) {
      this.result = result;
      this.connection = connection;
      this.message = message;
    };
    CommandResult.prototype.toJSON = function() {
      let result = Object.assign({}, this, this.result);
      delete result.message;
      return result;
    };
    CommandResult.prototype.toString = function() {
      return JSON.stringify(this.toJSON());
    };
    module2.exports = CommandResult;
  }
});

// node_modules/mongodb/lib/core/connection/connection.js
var require_connection = __commonJS({
  "node_modules/mongodb/lib/core/connection/connection.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var crypto = require("crypto");
    var debugOptions = require_utils5().debugOptions;
    var parseHeader = require_shared().parseHeader;
    var decompress = require_compression().decompress;
    var Response = require_commands().Response;
    var BinMsg = require_msg().BinMsg;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var MongoError = require_error().MongoError;
    var Logger = require_logger();
    var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
    var OP_MSG = require_shared().opcodes.OP_MSG;
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var Buffer2 = require_safe_buffer().Buffer;
    var Query = require_commands().Query;
    var CommandResult = require_command_result();
    var _id = 0;
    var DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;
    var DEBUG_FIELDS = [
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "checkServerIdentity"
    ];
    var connectionAccountingSpy = void 0;
    var connectionAccounting = false;
    var connections = {};
    var Connection = class extends EventEmitter {
      constructor(socket, options) {
        super();
        options = options || {};
        if (!options.bson) {
          throw new TypeError("must pass in valid bson parser");
        }
        this.id = _id++;
        this.options = options;
        this.logger = Logger("Connection", options);
        this.bson = options.bson;
        this.tag = options.tag;
        this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;
        this.port = options.port || 27017;
        this.host = options.host || "localhost";
        this.socketTimeout = typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
        this.keepAlive = typeof options.keepAlive === "boolean" ? options.keepAlive : true;
        this.keepAliveInitialDelay = typeof options.keepAliveInitialDelay === "number" ? options.keepAliveInitialDelay : 12e4;
        this.connectionTimeout = typeof options.connectionTimeout === "number" ? options.connectionTimeout : 3e4;
        if (this.keepAliveInitialDelay > this.socketTimeout) {
          this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);
        }
        if (this.logger.isDebug()) {
          this.logger.debug(`creating connection ${this.id} with options [${JSON.stringify(debugOptions(DEBUG_FIELDS, options))}]`);
        }
        this.responseOptions = {
          promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
          promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
          promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false,
          bsonRegExp: typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : false
        };
        this.flushing = false;
        this.queue = [];
        this.writeStream = null;
        this.destroyed = false;
        this.timedOut = false;
        const hash = crypto.createHash("sha1");
        hash.update(this.address);
        this.hashedName = hash.digest("hex");
        this.workItems = [];
        this.socket = socket;
        this.socket.once("error", errorHandler(this));
        this.socket.once("timeout", timeoutHandler(this));
        this.socket.once("close", closeHandler(this));
        this.socket.on("data", dataHandler(this));
        if (connectionAccounting) {
          addConnection(this.id, this);
        }
      }
      setSocketTimeout(value) {
        if (this.socket) {
          this.socket.setTimeout(value);
        }
      }
      resetSocketTimeout() {
        if (this.socket) {
          this.socket.setTimeout(this.socketTimeout);
        }
      }
      static enableConnectionAccounting(spy) {
        if (spy) {
          connectionAccountingSpy = spy;
        }
        connectionAccounting = true;
        connections = {};
      }
      static disableConnectionAccounting() {
        connectionAccounting = false;
        connectionAccountingSpy = void 0;
      }
      static connections() {
        return connections;
      }
      get address() {
        return `${this.host}:${this.port}`;
      }
      unref() {
        if (this.socket == null) {
          this.once("connect", () => this.socket.unref());
          return;
        }
        this.socket.unref();
      }
      flush(err) {
        while (this.workItems.length > 0) {
          const workItem = this.workItems.shift();
          if (workItem.cb) {
            workItem.cb(err);
          }
        }
      }
      destroy(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = Object.assign({ force: false }, options);
        if (connectionAccounting) {
          deleteConnection(this.id);
        }
        if (this.socket == null) {
          this.destroyed = true;
          return;
        }
        if (options.force || this.timedOut) {
          this.socket.destroy();
          this.destroyed = true;
          if (typeof callback === "function")
            callback(null, null);
          return;
        }
        this.socket.end((err) => {
          this.destroyed = true;
          if (typeof callback === "function")
            callback(err, null);
        });
      }
      write(buffer) {
        if (this.logger.isDebug()) {
          if (!Array.isArray(buffer)) {
            this.logger.debug(`writing buffer [ ${buffer.length} ] to ${this.address}`);
          } else {
            for (let i = 0; i < buffer.length; i++)
              this.logger.debug(`writing buffer [ ${buffer[i].length} ] to ${this.address}`);
          }
        }
        if (this.socket.destroyed === false) {
          if (!Array.isArray(buffer)) {
            this.socket.write(buffer, "binary");
            return true;
          }
          for (let i = 0; i < buffer.length; i++) {
            this.socket.write(buffer[i], "binary");
          }
          return true;
        }
        return false;
      }
      toString() {
        return "" + this.id;
      }
      toJSON() {
        return { id: this.id, host: this.host, port: this.port };
      }
      isConnected() {
        if (this.destroyed)
          return false;
        return !this.socket.destroyed && this.socket.writable;
      }
      command(ns, command, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        const conn = this;
        const socketTimeout = typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
        const bson = conn.options.bson;
        const query = new Query(bson, ns, command, {
          numberToSkip: 0,
          numberToReturn: 1
        });
        const noop = () => {
        };
        function _callback(err, result) {
          callback(err, result);
          callback = noop;
        }
        function errorHandler2(err) {
          conn.resetSocketTimeout();
          CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
          conn.removeListener("message", messageHandler);
          if (err == null) {
            err = new MongoError(`runCommand failed for connection to '${conn.address}'`);
          }
          conn.on("error", noop);
          _callback(err);
        }
        function messageHandler(msg) {
          if (msg.responseTo !== query.requestId) {
            return;
          }
          conn.resetSocketTimeout();
          CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
          conn.removeListener("message", messageHandler);
          msg.parse({ promoteValues: true });
          const response = msg.documents[0];
          if (response.ok === 0 || response.$err || response.errmsg || response.code) {
            _callback(new MongoError(response));
            return;
          }
          _callback(void 0, new CommandResult(response, this, msg));
        }
        conn.setSocketTimeout(socketTimeout);
        CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.once(eventName, errorHandler2));
        conn.on("message", messageHandler);
        conn.write(query.toBin());
      }
    };
    var CONNECTION_ERROR_EVENTS = ["error", "close", "timeout", "parseError"];
    function deleteConnection(id) {
      delete connections[id];
      if (connectionAccountingSpy) {
        connectionAccountingSpy.deleteConnection(id);
      }
    }
    function addConnection(id, connection) {
      connections[id] = connection;
      if (connectionAccountingSpy) {
        connectionAccountingSpy.addConnection(id, connection);
      }
    }
    function errorHandler(conn) {
      return function(err) {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`);
        }
        conn.emit("error", new MongoNetworkError(err), conn);
      };
    }
    function timeoutHandler(conn) {
      return function() {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);
        }
        conn.timedOut = true;
        conn.emit("timeout", new MongoNetworkTimeoutError(`connection ${conn.id} to ${conn.address} timed out`, {
          beforeHandshake: conn.ismaster == null
        }), conn);
      };
    }
    function closeHandler(conn) {
      return function(hadError) {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);
        }
        if (!hadError) {
          conn.emit("close", new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`), conn);
        }
      };
    }
    function processMessage(conn, message) {
      const msgHeader = parseHeader(message);
      if (msgHeader.opCode !== OP_COMPRESSED) {
        const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;
        conn.emit("message", new ResponseConstructor(conn.bson, message, msgHeader, message.slice(MESSAGE_HEADER_SIZE), conn.responseOptions), conn);
        return;
      }
      msgHeader.fromCompressed = true;
      let index = MESSAGE_HEADER_SIZE;
      msgHeader.opCode = message.readInt32LE(index);
      index += 4;
      msgHeader.length = message.readInt32LE(index);
      index += 4;
      const compressorID = message[index];
      index++;
      decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {
        if (err) {
          conn.emit("error", err);
          return;
        }
        if (decompressedMsgBody.length !== msgHeader.length) {
          conn.emit("error", new MongoError("Decompressing a compressed message from the server failed. The message is corrupt."));
          return;
        }
        const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;
        conn.emit("message", new ResponseConstructor(conn.bson, message, msgHeader, decompressedMsgBody, conn.responseOptions), conn);
      });
    }
    function dataHandler(conn) {
      return function(data) {
        while (data.length > 0) {
          if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {
            const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;
            if (remainingBytesToRead > data.length) {
              data.copy(conn.buffer, conn.bytesRead);
              conn.bytesRead = conn.bytesRead + data.length;
              data = Buffer2.alloc(0);
            } else {
              data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);
              data = data.slice(remainingBytesToRead);
              const emitBuffer = conn.buffer;
              conn.buffer = null;
              conn.sizeOfMessage = 0;
              conn.bytesRead = 0;
              conn.stubBuffer = null;
              processMessage(conn, emitBuffer);
            }
          } else {
            if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {
              if (conn.stubBuffer.length + data.length > 4) {
                const newData = Buffer2.alloc(conn.stubBuffer.length + data.length);
                conn.stubBuffer.copy(newData, 0);
                data.copy(newData, conn.stubBuffer.length);
                data = newData;
                conn.buffer = null;
                conn.sizeOfMessage = 0;
                conn.bytesRead = 0;
                conn.stubBuffer = null;
              } else {
                const newStubBuffer = Buffer2.alloc(conn.stubBuffer.length + data.length);
                conn.stubBuffer.copy(newStubBuffer, 0);
                data.copy(newStubBuffer, conn.stubBuffer.length);
                data = Buffer2.alloc(0);
              }
            } else {
              if (data.length > 4) {
                const sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;
                if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {
                  const errorObject = {
                    err: "socketHandler",
                    trace: "",
                    bin: conn.buffer,
                    parseState: {
                      sizeOfMessage,
                      bytesRead: conn.bytesRead,
                      stubBuffer: conn.stubBuffer
                    }
                  };
                  conn.emit("parseError", errorObject, conn);
                  return;
                }
                if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage > data.length) {
                  conn.buffer = Buffer2.alloc(sizeOfMessage);
                  data.copy(conn.buffer, 0);
                  conn.bytesRead = data.length;
                  conn.sizeOfMessage = sizeOfMessage;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                } else if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage === data.length) {
                  const emitBuffer = data;
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                  processMessage(conn, emitBuffer);
                } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {
                  const errorObject = {
                    err: "socketHandler",
                    trace: null,
                    bin: data,
                    parseState: {
                      sizeOfMessage,
                      bytesRead: 0,
                      buffer: null,
                      stubBuffer: null
                    }
                  };
                  conn.emit("parseError", errorObject, conn);
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                } else {
                  const emitBuffer = data.slice(0, sizeOfMessage);
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = data.slice(sizeOfMessage);
                  processMessage(conn, emitBuffer);
                }
              } else {
                conn.stubBuffer = Buffer2.alloc(data.length);
                data.copy(conn.stubBuffer, 0);
                data = Buffer2.alloc(0);
              }
            }
          }
        }
      };
    }
    module2.exports = Connection;
  }
});

// node_modules/mongodb/lib/command_utils.js
var require_command_utils = __commonJS({
  "node_modules/mongodb/lib/command_utils.js"(exports2, module2) {
    "use strict";
    var Msg = require_msg().Msg;
    var KillCursor = require_commands().KillCursor;
    var GetMore = require_commands().GetMore;
    var deepCopy = require_utils6().deepCopy;
    var SENSITIVE_COMMANDS = new Set([
      "authenticate",
      "saslStart",
      "saslContinue",
      "getnonce",
      "createUser",
      "updateUser",
      "copydbgetnonce",
      "copydbsaslstart",
      "copydb"
    ]);
    var HELLO_COMMANDS = new Set(["hello", "ismaster", "isMaster"]);
    var LEGACY_FIND_QUERY_MAP = {
      $query: "filter",
      $orderby: "sort",
      $hint: "hint",
      $comment: "comment",
      $maxScan: "maxScan",
      $max: "max",
      $min: "min",
      $returnKey: "returnKey",
      $showDiskLoc: "showRecordId",
      $maxTimeMS: "maxTimeMS",
      $snapshot: "snapshot"
    };
    var LEGACY_FIND_OPTIONS_MAP = {
      numberToSkip: "skip",
      numberToReturn: "batchSize",
      returnFieldsSelector: "projection"
    };
    var OP_QUERY_KEYS = [
      "tailable",
      "oplogReplay",
      "noCursorTimeout",
      "awaitData",
      "partial",
      "exhaust"
    ];
    var collectionName = (command) => command.ns.split(".")[1];
    var shouldRedactCommand = (commandName, cmd) => SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && !!cmd.speculativeAuthenticate;
    var extractCommand = (command) => {
      let extractedCommand;
      if (command instanceof GetMore) {
        extractedCommand = {
          getMore: deepCopy(command.cursorId),
          collection: collectionName(command),
          batchSize: command.numberToReturn
        };
      } else if (command instanceof KillCursor) {
        extractedCommand = {
          killCursors: collectionName(command),
          cursors: deepCopy(command.cursorIds)
        };
      } else if (command instanceof Msg) {
        extractedCommand = deepCopy(command.command);
      } else if (command.query && command.query.$query) {
        let result;
        if (command.ns === "admin.$cmd") {
          result = Object.assign({}, command.query.$query);
        } else {
          result = { find: collectionName(command) };
          Object.keys(LEGACY_FIND_QUERY_MAP).forEach((key) => {
            if (typeof command.query[key] !== "undefined")
              result[LEGACY_FIND_QUERY_MAP[key]] = deepCopy(command.query[key]);
          });
        }
        Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach((key) => {
          if (typeof command[key] !== "undefined")
            result[LEGACY_FIND_OPTIONS_MAP[key]] = deepCopy(command[key]);
        });
        OP_QUERY_KEYS.forEach((key) => {
          if (command[key])
            result[key] = command[key];
        });
        if (typeof command.pre32Limit !== "undefined") {
          result.limit = command.pre32Limit;
        }
        if (command.query.$explain) {
          extractedCommand = { explain: result };
        } else {
          extractedCommand = result;
        }
      } else {
        extractedCommand = deepCopy(command.query || command);
      }
      const commandName = Object.keys(extractedCommand)[0];
      return {
        cmd: extractedCommand,
        name: commandName,
        shouldRedact: shouldRedactCommand(commandName, extractedCommand)
      };
    };
    module2.exports = {
      extractCommand
    };
  }
});

// node_modules/mongodb/lib/core/connection/apm.js
var require_apm = __commonJS({
  "node_modules/mongodb/lib/core/connection/apm.js"(exports2, module2) {
    "use strict";
    var KillCursor = require_commands().KillCursor;
    var GetMore = require_commands().GetMore;
    var calculateDurationInMs = require_utils6().calculateDurationInMs;
    var extractCommand = require_command_utils().extractCommand;
    var namespace = (command) => command.ns;
    var databaseName = (command) => command.ns.split(".")[0];
    var generateConnectionId = (pool) => pool.options ? `${pool.options.host}:${pool.options.port}` : pool.address;
    var isLegacyPool = (pool) => pool.s && pool.queue;
    var extractReply = (command, reply) => {
      if (command instanceof GetMore) {
        return {
          ok: 1,
          cursor: {
            id: reply.message.cursorId,
            ns: namespace(command),
            nextBatch: reply.message.documents
          }
        };
      }
      if (command instanceof KillCursor) {
        return {
          ok: 1,
          cursorsUnknown: command.cursorIds
        };
      }
      if (command.query && typeof command.query.$query !== "undefined") {
        return {
          ok: 1,
          cursor: {
            id: reply.message.cursorId,
            ns: namespace(command),
            firstBatch: reply.message.documents
          }
        };
      }
      return reply && reply.result ? reply.result : reply;
    };
    var extractConnectionDetails = (pool) => {
      if (isLegacyPool(pool)) {
        return {
          connectionId: generateConnectionId(pool)
        };
      }
      const connection = pool;
      return {
        address: connection.address,
        connectionId: connection.id
      };
    };
    var CommandStartedEvent = class {
      constructor(pool, command) {
        const extractedCommand = extractCommand(command);
        const commandName = extractedCommand.name;
        const connectionDetails = extractConnectionDetails(pool);
        Object.assign(this, connectionDetails, {
          requestId: command.requestId,
          databaseName: databaseName(command),
          commandName,
          command: extractedCommand.shouldRedact ? {} : extractedCommand.cmd
        });
      }
    };
    var CommandSucceededEvent = class {
      constructor(pool, command, reply, started) {
        const extractedCommand = extractCommand(command);
        const commandName = extractedCommand.name;
        const connectionDetails = extractConnectionDetails(pool);
        Object.assign(this, connectionDetails, {
          requestId: command.requestId,
          commandName,
          duration: calculateDurationInMs(started),
          reply: extractedCommand.shouldRedact ? {} : extractReply(command, reply)
        });
      }
    };
    var CommandFailedEvent = class {
      constructor(pool, command, error, started) {
        const extractedCommand = extractCommand(command);
        const commandName = extractedCommand.name;
        const connectionDetails = extractConnectionDetails(pool);
        Object.assign(this, connectionDetails, {
          requestId: command.requestId,
          commandName,
          duration: calculateDurationInMs(started),
          failure: extractedCommand.shouldRedact ? {} : error
        });
      }
    };
    module2.exports = {
      CommandStartedEvent,
      CommandSucceededEvent,
      CommandFailedEvent
    };
  }
});

// node_modules/mongodb/lib/core/auth/auth_provider.js
var require_auth_provider = __commonJS({
  "node_modules/mongodb/lib/core/auth/auth_provider.js"(exports2, module2) {
    "use strict";
    var AuthContext = class {
      constructor(connection, credentials, options) {
        this.connection = connection;
        this.credentials = credentials;
        this.options = options;
      }
    };
    var AuthProvider = class {
      constructor(bson) {
        this.bson = bson;
      }
      prepare(handshakeDoc, context, callback) {
        callback(void 0, handshakeDoc);
      }
      auth(context, callback) {
        callback(new TypeError("`auth` method must be overridden by subclass"));
      }
    };
    module2.exports = { AuthContext, AuthProvider };
  }
});

// node_modules/mongodb/lib/core/auth/mongocr.js
var require_mongocr = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongocr.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    var AuthProvider = require_auth_provider().AuthProvider;
    var MongoCR = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        const username = credentials.username;
        const password = credentials.password;
        const source = credentials.source;
        connection.command(`${source}.$cmd`, { getnonce: 1 }, (err, result) => {
          let nonce = null;
          let key = null;
          if (err == null) {
            const r = result.result;
            nonce = r.nonce;
            let md5 = crypto.createHash("md5");
            md5.update(username + ":mongo:" + password, "utf8");
            const hash_password = md5.digest("hex");
            md5 = crypto.createHash("md5");
            md5.update(nonce + username + hash_password, "utf8");
            key = md5.digest("hex");
          }
          const authenticateCommand = {
            authenticate: 1,
            user: username,
            nonce,
            key
          };
          connection.command(`${source}.$cmd`, authenticateCommand, callback);
        });
      }
    };
    module2.exports = MongoCR;
  }
});

// node_modules/mongodb/lib/core/auth/x509.js
var require_x509 = __commonJS({
  "node_modules/mongodb/lib/core/auth/x509.js"(exports2, module2) {
    "use strict";
    var AuthProvider = require_auth_provider().AuthProvider;
    var X509 = class extends AuthProvider {
      prepare(handshakeDoc, authContext, callback) {
        const credentials = authContext.credentials;
        Object.assign(handshakeDoc, {
          speculativeAuthenticate: x509AuthenticateCommand(credentials)
        });
        callback(void 0, handshakeDoc);
      }
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        const response = authContext.response;
        if (response.speculativeAuthenticate) {
          return callback();
        }
        connection.command("$external.$cmd", x509AuthenticateCommand(credentials), callback);
      }
    };
    function x509AuthenticateCommand(credentials) {
      const command = { authenticate: 1, mechanism: "MONGODB-X509" };
      if (credentials.username) {
        Object.assign(command, { user: credentials.username });
      }
      return command;
    }
    module2.exports = X509;
  }
});

// node_modules/mongodb/lib/core/auth/plain.js
var require_plain = __commonJS({
  "node_modules/mongodb/lib/core/auth/plain.js"(exports2, module2) {
    "use strict";
    var retrieveBSON = require_utils5().retrieveBSON;
    var AuthProvider = require_auth_provider().AuthProvider;
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var Plain = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        const username = credentials.username;
        const password = credentials.password;
        const payload = new Binary2(`\0${username}\0${password}`);
        const command = {
          saslStart: 1,
          mechanism: "PLAIN",
          payload,
          autoAuthorize: 1
        };
        connection.command("$external.$cmd", command, callback);
      }
    };
    module2.exports = Plain;
  }
});

// node_modules/mongodb/lib/core/auth/gssapi.js
var require_gssapi = __commonJS({
  "node_modules/mongodb/lib/core/auth/gssapi.js"(exports2, module2) {
    "use strict";
    var dns = require("dns");
    var AuthProvider = require_auth_provider().AuthProvider;
    var retrieveKerberos = require_utils4().retrieveKerberos;
    var MongoError = require_error().MongoError;
    var kerberos;
    var GSSAPI = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        if (credentials == null)
          return callback(new MongoError("credentials required"));
        const username = credentials.username;
        function externalCommand(command, cb) {
          return connection.command("$external.$cmd", command, cb);
        }
        makeKerberosClient(authContext, (err, client) => {
          if (err)
            return callback(err);
          if (client == null)
            return callback(new MongoError("gssapi client missing"));
          client.step("", (err2, payload) => {
            if (err2)
              return callback(err2);
            externalCommand(saslStart(payload), (err3, response) => {
              if (err3)
                return callback(err3);
              const result = response.result;
              negotiate(client, 10, result.payload, (err4, payload2) => {
                if (err4)
                  return callback(err4);
                externalCommand(saslContinue(payload2, result.conversationId), (err5, response2) => {
                  if (err5)
                    return callback(err5);
                  const result2 = response2.result;
                  finalize(client, username, result2.payload, (err6, payload3) => {
                    if (err6)
                      return callback(err6);
                    externalCommand({
                      saslContinue: 1,
                      conversationId: result2.conversationId,
                      payload: payload3
                    }, (err7, result3) => {
                      if (err7)
                        return callback(err7);
                      callback(void 0, result3);
                    });
                  });
                });
              });
            });
          });
        });
      }
    };
    module2.exports = GSSAPI;
    function makeKerberosClient(authContext, callback) {
      const host = authContext.options.host;
      const port = authContext.options.port;
      const credentials = authContext.credentials;
      if (!host || !port || !credentials) {
        return callback(new MongoError(`Connection must specify: ${host ? "host" : ""}, ${port ? "port" : ""}, ${credentials ? "host" : "credentials"}.`));
      }
      if (kerberos == null) {
        try {
          kerberos = retrieveKerberos();
        } catch (e) {
          return callback(e);
        }
      }
      const username = credentials.username;
      const password = credentials.password;
      const mechanismProperties = credentials.mechanismProperties;
      const serviceName = mechanismProperties["gssapiservicename"] || mechanismProperties["gssapiServiceName"] || "mongodb";
      performGssapiCanonicalizeHostName(host, mechanismProperties, (err, host2) => {
        if (err)
          return callback(err);
        const initOptions = {};
        if (password != null) {
          Object.assign(initOptions, { user: username, password });
        }
        kerberos.initializeClient(`${serviceName}${process.platform === "win32" ? "/" : "@"}${host2}`, initOptions, (err2, client) => {
          if (err2)
            return callback(new MongoError(err2));
          callback(null, client);
        });
      });
    }
    function saslStart(payload) {
      return {
        saslStart: 1,
        mechanism: "GSSAPI",
        payload,
        autoAuthorize: 1
      };
    }
    function saslContinue(payload, conversationId) {
      return {
        saslContinue: 1,
        conversationId,
        payload
      };
    }
    function negotiate(client, retries, payload, callback) {
      client.step(payload, (err, response) => {
        if (err && retries === 0)
          return callback(err);
        if (err)
          return negotiate(client, retries - 1, payload, callback);
        callback(void 0, response || "");
      });
    }
    function finalize(client, user, payload, callback) {
      client.unwrap(payload, (err, response) => {
        if (err)
          return callback(err);
        client.wrap(response || "", { user }, (err2, wrapped) => {
          if (err2)
            return callback(err2);
          callback(void 0, wrapped);
        });
      });
    }
    function performGssapiCanonicalizeHostName(host, mechanismProperties, callback) {
      const canonicalizeHostName = typeof mechanismProperties.gssapiCanonicalizeHostName === "boolean" ? mechanismProperties.gssapiCanonicalizeHostName : false;
      if (!canonicalizeHostName)
        return callback(void 0, host);
      dns.resolveCname(host, (err, r) => {
        if (err)
          return callback(err);
        if (Array.isArray(r) && r.length > 0) {
          return callback(void 0, r[0]);
        }
        callback(void 0, host);
      });
    }
  }
});

// node_modules/memory-pager/index.js
var require_memory_pager = __commonJS({
  "node_modules/memory-pager/index.js"(exports2, module2) {
    module2.exports = Pager;
    function Pager(pageSize, opts) {
      if (!(this instanceof Pager))
        return new Pager(pageSize, opts);
      this.length = 0;
      this.updates = [];
      this.path = new Uint16Array(4);
      this.pages = new Array(32768);
      this.maxPages = this.pages.length;
      this.level = 0;
      this.pageSize = pageSize || 1024;
      this.deduplicate = opts ? opts.deduplicate : null;
      this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
    }
    Pager.prototype.updated = function(page) {
      while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
        page.deduplicate++;
        if (page.deduplicate === this.deduplicate.length) {
          page.deduplicate = 0;
          if (page.buffer.equals && page.buffer.equals(this.deduplicate))
            page.buffer = this.deduplicate;
          break;
        }
      }
      if (page.updated || !this.updates)
        return;
      page.updated = true;
      this.updates.push(page);
    };
    Pager.prototype.lastUpdate = function() {
      if (!this.updates || !this.updates.length)
        return null;
      var page = this.updates.pop();
      page.updated = false;
      return page;
    };
    Pager.prototype._array = function(i, noAllocate) {
      if (i >= this.maxPages) {
        if (noAllocate)
          return;
        grow(this, i);
      }
      factor(i, this.path);
      var arr = this.pages;
      for (var j = this.level; j > 0; j--) {
        var p = this.path[j];
        var next = arr[p];
        if (!next) {
          if (noAllocate)
            return;
          next = arr[p] = new Array(32768);
        }
        arr = next;
      }
      return arr;
    };
    Pager.prototype.get = function(i, noAllocate) {
      var arr = this._array(i, noAllocate);
      var first = this.path[0];
      var page = arr && arr[first];
      if (!page && !noAllocate) {
        page = arr[first] = new Page(i, alloc(this.pageSize));
        if (i >= this.length)
          this.length = i + 1;
      }
      if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
        page.buffer = copy(page.buffer);
        page.deduplicate = 0;
      }
      return page;
    };
    Pager.prototype.set = function(i, buf) {
      var arr = this._array(i, false);
      var first = this.path[0];
      if (i >= this.length)
        this.length = i + 1;
      if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
        arr[first] = void 0;
        return;
      }
      if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
        buf = this.deduplicate;
      }
      var page = arr[first];
      var b = truncate(buf, this.pageSize);
      if (page)
        page.buffer = b;
      else
        arr[first] = new Page(i, b);
    };
    Pager.prototype.toBuffer = function() {
      var list = new Array(this.length);
      var empty = alloc(this.pageSize);
      var ptr = 0;
      while (ptr < list.length) {
        var arr = this._array(ptr, true);
        for (var i = 0; i < 32768 && ptr < list.length; i++) {
          list[ptr++] = arr && arr[i] ? arr[i].buffer : empty;
        }
      }
      return Buffer.concat(list);
    };
    function grow(pager, index) {
      while (pager.maxPages < index) {
        var old = pager.pages;
        pager.pages = new Array(32768);
        pager.pages[0] = old;
        pager.level++;
        pager.maxPages *= 32768;
      }
    }
    function truncate(buf, len) {
      if (buf.length === len)
        return buf;
      if (buf.length > len)
        return buf.slice(0, len);
      var cpy = alloc(len);
      buf.copy(cpy);
      return cpy;
    }
    function alloc(size) {
      if (Buffer.alloc)
        return Buffer.alloc(size);
      var buf = new Buffer(size);
      buf.fill(0);
      return buf;
    }
    function copy(buf) {
      var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
      buf.copy(cpy);
      return cpy;
    }
    function Page(i, buf) {
      this.offset = i * buf.length;
      this.buffer = buf;
      this.updated = false;
      this.deduplicate = 0;
    }
    function factor(n, out) {
      n = (n - (out[0] = n & 32767)) / 32768;
      n = (n - (out[1] = n & 32767)) / 32768;
      out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
    }
  }
});

// node_modules/sparse-bitfield/index.js
var require_sparse_bitfield = __commonJS({
  "node_modules/sparse-bitfield/index.js"(exports2, module2) {
    var pager = require_memory_pager();
    module2.exports = Bitfield;
    function Bitfield(opts) {
      if (!(this instanceof Bitfield))
        return new Bitfield(opts);
      if (!opts)
        opts = {};
      if (Buffer.isBuffer(opts))
        opts = { buffer: opts };
      this.pageOffset = opts.pageOffset || 0;
      this.pageSize = opts.pageSize || 1024;
      this.pages = opts.pages || pager(this.pageSize);
      this.byteLength = this.pages.length * this.pageSize;
      this.length = 8 * this.byteLength;
      if (!powerOfTwo(this.pageSize))
        throw new Error("The page size should be a power of two");
      this._trackUpdates = !!opts.trackUpdates;
      this._pageMask = this.pageSize - 1;
      if (opts.buffer) {
        for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
          this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
        }
        this.byteLength = opts.buffer.length;
        this.length = 8 * this.byteLength;
      }
    }
    Bitfield.prototype.get = function(i) {
      var o = i & 7;
      var j = (i - o) / 8;
      return !!(this.getByte(j) & 128 >> o);
    };
    Bitfield.prototype.getByte = function(i) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, true);
      return page ? page.buffer[o + this.pageOffset] : 0;
    };
    Bitfield.prototype.set = function(i, v) {
      var o = i & 7;
      var j = (i - o) / 8;
      var b = this.getByte(j);
      return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));
    };
    Bitfield.prototype.toBuffer = function() {
      var all = alloc(this.pages.length * this.pageSize);
      for (var i = 0; i < this.pages.length; i++) {
        var next = this.pages.get(i, true);
        var allOffset = i * this.pageSize;
        if (next)
          next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
      }
      return all;
    };
    Bitfield.prototype.setByte = function(i, b) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, false);
      o += this.pageOffset;
      if (page.buffer[o] === b)
        return false;
      page.buffer[o] = b;
      if (i >= this.byteLength) {
        this.byteLength = i + 1;
        this.length = this.byteLength * 8;
      }
      if (this._trackUpdates)
        this.pages.updated(page);
      return true;
    };
    function alloc(n) {
      if (Buffer.alloc)
        return Buffer.alloc(n);
      var b = new Buffer(n);
      b.fill(0);
      return b;
    }
    function powerOfTwo(x) {
      return !(x & x - 1);
    }
  }
});

// node_modules/saslprep/lib/memory-code-points.js
var require_memory_code_points = __commonJS({
  "node_modules/saslprep/lib/memory-code-points.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var bitfield = require_sparse_bitfield();
    var memory = fs.readFileSync(path.resolve(__dirname, "../code-points.mem"));
    var offset = 0;
    function read() {
      const size = memory.readUInt32BE(offset);
      offset += 4;
      const codepoints = memory.slice(offset, offset + size);
      offset += size;
      return bitfield({ buffer: codepoints });
    }
    var unassigned_code_points = read();
    var commonly_mapped_to_nothing = read();
    var non_ASCII_space_characters = read();
    var prohibited_characters = read();
    var bidirectional_r_al = read();
    var bidirectional_l = read();
    module2.exports = {
      unassigned_code_points,
      commonly_mapped_to_nothing,
      non_ASCII_space_characters,
      prohibited_characters,
      bidirectional_r_al,
      bidirectional_l
    };
  }
});

// node_modules/saslprep/index.js
var require_saslprep = __commonJS({
  "node_modules/saslprep/index.js"(exports2, module2) {
    "use strict";
    var {
      unassigned_code_points,
      commonly_mapped_to_nothing,
      non_ASCII_space_characters,
      prohibited_characters,
      bidirectional_r_al,
      bidirectional_l
    } = require_memory_code_points();
    module2.exports = saslprep;
    var mapping2space = non_ASCII_space_characters;
    var mapping2nothing = commonly_mapped_to_nothing;
    var getCodePoint = (character) => character.codePointAt(0);
    var first = (x) => x[0];
    var last = (x) => x[x.length - 1];
    function toCodePoints(input) {
      const codepoints = [];
      const size = input.length;
      for (let i = 0; i < size; i += 1) {
        const before = input.charCodeAt(i);
        if (before >= 55296 && before <= 56319 && size > i + 1) {
          const next = input.charCodeAt(i + 1);
          if (next >= 56320 && next <= 57343) {
            codepoints.push((before - 55296) * 1024 + next - 56320 + 65536);
            i += 1;
            continue;
          }
        }
        codepoints.push(before);
      }
      return codepoints;
    }
    function saslprep(input, opts = {}) {
      if (typeof input !== "string") {
        throw new TypeError("Expected string.");
      }
      if (input.length === 0) {
        return "";
      }
      const mapped_input = toCodePoints(input).map((character) => mapping2space.get(character) ? 32 : character).filter((character) => !mapping2nothing.get(character));
      const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize("NFKC");
      const normalized_map = toCodePoints(normalized_input);
      const hasProhibited = normalized_map.some((character) => prohibited_characters.get(character));
      if (hasProhibited) {
        throw new Error("Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3");
      }
      if (opts.allowUnassigned !== true) {
        const hasUnassigned = normalized_map.some((character) => unassigned_code_points.get(character));
        if (hasUnassigned) {
          throw new Error("Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5");
        }
      }
      const hasBidiRAL = normalized_map.some((character) => bidirectional_r_al.get(character));
      const hasBidiL = normalized_map.some((character) => bidirectional_l.get(character));
      if (hasBidiRAL && hasBidiL) {
        throw new Error("String must not contain RandALCat and LCat at the same time, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      const isFirstBidiRAL = bidirectional_r_al.get(getCodePoint(first(normalized_input)));
      const isLastBidiRAL = bidirectional_r_al.get(getCodePoint(last(normalized_input)));
      if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
        throw new Error("Bidirectional RandALCat character must be the first and the last character of the string, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      return normalized_input;
    }
  }
});

// node_modules/mongodb/lib/core/auth/scram.js
var require_scram = __commonJS({
  "node_modules/mongodb/lib/core/auth/scram.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    var Buffer2 = require_safe_buffer().Buffer;
    var retrieveBSON = require_utils5().retrieveBSON;
    var MongoError = require_error().MongoError;
    var AuthProvider = require_auth_provider().AuthProvider;
    var emitWarningOnce = require_utils6().emitWarning;
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var saslprep;
    try {
      saslprep = require_saslprep();
    } catch (e) {
    }
    var ScramSHA = class extends AuthProvider {
      constructor(bson, cryptoMethod) {
        super(bson);
        this.cryptoMethod = cryptoMethod || "sha1";
      }
      prepare(handshakeDoc, authContext, callback) {
        const cryptoMethod = this.cryptoMethod;
        if (cryptoMethod === "sha256" && saslprep == null) {
          emitWarningOnce("Warning: no saslprep library specified. Passwords will not be sanitized");
        }
        crypto.randomBytes(24, (err, nonce) => {
          if (err) {
            return callback(err);
          }
          Object.assign(authContext, { nonce });
          const credentials = authContext.credentials;
          const request = Object.assign({}, handshakeDoc, {
            speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {
              db: credentials.source
            })
          });
          callback(void 0, request);
        });
      }
      auth(authContext, callback) {
        const response = authContext.response;
        if (response && response.speculativeAuthenticate) {
          continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);
          return;
        }
        executeScram(this.cryptoMethod, authContext, callback);
      }
    };
    function cleanUsername(username) {
      return username.replace("=", "=3D").replace(",", "=2C");
    }
    function clientFirstMessageBare(username, nonce) {
      return Buffer2.concat([
        Buffer2.from("n=", "utf8"),
        Buffer2.from(username, "utf8"),
        Buffer2.from(",r=", "utf8"),
        Buffer2.from(nonce.toString("base64"), "utf8")
      ]);
    }
    function makeFirstMessage(cryptoMethod, credentials, nonce) {
      const username = cleanUsername(credentials.username);
      const mechanism = cryptoMethod === "sha1" ? "SCRAM-SHA-1" : "SCRAM-SHA-256";
      return {
        saslStart: 1,
        mechanism,
        payload: new Binary2(Buffer2.concat([Buffer2.from("n,,", "utf8"), clientFirstMessageBare(username, nonce)])),
        autoAuthorize: 1,
        options: { skipEmptyExchange: true }
      };
    }
    function executeScram(cryptoMethod, authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const nonce = authContext.nonce;
      const db = credentials.source;
      const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
      connection.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {
        const err = resolveError(_err, result);
        if (err) {
          return callback(err);
        }
        continueScramConversation(cryptoMethod, result.result, authContext, callback);
      });
    }
    function continueScramConversation(cryptoMethod, response, authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const nonce = authContext.nonce;
      const db = credentials.source;
      const username = cleanUsername(credentials.username);
      const password = credentials.password;
      let processedPassword;
      if (cryptoMethod === "sha256") {
        processedPassword = saslprep ? saslprep(password) : password;
      } else {
        try {
          processedPassword = passwordDigest(username, password);
        } catch (e) {
          return callback(e);
        }
      }
      const payload = Buffer2.isBuffer(response.payload) ? new Binary2(response.payload) : response.payload;
      const dict = parsePayload(payload.value());
      const iterations = parseInt(dict.i, 10);
      if (iterations && iterations < 4096) {
        callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);
        return;
      }
      const salt = dict.s;
      const rnonce = dict.r;
      if (rnonce.startsWith("nonce")) {
        callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);
        return;
      }
      const withoutProof = `c=biws,r=${rnonce}`;
      const saltedPassword = HI(processedPassword, Buffer2.from(salt, "base64"), iterations, cryptoMethod);
      const clientKey = HMAC(cryptoMethod, saltedPassword, "Client Key");
      const serverKey = HMAC(cryptoMethod, saltedPassword, "Server Key");
      const storedKey = H(cryptoMethod, clientKey);
      const authMessage = [
        clientFirstMessageBare(username, nonce),
        payload.value().toString("base64"),
        withoutProof
      ].join(",");
      const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
      const clientProof = `p=${xor(clientKey, clientSignature)}`;
      const clientFinal = [withoutProof, clientProof].join(",");
      const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
      const saslContinueCmd = {
        saslContinue: 1,
        conversationId: response.conversationId,
        payload: new Binary2(Buffer2.from(clientFinal))
      };
      connection.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {
        const err = resolveError(_err, result);
        if (err) {
          return callback(err);
        }
        const r = result.result;
        const parsedResponse = parsePayload(r.payload.value());
        if (!compareDigest(Buffer2.from(parsedResponse.v, "base64"), serverSignature)) {
          callback(new MongoError("Server returned an invalid signature"));
          return;
        }
        if (!r || r.done !== false) {
          return callback(err, r);
        }
        const retrySaslContinueCmd = {
          saslContinue: 1,
          conversationId: r.conversationId,
          payload: Buffer2.alloc(0)
        };
        connection.command(`${db}.$cmd`, retrySaslContinueCmd, callback);
      });
    }
    function parsePayload(payload) {
      const dict = {};
      const parts = payload.split(",");
      for (let i = 0; i < parts.length; i++) {
        const valueParts = parts[i].split("=");
        dict[valueParts[0]] = valueParts[1];
      }
      return dict;
    }
    function passwordDigest(username, password) {
      if (typeof username !== "string") {
        throw new MongoError("username must be a string");
      }
      if (typeof password !== "string") {
        throw new MongoError("password must be a string");
      }
      if (password.length === 0) {
        throw new MongoError("password cannot be empty");
      }
      const md5 = crypto.createHash("md5");
      md5.update(`${username}:mongo:${password}`, "utf8");
      return md5.digest("hex");
    }
    function xor(a, b) {
      if (!Buffer2.isBuffer(a)) {
        a = Buffer2.from(a);
      }
      if (!Buffer2.isBuffer(b)) {
        b = Buffer2.from(b);
      }
      const length = Math.max(a.length, b.length);
      const res = [];
      for (let i = 0; i < length; i += 1) {
        res.push(a[i] ^ b[i]);
      }
      return Buffer2.from(res).toString("base64");
    }
    function H(method, text) {
      return crypto.createHash(method).update(text).digest();
    }
    function HMAC(method, key, text) {
      return crypto.createHmac(method, key).update(text).digest();
    }
    var _hiCache = {};
    var _hiCacheCount = 0;
    function _hiCachePurge() {
      _hiCache = {};
      _hiCacheCount = 0;
    }
    var hiLengthMap = {
      sha256: 32,
      sha1: 20
    };
    function HI(data, salt, iterations, cryptoMethod) {
      const key = [data, salt.toString("base64"), iterations].join("_");
      if (_hiCache[key] !== void 0) {
        return _hiCache[key];
      }
      const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);
      if (_hiCacheCount >= 200) {
        _hiCachePurge();
      }
      _hiCache[key] = saltedData;
      _hiCacheCount += 1;
      return saltedData;
    }
    function compareDigest(lhs, rhs) {
      if (lhs.length !== rhs.length) {
        return false;
      }
      if (typeof crypto.timingSafeEqual === "function") {
        return crypto.timingSafeEqual(lhs, rhs);
      }
      let result = 0;
      for (let i = 0; i < lhs.length; i++) {
        result |= lhs[i] ^ rhs[i];
      }
      return result === 0;
    }
    function resolveError(err, result) {
      if (err)
        return err;
      const r = result.result;
      if (r.$err || r.errmsg)
        return new MongoError(r);
    }
    var ScramSHA1 = class extends ScramSHA {
      constructor(bson) {
        super(bson, "sha1");
      }
    };
    var ScramSHA256 = class extends ScramSHA {
      constructor(bson) {
        super(bson, "sha256");
      }
    };
    module2.exports = { ScramSHA1, ScramSHA256 };
  }
});

// node_modules/mongodb/lib/core/auth/mongo_credentials.js
var require_mongo_credentials = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongo_credentials.js"(exports2, module2) {
    "use strict";
    function getDefaultAuthMechanism(ismaster) {
      if (ismaster) {
        if (Array.isArray(ismaster.saslSupportedMechs)) {
          return ismaster.saslSupportedMechs.indexOf("SCRAM-SHA-256") >= 0 ? "scram-sha-256" : "scram-sha-1";
        }
        if (ismaster.maxWireVersion >= 3) {
          return "scram-sha-1";
        }
      }
      return "mongocr";
    }
    var MongoCredentials = class {
      constructor(options) {
        options = options || {};
        this.username = options.username;
        this.password = options.password;
        this.source = options.source || options.db;
        this.mechanism = options.mechanism || "default";
        this.mechanismProperties = options.mechanismProperties || {};
        if (/MONGODB-AWS/i.test(this.mechanism)) {
          if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
            this.username = process.env.AWS_ACCESS_KEY_ID;
          }
          if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
            this.password = process.env.AWS_SECRET_ACCESS_KEY;
          }
          if (!this.mechanismProperties.AWS_SESSION_TOKEN && process.env.AWS_SESSION_TOKEN) {
            this.mechanismProperties.AWS_SESSION_TOKEN = process.env.AWS_SESSION_TOKEN;
          }
        }
        Object.freeze(this.mechanismProperties);
        Object.freeze(this);
      }
      equals(other) {
        return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
      }
      resolveAuthMechanism(ismaster) {
        if (/DEFAULT/i.test(this.mechanism)) {
          return new MongoCredentials({
            username: this.username,
            password: this.password,
            source: this.source,
            mechanism: getDefaultAuthMechanism(ismaster),
            mechanismProperties: this.mechanismProperties
          });
        }
        return this;
      }
    };
    module2.exports = { MongoCredentials };
  }
});

// node_modules/mongodb/lib/core/auth/mongodb_aws.js
var require_mongodb_aws = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongodb_aws.js"(exports2, module2) {
    "use strict";
    var AuthProvider = require_auth_provider().AuthProvider;
    var MongoCredentials = require_mongo_credentials().MongoCredentials;
    var MongoError = require_error().MongoError;
    var crypto = require("crypto");
    var http = require("http");
    var maxWireVersion = require_utils4().maxWireVersion;
    var url = require("url");
    var aws4;
    try {
      aws4 = require("aws4");
    } catch (e) {
    }
    var ASCII_N = 110;
    var AWS_RELATIVE_URI = "http://169.254.170.2";
    var AWS_EC2_URI = "http://169.254.169.254";
    var AWS_EC2_PATH = "/latest/meta-data/iam/security-credentials";
    var MongoDBAWS = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        if (maxWireVersion(connection) < 9) {
          callback(new MongoError("MONGODB-AWS authentication requires MongoDB version 4.4 or later"));
          return;
        }
        if (aws4 == null) {
          callback(new MongoError("MONGODB-AWS authentication requires the `aws4` module, please install it as a dependency of your project"));
          return;
        }
        if (credentials.username == null) {
          makeTempCredentials(credentials, (err, tempCredentials) => {
            if (err)
              return callback(err);
            authContext.credentials = tempCredentials;
            this.auth(authContext, callback);
          });
          return;
        }
        const username = credentials.username;
        const password = credentials.password;
        const db = credentials.source;
        const token = credentials.mechanismProperties.AWS_SESSION_TOKEN;
        const bson = this.bson;
        crypto.randomBytes(32, (err, nonce) => {
          if (err) {
            callback(err);
            return;
          }
          const saslStart = {
            saslStart: 1,
            mechanism: "MONGODB-AWS",
            payload: bson.serialize({ r: nonce, p: ASCII_N })
          };
          connection.command(`${db}.$cmd`, saslStart, (err2, result) => {
            if (err2)
              return callback(err2);
            const res = result.result;
            const serverResponse = bson.deserialize(res.payload.buffer);
            const host = serverResponse.h;
            const serverNonce = serverResponse.s.buffer;
            if (serverNonce.length !== 64) {
              callback(new MongoError(`Invalid server nonce length ${serverNonce.length}, expected 64`));
              return;
            }
            if (serverNonce.compare(nonce, 0, nonce.length, 0, nonce.length) !== 0) {
              callback(new MongoError("Server nonce does not begin with client nonce"));
              return;
            }
            if (host.length < 1 || host.length > 255 || host.indexOf("..") !== -1) {
              callback(new MongoError(`Server returned an invalid host: "${host}"`));
              return;
            }
            const body = "Action=GetCallerIdentity&Version=2011-06-15";
            const options = aws4.sign({
              method: "POST",
              host,
              region: deriveRegion(serverResponse.h),
              service: "sts",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Content-Length": body.length,
                "X-MongoDB-Server-Nonce": serverNonce.toString("base64"),
                "X-MongoDB-GS2-CB-Flag": "n"
              },
              path: "/",
              body
            }, {
              accessKeyId: username,
              secretAccessKey: password,
              token
            });
            const authorization = options.headers.Authorization;
            const date = options.headers["X-Amz-Date"];
            const payload = { a: authorization, d: date };
            if (token) {
              payload.t = token;
            }
            const saslContinue = {
              saslContinue: 1,
              conversationId: 1,
              payload: bson.serialize(payload)
            };
            connection.command(`${db}.$cmd`, saslContinue, (err3) => {
              if (err3)
                return callback(err3);
              callback();
            });
          });
        });
      }
    };
    function makeTempCredentials(credentials, callback) {
      function done(creds) {
        if (creds.AccessKeyId == null || creds.SecretAccessKey == null || creds.Token == null) {
          callback(new MongoError("Could not obtain temporary MONGODB-AWS credentials"));
          return;
        }
        callback(void 0, new MongoCredentials({
          username: creds.AccessKeyId,
          password: creds.SecretAccessKey,
          source: credentials.source,
          mechanism: "MONGODB-AWS",
          mechanismProperties: {
            AWS_SESSION_TOKEN: creds.Token
          }
        }));
      }
      if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
        request(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`, (err, res) => {
          if (err)
            return callback(err);
          done(res);
        });
        return;
      }
      request(`${AWS_EC2_URI}/latest/api/token`, { method: "PUT", json: false, headers: { "X-aws-ec2-metadata-token-ttl-seconds": 30 } }, (err, token) => {
        if (err)
          return callback(err);
        request(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, { json: false, headers: { "X-aws-ec2-metadata-token": token } }, (err2, roleName) => {
          if (err2)
            return callback(err2);
          request(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, { headers: { "X-aws-ec2-metadata-token": token } }, (err3, creds) => {
            if (err3)
              return callback(err3);
            done(creds);
          });
        });
      });
    }
    function deriveRegion(host) {
      const parts = host.split(".");
      if (parts.length === 1 || parts[1] === "amazonaws") {
        return "us-east-1";
      }
      return parts[1];
    }
    function request(uri, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = Object.assign({
        method: "GET",
        timeout: 1e4,
        json: true
      }, url.parse(uri), options);
      const req = http.request(options, (res) => {
        res.setEncoding("utf8");
        let data = "";
        res.on("data", (d) => data += d);
        res.on("end", () => {
          if (options.json === false) {
            callback(void 0, data);
            return;
          }
          try {
            const parsed = JSON.parse(data);
            callback(void 0, parsed);
          } catch (err) {
            callback(new MongoError(`Invalid JSON response: "${data}"`));
          }
        });
      });
      req.on("error", (err) => callback(err));
      req.end();
    }
    module2.exports = MongoDBAWS;
  }
});

// node_modules/mongodb/lib/core/auth/defaultAuthProviders.js
var require_defaultAuthProviders = __commonJS({
  "node_modules/mongodb/lib/core/auth/defaultAuthProviders.js"(exports2, module2) {
    "use strict";
    var MongoCR = require_mongocr();
    var X509 = require_x509();
    var Plain = require_plain();
    var GSSAPI = require_gssapi();
    var ScramSHA1 = require_scram().ScramSHA1;
    var ScramSHA256 = require_scram().ScramSHA256;
    var MongoDBAWS = require_mongodb_aws();
    function defaultAuthProviders(bson) {
      return {
        "mongodb-aws": new MongoDBAWS(bson),
        mongocr: new MongoCR(bson),
        x509: new X509(bson),
        plain: new Plain(bson),
        gssapi: new GSSAPI(bson),
        "scram-sha-1": new ScramSHA1(bson),
        "scram-sha-256": new ScramSHA256(bson)
      };
    }
    module2.exports = { defaultAuthProviders };
  }
});

// node_modules/mongodb/lib/core/connection/connect.js
var require_connect = __commonJS({
  "node_modules/mongodb/lib/core/connection/connect.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var Connection = require_connection();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var defaultAuthProviders = require_defaultAuthProviders().defaultAuthProviders;
    var AuthContext = require_auth_provider().AuthContext;
    var WIRE_CONSTANTS = require_constants();
    var makeClientMetadata = require_utils4().makeClientMetadata;
    var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
    var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
    var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
    var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
    var AUTH_PROVIDERS;
    function connect(options, cancellationToken, callback) {
      if (typeof cancellationToken === "function") {
        callback = cancellationToken;
        cancellationToken = void 0;
      }
      const ConnectionType = options && options.connectionType ? options.connectionType : Connection;
      if (AUTH_PROVIDERS == null) {
        AUTH_PROVIDERS = defaultAuthProviders(options.bson);
      }
      const family = options.family !== void 0 ? options.family : 0;
      makeConnection(family, options, cancellationToken, (err, socket) => {
        if (err) {
          callback(err, socket);
          return;
        }
        performInitialHandshake(new ConnectionType(socket, options), options, callback);
      });
    }
    function isModernConnectionType(conn) {
      return !(conn instanceof Connection);
    }
    function checkSupportedServer(ismaster, options) {
      const serverVersionHighEnough = ismaster && typeof ismaster.maxWireVersion === "number" && ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;
      const serverVersionLowEnough = ismaster && typeof ismaster.minWireVersion === "number" && ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;
      if (serverVersionHighEnough) {
        if (serverVersionLowEnough) {
          return null;
        }
        const message2 = `Server at ${options.host}:${options.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
        return new MongoError(message2);
      }
      const message = `Server at ${options.host}:${options.port} reports maximum wire version ${ismaster.maxWireVersion || 0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;
      return new MongoError(message);
    }
    function performInitialHandshake(conn, options, _callback) {
      const callback = function(err, ret2) {
        if (err && conn) {
          conn.destroy();
        }
        _callback(err, ret2);
      };
      const credentials = options.credentials;
      if (credentials) {
        if (!credentials.mechanism.match(/DEFAULT/i) && !AUTH_PROVIDERS[credentials.mechanism]) {
          callback(new MongoError(`authMechanism '${credentials.mechanism}' not supported`));
          return;
        }
      }
      const authContext = new AuthContext(conn, credentials, options);
      prepareHandshakeDocument(authContext, (err, handshakeDoc) => {
        if (err) {
          return callback(err);
        }
        const handshakeOptions = Object.assign({}, options);
        if (options.connectTimeoutMS || options.connectionTimeout) {
          handshakeOptions.socketTimeout = options.connectTimeoutMS || options.connectionTimeout;
        }
        const start = new Date().getTime();
        conn.command("admin.$cmd", handshakeDoc, handshakeOptions, (err2, result) => {
          if (err2) {
            callback(err2);
            return;
          }
          const response = result.result;
          if (response.ok === 0) {
            callback(new MongoError(response));
            return;
          }
          const supportedServerErr = checkSupportedServer(response, options);
          if (supportedServerErr) {
            callback(supportedServerErr);
            return;
          }
          if (!isModernConnectionType(conn)) {
            if (response.compression) {
              const agreedCompressors = handshakeDoc.compression.filter((compressor) => response.compression.indexOf(compressor) !== -1);
              if (agreedCompressors.length) {
                conn.agreedCompressor = agreedCompressors[0];
              }
              if (options.compression && options.compression.zlibCompressionLevel) {
                conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;
              }
            }
          }
          conn.ismaster = response;
          conn.lastIsMasterMS = new Date().getTime() - start;
          if (!response.arbiterOnly && credentials) {
            Object.assign(authContext, { response });
            const resolvedCredentials = credentials.resolveAuthMechanism(response);
            const authProvider = AUTH_PROVIDERS[resolvedCredentials.mechanism];
            authProvider.auth(authContext, (err3) => {
              if (err3)
                return callback(err3);
              callback(void 0, conn);
            });
            return;
          }
          callback(void 0, conn);
        });
      });
    }
    function prepareHandshakeDocument(authContext, callback) {
      const options = authContext.options;
      const compressors = options.compression && options.compression.compressors ? options.compression.compressors : [];
      const handshakeDoc = {
        ismaster: true,
        client: options.metadata || makeClientMetadata(options),
        compression: compressors
      };
      const credentials = authContext.credentials;
      if (credentials) {
        if (credentials.mechanism.match(/DEFAULT/i) && credentials.username) {
          Object.assign(handshakeDoc, {
            saslSupportedMechs: `${credentials.source}.${credentials.username}`
          });
          AUTH_PROVIDERS["scram-sha-256"].prepare(handshakeDoc, authContext, callback);
          return;
        }
        const authProvider = AUTH_PROVIDERS[credentials.mechanism];
        if (authProvider == null) {
          return callback(new MongoError(`No AuthProvider for ${credentials.mechanism} defined.`));
        }
        authProvider.prepare(handshakeDoc, authContext, callback);
        return;
      }
      callback(void 0, handshakeDoc);
    }
    var LEGAL_SSL_SOCKET_OPTIONS = [
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "NPNProtocols",
      "ALPNProtocols",
      "servername",
      "ecdhCurve",
      "secureProtocol",
      "secureContext",
      "session",
      "minDHSize",
      "crl",
      "rejectUnauthorized"
    ];
    function parseConnectOptions(family, options) {
      const host = typeof options.host === "string" ? options.host : "localhost";
      if (host.indexOf("/") !== -1) {
        return { path: host };
      }
      const result = {
        family,
        host,
        port: typeof options.port === "number" ? options.port : 27017,
        rejectUnauthorized: false
      };
      return result;
    }
    function parseSslOptions(family, options) {
      const result = parseConnectOptions(family, options);
      for (const name in options) {
        if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {
          result[name] = options[name];
        }
      }
      if (options.checkServerIdentity === false) {
        result.checkServerIdentity = function() {
          return void 0;
        };
      } else if (typeof options.checkServerIdentity === "function") {
        result.checkServerIdentity = options.checkServerIdentity;
      }
      if (result.servername == null && !net.isIP(result.host)) {
        result.servername = result.host;
      }
      return result;
    }
    var SOCKET_ERROR_EVENTS = new Set(["error", "close", "timeout", "parseError"]);
    function makeConnection(family, options, cancellationToken, _callback) {
      const useSsl = typeof options.ssl === "boolean" ? options.ssl : false;
      const keepAlive = typeof options.keepAlive === "boolean" ? options.keepAlive : true;
      let keepAliveInitialDelay = typeof options.keepAliveInitialDelay === "number" ? options.keepAliveInitialDelay : 12e4;
      const noDelay = typeof options.noDelay === "boolean" ? options.noDelay : true;
      const connectionTimeout = typeof options.connectionTimeout === "number" ? options.connectionTimeout : typeof options.connectTimeoutMS === "number" ? options.connectTimeoutMS : 3e4;
      const socketTimeout = typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
      const rejectUnauthorized = typeof options.rejectUnauthorized === "boolean" ? options.rejectUnauthorized : true;
      if (keepAliveInitialDelay > socketTimeout) {
        keepAliveInitialDelay = Math.round(socketTimeout / 2);
      }
      let socket;
      const callback = function(err, ret2) {
        if (err && socket) {
          socket.destroy();
        }
        _callback(err, ret2);
      };
      try {
        if (useSsl) {
          socket = tls.connect(parseSslOptions(family, options));
          if (typeof socket.disableRenegotiation === "function") {
            socket.disableRenegotiation();
          }
        } else {
          socket = net.createConnection(parseConnectOptions(family, options));
        }
      } catch (err) {
        return callback(err);
      }
      socket.setKeepAlive(keepAlive, keepAliveInitialDelay);
      socket.setTimeout(connectionTimeout);
      socket.setNoDelay(noDelay);
      const connectEvent = useSsl ? "secureConnect" : "connect";
      let cancellationHandler;
      function errorHandler(eventName) {
        return (err) => {
          SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
          if (cancellationHandler) {
            cancellationToken.removeListener("cancel", cancellationHandler);
          }
          socket.removeListener(connectEvent, connectHandler);
          callback(connectionFailureError(eventName, err));
        };
      }
      function connectHandler() {
        SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
        if (cancellationHandler) {
          cancellationToken.removeListener("cancel", cancellationHandler);
        }
        if (socket.authorizationError && rejectUnauthorized) {
          return callback(socket.authorizationError);
        }
        socket.setTimeout(socketTimeout);
        callback(null, socket);
      }
      SOCKET_ERROR_EVENTS.forEach((event) => socket.once(event, errorHandler(event)));
      if (cancellationToken) {
        cancellationHandler = errorHandler("cancel");
        cancellationToken.once("cancel", cancellationHandler);
      }
      socket.once(connectEvent, connectHandler);
    }
    function connectionFailureError(type, err) {
      switch (type) {
        case "error":
          return new MongoNetworkError(err);
        case "timeout":
          return new MongoNetworkTimeoutError(`connection timed out`);
        case "close":
          return new MongoNetworkError(`connection closed`);
        case "cancel":
          return new MongoNetworkError(`connection establishment was cancelled`);
        default:
          return new MongoNetworkError(`unknown network error`);
      }
    }
    module2.exports = connect;
  }
});

// node_modules/mongodb/lib/read_concern.js
var require_read_concern = __commonJS({
  "node_modules/mongodb/lib/read_concern.js"(exports2, module2) {
    "use strict";
    var ReadConcern = class {
      constructor(level) {
        if (level != null) {
          this.level = level;
        }
      }
      static fromOptions(options) {
        if (options == null) {
          return;
        }
        if (options.readConcern) {
          if (options.readConcern instanceof ReadConcern) {
            return options.readConcern;
          }
          return new ReadConcern(options.readConcern.level);
        }
        if (options.level) {
          return new ReadConcern(options.level);
        }
      }
      static get MAJORITY() {
        return "majority";
      }
      static get AVAILABLE() {
        return "available";
      }
      static get LINEARIZABLE() {
        return "linearizable";
      }
      static get SNAPSHOT() {
        return "snapshot";
      }
    };
    module2.exports = ReadConcern;
  }
});

// node_modules/mongodb/lib/core/transactions.js
var require_transactions = __commonJS({
  "node_modules/mongodb/lib/core/transactions.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var ReadPreference = require_read_preference();
    var ReadConcern = require_read_concern();
    var WriteConcern = require_write_concern();
    var TxnState;
    var stateMachine;
    (() => {
      const NO_TRANSACTION = "NO_TRANSACTION";
      const STARTING_TRANSACTION = "STARTING_TRANSACTION";
      const TRANSACTION_IN_PROGRESS = "TRANSACTION_IN_PROGRESS";
      const TRANSACTION_COMMITTED = "TRANSACTION_COMMITTED";
      const TRANSACTION_COMMITTED_EMPTY = "TRANSACTION_COMMITTED_EMPTY";
      const TRANSACTION_ABORTED = "TRANSACTION_ABORTED";
      TxnState = {
        NO_TRANSACTION,
        STARTING_TRANSACTION,
        TRANSACTION_IN_PROGRESS,
        TRANSACTION_COMMITTED,
        TRANSACTION_COMMITTED_EMPTY,
        TRANSACTION_ABORTED
      };
      stateMachine = {
        [NO_TRANSACTION]: [NO_TRANSACTION, STARTING_TRANSACTION],
        [STARTING_TRANSACTION]: [
          TRANSACTION_IN_PROGRESS,
          TRANSACTION_COMMITTED,
          TRANSACTION_COMMITTED_EMPTY,
          TRANSACTION_ABORTED
        ],
        [TRANSACTION_IN_PROGRESS]: [
          TRANSACTION_IN_PROGRESS,
          TRANSACTION_COMMITTED,
          TRANSACTION_ABORTED
        ],
        [TRANSACTION_COMMITTED]: [
          TRANSACTION_COMMITTED,
          TRANSACTION_COMMITTED_EMPTY,
          STARTING_TRANSACTION,
          NO_TRANSACTION
        ],
        [TRANSACTION_ABORTED]: [STARTING_TRANSACTION, NO_TRANSACTION],
        [TRANSACTION_COMMITTED_EMPTY]: [TRANSACTION_COMMITTED_EMPTY, NO_TRANSACTION]
      };
    })();
    var Transaction = class {
      constructor(options) {
        options = options || {};
        this.state = TxnState.NO_TRANSACTION;
        this.options = {};
        const writeConcern = WriteConcern.fromOptions(options);
        if (writeConcern) {
          if (writeConcern.w <= 0) {
            throw new MongoError("Transactions do not support unacknowledged write concern");
          }
          this.options.writeConcern = writeConcern;
        }
        if (options.readConcern) {
          this.options.readConcern = ReadConcern.fromOptions(options);
        }
        if (options.readPreference) {
          this.options.readPreference = ReadPreference.fromOptions(options);
        }
        if (options.maxCommitTimeMS) {
          this.options.maxTimeMS = options.maxCommitTimeMS;
        }
        this._pinnedServer = void 0;
        this._recoveryToken = void 0;
      }
      get server() {
        return this._pinnedServer;
      }
      get recoveryToken() {
        return this._recoveryToken;
      }
      get isPinned() {
        return !!this.server;
      }
      get isActive() {
        return [TxnState.STARTING_TRANSACTION, TxnState.TRANSACTION_IN_PROGRESS].indexOf(this.state) !== -1;
      }
      transition(nextState) {
        const nextStates = stateMachine[this.state];
        if (nextStates && nextStates.indexOf(nextState) !== -1) {
          this.state = nextState;
          if (this.state === TxnState.NO_TRANSACTION || this.state === TxnState.STARTING_TRANSACTION) {
            this.unpinServer();
          }
          return;
        }
        throw new MongoError(`Attempted illegal state transition from [${this.state}] to [${nextState}]`);
      }
      pinServer(server) {
        if (this.isActive) {
          this._pinnedServer = server;
        }
      }
      unpinServer() {
        this._pinnedServer = void 0;
      }
    };
    function isTransactionCommand(command) {
      return !!(command.commitTransaction || command.abortTransaction);
    }
    module2.exports = { TxnState, Transaction, isTransactionCommand };
  }
});

// node_modules/mongodb/lib/core/topologies/shared.js
var require_shared2 = __commonJS({
  "node_modules/mongodb/lib/core/topologies/shared.js"(exports2, module2) {
    "use strict";
    var ReadPreference = require_read_preference();
    var TopologyType = require_common().TopologyType;
    var MongoError = require_error().MongoError;
    var isRetryableWriteError = require_error().isRetryableWriteError;
    var maxWireVersion = require_utils4().maxWireVersion;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MMAPv1_RETRY_WRITES_ERROR_CODE = 20;
    function emitSDAMEvent(self2, event, description) {
      if (self2.listeners(event).length > 0) {
        self2.emit(event, description);
      }
    }
    function createCompressionInfo(options) {
      if (!options.compression || !options.compression.compressors) {
        return [];
      }
      options.compression.compressors.forEach(function(compressor) {
        if (compressor !== "snappy" && compressor !== "zlib") {
          throw new Error("compressors must be at least one of snappy or zlib");
        }
      });
      return options.compression.compressors;
    }
    function clone(object) {
      return JSON.parse(JSON.stringify(object));
    }
    var getPreviousDescription = function(self2) {
      if (!self2.s.serverDescription) {
        self2.s.serverDescription = {
          address: self2.name,
          arbiters: [],
          hosts: [],
          passives: [],
          type: "Unknown"
        };
      }
      return self2.s.serverDescription;
    };
    var emitServerDescriptionChanged = function(self2, description) {
      if (self2.listeners("serverDescriptionChanged").length > 0) {
        self2.emit("serverDescriptionChanged", {
          topologyId: self2.s.topologyId !== -1 ? self2.s.topologyId : self2.id,
          address: self2.name,
          previousDescription: getPreviousDescription(self2),
          newDescription: description
        });
        self2.s.serverDescription = description;
      }
    };
    var getPreviousTopologyDescription = function(self2) {
      if (!self2.s.topologyDescription) {
        self2.s.topologyDescription = {
          topologyType: "Unknown",
          servers: [
            {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: "Unknown"
            }
          ]
        };
      }
      return self2.s.topologyDescription;
    };
    var emitTopologyDescriptionChanged = function(self2, description) {
      if (self2.listeners("topologyDescriptionChanged").length > 0) {
        self2.emit("topologyDescriptionChanged", {
          topologyId: self2.s.topologyId !== -1 ? self2.s.topologyId : self2.id,
          address: self2.name,
          previousDescription: getPreviousTopologyDescription(self2),
          newDescription: description
        });
        self2.s.serverDescription = description;
      }
    };
    var changedIsMaster = function(self2, currentIsmaster, ismaster) {
      var currentType = getTopologyType(self2, currentIsmaster);
      var newType = getTopologyType(self2, ismaster);
      if (newType !== currentType)
        return true;
      return false;
    };
    var getTopologyType = function(self2, ismaster) {
      if (!ismaster) {
        ismaster = self2.ismaster;
      }
      if (!ismaster)
        return "Unknown";
      if (ismaster.ismaster && ismaster.msg === "isdbgrid")
        return "Mongos";
      if (ismaster.ismaster && !ismaster.hosts)
        return "Standalone";
      if (ismaster.ismaster)
        return "RSPrimary";
      if (ismaster.secondary)
        return "RSSecondary";
      if (ismaster.arbiterOnly)
        return "RSArbiter";
      return "Unknown";
    };
    var inquireServerState = function(self2) {
      return function(callback) {
        if (self2.s.state === "destroyed")
          return;
        var start = new Date().getTime();
        emitSDAMEvent(self2, "serverHeartbeatStarted", { connectionId: self2.name });
        self2.command("admin.$cmd", { ismaster: true }, { monitoring: true }, function(err, r) {
          if (!err) {
            self2.emit("ismaster", r, self2);
            var latencyMS = new Date().getTime() - start;
            emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
              durationMS: latencyMS,
              reply: r.result,
              connectionId: self2.name
            });
            if (changedIsMaster(self2, self2.s.ismaster, r.result)) {
              emitServerDescriptionChanged(self2, {
                address: self2.name,
                arbiters: [],
                hosts: [],
                passives: [],
                type: !self2.s.inTopology ? "Standalone" : getTopologyType(self2)
              });
            }
            self2.s.ismaster = r.result;
            self2.s.isMasterLatencyMS = latencyMS;
          } else {
            emitSDAMEvent(self2, "serverHeartbeatFailed", {
              durationMS: latencyMS,
              failure: err,
              connectionId: self2.name
            });
          }
          if (typeof callback === "function") {
            return callback(err, r);
          }
          self2.s.inquireServerStateTimeout = setTimeout(inquireServerState(self2), self2.s.haInterval);
        });
      };
    };
    var cloneOptions = function(options) {
      var opts = {};
      for (var name in options) {
        opts[name] = options[name];
      }
      return opts;
    };
    function Interval(fn, time) {
      var timer = false;
      this.start = function() {
        if (!this.isRunning()) {
          timer = setInterval(fn, time);
        }
        return this;
      };
      this.stop = function() {
        clearInterval(timer);
        timer = false;
        return this;
      };
      this.isRunning = function() {
        return timer !== false;
      };
    }
    function Timeout(fn, time) {
      var timer = false;
      var func = () => {
        if (timer) {
          clearTimeout(timer);
          timer = false;
          fn();
        }
      };
      this.start = function() {
        if (!this.isRunning()) {
          timer = setTimeout(func, time);
        }
        return this;
      };
      this.stop = function() {
        clearTimeout(timer);
        timer = false;
        return this;
      };
      this.isRunning = function() {
        return timer !== false;
      };
    }
    function diff(previous, current) {
      var diff2 = {
        servers: []
      };
      if (!previous) {
        previous = { servers: [] };
      }
      for (var i = 0; i < previous.servers.length; i++) {
        var found = false;
        for (var j = 0; j < current.servers.length; j++) {
          if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {
            found = true;
            break;
          }
        }
        if (!found) {
          diff2.servers.push({
            address: previous.servers[i].address,
            from: previous.servers[i].type,
            to: "Unknown"
          });
        }
      }
      for (j = 0; j < current.servers.length; j++) {
        found = false;
        for (i = 0; i < previous.servers.length; i++) {
          if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {
            found = true;
            break;
          }
        }
        if (!found) {
          diff2.servers.push({
            address: current.servers[j].address,
            from: "Unknown",
            to: current.servers[j].type
          });
        }
      }
      for (i = 0; i < previous.servers.length; i++) {
        var prevServer = previous.servers[i];
        for (j = 0; j < current.servers.length; j++) {
          var currServer = current.servers[j];
          if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {
            if (prevServer.type !== currServer.type) {
              diff2.servers.push({
                address: prevServer.address,
                from: prevServer.type,
                to: currServer.type
              });
            }
          }
        }
      }
      return diff2;
    }
    function resolveClusterTime(topology, $clusterTime) {
      if (topology.clusterTime == null) {
        topology.clusterTime = $clusterTime;
      } else {
        if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {
          topology.clusterTime = $clusterTime;
        }
      }
    }
    var SessionMixins = {
      endSessions: function(sessions, callback) {
        if (!Array.isArray(sessions)) {
          sessions = [sessions];
        }
        this.command("admin.$cmd", { endSessions: sessions }, { readPreference: ReadPreference.primaryPreferred }, () => {
          if (typeof callback === "function")
            callback();
        });
      }
    };
    function topologyType(topology) {
      if (topology.description) {
        return topology.description.type;
      }
      if (topology.type === "mongos") {
        return TopologyType.Sharded;
      } else if (topology.type === "replset") {
        return TopologyType.ReplicaSetWithPrimary;
      }
      return TopologyType.Single;
    }
    var RETRYABLE_WIRE_VERSION = 6;
    var isRetryableWritesSupported = function(topology) {
      const maxWireVersion2 = topology.lastIsMaster().maxWireVersion;
      if (maxWireVersion2 < RETRYABLE_WIRE_VERSION) {
        return false;
      }
      if (!topology.logicalSessionTimeoutMinutes) {
        return false;
      }
      if (topologyType(topology) === TopologyType.Single) {
        return false;
      }
      return true;
    };
    var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = "This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.";
    function getMMAPError(err) {
      if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes("Transaction numbers")) {
        return err;
      }
      const newErr = new MongoError({
        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        originalError: err
      });
      return newErr;
    }
    function legacyIsRetryableWriteError(err, topology) {
      if (!(err instanceof MongoError)) {
        return false;
      }
      if (isRetryableWritesSupported(topology) && (err instanceof MongoNetworkError || maxWireVersion(topology) < 9 && isRetryableWriteError(err))) {
        err.addErrorLabel("RetryableWriteError");
      }
      return err.hasErrorLabel("RetryableWriteError");
    }
    module2.exports = {
      SessionMixins,
      resolveClusterTime,
      inquireServerState,
      getTopologyType,
      emitServerDescriptionChanged,
      emitTopologyDescriptionChanged,
      cloneOptions,
      createCompressionInfo,
      clone,
      diff,
      Interval,
      Timeout,
      isRetryableWritesSupported,
      getMMAPError,
      topologyType,
      legacyIsRetryableWriteError
    };
  }
});

// node_modules/mongodb/lib/core/sessions.js
var require_sessions = __commonJS({
  "node_modules/mongodb/lib/core/sessions.js"(exports2, module2) {
    "use strict";
    var retrieveBSON = require_utils5().retrieveBSON;
    var EventEmitter = require("events");
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var uuidV4 = require_utils4().uuidV4;
    var MongoError = require_error().MongoError;
    var isRetryableError = require_error().isRetryableError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var Transaction = require_transactions().Transaction;
    var TxnState = require_transactions().TxnState;
    var isPromiseLike = require_utils4().isPromiseLike;
    var ReadPreference = require_read_preference();
    var maybePromise = require_utils6().maybePromise;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var isSharded = require_shared().isSharded;
    var maxWireVersion = require_utils4().maxWireVersion;
    var now = require_utils6().now;
    var calculateDurationInMs = require_utils6().calculateDurationInMs;
    var minWireVersionForShardedTransactions = 8;
    function assertAlive(session, callback) {
      if (session.serverSession == null) {
        const error = new MongoError("Cannot use a session that has ended");
        if (typeof callback === "function") {
          callback(error, null);
          return false;
        }
        throw error;
      }
      return true;
    }
    var kServerSession = Symbol("serverSession");
    var ClientSession = class extends EventEmitter {
      constructor(topology, sessionPool, options, clientOptions) {
        super();
        if (topology == null) {
          throw new Error("ClientSession requires a topology");
        }
        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
          throw new Error("ClientSession requires a ServerSessionPool");
        }
        options = options || {};
        clientOptions = clientOptions || {};
        this.topology = topology;
        this.sessionPool = sessionPool;
        this.hasEnded = false;
        this.clientOptions = clientOptions;
        this[kServerSession] = void 0;
        this.supports = {
          causalConsistency: typeof options.causalConsistency !== "undefined" ? options.causalConsistency : true
        };
        this.clusterTime = options.initialClusterTime;
        this.operationTime = null;
        this.explicit = !!options.explicit;
        this.owner = options.owner;
        this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);
        this.transaction = new Transaction();
      }
      get id() {
        return this.serverSession.id;
      }
      get serverSession() {
        if (this[kServerSession] == null) {
          this[kServerSession] = this.sessionPool.acquire();
        }
        return this[kServerSession];
      }
      endSession(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options || {};
        const session = this;
        return maybePromise(this, callback, (done) => {
          if (session.hasEnded) {
            return done();
          }
          function completeEndSession() {
            session.sessionPool.release(session.serverSession);
            session[kServerSession] = void 0;
            session.hasEnded = true;
            session.emit("ended", session);
            done();
          }
          if (session.serverSession && session.inTransaction()) {
            session.abortTransaction((err) => {
              if (err)
                return done(err);
              completeEndSession();
            });
            return;
          }
          completeEndSession();
        });
      }
      advanceOperationTime(operationTime) {
        if (this.operationTime == null) {
          this.operationTime = operationTime;
          return;
        }
        if (operationTime.greaterThan(this.operationTime)) {
          this.operationTime = operationTime;
        }
      }
      equals(session) {
        if (!(session instanceof ClientSession)) {
          return false;
        }
        return this.id.id.buffer.equals(session.id.id.buffer);
      }
      incrementTransactionNumber() {
        this.serverSession.txnNumber++;
      }
      inTransaction() {
        return this.transaction.isActive;
      }
      startTransaction(options) {
        assertAlive(this);
        if (this.inTransaction()) {
          throw new MongoError("Transaction already in progress");
        }
        const topologyMaxWireVersion = maxWireVersion(this.topology);
        if (isSharded(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
          throw new MongoError("Transactions are not supported on sharded clusters in MongoDB < 4.2.");
        }
        this.incrementTransactionNumber();
        this.transaction = new Transaction(Object.assign({}, this.clientOptions, options || this.defaultTransactionOptions));
        this.transaction.transition(TxnState.STARTING_TRANSACTION);
      }
      commitTransaction(callback) {
        return maybePromise(this, callback, (done) => endTransaction(this, "commitTransaction", done));
      }
      abortTransaction(callback) {
        return maybePromise(this, callback, (done) => endTransaction(this, "abortTransaction", done));
      }
      toBSON() {
        throw new Error("ClientSession cannot be serialized to BSON.");
      }
      withTransaction(fn, options) {
        const startTime = now();
        return attemptTransaction(this, startTime, fn, options);
      }
    };
    var MAX_WITH_TRANSACTION_TIMEOUT = 12e4;
    var UNSATISFIABLE_WRITE_CONCERN_CODE = 100;
    var UNKNOWN_REPL_WRITE_CONCERN_CODE = 79;
    var MAX_TIME_MS_EXPIRED_CODE = 50;
    var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([
      "CannotSatisfyWriteConcern",
      "UnknownReplWriteConcern",
      "UnsatisfiableWriteConcern"
    ]);
    function hasNotTimedOut(startTime, max) {
      return calculateDurationInMs(startTime) < max;
    }
    function isUnknownTransactionCommitResult(err) {
      return isMaxTimeMSExpiredError(err) || !NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName) && err.code !== UNSATISFIABLE_WRITE_CONCERN_CODE && err.code !== UNKNOWN_REPL_WRITE_CONCERN_CODE;
    }
    function isMaxTimeMSExpiredError(err) {
      if (err == null)
        return false;
      return err.code === MAX_TIME_MS_EXPIRED_CODE || err.writeConcernError && err.writeConcernError.code === MAX_TIME_MS_EXPIRED_CODE;
    }
    function attemptTransactionCommit(session, startTime, fn, options) {
      return session.commitTransaction().catch((err) => {
        if (err instanceof MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {
          if (err.hasErrorLabel("UnknownTransactionCommitResult")) {
            return attemptTransactionCommit(session, startTime, fn, options);
          }
          if (err.hasErrorLabel("TransientTransactionError")) {
            return attemptTransaction(session, startTime, fn, options);
          }
        }
        throw err;
      });
    }
    var USER_EXPLICIT_TXN_END_STATES = new Set([
      TxnState.NO_TRANSACTION,
      TxnState.TRANSACTION_COMMITTED,
      TxnState.TRANSACTION_ABORTED
    ]);
    function userExplicitlyEndedTransaction(session) {
      return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);
    }
    function attemptTransaction(session, startTime, fn, options) {
      session.startTransaction(options);
      let promise;
      try {
        promise = fn(session);
      } catch (err) {
        promise = Promise.reject(err);
      }
      if (!isPromiseLike(promise)) {
        session.abortTransaction();
        throw new TypeError("Function provided to `withTransaction` must return a Promise");
      }
      return promise.then(() => {
        if (userExplicitlyEndedTransaction(session)) {
          return;
        }
        return attemptTransactionCommit(session, startTime, fn, options);
      }).catch((err) => {
        function maybeRetryOrThrow(err2) {
          if (err2 instanceof MongoError && err2.hasErrorLabel("TransientTransactionError") && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {
            return attemptTransaction(session, startTime, fn, options);
          }
          if (isMaxTimeMSExpiredError(err2)) {
            err2.addErrorLabel("UnknownTransactionCommitResult");
          }
          throw err2;
        }
        if (session.transaction.isActive) {
          return session.abortTransaction().then(() => maybeRetryOrThrow(err));
        }
        return maybeRetryOrThrow(err);
      });
    }
    function endTransaction(session, commandName, callback) {
      if (!assertAlive(session, callback)) {
        return;
      }
      let txnState = session.transaction.state;
      if (txnState === TxnState.NO_TRANSACTION) {
        callback(new MongoError("No transaction started"));
        return;
      }
      if (commandName === "commitTransaction") {
        if (txnState === TxnState.STARTING_TRANSACTION || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
          session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);
          callback(null, null);
          return;
        }
        if (txnState === TxnState.TRANSACTION_ABORTED) {
          callback(new MongoError("Cannot call commitTransaction after calling abortTransaction"));
          return;
        }
      } else {
        if (txnState === TxnState.STARTING_TRANSACTION) {
          session.transaction.transition(TxnState.TRANSACTION_ABORTED);
          callback(null, null);
          return;
        }
        if (txnState === TxnState.TRANSACTION_ABORTED) {
          callback(new MongoError("Cannot call abortTransaction twice"));
          return;
        }
        if (txnState === TxnState.TRANSACTION_COMMITTED || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
          callback(new MongoError("Cannot call abortTransaction after calling commitTransaction"));
          return;
        }
      }
      const command = { [commandName]: 1 };
      let writeConcern;
      if (session.transaction.options.writeConcern) {
        writeConcern = Object.assign({}, session.transaction.options.writeConcern);
      } else if (session.clientOptions && session.clientOptions.w) {
        writeConcern = { w: session.clientOptions.w };
      }
      if (txnState === TxnState.TRANSACTION_COMMITTED) {
        writeConcern = Object.assign({ wtimeout: 1e4 }, writeConcern, { w: "majority" });
      }
      if (writeConcern) {
        Object.assign(command, { writeConcern });
      }
      if (commandName === "commitTransaction" && session.transaction.options.maxTimeMS) {
        Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });
      }
      function commandHandler(e, r) {
        if (commandName === "commitTransaction") {
          session.transaction.transition(TxnState.TRANSACTION_COMMITTED);
          if (e && (e instanceof MongoNetworkError || e instanceof MongoWriteConcernError || isRetryableError(e) || isMaxTimeMSExpiredError(e))) {
            if (isUnknownTransactionCommitResult(e)) {
              e.addErrorLabel("UnknownTransactionCommitResult");
              session.transaction.unpinServer();
            }
          }
        } else {
          session.transaction.transition(TxnState.TRANSACTION_ABORTED);
        }
        callback(e, r);
      }
      function transactionError(err) {
        return commandName === "commitTransaction" ? err : null;
      }
      if (session.transaction.recoveryToken && supportsRecoveryToken(session)) {
        command.recoveryToken = session.transaction.recoveryToken;
      }
      session.topology.command("admin.$cmd", command, { session }, (err, reply) => {
        if (err && isRetryableError(err)) {
          if (command.commitTransaction) {
            session.transaction.unpinServer();
            command.writeConcern = Object.assign({ wtimeout: 1e4 }, command.writeConcern, {
              w: "majority"
            });
          }
          return session.topology.command("admin.$cmd", command, { session }, (_err, _reply) => commandHandler(transactionError(_err), _reply));
        }
        commandHandler(transactionError(err), reply);
      });
    }
    function supportsRecoveryToken(session) {
      const topology = session.topology;
      return !!topology.s.options.useRecoveryToken;
    }
    var ServerSession = class {
      constructor() {
        this.id = { id: new Binary2(uuidV4(), Binary2.SUBTYPE_UUID) };
        this.lastUse = now();
        this.txnNumber = 0;
        this.isDirty = false;
      }
      hasTimedOut(sessionTimeoutMinutes) {
        const idleTimeMinutes = Math.round(calculateDurationInMs(this.lastUse) % 864e5 % 36e5 / 6e4);
        return idleTimeMinutes > sessionTimeoutMinutes - 1;
      }
    };
    var ServerSessionPool = class {
      constructor(topology) {
        if (topology == null) {
          throw new Error("ServerSessionPool requires a topology");
        }
        this.topology = topology;
        this.sessions = [];
      }
      endAllPooledSessions(callback) {
        if (this.sessions.length) {
          this.topology.endSessions(this.sessions.map((session) => session.id), () => {
            this.sessions = [];
            if (typeof callback === "function") {
              callback();
            }
          });
          return;
        }
        if (typeof callback === "function") {
          callback();
        }
      }
      acquire() {
        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
        while (this.sessions.length) {
          const session = this.sessions.shift();
          if (!session.hasTimedOut(sessionTimeoutMinutes)) {
            return session;
          }
        }
        return new ServerSession();
      }
      release(session) {
        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
        while (this.sessions.length) {
          const pooledSession = this.sessions[this.sessions.length - 1];
          if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {
            this.sessions.pop();
          } else {
            break;
          }
        }
        if (!session.hasTimedOut(sessionTimeoutMinutes)) {
          if (session.isDirty) {
            return;
          }
          this.sessions.unshift(session);
        }
      }
    };
    function commandSupportsReadConcern(command, options) {
      if (command.aggregate || command.count || command.distinct || command.find || command.parallelCollectionScan || command.geoNear || command.geoSearch) {
        return true;
      }
      if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === "inline")) {
        return true;
      }
      return false;
    }
    function applySession(session, command, options) {
      if (session.hasEnded) {
        return new MongoError("Cannot use a session that has ended");
      }
      if (options && options.writeConcern && options.writeConcern.w === 0) {
        return;
      }
      const serverSession = session.serverSession;
      serverSession.lastUse = now();
      command.lsid = serverSession.id;
      const inTransaction = session.inTransaction() || isTransactionCommand(command);
      const isRetryableWrite = options.willRetryWrite;
      const shouldApplyReadConcern = commandSupportsReadConcern(command, options);
      if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {
        command.txnNumber = BSON2.Long.fromNumber(serverSession.txnNumber);
      }
      if (!inTransaction) {
        if (session.transaction.state !== TxnState.NO_TRANSACTION) {
          session.transaction.transition(TxnState.NO_TRANSACTION);
        }
        if (session.supports.causalConsistency && session.operationTime && shouldApplyReadConcern) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        }
        return;
      }
      if (options.readPreference && !options.readPreference.equals(ReadPreference.primary)) {
        return new MongoError(`Read preference in a transaction must be primary, not: ${options.readPreference.mode}`);
      }
      command.autocommit = false;
      if (session.transaction.state === TxnState.STARTING_TRANSACTION) {
        session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);
        command.startTransaction = true;
        const readConcern = session.transaction.options.readConcern || session.clientOptions.readConcern;
        if (readConcern) {
          command.readConcern = readConcern;
        }
        if (session.supports.causalConsistency && session.operationTime) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        }
      }
    }
    function updateSessionFromResponse(session, document2) {
      if (document2.$clusterTime) {
        resolveClusterTime(session, document2.$clusterTime);
      }
      if (document2.operationTime && session && session.supports.causalConsistency) {
        session.advanceOperationTime(document2.operationTime);
      }
      if (document2.recoveryToken && session && session.inTransaction()) {
        session.transaction._recoveryToken = document2.recoveryToken;
      }
    }
    module2.exports = {
      ClientSession,
      ServerSession,
      ServerSessionPool,
      TxnState,
      applySession,
      updateSessionFromResponse,
      commandSupportsReadConcern
    };
  }
});

// node_modules/mongodb/lib/core/connection/pool.js
var require_pool = __commonJS({
  "node_modules/mongodb/lib/core/connection/pool.js"(exports2, module2) {
    "use strict";
    var inherits2 = require("util").inherits;
    var EventEmitter = require("events").EventEmitter;
    var MongoError = require_error().MongoError;
    var MongoTimeoutError = require_error().MongoTimeoutError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var Logger = require_logger();
    var f = require("util").format;
    var Msg = require_msg().Msg;
    var CommandResult = require_command_result();
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
    var opcodes = require_shared().opcodes;
    var compress = require_compression().compress;
    var compressorIDs = require_compression().compressorIDs;
    var uncompressibleCommands = require_compression().uncompressibleCommands;
    var apm = require_apm();
    var Buffer2 = require_safe_buffer().Buffer;
    var connect = require_connect();
    var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
    var eachAsync = require_utils4().eachAsync;
    var makeStateMachine = require_utils4().makeStateMachine;
    var now = require_utils6().now;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var DRAINING = "draining";
    var DESTROYING = "destroying";
    var DESTROYED = "destroyed";
    var stateTransition = makeStateMachine({
      [DISCONNECTED]: [CONNECTING, DRAINING, DISCONNECTED],
      [CONNECTING]: [CONNECTING, CONNECTED, DRAINING, DISCONNECTED],
      [CONNECTED]: [CONNECTED, DISCONNECTED, DRAINING],
      [DRAINING]: [DRAINING, DESTROYING, DESTROYED],
      [DESTROYING]: [DESTROYING, DESTROYED],
      [DESTROYED]: [DESTROYED]
    });
    var CONNECTION_EVENTS = new Set([
      "error",
      "close",
      "timeout",
      "parseError",
      "connect",
      "message"
    ]);
    var _id = 0;
    var Pool = function(topology, options) {
      EventEmitter.call(this);
      this.topology = topology;
      this.s = {
        state: DISCONNECTED,
        cancellationToken: new EventEmitter()
      };
      this.s.cancellationToken.setMaxListeners(Infinity);
      this.options = Object.assign({
        host: "localhost",
        port: 27017,
        size: 5,
        minSize: 0,
        connectionTimeout: 3e4,
        socketTimeout: 0,
        keepAlive: true,
        keepAliveInitialDelay: 12e4,
        noDelay: true,
        ssl: false,
        checkServerIdentity: true,
        ca: null,
        crl: null,
        cert: null,
        key: null,
        passphrase: null,
        rejectUnauthorized: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false,
        reconnect: true,
        reconnectInterval: 1e3,
        reconnectTries: 30,
        domainsEnabled: false,
        legacyCompatMode: true
      }, options);
      this.id = _id++;
      this.retriesLeft = this.options.reconnectTries;
      this.reconnectId = null;
      this.reconnectError = null;
      if (!options.bson || options.bson && (typeof options.bson.serialize !== "function" || typeof options.bson.deserialize !== "function")) {
        throw new Error("must pass in valid bson parser");
      }
      this.logger = Logger("Pool", options);
      this.availableConnections = [];
      this.inUseConnections = [];
      this.connectingConnections = 0;
      this.executing = false;
      this.queue = [];
      this.numberOfConsecutiveTimeouts = 0;
      this.connectionIndex = 0;
      const pool = this;
      this._messageHandler = messageHandler(this);
      this._connectionCloseHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "close", err, connection);
      };
      this._connectionErrorHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "error", err, connection);
      };
      this._connectionTimeoutHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "timeout", err, connection);
      };
      this._connectionParseErrorHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "parseError", err, connection);
      };
    };
    inherits2(Pool, EventEmitter);
    Object.defineProperty(Pool.prototype, "size", {
      enumerable: true,
      get: function() {
        return this.options.size;
      }
    });
    Object.defineProperty(Pool.prototype, "minSize", {
      enumerable: true,
      get: function() {
        return this.options.minSize;
      }
    });
    Object.defineProperty(Pool.prototype, "connectionTimeout", {
      enumerable: true,
      get: function() {
        return this.options.connectionTimeout;
      }
    });
    Object.defineProperty(Pool.prototype, "socketTimeout", {
      enumerable: true,
      get: function() {
        return this.options.socketTimeout;
      }
    });
    Object.defineProperty(Pool.prototype, "state", {
      enumerable: true,
      get: function() {
        return this.s.state;
      }
    });
    function resetPoolState(pool) {
      pool.inUseConnections = [];
      pool.availableConnections = [];
      pool.connectingConnections = 0;
      pool.executing = false;
      pool.numberOfConsecutiveTimeouts = 0;
      pool.connectionIndex = 0;
      pool.retriesLeft = pool.options.reconnectTries;
      pool.reconnectId = null;
    }
    function connectionFailureHandler(pool, event, err, conn) {
      if (conn) {
        if (conn._connectionFailHandled) {
          return;
        }
        conn._connectionFailHandled = true;
        conn.destroy();
        removeConnection(pool, conn);
        conn.flush(err);
      }
      if (event === "timeout") {
        pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1;
        if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {
          pool.numberOfConsecutiveTimeouts = 0;
          pool.destroy(true);
          return pool.emit("close", pool);
        }
      }
      if (pool.socketCount() === 0) {
        if (pool.state !== DESTROYED && pool.state !== DESTROYING && pool.state !== DRAINING) {
          if (pool.options.reconnect) {
            stateTransition(pool, DISCONNECTED);
          }
        }
        event = event === "error" ? "close" : event;
        pool.emit(event, err);
      }
      if (!pool.reconnectId && pool.options.reconnect) {
        pool.reconnectError = err;
        pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);
      }
      const totalConnections = totalConnectionCount(pool);
      if (totalConnections < pool.minSize) {
        createConnection(pool);
      }
    }
    function attemptReconnect(pool, callback) {
      return function() {
        pool.emit("attemptReconnect", pool);
        if (pool.state === DESTROYED || pool.state === DESTROYING) {
          if (typeof callback === "function") {
            callback(new MongoError("Cannot create connection when pool is destroyed"));
          }
          return;
        }
        pool.retriesLeft = pool.retriesLeft - 1;
        if (pool.retriesLeft <= 0) {
          pool.destroy();
          const error = new MongoTimeoutError(`failed to reconnect after ${pool.options.reconnectTries} attempts with interval ${pool.options.reconnectInterval} ms`, pool.reconnectError);
          pool.emit("reconnectFailed", error);
          if (typeof callback === "function") {
            callback(error);
          }
          return;
        }
        pool.reconnectId = null;
        createConnection(pool, (err, conn) => {
          if (err == null) {
            pool.reconnectId = null;
            pool.retriesLeft = pool.options.reconnectTries;
            pool.emit("reconnect", pool);
          }
          if (typeof callback === "function") {
            callback(err, conn);
          }
        });
      };
    }
    function moveConnectionBetween(connection, from, to) {
      var index = from.indexOf(connection);
      if (index !== -1) {
        from.splice(index, 1);
        to.push(connection);
      }
    }
    function messageHandler(self2) {
      return function(message, connection) {
        var workItem = null;
        for (var i = 0; i < connection.workItems.length; i++) {
          if (connection.workItems[i].requestId === message.responseTo) {
            workItem = connection.workItems[i];
            connection.workItems.splice(i, 1);
          }
        }
        if (workItem && workItem.monitoring) {
          moveConnectionBetween(connection, self2.inUseConnections, self2.availableConnections);
        }
        self2.numberOfConsecutiveTimeouts = 0;
        if (workItem && workItem.socketTimeout) {
          connection.resetSocketTimeout();
        }
        if (self2.logger.isDebug()) {
          self2.logger.debug(f("message [ %s ] received from %s:%s", message.raw.length, self2.options.host, self2.options.port));
        }
        function handleOperationCallback(self3, cb, err, result) {
          if (!self3.options.domainsEnabled) {
            return process.nextTick(function() {
              return cb(err, result);
            });
          }
          cb(err, result);
        }
        if (!self2.executing) {
          process.nextTick(function() {
            _execute(self2)();
          });
        }
        if (workItem && !workItem.immediateRelease) {
          try {
            message.parse(workItem);
          } catch (err) {
            return handleOperationCallback(self2, workItem.cb, new MongoError(err));
          }
          if (message.documents[0]) {
            const document2 = message.documents[0];
            const session = workItem.session;
            if (session) {
              updateSessionFromResponse(session, document2);
            }
            if (self2.topology && document2.$clusterTime) {
              self2.topology.clusterTime = document2.$clusterTime;
            }
          }
          if (workItem.command && message.documents[0]) {
            const responseDoc = message.documents[0];
            if (responseDoc.writeConcernError) {
              const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);
              return handleOperationCallback(self2, workItem.cb, err);
            }
            if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {
              return handleOperationCallback(self2, workItem.cb, new MongoError(responseDoc));
            }
          }
          message.hashedName = connection.hashedName;
          handleOperationCallback(self2, workItem.cb, null, new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message));
        }
      };
    }
    Pool.prototype.socketCount = function() {
      return this.availableConnections.length + this.inUseConnections.length;
    };
    function totalConnectionCount(pool) {
      return pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections;
    }
    Pool.prototype.allConnections = function() {
      return this.availableConnections.concat(this.inUseConnections);
    };
    Pool.prototype.get = function() {
      return this.allConnections()[0];
    };
    Pool.prototype.isConnected = function() {
      if (this.state === DESTROYED || this.state === DESTROYING) {
        return false;
      }
      var connections = this.availableConnections.concat(this.inUseConnections);
      for (var i = 0; i < connections.length; i++) {
        if (connections[i].isConnected())
          return true;
      }
      return false;
    };
    Pool.prototype.isDestroyed = function() {
      return this.state === DESTROYED || this.state === DESTROYING;
    };
    Pool.prototype.isDisconnected = function() {
      return this.state === DISCONNECTED;
    };
    Pool.prototype.connect = function(callback) {
      if (this.state !== DISCONNECTED) {
        throw new MongoError("connection in unlawful state " + this.state);
      }
      stateTransition(this, CONNECTING);
      createConnection(this, (err, conn) => {
        if (err) {
          if (typeof callback === "function") {
            this.destroy();
            callback(err);
            return;
          }
          if (this.state === CONNECTING) {
            this.emit("error", err);
          }
          this.destroy();
          return;
        }
        stateTransition(this, CONNECTED);
        if (this.minSize) {
          for (let i = 0; i < this.minSize; i++) {
            createConnection(this);
          }
        }
        if (typeof callback === "function") {
          callback(null, conn);
        } else {
          this.emit("connect", this, conn);
        }
      });
    };
    Pool.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Pool.prototype.logout = function(dbName, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Pool.prototype.unref = function() {
      var connections = this.availableConnections.concat(this.inUseConnections);
      connections.forEach(function(c) {
        c.unref();
      });
    };
    function destroy(self2, connections, options, callback) {
      stateTransition(self2, DESTROYING);
      self2.s.cancellationToken.emit("cancel");
      eachAsync(connections, (conn, cb) => {
        for (const eventName of CONNECTION_EVENTS) {
          conn.removeAllListeners(eventName);
        }
        conn.on("error", () => {
        });
        conn.destroy(options, cb);
      }, (err) => {
        if (err) {
          if (typeof callback === "function")
            callback(err, null);
          return;
        }
        resetPoolState(self2);
        self2.queue = [];
        stateTransition(self2, DESTROYED);
        if (typeof callback === "function")
          callback(null, null);
      });
    }
    Pool.prototype.destroy = function(force, callback) {
      var self2 = this;
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      if (this.state === DESTROYED || self2.state === DESTROYING) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      stateTransition(this, DRAINING);
      if (force) {
        var connections = self2.availableConnections.concat(self2.inUseConnections);
        while (self2.queue.length > 0) {
          var workItem = self2.queue.shift();
          if (typeof workItem.cb === "function") {
            workItem.cb(new MongoError("Pool was force destroyed"));
          }
        }
        return destroy(self2, connections, { force: true }, callback);
      }
      if (this.reconnectId) {
        clearTimeout(this.reconnectId);
      }
      function checkStatus() {
        if (self2.state === DESTROYED || self2.state === DESTROYING) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        flushMonitoringOperations(self2.queue);
        if (self2.queue.length === 0) {
          var connections2 = self2.availableConnections.concat(self2.inUseConnections);
          for (var i = 0; i < connections2.length; i++) {
            if (connections2[i].workItems.length > 0) {
              return setTimeout(checkStatus, 1);
            }
          }
          destroy(self2, connections2, { force: false }, callback);
        } else {
          _execute(self2)();
          setTimeout(checkStatus, 1);
        }
      }
      checkStatus();
    };
    Pool.prototype.reset = function(callback) {
      if (this.s.state !== CONNECTED) {
        if (typeof callback === "function") {
          callback(new MongoError("pool is not connected, reset aborted"));
        }
        return;
      }
      this.s.cancellationToken.emit("cancel");
      const connections = this.availableConnections.concat(this.inUseConnections);
      eachAsync(connections, (conn, cb) => {
        for (const eventName of CONNECTION_EVENTS) {
          conn.removeAllListeners(eventName);
        }
        conn.destroy({ force: true }, cb);
      }, (err) => {
        if (err) {
          if (typeof callback === "function") {
            callback(err, null);
            return;
          }
        }
        resetPoolState(this);
        createConnection(this, () => {
          if (typeof callback === "function") {
            callback(null, null);
          }
        });
      });
    };
    function serializeCommand(self2, command, callback) {
      const originalCommandBuffer = command.toBin();
      const shouldCompress = !!self2.options.agreedCompressor;
      if (!shouldCompress || !canCompress(command)) {
        return callback(null, originalCommandBuffer);
      }
      const concatenatedOriginalCommandBuffer = Buffer2.concat(originalCommandBuffer);
      const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
      const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
      compress(self2, messageToBeCompressed, function(err, compressedMessage) {
        if (err)
          return callback(err, null);
        const msgHeader = Buffer2.alloc(MESSAGE_HEADER_SIZE);
        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
        msgHeader.writeInt32LE(command.requestId, 4);
        msgHeader.writeInt32LE(0, 8);
        msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
        const compressionDetails = Buffer2.alloc(COMPRESSION_DETAILS_SIZE);
        compressionDetails.writeInt32LE(originalCommandOpCode, 0);
        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
        compressionDetails.writeUInt8(compressorIDs[self2.options.agreedCompressor], 8);
        return callback(null, [msgHeader, compressionDetails, compressedMessage]);
      });
    }
    Pool.prototype.write = function(command, options, cb) {
      var self2 = this;
      if (typeof options === "function") {
        cb = options;
      }
      options = options || {};
      if (!(typeof cb === "function") && !options.noResponse) {
        throw new MongoError("write method must provide a callback");
      }
      if (this.state === DESTROYED || this.state === DESTROYING) {
        cb(new MongoError("pool destroyed"));
        return;
      }
      if (this.state === DRAINING) {
        cb(new MongoError("pool is draining, new operations prohibited"));
        return;
      }
      if (this.options.domainsEnabled && process.domain && typeof cb === "function") {
        var oldCb = cb;
        cb = process.domain.bind(function() {
          var args = new Array(arguments.length);
          for (var i = 0; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
          process.nextTick(function() {
            oldCb.apply(null, args);
          });
        });
      }
      var operation = {
        cb,
        raw: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false,
        fullResult: false
      };
      operation.promoteLongs = typeof options.promoteLongs === "boolean" ? options.promoteLongs : true;
      operation.promoteValues = typeof options.promoteValues === "boolean" ? options.promoteValues : true;
      operation.promoteBuffers = typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false;
      operation.bsonRegExp = typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : false;
      operation.raw = typeof options.raw === "boolean" ? options.raw : false;
      operation.immediateRelease = typeof options.immediateRelease === "boolean" ? options.immediateRelease : false;
      operation.documentsReturnedIn = options.documentsReturnedIn;
      operation.command = typeof options.command === "boolean" ? options.command : false;
      operation.fullResult = typeof options.fullResult === "boolean" ? options.fullResult : false;
      operation.noResponse = typeof options.noResponse === "boolean" ? options.noResponse : false;
      operation.session = options.session || null;
      operation.socketTimeout = options.socketTimeout;
      operation.monitoring = options.monitoring;
      operation.requestId = command.requestId;
      if (self2.options.monitorCommands) {
        this.emit("commandStarted", new apm.CommandStartedEvent(this, command));
        operation.started = now();
        operation.cb = (err, reply) => {
          if (err) {
            self2.emit("commandFailed", new apm.CommandFailedEvent(this, command, err, operation.started));
          } else {
            if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
              self2.emit("commandFailed", new apm.CommandFailedEvent(this, command, reply.result, operation.started));
            } else {
              self2.emit("commandSucceeded", new apm.CommandSucceededEvent(this, command, reply, operation.started));
            }
          }
          if (typeof cb === "function")
            cb(err, reply);
        };
      }
      serializeCommand(self2, command, (err, serializedBuffers) => {
        if (err)
          throw err;
        operation.buffer = serializedBuffers;
        if (options.monitoring) {
          self2.queue.unshift(operation);
        } else {
          self2.queue.push(operation);
        }
        if (!self2.executing) {
          process.nextTick(function() {
            _execute(self2)();
          });
        }
      });
    };
    function canCompress(command) {
      const commandDoc = command instanceof Msg ? command.command : command.query;
      const commandName = Object.keys(commandDoc)[0];
      return !uncompressibleCommands.has(commandName);
    }
    function remove(connection, connections) {
      for (var i = 0; i < connections.length; i++) {
        if (connections[i] === connection) {
          connections.splice(i, 1);
          return true;
        }
      }
    }
    function removeConnection(self2, connection) {
      if (remove(connection, self2.availableConnections))
        return;
      if (remove(connection, self2.inUseConnections))
        return;
    }
    function createConnection(pool, callback) {
      if (pool.state === DESTROYED || pool.state === DESTROYING) {
        if (typeof callback === "function") {
          callback(new MongoError("Cannot create connection when pool is destroyed"));
        }
        return;
      }
      pool.connectingConnections++;
      connect(pool.options, pool.s.cancellationToken, (err, connection) => {
        pool.connectingConnections--;
        if (err) {
          if (pool.logger.isDebug()) {
            pool.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
          }
          if (!pool.reconnectId && pool.options.reconnect) {
            if (pool.state === CONNECTING && pool.options.legacyCompatMode) {
              callback(err);
              return;
            }
            pool.reconnectError = err;
            pool.reconnectId = setTimeout(attemptReconnect(pool, callback), pool.options.reconnectInterval);
            return;
          }
          if (typeof callback === "function") {
            callback(err);
          }
          return;
        }
        if (pool.state === DESTROYED || pool.state === DESTROYING) {
          if (typeof callback === "function") {
            callback(new MongoError("Pool was destroyed after connection creation"));
          }
          connection.destroy();
          return;
        }
        connection.on("error", pool._connectionErrorHandler);
        connection.on("close", pool._connectionCloseHandler);
        connection.on("timeout", pool._connectionTimeoutHandler);
        connection.on("parseError", pool._connectionParseErrorHandler);
        connection.on("message", pool._messageHandler);
        pool.availableConnections.push(connection);
        if (typeof callback === "function") {
          callback(null, connection);
        }
        _execute(pool)();
      });
    }
    function flushMonitoringOperations(queue) {
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].monitoring) {
          var workItem = queue[i];
          queue.splice(i, 1);
          workItem.cb(new MongoError({ message: "no connection available for monitoring", driver: true }));
        }
      }
    }
    function _execute(self2) {
      return function() {
        if (self2.state === DESTROYED)
          return;
        if (self2.executing)
          return;
        self2.executing = true;
        if (self2.connectingConnections > 0) {
          self2.executing = false;
          return;
        }
        while (true) {
          const totalConnections = totalConnectionCount(self2);
          if (self2.availableConnections.length === 0) {
            flushMonitoringOperations(self2.queue);
            if (totalConnections < self2.options.size && self2.queue.length > 0) {
              createConnection(self2);
            }
            break;
          }
          if (self2.queue.length === 0) {
            break;
          }
          var connection = null;
          const connections = self2.availableConnections.filter((conn) => conn.workItems.length === 0);
          if (connections.length === 0) {
            connection = self2.availableConnections[self2.connectionIndex++ % self2.availableConnections.length];
          } else {
            connection = connections[self2.connectionIndex++ % connections.length];
          }
          if (!connection.isConnected()) {
            removeConnection(self2, connection);
            flushMonitoringOperations(self2.queue);
            break;
          }
          var workItem = self2.queue.shift();
          if (workItem.monitoring) {
            var foundValidConnection = false;
            for (let i = 0; i < self2.availableConnections.length; i++) {
              if (self2.availableConnections[i].isConnected() && self2.availableConnections[i].workItems.length === 0) {
                foundValidConnection = true;
                connection = self2.availableConnections[i];
                break;
              }
            }
            if (!foundValidConnection) {
              self2.queue.unshift(workItem);
              if (totalConnections < self2.options.size && self2.queue.length > 0) {
                createConnection(self2);
              }
              setTimeout(() => _execute(self2)(), 10);
              break;
            }
          }
          if (totalConnections < self2.options.size) {
            if (connection.workItems.length > 0) {
              self2.queue.unshift(workItem);
              createConnection(self2);
              break;
            }
          }
          var buffer = workItem.buffer;
          if (workItem.monitoring) {
            moveConnectionBetween(connection, self2.availableConnections, self2.inUseConnections);
          }
          if (!workItem.noResponse) {
            connection.workItems.push(workItem);
          }
          if (!workItem.immediateRelease && typeof workItem.socketTimeout === "number") {
            connection.setSocketTimeout(workItem.socketTimeout);
          }
          var writeSuccessful = true;
          if (Array.isArray(buffer)) {
            for (let i = 0; i < buffer.length; i++) {
              writeSuccessful = connection.write(buffer[i]);
            }
          } else {
            writeSuccessful = connection.write(buffer);
          }
          if (workItem.noResponse && typeof workItem.cb === "function") {
            workItem.cb(null, null);
          }
          if (writeSuccessful === false) {
            self2.queue.unshift(workItem);
            removeConnection(self2, connection);
            flushMonitoringOperations(self2.queue);
            break;
          }
        }
        self2.executing = false;
      };
    }
    Pool._execute = _execute;
    module2.exports = Pool;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/command.js
var require_command = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/command.js"(exports2, module2) {
    "use strict";
    var Query = require_commands().Query;
    var Msg = require_msg().Msg;
    var MongoError = require_error().MongoError;
    var getReadPreference = require_shared().getReadPreference;
    var isSharded = require_shared().isSharded;
    var databaseNamespace = require_shared().databaseNamespace;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var applySession = require_sessions().applySession;
    var MongoNetworkError = require_error().MongoNetworkError;
    var maxWireVersion = require_utils4().maxWireVersion;
    function isClientEncryptionEnabled(server) {
      const wireVersion = maxWireVersion(server);
      return wireVersion && server.autoEncrypter;
    }
    function command(server, ns, cmd, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (cmd == null) {
        return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));
      }
      if (!isClientEncryptionEnabled(server)) {
        _command(server, ns, cmd, options, callback);
        return;
      }
      const wireVersion = maxWireVersion(server);
      if (typeof wireVersion !== "number" || wireVersion < 8) {
        callback(new MongoError("Auto-encryption requires a minimum MongoDB version of 4.2"));
        return;
      }
      _cryptCommand(server, ns, cmd, options, callback);
    }
    function _command(server, ns, cmd, options, callback) {
      const bson = server.s.bson;
      const pool = server.s.pool;
      const readPreference = getReadPreference(cmd, options);
      const shouldUseOpMsg = supportsOpMsg(server);
      const session = options.session;
      const serverClusterTime = server.clusterTime;
      let clusterTime = serverClusterTime;
      let finalCmd = Object.assign({}, cmd);
      if (hasSessionSupport(server) && session) {
        const sessionClusterTime = session.clusterTime;
        if (serverClusterTime && serverClusterTime.clusterTime && sessionClusterTime && sessionClusterTime.clusterTime && sessionClusterTime.clusterTime.greaterThan(serverClusterTime.clusterTime)) {
          clusterTime = sessionClusterTime;
        }
        const err = applySession(session, finalCmd, options);
        if (err) {
          return callback(err);
        }
      }
      if (clusterTime) {
        finalCmd.$clusterTime = clusterTime;
      }
      if (isSharded(server) && !shouldUseOpMsg && readPreference && readPreference.mode !== "primary") {
        finalCmd = {
          $query: finalCmd,
          $readPreference: readPreference.toJSON()
        };
      }
      const commandOptions = Object.assign({
        command: true,
        numberToSkip: 0,
        numberToReturn: -1,
        checkKeys: false
      }, options);
      commandOptions.slaveOk = readPreference.slaveOk();
      const cmdNs = `${databaseNamespace(ns)}.$cmd`;
      const message = shouldUseOpMsg ? new Msg(bson, cmdNs, finalCmd, commandOptions) : new Query(bson, cmdNs, finalCmd, commandOptions);
      const inTransaction = session && (session.inTransaction() || isTransactionCommand(finalCmd));
      const commandResponseHandler = inTransaction ? function(err) {
        if (err && err instanceof MongoNetworkError && !err.hasErrorLabel("TransientTransactionError")) {
          err.addErrorLabel("TransientTransactionError");
        }
        if (!cmd.commitTransaction && err && err instanceof MongoError && err.hasErrorLabel("TransientTransactionError")) {
          session.transaction.unpinServer();
        }
        return callback.apply(null, arguments);
      } : callback;
      try {
        pool.write(message, commandOptions, commandResponseHandler);
      } catch (err) {
        commandResponseHandler(err);
      }
    }
    function hasSessionSupport(topology) {
      if (topology == null)
        return false;
      if (topology.description) {
        return topology.description.maxWireVersion >= 6;
      }
      return topology.ismaster == null ? false : topology.ismaster.maxWireVersion >= 6;
    }
    function supportsOpMsg(topologyOrServer) {
      const description = topologyOrServer.ismaster ? topologyOrServer.ismaster : topologyOrServer.description;
      if (description == null) {
        return false;
      }
      return description.maxWireVersion >= 6 && description.__nodejs_mock_server__ == null;
    }
    function _cryptCommand(server, ns, cmd, options, callback) {
      const autoEncrypter = server.autoEncrypter;
      function commandResponseHandler(err, response) {
        if (err || response == null) {
          callback(err, response);
          return;
        }
        autoEncrypter.decrypt(response.result, options, (err2, decrypted) => {
          if (err2) {
            callback(err2, null);
            return;
          }
          response.result = decrypted;
          response.message.documents = [decrypted];
          callback(null, response);
        });
      }
      autoEncrypter.encrypt(ns, cmd, options, (err, encrypted) => {
        if (err) {
          callback(err, null);
          return;
        }
        _command(server, ns, encrypted, options, commandResponseHandler);
      });
    }
    module2.exports = command;
  }
});

// node_modules/mongodb/lib/explain.js
var require_explain = __commonJS({
  "node_modules/mongodb/lib/explain.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var ExplainVerbosity = {
      queryPlanner: "queryPlanner",
      queryPlannerExtended: "queryPlannerExtended",
      executionStats: "executionStats",
      allPlansExecution: "allPlansExecution"
    };
    var Explain = class {
      constructor(verbosity) {
        if (typeof verbosity === "boolean") {
          this.verbosity = verbosity ? "allPlansExecution" : "queryPlanner";
        } else {
          this.verbosity = verbosity;
        }
      }
      static fromOptions(options) {
        if (options == null || options.explain === void 0) {
          return;
        }
        const explain = options.explain;
        if (typeof explain === "boolean" || explain in ExplainVerbosity) {
          return new Explain(options.explain);
        }
        throw new MongoError(`explain must be one of ${Object.keys(ExplainVerbosity)} or a boolean`);
      }
    };
    module2.exports = { Explain };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/write_command.js
var require_write_command = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/write_command.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var collectionNamespace = require_shared().collectionNamespace;
    var command = require_command();
    var decorateWithExplain = require_utils6().decorateWithExplain;
    var Explain = require_explain().Explain;
    function writeCommand(server, type, opsField, ns, ops, options, callback) {
      if (ops.length === 0)
        throw new MongoError(`${type} must contain at least one document`);
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
      const writeConcern = options.writeConcern;
      let writeCommand2 = {};
      writeCommand2[type] = collectionNamespace(ns);
      writeCommand2[opsField] = ops;
      writeCommand2.ordered = ordered;
      if (writeConcern && Object.keys(writeConcern).length > 0) {
        writeCommand2.writeConcern = writeConcern;
      }
      if (options.collation) {
        for (let i = 0; i < writeCommand2[opsField].length; i++) {
          if (!writeCommand2[opsField][i].collation) {
            writeCommand2[opsField][i].collation = options.collation;
          }
        }
      }
      if (options.bypassDocumentValidation === true) {
        writeCommand2.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      const explain = Explain.fromOptions(options);
      if (explain) {
        writeCommand2 = decorateWithExplain(writeCommand2, explain);
      }
      const commandOptions = Object.assign({
        checkKeys: type === "insert",
        numberToReturn: 1
      }, options);
      command(server, ns, writeCommand2, commandOptions, callback);
    }
    module2.exports = writeCommand;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/kill_cursors.js
var require_kill_cursors = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/kill_cursors.js"(exports2, module2) {
    "use strict";
    var KillCursor = require_commands().KillCursor;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var collectionNamespace = require_shared().collectionNamespace;
    var maxWireVersion = require_utils4().maxWireVersion;
    var emitWarning = require_utils4().emitWarning;
    var command = require_command();
    function killCursors(server, ns, cursorState, callback) {
      callback = typeof callback === "function" ? callback : () => {
      };
      const cursorId = cursorState.cursorId;
      if (maxWireVersion(server) < 4) {
        const bson = server.s.bson;
        const pool = server.s.pool;
        const killCursor = new KillCursor(bson, ns, [cursorId]);
        const options2 = {
          immediateRelease: true,
          noResponse: true
        };
        if (typeof cursorState.session === "object") {
          options2.session = cursorState.session;
        }
        if (pool && pool.isConnected()) {
          try {
            pool.write(killCursor, options2, callback);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err, null);
            } else {
              emitWarning(err);
            }
          }
        }
        return;
      }
      const killCursorCmd = {
        killCursors: collectionNamespace(ns),
        cursors: [cursorId]
      };
      const options = {};
      if (typeof cursorState.session === "object")
        options.session = cursorState.session;
      command(server, ns, killCursorCmd, options, (err, result) => {
        if (err) {
          return callback(err);
        }
        const response = result.message;
        if (response.cursorNotFound) {
          return callback(new MongoNetworkError("cursor killed or timed out"), null);
        }
        if (!Array.isArray(response.documents) || response.documents.length === 0) {
          return callback(new MongoError(`invalid killCursors result returned for cursor id ${cursorId}`));
        }
        callback(null, response.documents[0]);
      });
    }
    module2.exports = killCursors;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/get_more.js
var require_get_more = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/get_more.js"(exports2, module2) {
    "use strict";
    var GetMore = require_commands().GetMore;
    var retrieveBSON = require_utils5().retrieveBSON;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var collectionNamespace = require_shared().collectionNamespace;
    var maxWireVersion = require_utils4().maxWireVersion;
    var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
    var command = require_command();
    function getMore(server, ns, cursorState, batchSize, options, callback) {
      options = options || {};
      const wireVersion = maxWireVersion(server);
      function queryCallback(err, result) {
        if (err)
          return callback(err);
        const response = result.message;
        if (response.cursorNotFound) {
          return callback(new MongoNetworkError("cursor killed or timed out"), null);
        }
        if (wireVersion < 4) {
          const cursorId3 = typeof response.cursorId === "number" ? Long2.fromNumber(response.cursorId) : response.cursorId;
          cursorState.documents = response.documents;
          cursorState.cursorId = cursorId3;
          callback(null, null, response.connection);
          return;
        }
        if (response.documents[0].ok === 0) {
          return callback(new MongoError(response.documents[0]));
        }
        const cursorId2 = typeof response.documents[0].cursor.id === "number" ? Long2.fromNumber(response.documents[0].cursor.id) : response.documents[0].cursor.id;
        cursorState.documents = response.documents[0].cursor.nextBatch;
        cursorState.cursorId = cursorId2;
        callback(null, response.documents[0], response.connection);
      }
      if (wireVersion < 4) {
        const bson = server.s.bson;
        const getMoreOp = new GetMore(bson, ns, cursorState.cursorId, { numberToReturn: batchSize });
        const queryOptions = applyCommonQueryOptions({}, cursorState);
        server.s.pool.write(getMoreOp, queryOptions, queryCallback);
        return;
      }
      const cursorId = cursorState.cursorId instanceof Long2 ? cursorState.cursorId : Long2.fromNumber(cursorState.cursorId);
      const getMoreCmd = {
        getMore: cursorId,
        collection: collectionNamespace(ns),
        batchSize: Math.abs(batchSize)
      };
      if (cursorState.cmd.tailable && typeof cursorState.cmd.maxAwaitTimeMS === "number") {
        getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;
      }
      const commandOptions = Object.assign({
        returnFieldSelector: null,
        documentsReturnedIn: "nextBatch"
      }, options);
      if (cursorState.session) {
        commandOptions.session = cursorState.session;
      }
      command(server, ns, getMoreCmd, commandOptions, queryCallback);
    }
    module2.exports = getMore;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/query.js
var require_query2 = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/query.js"(exports2, module2) {
    "use strict";
    var Query = require_commands().Query;
    var MongoError = require_error().MongoError;
    var getReadPreference = require_shared().getReadPreference;
    var collectionNamespace = require_shared().collectionNamespace;
    var isSharded = require_shared().isSharded;
    var maxWireVersion = require_utils4().maxWireVersion;
    var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
    var command = require_command();
    var decorateWithExplain = require_utils6().decorateWithExplain;
    var Explain = require_explain().Explain;
    function query(server, ns, cmd, cursorState, options, callback) {
      options = options || {};
      if (cursorState.cursorId != null) {
        return callback();
      }
      if (cmd == null) {
        return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));
      }
      if (maxWireVersion(server) < 4) {
        const query2 = prepareLegacyFindQuery(server, ns, cmd, cursorState, options);
        const queryOptions = applyCommonQueryOptions({}, cursorState);
        if (typeof query2.documentsReturnedIn === "string") {
          queryOptions.documentsReturnedIn = query2.documentsReturnedIn;
        }
        server.s.pool.write(query2, queryOptions, callback);
        return;
      }
      const readPreference = getReadPreference(cmd, options);
      let findCmd = prepareFindCommand(server, ns, cmd, cursorState, options);
      const explain = Explain.fromOptions(options);
      if (explain) {
        findCmd = decorateWithExplain(findCmd, explain);
      }
      cmd.virtual = false;
      const commandOptions = Object.assign({
        documentsReturnedIn: "firstBatch",
        numberToReturn: 1,
        slaveOk: readPreference.slaveOk()
      }, options);
      if (cmd.readPreference) {
        commandOptions.readPreference = readPreference;
      }
      if (cursorState.session) {
        commandOptions.session = cursorState.session;
      }
      command(server, ns, findCmd, commandOptions, callback);
    }
    function prepareFindCommand(server, ns, cmd, cursorState) {
      cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
      const findCmd = {
        find: collectionNamespace(ns)
      };
      if (cmd.query) {
        if (cmd.query["$query"]) {
          findCmd.filter = cmd.query["$query"];
        } else {
          findCmd.filter = cmd.query;
        }
      }
      let sortValue = cmd.sort;
      if (Array.isArray(sortValue)) {
        const sortObject = {};
        if (sortValue.length > 0 && !Array.isArray(sortValue[0])) {
          let sortDirection = sortValue[1];
          if (sortDirection === "asc") {
            sortDirection = 1;
          } else if (sortDirection === "desc") {
            sortDirection = -1;
          }
          sortObject[sortValue[0]] = sortDirection;
        } else {
          for (let i = 0; i < sortValue.length; i++) {
            let sortDirection = sortValue[i][1];
            if (sortDirection === "asc") {
              sortDirection = 1;
            } else if (sortDirection === "desc") {
              sortDirection = -1;
            }
            sortObject[sortValue[i][0]] = sortDirection;
          }
        }
        sortValue = sortObject;
      }
      if (typeof cmd.allowDiskUse === "boolean") {
        findCmd.allowDiskUse = cmd.allowDiskUse;
      }
      if (cmd.sort)
        findCmd.sort = sortValue;
      if (cmd.fields)
        findCmd.projection = cmd.fields;
      if (cmd.hint)
        findCmd.hint = cmd.hint;
      if (cmd.skip)
        findCmd.skip = cmd.skip;
      if (cmd.limit)
        findCmd.limit = cmd.limit;
      if (cmd.limit < 0) {
        findCmd.limit = Math.abs(cmd.limit);
        findCmd.singleBatch = true;
      }
      if (typeof cmd.batchSize === "number") {
        if (cmd.batchSize < 0) {
          if (cmd.limit !== 0 && Math.abs(cmd.batchSize) < Math.abs(cmd.limit)) {
            findCmd.limit = Math.abs(cmd.batchSize);
          }
          findCmd.singleBatch = true;
        }
        findCmd.batchSize = Math.abs(cmd.batchSize);
      }
      if (cmd.comment)
        findCmd.comment = cmd.comment;
      if (cmd.maxScan)
        findCmd.maxScan = cmd.maxScan;
      if (cmd.maxTimeMS)
        findCmd.maxTimeMS = cmd.maxTimeMS;
      if (cmd.min)
        findCmd.min = cmd.min;
      if (cmd.max)
        findCmd.max = cmd.max;
      findCmd.returnKey = cmd.returnKey ? cmd.returnKey : false;
      findCmd.showRecordId = cmd.showDiskLoc ? cmd.showDiskLoc : false;
      if (cmd.snapshot)
        findCmd.snapshot = cmd.snapshot;
      if (cmd.tailable)
        findCmd.tailable = cmd.tailable;
      if (cmd.oplogReplay)
        findCmd.oplogReplay = cmd.oplogReplay;
      if (cmd.noCursorTimeout)
        findCmd.noCursorTimeout = cmd.noCursorTimeout;
      if (cmd.awaitData)
        findCmd.awaitData = cmd.awaitData;
      if (cmd.awaitdata)
        findCmd.awaitData = cmd.awaitdata;
      if (cmd.partial)
        findCmd.partial = cmd.partial;
      if (cmd.collation)
        findCmd.collation = cmd.collation;
      if (cmd.readConcern)
        findCmd.readConcern = cmd.readConcern;
      return findCmd;
    }
    function prepareLegacyFindQuery(server, ns, cmd, cursorState, options) {
      options = options || {};
      const bson = server.s.bson;
      const readPreference = getReadPreference(cmd, options);
      cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
      let numberToReturn = 0;
      if (cursorState.limit < 0 || cursorState.limit !== 0 && cursorState.limit < cursorState.batchSize || cursorState.limit > 0 && cursorState.batchSize === 0) {
        numberToReturn = cursorState.limit;
      } else {
        numberToReturn = cursorState.batchSize;
      }
      const numberToSkip = cursorState.skip || 0;
      const findCmd = {};
      if (isSharded(server) && readPreference) {
        findCmd["$readPreference"] = readPreference.toJSON();
      }
      if (cmd.sort)
        findCmd["$orderby"] = cmd.sort;
      if (cmd.hint)
        findCmd["$hint"] = cmd.hint;
      if (cmd.snapshot)
        findCmd["$snapshot"] = cmd.snapshot;
      if (typeof cmd.returnKey !== "undefined")
        findCmd["$returnKey"] = cmd.returnKey;
      if (cmd.maxScan)
        findCmd["$maxScan"] = cmd.maxScan;
      if (cmd.min)
        findCmd["$min"] = cmd.min;
      if (cmd.max)
        findCmd["$max"] = cmd.max;
      if (typeof cmd.showDiskLoc !== "undefined")
        findCmd["$showDiskLoc"] = cmd.showDiskLoc;
      if (cmd.comment)
        findCmd["$comment"] = cmd.comment;
      if (cmd.maxTimeMS)
        findCmd["$maxTimeMS"] = cmd.maxTimeMS;
      if (options.explain !== void 0) {
        numberToReturn = -Math.abs(cmd.limit || 0);
        findCmd["$explain"] = true;
      }
      findCmd["$query"] = cmd.query;
      if (cmd.readConcern && cmd.readConcern.level !== "local") {
        throw new MongoError(`server find command does not support a readConcern level of ${cmd.readConcern.level}`);
      }
      if (cmd.readConcern) {
        cmd = Object.assign({}, cmd);
        delete cmd["readConcern"];
      }
      const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
      const query2 = new Query(bson, ns, findCmd, {
        numberToSkip,
        numberToReturn,
        pre32Limit: typeof cmd.limit !== "undefined" ? cmd.limit : void 0,
        checkKeys: false,
        returnFieldSelector: cmd.fields,
        serializeFunctions,
        ignoreUndefined
      });
      if (typeof cmd.tailable === "boolean")
        query2.tailable = cmd.tailable;
      if (typeof cmd.oplogReplay === "boolean")
        query2.oplogReplay = cmd.oplogReplay;
      if (typeof cmd.noCursorTimeout === "boolean")
        query2.noCursorTimeout = cmd.noCursorTimeout;
      if (typeof cmd.awaitData === "boolean")
        query2.awaitData = cmd.awaitData;
      if (typeof cmd.partial === "boolean")
        query2.partial = cmd.partial;
      query2.slaveOk = readPreference.slaveOk();
      return query2;
    }
    module2.exports = query;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/index.js
var require_wireprotocol = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/index.js"(exports2, module2) {
    "use strict";
    var writeCommand = require_write_command();
    module2.exports = {
      insert: function insert(server, ns, ops, options, callback) {
        writeCommand(server, "insert", "documents", ns, ops, options, callback);
      },
      update: function update(server, ns, ops, options, callback) {
        writeCommand(server, "update", "updates", ns, ops, options, callback);
      },
      remove: function remove(server, ns, ops, options, callback) {
        writeCommand(server, "delete", "deletes", ns, ops, options, callback);
      },
      killCursors: require_kill_cursors(),
      getMore: require_get_more(),
      query: require_query2(),
      command: require_command()
    };
  }
});

// node_modules/mongodb/lib/operations/operation.js
var require_operation = __commonJS({
  "node_modules/mongodb/lib/operations/operation.js"(exports2, module2) {
    "use strict";
    var Explain = require_explain().Explain;
    var MongoError = require_error().MongoError;
    var Aspect = {
      READ_OPERATION: Symbol("READ_OPERATION"),
      WRITE_OPERATION: Symbol("WRITE_OPERATION"),
      RETRYABLE: Symbol("RETRYABLE"),
      EXECUTE_WITH_SELECTION: Symbol("EXECUTE_WITH_SELECTION"),
      NO_INHERIT_OPTIONS: Symbol("NO_INHERIT_OPTIONS"),
      EXPLAINABLE: Symbol("EXPLAINABLE")
    };
    var OperationBase = class {
      constructor(options) {
        this.options = Object.assign({}, options);
        if (this.hasAspect(Aspect.EXPLAINABLE)) {
          this.explain = Explain.fromOptions(options);
        } else if (this.options.explain !== void 0) {
          throw new MongoError(`explain is not supported on this command`);
        }
      }
      hasAspect(aspect) {
        if (this.constructor.aspects == null) {
          return false;
        }
        return this.constructor.aspects.has(aspect);
      }
      set session(session) {
        Object.assign(this.options, { session });
      }
      get session() {
        return this.options.session;
      }
      clearSession() {
        delete this.options.session;
      }
      get canRetryRead() {
        return true;
      }
      execute() {
        throw new TypeError("`execute` must be implemented for OperationBase subclasses");
      }
    };
    function defineAspects(operation, aspects) {
      if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
        aspects = [aspects];
      }
      aspects = new Set(aspects);
      Object.defineProperty(operation, "aspects", {
        value: aspects,
        writable: false
      });
      return aspects;
    }
    module2.exports = {
      Aspect,
      defineAspects,
      OperationBase
    };
  }
});

// node_modules/mongodb/lib/operations/execute_operation.js
var require_execute_operation = __commonJS({
  "node_modules/mongodb/lib/operations/execute_operation.js"(exports2, module2) {
    "use strict";
    var maybePromise = require_utils6().maybePromise;
    var MongoError = require_error().MongoError;
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_read_preference();
    var isRetryableError = require_error().isRetryableError;
    var maxWireVersion = require_utils4().maxWireVersion;
    var isUnifiedTopology = require_utils4().isUnifiedTopology;
    function executeOperation(topology, operation, cb) {
      if (topology == null) {
        throw new TypeError("This method requires a valid topology instance");
      }
      if (!(operation instanceof OperationBase)) {
        throw new TypeError("This method requires a valid operation instance");
      }
      return maybePromise(topology, cb, (callback) => {
        if (isUnifiedTopology(topology) && topology.shouldCheckForSessionSupport()) {
          return selectServerForSessionSupport(topology, operation, callback);
        }
        let session, owner;
        if (topology.hasSessionSupport()) {
          if (operation.session == null) {
            owner = Symbol();
            session = topology.startSession({ owner });
            operation.session = session;
          } else if (operation.session.hasEnded) {
            return callback(new MongoError("Use of expired sessions is not permitted"));
          }
        } else if (operation.session) {
          return callback(new MongoError("Current topology does not support sessions"));
        }
        function executeCallback(err, result) {
          if (session && session.owner === owner) {
            session.endSession();
            if (operation.session === session) {
              operation.clearSession();
            }
          }
          callback(err, result);
        }
        try {
          if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {
            executeWithServerSelection(topology, operation, executeCallback);
          } else {
            operation.execute(executeCallback);
          }
        } catch (error) {
          if (session && session.owner === owner) {
            session.endSession();
            if (operation.session === session) {
              operation.clearSession();
            }
          }
          callback(error);
        }
      });
    }
    function supportsRetryableReads(server) {
      return maxWireVersion(server) >= 6;
    }
    function executeWithServerSelection(topology, operation, callback) {
      const readPreference = operation.readPreference || ReadPreference.primary;
      const inTransaction = operation.session && operation.session.inTransaction();
      if (inTransaction && !readPreference.equals(ReadPreference.primary)) {
        callback(new MongoError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));
        return;
      }
      const serverSelectionOptions = {
        readPreference,
        session: operation.session
      };
      function callbackWithRetry(err, result) {
        if (err == null) {
          return callback(null, result);
        }
        if (!isRetryableError(err)) {
          return callback(err);
        }
        topology.selectServer(serverSelectionOptions, (err2, server) => {
          if (err2 || !supportsRetryableReads(server)) {
            callback(err2, null);
            return;
          }
          operation.execute(server, callback);
        });
      }
      topology.selectServer(serverSelectionOptions, (err, server) => {
        if (err) {
          callback(err, null);
          return;
        }
        const shouldRetryReads = topology.s.options.retryReads !== false && operation.session && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;
        if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {
          operation.execute(server, callbackWithRetry);
          return;
        }
        operation.execute(server, callback);
      });
    }
    function selectServerForSessionSupport(topology, operation, callback) {
      topology.selectServer(ReadPreference.primaryPreferred, (err) => {
        if (err) {
          return callback(err);
        }
        executeOperation(topology, operation, callback);
      });
    }
    module2.exports = executeOperation;
  }
});

// node_modules/mongodb/lib/core/cursor.js
var require_cursor = __commonJS({
  "node_modules/mongodb/lib/core/cursor.js"(exports2, module2) {
    "use strict";
    var Logger = require_logger();
    var retrieveBSON = require_utils5().retrieveBSON;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var collationNotSupported = require_utils4().collationNotSupported;
    var ReadPreference = require_read_preference();
    var isUnifiedTopology = require_utils4().isUnifiedTopology;
    var executeOperation = require_execute_operation();
    var Readable = require("stream").Readable;
    var SUPPORTS = require_utils6().SUPPORTS;
    var MongoDBNamespace = require_utils6().MongoDBNamespace;
    var mergeOptions = require_utils6().mergeOptions;
    var OperationBase = require_operation().OperationBase;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var CursorState = {
      INIT: 0,
      OPEN: 1,
      CLOSED: 2,
      GET_MORE: 3
    };
    function handleCallback(callback, err, result) {
      try {
        callback(err, result);
      } catch (err2) {
        process.nextTick(function() {
          throw err2;
        });
      }
    }
    var CoreCursor = class extends Readable {
      constructor(topology, ns, cmd, options) {
        super({ objectMode: true });
        options = options || {};
        if (ns instanceof OperationBase) {
          this.operation = ns;
          ns = this.operation.ns.toString();
          options = this.operation.options;
          cmd = this.operation.cmd ? this.operation.cmd : {};
        }
        this.pool = null;
        this.server = null;
        this.disconnectHandler = options.disconnectHandler;
        this.bson = topology.s.bson;
        this.ns = ns;
        this.namespace = MongoDBNamespace.fromString(ns);
        this.cmd = cmd;
        this.options = options;
        this.topology = topology;
        this.cursorState = {
          cursorId: null,
          cmd,
          documents: options.documents || [],
          cursorIndex: 0,
          dead: false,
          killed: false,
          init: false,
          notified: false,
          limit: options.limit || cmd.limit || 0,
          skip: options.skip || cmd.skip || 0,
          batchSize: options.batchSize || cmd.batchSize || 1e3,
          currentLimit: 0,
          transforms: options.transforms,
          raw: options.raw || cmd && cmd.raw
        };
        if (typeof options.session === "object") {
          this.cursorState.session = options.session;
        }
        const topologyOptions = topology.s.options;
        if (typeof topologyOptions.promoteLongs === "boolean") {
          this.cursorState.promoteLongs = topologyOptions.promoteLongs;
        } else if (typeof options.promoteLongs === "boolean") {
          this.cursorState.promoteLongs = options.promoteLongs;
        }
        if (typeof topologyOptions.promoteValues === "boolean") {
          this.cursorState.promoteValues = topologyOptions.promoteValues;
        } else if (typeof options.promoteValues === "boolean") {
          this.cursorState.promoteValues = options.promoteValues;
        }
        if (typeof topologyOptions.promoteBuffers === "boolean") {
          this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;
        } else if (typeof options.promoteBuffers === "boolean") {
          this.cursorState.promoteBuffers = options.promoteBuffers;
        }
        if (typeof topologyOptions.bsonRegExp === "boolean") {
          this.cursorState.bsonRegExp = topologyOptions.bsonRegExp;
        } else if (typeof options.bsonRegExp === "boolean") {
          this.cursorState.bsonRegExp = options.bsonRegExp;
        }
        if (topologyOptions.reconnect) {
          this.cursorState.reconnect = topologyOptions.reconnect;
        }
        this.logger = Logger("Cursor", topologyOptions);
        if (typeof cmd === "number") {
          this.cursorState.cursorId = Long2.fromNumber(cmd);
          this.cursorState.lastCursorId = this.cursorState.cursorId;
        } else if (cmd instanceof Long2) {
          this.cursorState.cursorId = cmd;
          this.cursorState.lastCursorId = cmd;
        }
        if (this.operation) {
          this.operation.cursorState = this.cursorState;
        }
      }
      setCursorBatchSize(value) {
        this.cursorState.batchSize = value;
      }
      cursorBatchSize() {
        return this.cursorState.batchSize;
      }
      setCursorLimit(value) {
        this.cursorState.limit = value;
      }
      cursorLimit() {
        return this.cursorState.limit;
      }
      setCursorSkip(value) {
        this.cursorState.skip = value;
      }
      cursorSkip() {
        return this.cursorState.skip;
      }
      _next(callback) {
        nextFunction(this, callback);
      }
      clone() {
        const clonedOptions = mergeOptions({}, this.options);
        delete clonedOptions.session;
        return this.topology.cursor(this.ns, this.cmd, clonedOptions);
      }
      isDead() {
        return this.cursorState.dead === true;
      }
      isKilled() {
        return this.cursorState.killed === true;
      }
      isNotified() {
        return this.cursorState.notified === true;
      }
      bufferedCount() {
        return this.cursorState.documents.length - this.cursorState.cursorIndex;
      }
      readBufferedDocuments(number) {
        const unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;
        const length = number < unreadDocumentsLength ? number : unreadDocumentsLength;
        let elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length);
        if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === "function") {
          for (let i = 0; i < elements.length; i++) {
            elements[i] = this.cursorState.transforms.doc(elements[i]);
          }
        }
        if (this.cursorState.limit > 0 && this.cursorState.currentLimit + elements.length > this.cursorState.limit) {
          elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);
          this.kill();
        }
        this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;
        this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;
        return elements;
      }
      kill(callback) {
        this.cursorState.dead = true;
        this.cursorState.killed = true;
        this.cursorState.documents = [];
        if (this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init === false) {
          if (callback)
            callback(null, null);
          return;
        }
        this.server.killCursors(this.ns, this.cursorState, callback);
      }
      rewind() {
        if (this.cursorState.init) {
          if (!this.cursorState.dead) {
            this.kill();
          }
          this.cursorState.currentLimit = 0;
          this.cursorState.init = false;
          this.cursorState.dead = false;
          this.cursorState.killed = false;
          this.cursorState.notified = false;
          this.cursorState.documents = [];
          this.cursorState.cursorId = null;
          this.cursorState.cursorIndex = 0;
        }
      }
      _read() {
        if (this.s && this.s.state === CursorState.CLOSED || this.isDead()) {
          return this.push(null);
        }
        this._next((err, result) => {
          if (err) {
            if (this.listeners("error") && this.listeners("error").length > 0) {
              this.emit("error", err);
            }
            if (!this.isDead())
              this.close();
            this.emit("end");
            return this.emit("finish");
          }
          if (this.cursorState.streamOptions && typeof this.cursorState.streamOptions.transform === "function" && result != null) {
            return this.push(this.cursorState.streamOptions.transform(result));
          }
          this.push(result);
          if (result === null && this.isDead()) {
            this.once("end", () => {
              this.close();
              this.emit("finish");
            });
          }
        });
      }
      _endSession(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        const session = this.cursorState.session;
        if (session && (options.force || session.owner === this)) {
          this.cursorState.session = void 0;
          if (this.operation) {
            this.operation.clearSession();
          }
          session.endSession(callback);
          return true;
        }
        if (callback) {
          callback();
        }
        return false;
      }
      _getMore(callback) {
        if (this.logger.isDebug()) {
          this.logger.debug(`schedule getMore call for query [${JSON.stringify(this.query)}]`);
        }
        let batchSize = this.cursorState.batchSize;
        if (this.cursorState.limit > 0 && this.cursorState.currentLimit + batchSize > this.cursorState.limit) {
          batchSize = this.cursorState.limit - this.cursorState.currentLimit;
        }
        const cursorState = this.cursorState;
        this.server.getMore(this.ns, cursorState, batchSize, this.options, (err, result, conn) => {
          if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
            this._endSession();
          }
          callback(err, result, conn);
        });
      }
      _initializeCursor(callback) {
        const cursor = this;
        if (isUnifiedTopology(cursor.topology) && cursor.topology.shouldCheckForSessionSupport()) {
          cursor.topology.selectServer(ReadPreference.primaryPreferred, (err) => {
            if (err) {
              callback(err);
              return;
            }
            this._initializeCursor(callback);
          });
          return;
        }
        function done(err, result) {
          const cursorState = cursor.cursorState;
          if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
            cursor._endSession();
          }
          if (cursorState.documents.length === 0 && cursorState.cursorId && cursorState.cursorId.isZero() && !cursor.cmd.tailable && !cursor.cmd.awaitData) {
            return setCursorNotified(cursor, callback);
          }
          callback(err, result);
        }
        const queryCallback = (err, r) => {
          if (err) {
            return done(err);
          }
          const result = r.message;
          if (Array.isArray(result.documents) && result.documents.length === 1) {
            const document2 = result.documents[0];
            if (result.queryFailure) {
              return done(new MongoError(document2), null);
            }
            if (!cursor.cmd.find || cursor.cmd.find && cursor.cmd.virtual === false) {
              if (document2.$err || document2.errmsg) {
                return done(new MongoError(document2), null);
              }
              if (document2.cursor != null && typeof document2.cursor !== "string") {
                const id = document2.cursor.id;
                if (document2.cursor.ns) {
                  cursor.ns = document2.cursor.ns;
                }
                cursor.cursorState.cursorId = typeof id === "number" ? Long2.fromNumber(id) : id;
                cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;
                cursor.cursorState.operationTime = document2.operationTime;
                if (Array.isArray(document2.cursor.firstBatch)) {
                  cursor.cursorState.documents = document2.cursor.firstBatch;
                }
                return done(null, result);
              }
            }
          }
          const cursorId = result.cursorId || 0;
          cursor.cursorState.cursorId = cursorId instanceof Long2 ? cursorId : Long2.fromNumber(cursorId);
          cursor.cursorState.documents = result.documents;
          cursor.cursorState.lastCursorId = result.cursorId;
          if (cursor.cursorState.transforms && typeof cursor.cursorState.transforms.query === "function") {
            cursor.cursorState.documents = cursor.cursorState.transforms.query(result);
          }
          done(null, result);
        };
        if (cursor.operation) {
          if (cursor.logger.isDebug()) {
            cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);
          }
          executeOperation(cursor.topology, cursor.operation, (err, result) => {
            if (err) {
              done(err);
              return;
            }
            cursor.server = cursor.operation.server;
            cursor.cursorState.init = true;
            if (cursor.cursorState.cursorId != null) {
              return done();
            }
            queryCallback(err, result);
          });
          return;
        }
        const serverSelectOptions = {};
        if (cursor.cursorState.session) {
          serverSelectOptions.session = cursor.cursorState.session;
        }
        if (cursor.operation) {
          serverSelectOptions.readPreference = cursor.operation.readPreference;
        } else if (cursor.options.readPreference) {
          serverSelectOptions.readPreference = cursor.options.readPreference;
        }
        return cursor.topology.selectServer(serverSelectOptions, (err, server) => {
          if (err) {
            const disconnectHandler = cursor.disconnectHandler;
            if (disconnectHandler != null) {
              return disconnectHandler.addObjectAndMethod("cursor", cursor, "next", [callback], callback);
            }
            return callback(err);
          }
          cursor.server = server;
          cursor.cursorState.init = true;
          if (collationNotSupported(cursor.server, cursor.cmd)) {
            return callback(new MongoError(`server ${cursor.server.name} does not support collation`));
          }
          if (cursor.cursorState.cursorId != null) {
            return done();
          }
          if (cursor.logger.isDebug()) {
            cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);
          }
          if (cursor.cmd.find != null) {
            server.query(cursor.ns, cursor.cmd, cursor.cursorState, cursor.options, queryCallback);
            return;
          }
          const commandOptions = Object.assign({ session: cursor.cursorState.session }, cursor.options);
          server.command(cursor.ns, cursor.cmd, commandOptions, queryCallback);
        });
      }
    };
    if (SUPPORTS.ASYNC_ITERATOR) {
      CoreCursor.prototype[Symbol.asyncIterator] = require_async_iterator().asyncIterator;
    }
    function isConnectionDead(self2, callback) {
      if (self2.pool && self2.pool.isDestroyed()) {
        self2.cursorState.killed = true;
        const err = new MongoNetworkError(`connection to host ${self2.pool.host}:${self2.pool.port} was destroyed`);
        _setCursorNotifiedImpl(self2, () => callback(err));
        return true;
      }
      return false;
    }
    function isCursorDeadButNotkilled(self2, callback) {
      if (self2.cursorState.dead && !self2.cursorState.killed) {
        self2.cursorState.killed = true;
        setCursorNotified(self2, callback);
        return true;
      }
      return false;
    }
    function isCursorDeadAndKilled(self2, callback) {
      if (self2.cursorState.dead && self2.cursorState.killed) {
        handleCallback(callback, new MongoError("cursor is dead"));
        return true;
      }
      return false;
    }
    function isCursorKilled(self2, callback) {
      if (self2.cursorState.killed) {
        setCursorNotified(self2, callback);
        return true;
      }
      return false;
    }
    function setCursorDeadAndNotified(self2, callback) {
      self2.cursorState.dead = true;
      setCursorNotified(self2, callback);
    }
    function setCursorNotified(self2, callback) {
      _setCursorNotifiedImpl(self2, () => handleCallback(callback, null, null));
    }
    function _setCursorNotifiedImpl(self2, callback) {
      self2.cursorState.notified = true;
      self2.cursorState.documents = [];
      self2.cursorState.cursorIndex = 0;
      if (self2.cursorState.session) {
        self2._endSession(callback);
        return;
      }
      return callback();
    }
    function nextFunction(self2, callback) {
      if (self2.cursorState.notified) {
        return callback(new Error("cursor is exhausted"));
      }
      if (isCursorKilled(self2, callback))
        return;
      if (isCursorDeadButNotkilled(self2, callback))
        return;
      if (isCursorDeadAndKilled(self2, callback))
        return;
      if (!self2.cursorState.init) {
        if (!self2.topology.isConnected(self2.options)) {
          if (self2.topology._type === "server" && !self2.topology.s.options.reconnect) {
            return callback(new MongoError("no connection available"));
          }
          if (self2.disconnectHandler != null) {
            if (self2.topology.isDestroyed()) {
              return callback(new MongoError("Topology was destroyed"));
            }
            self2.disconnectHandler.addObjectAndMethod("cursor", self2, "next", [callback], callback);
            return;
          }
        }
        self2._initializeCursor((err, result) => {
          if (err || result === null) {
            callback(err, result);
            return;
          }
          nextFunction(self2, callback);
        });
        return;
      }
      if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
        self2.kill(() => setCursorDeadAndNotified(self2, callback));
      } else if (self2.cursorState.cursorIndex === self2.cursorState.documents.length && !Long2.ZERO.equals(self2.cursorState.cursorId)) {
        self2.cursorState.documents = [];
        self2.cursorState.cursorIndex = 0;
        if (self2.topology.isDestroyed())
          return callback(new MongoNetworkError("connection destroyed, not possible to instantiate cursor"));
        if (isConnectionDead(self2, callback))
          return;
        self2._getMore(function(err, doc, connection) {
          if (err) {
            return handleCallback(callback, err);
          }
          self2.connection = connection;
          if (self2.cursorState.documents.length === 0 && self2.cmd.tailable && Long2.ZERO.equals(self2.cursorState.cursorId)) {
            return handleCallback(callback, new MongoError({
              message: "No more documents in tailed cursor",
              tailable: self2.cmd.tailable,
              awaitData: self2.cmd.awaitData
            }));
          } else if (self2.cursorState.documents.length === 0 && self2.cmd.tailable && !Long2.ZERO.equals(self2.cursorState.cursorId)) {
            return nextFunction(self2, callback);
          }
          if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
            return setCursorDeadAndNotified(self2, callback);
          }
          nextFunction(self2, callback);
        });
      } else if (self2.cursorState.documents.length === self2.cursorState.cursorIndex && self2.cmd.tailable && Long2.ZERO.equals(self2.cursorState.cursorId)) {
        return handleCallback(callback, new MongoError({
          message: "No more documents in tailed cursor",
          tailable: self2.cmd.tailable,
          awaitData: self2.cmd.awaitData
        }));
      } else if (self2.cursorState.documents.length === self2.cursorState.cursorIndex && Long2.ZERO.equals(self2.cursorState.cursorId)) {
        setCursorDeadAndNotified(self2, callback);
      } else {
        if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
          self2.kill(() => setCursorDeadAndNotified(self2, callback));
          return;
        }
        self2.cursorState.currentLimit += 1;
        let doc = self2.cursorState.documents[self2.cursorState.cursorIndex++];
        if (!doc || doc.$err) {
          self2.kill(() => setCursorDeadAndNotified(self2, function() {
            handleCallback(callback, new MongoError(doc ? doc.$err : void 0));
          }));
          return;
        }
        if (self2.cursorState.transforms && typeof self2.cursorState.transforms.doc === "function") {
          doc = self2.cursorState.transforms.doc(doc);
        }
        handleCallback(callback, null, doc);
      }
    }
    module2.exports = {
      CursorState,
      CoreCursor
    };
  }
});

// node_modules/mongodb/lib/core/topologies/server.js
var require_server = __commonJS({
  "node_modules/mongodb/lib/core/topologies/server.js"(exports2, module2) {
    "use strict";
    var inherits2 = require("util").inherits;
    var f = require("util").format;
    var EventEmitter = require("events").EventEmitter;
    var ReadPreference = require_read_preference();
    var Logger = require_logger();
    var debugOptions = require_utils5().debugOptions;
    var retrieveBSON = require_utils5().retrieveBSON;
    var Pool = require_pool();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var wireProtocol = require_wireprotocol();
    var CoreCursor = require_cursor().CoreCursor;
    var sdam = require_shared2();
    var createCompressionInfo = require_shared2().createCompressionInfo;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var SessionMixins = require_shared2().SessionMixins;
    var extractCommand = require_command_utils().extractCommand;
    var relayEvents = require_utils4().relayEvents;
    var collationNotSupported = require_utils4().collationNotSupported;
    var makeClientMetadata = require_utils4().makeClientMetadata;
    var debugFields = [
      "reconnect",
      "reconnectTries",
      "reconnectInterval",
      "emitError",
      "cursorFactory",
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "checkServerIdentity",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "key",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "servername"
    ];
    var id = 0;
    var serverAccounting = false;
    var servers = {};
    var BSON2 = retrieveBSON();
    function topologyId(server) {
      return server.s.parent == null ? server.id : server.s.parent.id;
    }
    var Server = function(options) {
      options = options || {};
      EventEmitter.call(this);
      this.id = id++;
      this.s = {
        options: Object.assign({ metadata: makeClientMetadata(options) }, options),
        logger: Logger("Server", options),
        Cursor: options.cursorFactory || CoreCursor,
        bson: options.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        pool: null,
        disconnectHandler: options.disconnectHandler,
        monitoring: typeof options.monitoring === "boolean" ? options.monitoring : true,
        inTopology: !!options.parent,
        monitoringInterval: typeof options.monitoringInterval === "number" ? options.monitoringInterval : 5e3,
        compression: { compressors: createCompressionInfo(options) },
        parent: options.parent
      };
      if (!this.s.parent) {
        this.s.clusterTime = null;
      }
      this.ismaster = null;
      this.lastIsMasterMS = -1;
      this.monitoringProcessId = null;
      this.initialConnect = true;
      this._type = "server";
      this.lastUpdateTime = 0;
      this.lastWriteDate = 0;
      this.staleness = 0;
    };
    inherits2(Server, EventEmitter);
    Object.assign(Server.prototype, SessionMixins);
    Object.defineProperty(Server.prototype, "type", {
      enumerable: true,
      get: function() {
        return this._type;
      }
    });
    Object.defineProperty(Server.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(Server.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        if (!this.ismaster)
          return null;
        return this.ismaster.logicalSessionTimeoutMinutes || null;
      }
    });
    Object.defineProperty(Server.prototype, "clientMetadata", {
      enumerable: true,
      get: function() {
        return this.s.options.metadata;
      }
    });
    Object.defineProperty(Server.prototype, "clusterTime", {
      enumerable: true,
      set: function(clusterTime) {
        const settings = this.s.parent ? this.s.parent : this.s;
        resolveClusterTime(settings, clusterTime);
      },
      get: function() {
        const settings = this.s.parent ? this.s.parent : this.s;
        return settings.clusterTime || null;
      }
    });
    Server.enableServerAccounting = function() {
      serverAccounting = true;
      servers = {};
    };
    Server.disableServerAccounting = function() {
      serverAccounting = false;
    };
    Server.servers = function() {
      return servers;
    };
    Object.defineProperty(Server.prototype, "name", {
      enumerable: true,
      get: function() {
        return this.s.options.host + ":" + this.s.options.port;
      }
    });
    function disconnectHandler(self2, type, ns, cmd, options, callback) {
      if (!self2.s.pool.isConnected() && self2.s.options.reconnect && self2.s.disconnectHandler != null && !options.monitoring) {
        self2.s.disconnectHandler.add(type, ns, cmd, options, callback);
        return true;
      }
      if (!self2.s.pool.isConnected()) {
        callback(new MongoError(f("no connection available to server %s", self2.name)));
        return true;
      }
    }
    function monitoringProcess(self2) {
      return function() {
        if (self2.s.pool.isDestroyed())
          return;
        self2.emit("monitoring", self2);
        var start = new Date().getTime();
        self2.command("admin.$cmd", { ismaster: true }, {
          socketTimeout: typeof self2.s.options.connectionTimeout !== "number" ? 2e3 : self2.s.options.connectionTimeout,
          monitoring: true
        }, (err, result) => {
          self2.lastIsMasterMS = new Date().getTime() - start;
          if (self2.s.pool.isDestroyed())
            return;
          if (result) {
            self2.ismaster = result.result;
          }
          self2.monitoringProcessId = setTimeout(monitoringProcess(self2), self2.s.monitoringInterval);
        });
      };
    }
    var eventHandler = function(self2, event) {
      return function(err, conn) {
        if (self2.s.logger.isInfo()) {
          var object = err instanceof MongoError ? JSON.stringify(err) : {};
          self2.s.logger.info(f("server %s fired event %s out with message %s", self2.name, event, object));
        }
        if (event === "connect") {
          self2.initialConnect = false;
          self2.ismaster = conn.ismaster;
          self2.lastIsMasterMS = conn.lastIsMasterMS;
          if (conn.agreedCompressor) {
            self2.s.pool.options.agreedCompressor = conn.agreedCompressor;
          }
          if (conn.zlibCompressionLevel) {
            self2.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;
          }
          if (conn.ismaster.$clusterTime) {
            const $clusterTime = conn.ismaster.$clusterTime;
            self2.clusterTime = $clusterTime;
          }
          if (self2.ismaster.msg === "isdbgrid") {
            self2._type = "mongos";
          }
          if (self2.s.monitoring) {
            self2.monitoringProcessId = setTimeout(monitoringProcess(self2), self2.s.monitoringInterval);
          }
          sdam.emitServerDescriptionChanged(self2, {
            address: self2.name,
            arbiters: [],
            hosts: [],
            passives: [],
            type: sdam.getTopologyType(self2)
          });
          if (!self2.s.inTopology) {
            sdam.emitTopologyDescriptionChanged(self2, {
              topologyType: "Single",
              servers: [
                {
                  address: self2.name,
                  arbiters: [],
                  hosts: [],
                  passives: [],
                  type: sdam.getTopologyType(self2)
                }
              ]
            });
          }
          if (self2.s.logger.isInfo()) {
            self2.s.logger.info(f("server %s connected with ismaster [%s]", self2.name, JSON.stringify(self2.ismaster)));
          }
          self2.emit("connect", self2);
        } else if (event === "error" || event === "parseError" || event === "close" || event === "timeout" || event === "reconnect" || event === "attemptReconnect" || event === "reconnectFailed") {
          if (serverAccounting && ["close", "timeout", "error", "parseError", "reconnectFailed"].indexOf(event) !== -1) {
            if (!self2.s.inTopology) {
              self2.emit("topologyOpening", { topologyId: self2.id });
            }
            delete servers[self2.id];
          }
          if (event === "close") {
            sdam.emitServerDescriptionChanged(self2, {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: "Unknown"
            });
          }
          if (event === "reconnectFailed") {
            self2.emit("reconnectFailed", err);
            if (self2.listeners("error").length > 0) {
              self2.emit("error", err);
            }
            return;
          }
          if (["disconnected", "connecting"].indexOf(self2.s.pool.state) !== -1 && self2.initialConnect && ["close", "timeout", "error", "parseError"].indexOf(event) !== -1) {
            self2.initialConnect = false;
            return self2.emit("error", new MongoNetworkError(f("failed to connect to server [%s] on first connect [%s]", self2.name, err)));
          }
          if (event === "reconnect") {
            sdam.emitServerDescriptionChanged(self2, {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: sdam.getTopologyType(self2)
            });
            return self2.emit(event, self2);
          }
          self2.emit(event, err);
        }
      };
    };
    Server.prototype.connect = function(options) {
      var self2 = this;
      options = options || {};
      if (serverAccounting)
        servers[this.id] = this;
      if (self2.s.pool && !self2.s.pool.isDisconnected() && !self2.s.pool.isDestroyed()) {
        throw new MongoError(f("server instance in invalid state %s", self2.s.pool.state));
      }
      self2.s.pool = new Pool(this, Object.assign(self2.s.options, options, { bson: this.s.bson }));
      self2.s.pool.on("close", eventHandler(self2, "close"));
      self2.s.pool.on("error", eventHandler(self2, "error"));
      self2.s.pool.on("timeout", eventHandler(self2, "timeout"));
      self2.s.pool.on("parseError", eventHandler(self2, "parseError"));
      self2.s.pool.on("connect", eventHandler(self2, "connect"));
      self2.s.pool.on("reconnect", eventHandler(self2, "reconnect"));
      self2.s.pool.on("reconnectFailed", eventHandler(self2, "reconnectFailed"));
      relayEvents(self2.s.pool, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
      if (!self2.s.inTopology) {
        this.emit("topologyOpening", { topologyId: topologyId(self2) });
      }
      self2.emit("serverOpening", { topologyId: topologyId(self2), address: self2.name });
      self2.s.pool.connect();
    };
    Server.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Server.prototype.getDescription = function() {
      var ismaster = this.ismaster || {};
      var description = {
        type: sdam.getTopologyType(this),
        address: this.name
      };
      if (ismaster.hosts)
        description.hosts = ismaster.hosts;
      if (ismaster.arbiters)
        description.arbiters = ismaster.arbiters;
      if (ismaster.passives)
        description.passives = ismaster.passives;
      if (ismaster.setName)
        description.setName = ismaster.setName;
      return description;
    };
    Server.prototype.lastIsMaster = function() {
      return this.ismaster;
    };
    Server.prototype.unref = function() {
      this.s.pool.unref();
    };
    Server.prototype.isConnected = function() {
      if (!this.s.pool)
        return false;
      return this.s.pool.isConnected();
    };
    Server.prototype.isDestroyed = function() {
      if (!this.s.pool)
        return false;
      return this.s.pool.isDestroyed();
    };
    function basicWriteValidations(self2) {
      if (!self2.s.pool)
        return new MongoError("server instance is not connected");
      if (self2.s.pool.isDestroyed())
        return new MongoError("server instance pool was destroyed");
    }
    function basicReadValidations(self2, options) {
      basicWriteValidations(self2, options);
      if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {
        throw new Error("readPreference must be an instance of ReadPreference");
      }
    }
    Server.prototype.command = function(ns, cmd, options, callback) {
      var self2 = this;
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      var result = basicReadValidations(self2, options);
      if (result)
        return callback(result);
      options = Object.assign({}, options, { wireProtocolCommand: false });
      if (self2.s.logger.isDebug()) {
        const extractedCommand = extractCommand(cmd);
        self2.s.logger.debug(f("executing command [%s] against %s", JSON.stringify({
          ns,
          cmd: extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : cmd,
          options: debugOptions(debugFields, options)
        }), self2.name));
      }
      if (disconnectHandler(self2, "command", ns, cmd, options, callback))
        return;
      if (collationNotSupported(this, cmd)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      wireProtocol.command(self2, ns, cmd, options, callback);
    };
    Server.prototype.query = function(ns, cmd, cursorState, options, callback) {
      wireProtocol.query(this, ns, cmd, cursorState, options, callback);
    };
    Server.prototype.getMore = function(ns, cursorState, batchSize, options, callback) {
      wireProtocol.getMore(this, ns, cursorState, batchSize, options, callback);
    };
    Server.prototype.killCursors = function(ns, cursorState, callback) {
      wireProtocol.killCursors(this, ns, cursorState, callback);
    };
    Server.prototype.insert = function(ns, ops, options, callback) {
      var self2 = this;
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      var result = basicWriteValidations(self2, options);
      if (result)
        return callback(result);
      if (disconnectHandler(self2, "insert", ns, ops, options, callback))
        return;
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.insert(self2, ns, ops, options, callback);
    };
    Server.prototype.update = function(ns, ops, options, callback) {
      var self2 = this;
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      var result = basicWriteValidations(self2, options);
      if (result)
        return callback(result);
      if (disconnectHandler(self2, "update", ns, ops, options, callback))
        return;
      if (collationNotSupported(this, options)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.update(self2, ns, ops, options, callback);
    };
    Server.prototype.remove = function(ns, ops, options, callback) {
      var self2 = this;
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      var result = basicWriteValidations(self2, options);
      if (result)
        return callback(result);
      if (disconnectHandler(self2, "remove", ns, ops, options, callback))
        return;
      if (collationNotSupported(this, options)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.remove(self2, ns, ops, options, callback);
    };
    Server.prototype.cursor = function(ns, cmd, options) {
      options = options || {};
      const topology = options.topology || this;
      var FinalCursor = options.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd, options);
    };
    Server.prototype.equals = function(server) {
      if (typeof server === "string")
        return this.name.toLowerCase() === server.toLowerCase();
      if (server.name)
        return this.name.toLowerCase() === server.name.toLowerCase();
      return false;
    };
    Server.prototype.connections = function() {
      return this.s.pool.allConnections();
    };
    Server.prototype.selectServer = function(selector, options, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options = {};
      if (typeof options === "function")
        callback = options, options = selector, selector = void 0;
      callback(null, this);
    };
    var listeners = ["close", "error", "timeout", "parseError", "connect"];
    Server.prototype.destroy = function(options, callback) {
      if (this._destroyed) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var self2 = this;
      if (serverAccounting)
        delete servers[this.id];
      if (this.monitoringProcessId) {
        clearTimeout(this.monitoringProcessId);
      }
      if (!self2.s.pool || this._destroyed) {
        this._destroyed = true;
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      this._destroyed = true;
      if (options.emitClose) {
        self2.emit("close", self2);
      }
      if (options.emitDestroy) {
        self2.emit("destroy", self2);
      }
      listeners.forEach(function(event) {
        self2.s.pool.removeAllListeners(event);
      });
      if (self2.listeners("serverClosed").length > 0)
        self2.emit("serverClosed", { topologyId: topologyId(self2), address: self2.name });
      if (self2.listeners("topologyClosed").length > 0 && !self2.s.inTopology) {
        self2.emit("topologyClosed", { topologyId: topologyId(self2) });
      }
      if (self2.s.logger.isDebug()) {
        self2.s.logger.debug(f("destroy called on server %s", self2.name));
      }
      this.s.pool.destroy(options.force, callback);
    };
    module2.exports = Server;
  }
});

// node_modules/mongodb/lib/core/topologies/replset_state.js
var require_replset_state = __commonJS({
  "node_modules/mongodb/lib/core/topologies/replset_state.js"(exports2, module2) {
    "use strict";
    var inherits2 = require("util").inherits;
    var f = require("util").format;
    var diff = require_shared2().diff;
    var EventEmitter = require("events").EventEmitter;
    var Logger = require_logger();
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var Buffer2 = require_safe_buffer().Buffer;
    var TopologyType = {
      Single: "Single",
      ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
      ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
      Sharded: "Sharded",
      Unknown: "Unknown"
    };
    var ServerType = {
      Standalone: "Standalone",
      Mongos: "Mongos",
      PossiblePrimary: "PossiblePrimary",
      RSPrimary: "RSPrimary",
      RSSecondary: "RSSecondary",
      RSArbiter: "RSArbiter",
      RSOther: "RSOther",
      RSGhost: "RSGhost",
      Unknown: "Unknown"
    };
    var ReplSetState = function(options) {
      options = options || {};
      EventEmitter.call(this);
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
      this.setName = options.setName;
      this.set = {};
      this.id = options.id;
      this.setName = options.setName;
      this.logger = options.logger || Logger("ReplSet", options);
      this.index = 0;
      this.acceptableLatency = options.acceptableLatency || 15;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 1e4;
      this.primary = null;
      this.secondaries = [];
      this.arbiters = [];
      this.passives = [];
      this.ghosts = [];
      this.unknownServers = [];
      this.set = {};
      this.maxElectionId = null;
      this.maxSetVersion = 0;
      this.replicasetDescription = {
        topologyType: "Unknown",
        servers: []
      };
      this.logicalSessionTimeoutMinutes = void 0;
    };
    inherits2(ReplSetState, EventEmitter);
    ReplSetState.prototype.hasPrimaryAndSecondary = function() {
      return this.primary != null && this.secondaries.length > 0;
    };
    ReplSetState.prototype.hasPrimaryOrSecondary = function() {
      return this.hasPrimary() || this.hasSecondary();
    };
    ReplSetState.prototype.hasPrimary = function() {
      return this.primary != null;
    };
    ReplSetState.prototype.hasSecondary = function() {
      return this.secondaries.length > 0;
    };
    ReplSetState.prototype.get = function(host) {
      var servers = this.allServers();
      for (var i = 0; i < servers.length; i++) {
        if (servers[i].name.toLowerCase() === host.toLowerCase()) {
          return servers[i];
        }
      }
      return null;
    };
    ReplSetState.prototype.allServers = function(options) {
      options = options || {};
      var servers = this.primary ? [this.primary] : [];
      servers = servers.concat(this.secondaries);
      if (!options.ignoreArbiters)
        servers = servers.concat(this.arbiters);
      servers = servers.concat(this.passives);
      return servers;
    };
    ReplSetState.prototype.destroy = function(options, callback) {
      const serversToDestroy = this.secondaries.concat(this.arbiters).concat(this.passives).concat(this.ghosts);
      if (this.primary)
        serversToDestroy.push(this.primary);
      let serverCount = serversToDestroy.length;
      const serverDestroyed = () => {
        serverCount--;
        if (serverCount > 0) {
          return;
        }
        this.secondaries = [];
        this.arbiters = [];
        this.passives = [];
        this.ghosts = [];
        this.unknownServers = [];
        this.set = {};
        this.primary = null;
        emitTopologyDescriptionChanged(this);
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (serverCount === 0) {
        serverDestroyed();
        return;
      }
      serversToDestroy.forEach((server) => server.destroy(options, serverDestroyed));
    };
    ReplSetState.prototype.remove = function(server, options) {
      options = options || {};
      var serverName = server.name.toLowerCase();
      var servers = this.primary ? [this.primary] : [];
      servers = servers.concat(this.secondaries);
      servers = servers.concat(this.arbiters);
      servers = servers.concat(this.passives);
      for (var i = 0; i < servers.length; i++) {
        if (!options.force && servers[i].equals(server) && servers[i].isConnected && servers[i].isConnected()) {
          return;
        }
      }
      if (this.set[serverName]) {
        this.set[serverName].type = ServerType.Unknown;
        this.set[serverName].electionId = null;
        this.set[serverName].setName = null;
        this.set[serverName].setVersion = null;
      }
      var removeType = null;
      if (this.primary && this.primary.equals(server)) {
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        removeType = "primary";
      }
      removeType = removeFrom(server, this.secondaries) ? "secondary" : removeType;
      removeType = removeFrom(server, this.arbiters) ? "arbiter" : removeType;
      removeType = removeFrom(server, this.passives) ? "secondary" : removeType;
      removeFrom(server, this.ghosts);
      removeFrom(server, this.unknownServers);
      this.unknownServers.push(serverName);
      if (removeType) {
        this.emit("left", removeType, server);
      }
    };
    var isArbiter = (ismaster) => ismaster.arbiterOnly && ismaster.setName;
    ReplSetState.prototype.update = function(server) {
      var self2 = this;
      var ismaster = server.lastIsMaster();
      var serverName = server.name.toLowerCase();
      if (ismaster) {
        var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];
        hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);
        hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);
        hosts = hosts.map(function(s) {
          return s.toLowerCase();
        });
        for (var i = 0; i < hosts.length; i++) {
          if (this.unknownServers.indexOf(hosts[i]) === -1 && (!this.set[hosts[i]] || this.set[hosts[i]].type === ServerType.Unknown)) {
            this.unknownServers.push(hosts[i].toLowerCase());
          }
          if (!this.set[hosts[i]]) {
            this.set[hosts[i]] = {
              type: ServerType.Unknown,
              electionId: null,
              setName: null,
              setVersion: null
            };
          }
        }
      }
      if (!ismaster && !inList(ismaster, server, this.unknownServers)) {
        self2.set[serverName] = {
          type: ServerType.Unknown,
          setVersion: null,
          electionId: null,
          setName: null
        };
        self2.set[serverName].type = ServerType.Unknown;
        self2.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
        self2.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
        self2.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
        if (self2.unknownServers.indexOf(server.name) === -1) {
          self2.unknownServers.push(serverName);
        }
        return false;
      }
      if (ismaster.logicalSessionTimeoutMinutes !== void 0 && !isArbiter(ismaster)) {
        if (self2.logicalSessionTimeoutMinutes === void 0 || ismaster.logicalSessionTimeoutMinutes === null) {
          self2.logicalSessionTimeoutMinutes = ismaster.logicalSessionTimeoutMinutes;
        } else {
          self2.logicalSessionTimeoutMinutes = Math.min(self2.logicalSessionTimeoutMinutes, ismaster.logicalSessionTimeoutMinutes);
        }
      }
      if (ismaster && ismaster.msg === "isdbgrid") {
        if (this.primary && this.primary.name === serverName) {
          this.primary = null;
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        return false;
      }
      if (ismaster.isreplicaset) {
        self2.set[serverName] = {
          type: ServerType.RSGhost,
          setVersion: null,
          electionId: null,
          setName: ismaster.setName
        };
        if (this.primary && this.primary.name === serverName) {
          this.primary = null;
        }
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        return false;
      }
      if (ismaster.setName && ismaster.hidden || ismaster.setName && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly && !ismaster.passive) {
        self2.set[serverName] = {
          type: ServerType.RSOther,
          setVersion: null,
          electionId: null,
          setName: ismaster.setName
        };
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        return false;
      }
      if (ismaster && ismaster.ismaster && !ismaster.setName) {
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;
        this.remove(server, { force: true });
        return false;
      }
      if (ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {
        this.remove(server, { force: true });
        return false;
      }
      if (ismaster.me && ismaster.me.toLowerCase() !== serverName) {
        if (this.logger.isWarn()) {
          this.logger.warn(f("the seedlist server was removed due to its address %s not matching its ismaster.me address %s", server.name, ismaster.me));
        }
        delete this.set[serverName];
        removeFrom(server, self2.unknownServers);
        server.destroy({ force: true });
        if (this.primary && !this.primary.equals(server)) {
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        if (!this.primary && ismaster.primary) {
          this.set[ismaster.primary.toLowerCase()] = {
            type: ServerType.PossiblePrimary,
            setName: null,
            electionId: null,
            setVersion: null
          };
        }
        return false;
      }
      if (!this.primary && ismaster.ismaster && ismaster.setName) {
        var ismasterElectionId = server.lastIsMaster().electionId;
        if (this.setName && this.setName !== ismaster.setName) {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
          return new MongoError(f("setName from ismaster does not match provided connection setName [%s] != [%s]", ismaster.setName, this.setName));
        }
        if (!this.maxElectionId && ismasterElectionId) {
          this.maxElectionId = ismasterElectionId;
        } else if (this.maxElectionId && ismasterElectionId) {
          var result = compareObjectIds(this.maxElectionId, ismasterElectionId);
          var ismasterSetVersion = server.lastIsMaster().setVersion;
          if (result === 1) {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
            return false;
          } else if (result === 0 && ismasterSetVersion) {
            if (ismasterSetVersion < this.maxSetVersion) {
              this.topologyType = TopologyType.ReplicaSetNoPrimary;
              return false;
            }
          }
          this.maxSetVersion = ismasterSetVersion;
          this.maxElectionId = ismasterElectionId;
        }
        var normalizedHosts = ismaster.hosts.map(function(x) {
          return x.toLowerCase();
        });
        var locationIndex = normalizedHosts.indexOf(serverName);
        if (locationIndex !== -1) {
          self2.primary = server;
          self2.set[serverName] = {
            type: ServerType.RSPrimary,
            setVersion: ismaster.setVersion,
            electionId: ismaster.electionId,
            setName: ismaster.setName
          };
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
          if (ismaster.setName)
            this.setName = ismaster.setName;
          removeFrom(server, self2.unknownServers);
          removeFrom(server, self2.secondaries);
          removeFrom(server, self2.passives);
          self2.emit("joined", "primary", server);
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        emitTopologyDescriptionChanged(self2);
        return true;
      } else if (ismaster.ismaster && ismaster.setName) {
        var currentElectionId = self2.set[self2.primary.name.toLowerCase()].electionId;
        var currentSetVersion = self2.set[self2.primary.name.toLowerCase()].setVersion;
        var currentSetName = self2.set[self2.primary.name.toLowerCase()].setName;
        ismasterElectionId = server.lastIsMaster().electionId;
        ismasterSetVersion = server.lastIsMaster().setVersion;
        var ismasterSetName = server.lastIsMaster().setName;
        if (this.primary.equals(server) && currentSetName === ismasterSetName) {
          return false;
        }
        if (currentSetName && currentSetName !== ismasterSetName) {
          if (!this.primary.equals(server)) {
            this.topologyType = TopologyType.ReplicaSetWithPrimary;
          } else {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
          }
          return false;
        }
        if (currentElectionId && ismasterElectionId) {
          result = compareObjectIds(currentElectionId, ismasterElectionId);
          if (result === 1) {
            return false;
          } else if (result === 0 && currentSetVersion > ismasterSetVersion) {
            return false;
          }
        } else if (!currentElectionId && ismasterElectionId && ismasterSetVersion) {
          if (ismasterSetVersion < this.maxSetVersion) {
            return false;
          }
        }
        if (!this.maxElectionId && ismasterElectionId) {
          this.maxElectionId = ismasterElectionId;
        } else if (this.maxElectionId && ismasterElectionId) {
          result = compareObjectIds(this.maxElectionId, ismasterElectionId);
          if (result === 1) {
            return false;
          } else if (result === 0 && currentSetVersion && ismasterSetVersion) {
            if (ismasterSetVersion < this.maxSetVersion) {
              return false;
            }
          } else {
            if (ismasterSetVersion < this.maxSetVersion) {
              return false;
            }
          }
          this.maxElectionId = ismasterElectionId;
          this.maxSetVersion = ismasterSetVersion;
        } else {
          this.maxSetVersion = ismasterSetVersion;
        }
        self2.set[self2.primary.name.toLowerCase()] = {
          type: ServerType.Unknown,
          setVersion: null,
          electionId: null,
          setName: null
        };
        self2.emit("left", "primary", this.primary);
        self2.primary.destroy({ force: true });
        self2.primary = server;
        self2.set[serverName] = {
          type: ServerType.RSPrimary,
          setVersion: ismaster.setVersion,
          electionId: ismaster.electionId,
          setName: ismaster.setName
        };
        this.topologyType = TopologyType.ReplicaSetWithPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        removeFrom(server, self2.secondaries);
        removeFrom(server, self2.passives);
        self2.emit("joined", "primary", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (!this.primary && ismaster.primary) {
        self2.set[ismaster.primary.toLowerCase()] = {
          type: ServerType.PossiblePrimary,
          setVersion: null,
          electionId: null,
          setName: null
        };
      }
      if (ismaster.secondary && ismaster.setName && !inList(ismaster, server, this.secondaries) && this.setName && this.setName === ismaster.setName) {
        addToList(self2, ServerType.RSSecondary, ismaster, server, this.secondaries);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        if (this.primary && this.primary.name.toLowerCase() === serverName) {
          server.destroy({ force: true });
          this.primary = null;
          self2.emit("left", "primary", server);
        }
        self2.emit("joined", "secondary", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (isArbiter(ismaster) && !inList(ismaster, server, this.arbiters) && this.setName && this.setName === ismaster.setName) {
        addToList(self2, ServerType.RSArbiter, ismaster, server, this.arbiters);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        self2.emit("joined", "arbiter", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (ismaster.passive && ismaster.setName && !inList(ismaster, server, this.passives) && this.setName && this.setName === ismaster.setName) {
        addToList(self2, ServerType.RSSecondary, ismaster, server, this.passives);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        if (this.primary && this.primary.name.toLowerCase() === serverName) {
          server.destroy({ force: true });
          this.primary = null;
          self2.emit("left", "primary", server);
        }
        self2.emit("joined", "secondary", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (this.set[serverName] && this.set[serverName].type === ServerType.RSPrimary) {
        self2.emit("left", "primary", this.primary);
        this.primary.destroy({ force: true });
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        return false;
      }
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      return false;
    };
    ReplSetState.prototype.updateServerMaxStaleness = function(server, haInterval) {
      var max = 0;
      for (var i = 0; i < this.secondaries.length; i++) {
        max = Math.max(max, this.secondaries[i].lastWriteDate);
      }
      if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary && this.hasPrimary()) {
        server.staleness = server.lastUpdateTime - server.lastWriteDate - (this.primary.lastUpdateTime - this.primary.lastWriteDate) + haInterval;
      } else if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary) {
        server.staleness = max - server.lastWriteDate + haInterval;
      }
    };
    ReplSetState.prototype.updateSecondariesMaxStaleness = function(haInterval) {
      for (var i = 0; i < this.secondaries.length; i++) {
        this.updateServerMaxStaleness(this.secondaries[i], haInterval);
      }
    };
    ReplSetState.prototype.pickServer = function(readPreference) {
      readPreference = readPreference || ReadPreference.primary;
      if (readPreference.preference === "primary" && readPreference.maxStalenessSeconds != null) {
        return new MongoError("primary readPreference incompatible with maxStalenessSeconds");
      }
      var allservers = this.primary ? [this.primary] : [];
      allservers = allservers.concat(this.secondaries);
      if (readPreference.maxStalenessSeconds != null) {
        for (var i = 0; i < allservers.length; i++) {
          if (allservers[i].ismaster.maxWireVersion < 5) {
            return new MongoError("maxStalenessSeconds not supported by at least one of the replicaset members");
          }
        }
      }
      if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds == null) {
        return pickNearest(this, readPreference);
      } else if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds != null) {
        return pickNearestMaxStalenessSeconds(this, readPreference);
      }
      var secondaries = this.secondaries;
      if (readPreference.equals(ReadPreference.secondary) && secondaries.length === 0) {
        return new MongoError("no secondary server available");
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred) && secondaries.length === 0 && this.primary == null) {
        return new MongoError("no secondary or primary server available");
      }
      if (readPreference.equals(ReadPreference.primary) && this.primary == null) {
        return new MongoError("no primary server available");
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred) || readPreference.equals(ReadPreference.secondary)) {
        if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
          var server = pickNearest(this, readPreference);
          if (server) {
            return server;
          }
        } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
          server = pickNearestMaxStalenessSeconds(this, readPreference);
          if (server) {
            return server;
          }
        }
        if (readPreference.equals(ReadPreference.secondaryPreferred)) {
          return this.primary;
        }
        return null;
      }
      if (readPreference.equals(ReadPreference.primaryPreferred)) {
        server = null;
        if (this.primary) {
          return this.primary;
        }
        if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
          server = pickNearest(this, readPreference);
        } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
          server = pickNearestMaxStalenessSeconds(this, readPreference);
        }
        if (server)
          return server;
      }
      return this.primary;
    };
    var filterByTags = function(readPreference, servers) {
      if (readPreference.tags == null)
        return servers;
      var filteredServers = [];
      var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags];
      for (var j = 0; j < tagsArray.length; j++) {
        var tags = tagsArray[j];
        for (var i = 0; i < servers.length; i++) {
          var serverTag = servers[i].lastIsMaster().tags || {};
          var found = true;
          for (var name in tags) {
            if (serverTag[name] !== tags[name]) {
              found = false;
            }
          }
          if (found) {
            filteredServers.push(servers[i]);
          }
        }
      }
      return filteredServers;
    };
    function pickNearestMaxStalenessSeconds(self2, readPreference) {
      var servers = [];
      var maxStalenessMS = readPreference.maxStalenessSeconds * 1e3;
      if (maxStalenessMS < 90 * 1e3) {
        return new MongoError("maxStalenessSeconds must be set to at least 90 seconds");
      }
      if (self2.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      for (var i = 0; i < self2.secondaries.length; i++) {
        servers.push(self2.secondaries[i]);
      }
      if (self2.primary && servers.length === 0 && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      servers = filterByTags(readPreference, servers);
      servers = servers.filter(function(s) {
        return s.staleness <= maxStalenessMS;
      });
      servers.sort(function(a, b) {
        return a.lastIsMasterMS - b.lastIsMasterMS;
      });
      if (servers.length === 0) {
        return null;
      }
      self2.index = self2.index % servers.length;
      var server = servers[self2.index];
      self2.index = self2.index + 1;
      return server;
    }
    function pickNearest(self2, readPreference) {
      var servers = [];
      if (self2.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      for (var i = 0; i < self2.secondaries.length; i++) {
        servers.push(self2.secondaries[i]);
      }
      if (servers.length === 0 && self2.primary && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      servers = filterByTags(readPreference, servers);
      servers.sort(function(a, b) {
        return a.lastIsMasterMS - b.lastIsMasterMS;
      });
      var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;
      servers = servers.filter(function(s) {
        return s.lastIsMasterMS <= lowest + self2.acceptableLatency;
      });
      if (servers.length === 0) {
        return null;
      }
      self2.index = self2.index % servers.length;
      var server = servers[self2.index];
      self2.index = self2.index + 1;
      return server;
    }
    function inList(ismaster, server, list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i] && list[i].name && list[i].name.toLowerCase() === server.name.toLowerCase())
          return true;
      }
      return false;
    }
    function addToList(self2, type, ismaster, server, list) {
      var serverName = server.name.toLowerCase();
      self2.set[serverName].type = type;
      self2.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
      self2.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
      self2.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
      list.push(server);
    }
    function compareObjectIds(id1, id2) {
      var a = Buffer2.from(id1.toHexString(), "hex");
      var b = Buffer2.from(id2.toHexString(), "hex");
      if (a === b) {
        return 0;
      }
      if (typeof Buffer2.compare === "function") {
        return Buffer2.compare(a, b);
      }
      var x = a.length;
      var y = b.length;
      var len = Math.min(x, y);
      for (var i = 0; i < len; i++) {
        if (a[i] !== b[i]) {
          break;
        }
      }
      if (i !== len) {
        x = a[i];
        y = b[i];
      }
      return x < y ? -1 : y < x ? 1 : 0;
    }
    function removeFrom(server, list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].equals && list[i].equals(server)) {
          list.splice(i, 1);
          return true;
        } else if (typeof list[i] === "string" && list[i].toLowerCase() === server.name.toLowerCase()) {
          list.splice(i, 1);
          return true;
        }
      }
      return false;
    }
    function emitTopologyDescriptionChanged(self2) {
      if (self2.listeners("topologyDescriptionChanged").length > 0) {
        var topology = "Unknown";
        var setName = self2.setName;
        if (self2.hasPrimaryAndSecondary()) {
          topology = "ReplicaSetWithPrimary";
        } else if (!self2.hasPrimary() && self2.hasSecondary()) {
          topology = "ReplicaSetNoPrimary";
        }
        var description = {
          topologyType: topology,
          setName,
          servers: []
        };
        if (self2.hasPrimary()) {
          var desc = self2.primary.getDescription();
          desc.type = "RSPrimary";
          description.servers.push(desc);
        }
        description.servers = description.servers.concat(self2.secondaries.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "RSSecondary";
          return description2;
        }));
        description.servers = description.servers.concat(self2.arbiters.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "RSArbiter";
          return description2;
        }));
        description.servers = description.servers.concat(self2.passives.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "RSSecondary";
          return description2;
        }));
        var diffResult = diff(self2.replicasetDescription, description);
        var result = {
          topologyId: self2.id,
          previousDescription: self2.replicasetDescription,
          newDescription: description,
          diff: diffResult
        };
        self2.emit("topologyDescriptionChanged", result);
        self2.replicasetDescription = description;
      }
    }
    module2.exports = ReplSetState;
  }
});

// node_modules/mongodb/lib/core/topologies/replset.js
var require_replset = __commonJS({
  "node_modules/mongodb/lib/core/topologies/replset.js"(exports2, module2) {
    "use strict";
    var inherits2 = require("util").inherits;
    var f = require("util").format;
    var EventEmitter = require("events").EventEmitter;
    var ReadPreference = require_read_preference();
    var CoreCursor = require_cursor().CoreCursor;
    var retrieveBSON = require_utils5().retrieveBSON;
    var Logger = require_logger();
    var MongoError = require_error().MongoError;
    var Server = require_server();
    var ReplSetState = require_replset_state();
    var Timeout = require_shared2().Timeout;
    var Interval = require_shared2().Interval;
    var SessionMixins = require_shared2().SessionMixins;
    var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
    var relayEvents = require_utils4().relayEvents;
    var BSON2 = retrieveBSON();
    var getMMAPError = require_shared2().getMMAPError;
    var makeClientMetadata = require_utils4().makeClientMetadata;
    var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
    var now = require_utils6().now;
    var calculateDurationInMs = require_utils6().calculateDurationInMs;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var UNREFERENCED = "unreferenced";
    var DESTROYED = "destroyed";
    function stateTransition(self2, newState) {
      var legalTransitions = {
        disconnected: [CONNECTING, DESTROYED, DISCONNECTED],
        connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],
        connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],
        unreferenced: [UNREFERENCED, DESTROYED],
        destroyed: [DESTROYED]
      };
      var legalStates = legalTransitions[self2.state];
      if (legalStates && legalStates.indexOf(newState) !== -1) {
        self2.state = newState;
      } else {
        self2.s.logger.error(f("Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]", self2.id, self2.state, newState, legalStates));
      }
    }
    var id = 1;
    var handlers = ["connect", "close", "error", "timeout", "parseError"];
    var ReplSet = function(seedlist, options) {
      var self2 = this;
      options = options || {};
      if (!Array.isArray(seedlist))
        throw new MongoError("seedlist must be an array");
      if (seedlist.length === 0)
        throw new MongoError("seedlist must contain at least one entry");
      seedlist.forEach(function(e) {
        if (typeof e.host !== "string" || typeof e.port !== "number")
          throw new MongoError("seedlist entry must contain a host and port");
      });
      EventEmitter.call(this);
      this.id = id++;
      var localThresholdMS = options.localThresholdMS || 15;
      if (options.acceptableLatency)
        localThresholdMS = options.acceptableLatency;
      var logger = Logger("ReplSet", options);
      this.s = {
        options: Object.assign({ metadata: makeClientMetadata(options) }, options),
        bson: options.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        Cursor: options.cursorFactory || CoreCursor,
        logger,
        seedlist,
        replicaSetState: new ReplSetState({
          id: this.id,
          setName: options.setName,
          acceptableLatency: localThresholdMS,
          heartbeatFrequencyMS: options.haInterval ? options.haInterval : 1e4,
          logger
        }),
        connectingServers: [],
        haInterval: options.haInterval ? options.haInterval : 1e4,
        minHeartbeatFrequencyMS: 500,
        disconnectHandler: options.disconnectHandler,
        index: 0,
        connectOptions: {},
        debug: typeof options.debug === "boolean" ? options.debug : false
      };
      this.s.replicaSetState.on("topologyDescriptionChanged", function(r) {
        self2.emit("topologyDescriptionChanged", r);
      });
      if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
        this.s.logger.warn(f("warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts", this.s.options.socketTimeout, this.s.haInterval));
      }
      var types = ["joined", "left"];
      types.forEach(function(x) {
        self2.s.replicaSetState.on(x, function(t, s) {
          self2.emit(x, t, s);
        });
      });
      this.initialConnectState = {
        connect: false,
        fullsetup: false,
        all: false
      };
      this.state = DISCONNECTED;
      this.haTimeoutId = null;
      this.ismaster = null;
      this.intervalIds = [];
      this.clusterTime = null;
    };
    inherits2(ReplSet, EventEmitter);
    Object.assign(ReplSet.prototype, SessionMixins);
    Object.defineProperty(ReplSet.prototype, "type", {
      enumerable: true,
      get: function() {
        return "replset";
      }
    });
    Object.defineProperty(ReplSet.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(ReplSet.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        return this.s.replicaSetState.logicalSessionTimeoutMinutes || null;
      }
    });
    function rexecuteOperations(self2) {
      if (self2.s.replicaSetState.hasPrimaryAndSecondary() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute();
      } else if (self2.s.replicaSetState.hasPrimary() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute({ executePrimary: true });
      } else if (self2.s.replicaSetState.hasSecondary() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute({ executeSecondary: true });
      }
    }
    function connectNewServers(self2, servers, callback) {
      if (servers.length === 0) {
        return callback();
      }
      var count = servers.length;
      var error = null;
      function done() {
        count = count - 1;
        if (count === 0) {
          callback(error);
        }
      }
      var _handleEvent = function(self3, event) {
        return function(err) {
          var _self = this;
          if (self3.state === DESTROYED || self3.state === UNREFERENCED) {
            this.destroy({ force: true });
            return done();
          }
          if (event === "connect") {
            var result = self3.s.replicaSetState.update(_self);
            if (result) {
              if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {
                self3.ismaster = _self.lastIsMaster();
              }
              for (let i2 = 0; i2 < handlers.length; i2++) {
                _self.removeAllListeners(handlers[i2]);
              }
              _self.on("error", handleEvent(self3, "error"));
              _self.on("close", handleEvent(self3, "close"));
              _self.on("timeout", handleEvent(self3, "timeout"));
              _self.on("parseError", handleEvent(self3, "parseError"));
              monitorServer(_self.lastIsMaster().me, self3, {});
              rexecuteOperations(self3);
            } else {
              _self.destroy({ force: true });
            }
          } else if (event === "error") {
            error = err;
          }
          rexecuteOperations(self3);
          done();
        };
      };
      function execute(_server, i2) {
        setTimeout(function() {
          if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
            return;
          }
          const existingServerIdx = self2.s.connectingServers.findIndex((s) => s.name === _server);
          if (existingServerIdx >= 0) {
            const connectingServer = self2.s.connectingServers[existingServerIdx];
            connectingServer.destroy({ force: true });
            self2.s.connectingServers.splice(existingServerIdx, 1);
            return done();
          }
          var server = new Server(Object.assign({}, self2.s.options, {
            host: _server.split(":")[0],
            port: parseInt(_server.split(":")[1], 10),
            reconnect: false,
            monitoring: false,
            parent: self2
          }));
          server.once("connect", _handleEvent(self2, "connect"));
          server.once("close", _handleEvent(self2, "close"));
          server.once("timeout", _handleEvent(self2, "timeout"));
          server.once("error", _handleEvent(self2, "error"));
          server.once("parseError", _handleEvent(self2, "parseError"));
          server.on("serverOpening", (e) => self2.emit("serverOpening", e));
          server.on("serverDescriptionChanged", (e) => self2.emit("serverDescriptionChanged", e));
          server.on("serverClosed", (e) => self2.emit("serverClosed", e));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          self2.s.connectingServers.push(server);
          server.connect(self2.s.connectOptions);
        }, i2);
      }
      for (var i = 0; i < servers.length; i++) {
        execute(servers[i], i);
      }
    }
    var pingServer = function(self2, server, cb) {
      var start = new Date().getTime();
      emitSDAMEvent(self2, "serverHeartbeatStarted", { connectionId: server.name });
      server.command("admin.$cmd", {
        ismaster: true
      }, {
        monitoring: true,
        socketTimeout: self2.s.options.connectionTimeout || 2e3
      }, function(err, r) {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          server.destroy({ force: true });
          return cb(err, r);
        }
        var latencyMS = new Date().getTime() - start;
        server.lastUpdateTime = now();
        if (err) {
          emitSDAMEvent(self2, "serverHeartbeatFailed", {
            durationMS: latencyMS,
            failure: err,
            connectionId: server.name
          });
          self2.s.replicaSetState.remove(server);
        } else {
          server.ismaster = r.result;
          if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {
            server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();
          }
          if (server.lastIsMasterMS === -1) {
            server.lastIsMasterMS = latencyMS;
          } else if (server.lastIsMasterMS) {
            server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;
          }
          if (self2.s.replicaSetState.update(server)) {
            if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
              self2.ismaster = server.lastIsMaster();
            }
          }
          emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
            durationMS: latencyMS,
            reply: r.result,
            connectionId: server.name
          });
        }
        self2.s.replicaSetState.updateServerMaxStaleness(server, self2.s.haInterval);
        cb(err, r);
      });
    };
    var monitorServer = function(host, self2, options) {
      if (!options.haInterval) {
        for (var i = 0; i < self2.intervalIds.length; i++) {
          if (self2.intervalIds[i].__host === host) {
            return;
          }
        }
      }
      var _process = options.haInterval ? Timeout : Interval;
      var _haInterval = options.haInterval ? options.haInterval : self2.s.haInterval;
      var intervalId = new _process(function() {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          intervalId.stop();
          return;
        }
        var _server = self2.s.replicaSetState.get(host);
        if (_server) {
          return pingServer(self2, _server, function(err) {
            if (err) {
              return;
            }
            if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
              intervalId.stop();
              return;
            }
            self2.intervalIds = self2.intervalIds.filter(function(intervalId2) {
              return intervalId2.isRunning();
            });
            if (_process === Timeout) {
              if (self2.state === CONNECTING && (self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed || self2.s.replicaSetState.hasPrimary())) {
                stateTransition(self2, CONNECTED);
                process.nextTick(function() {
                  self2.emit("connect", self2);
                });
                topologyMonitor(self2, {});
              }
            } else {
              if (self2.state === DISCONNECTED && (self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed || self2.s.replicaSetState.hasPrimary())) {
                stateTransition(self2, CONNECTING);
                rexecuteOperations(self2);
                process.nextTick(function() {
                  self2.emit("reconnect", self2);
                });
              }
            }
            if (self2.initialConnectState.connect && !self2.initialConnectState.fullsetup && self2.s.replicaSetState.hasPrimaryAndSecondary()) {
              self2.initialConnectState.fullsetup = true;
              self2.initialConnectState.all = true;
              process.nextTick(function() {
                self2.emit("fullsetup", self2);
                self2.emit("all", self2);
              });
            }
          });
        }
      }, _haInterval);
      intervalId.start();
      intervalId.__host = host;
      self2.intervalIds.push(intervalId);
    };
    function topologyMonitor(self2, options) {
      if (self2.state === DESTROYED || self2.state === UNREFERENCED)
        return;
      options = options || {};
      var servers = Object.keys(self2.s.replicaSetState.set);
      var _process = options.haInterval ? Timeout : Interval;
      var _haInterval = options.haInterval ? options.haInterval : self2.s.haInterval;
      if (_process === Timeout) {
        return connectNewServers(self2, self2.s.replicaSetState.unknownServers, function(err) {
          if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
            return;
          }
          if (!self2.s.replicaSetState.hasPrimary() && !self2.s.options.secondaryOnlyConnectionAllowed) {
            if (err) {
              return self2.emit("error", err);
            }
            self2.emit("error", new MongoError("no primary found in replicaset or invalid replica set name"));
            return self2.destroy({ force: true });
          } else if (!self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed) {
            if (err) {
              return self2.emit("error", err);
            }
            self2.emit("error", new MongoError("no secondary found in replicaset or invalid replica set name"));
            return self2.destroy({ force: true });
          }
          for (var i2 = 0; i2 < servers.length; i2++) {
            monitorServer(servers[i2], self2, options);
          }
        });
      } else {
        for (var i = 0; i < servers.length; i++) {
          monitorServer(servers[i], self2, options);
        }
      }
      function executeReconnect(self3) {
        return function() {
          if (self3.state === DESTROYED || self3.state === UNREFERENCED) {
            return;
          }
          connectNewServers(self3, self3.s.replicaSetState.unknownServers, function() {
            var monitoringFrequencey = self3.s.replicaSetState.hasPrimary() ? _haInterval : self3.s.minHeartbeatFrequencyMS;
            self3.intervalIds.push(new Timeout(executeReconnect(self3), monitoringFrequencey).start());
          });
        };
      }
      var intervalTime = !self2.s.replicaSetState.hasPrimary() ? self2.s.minHeartbeatFrequencyMS : _haInterval;
      self2.intervalIds.push(new Timeout(executeReconnect(self2), intervalTime).start());
    }
    function addServerToList(list, server) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].name.toLowerCase() === server.name.toLowerCase())
          return true;
      }
      list.push(server);
    }
    function handleEvent(self2, event) {
      return function() {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED)
          return;
        if (self2.s.logger.isDebug()) {
          self2.s.logger.debug(f("handleEvent %s from server %s in replset with id %s", event, this.name, self2.id));
        }
        self2.s.replicaSetState.remove(this);
        if (self2.state === DESTROYED || self2.state === UNREFERENCED)
          return;
        if (!self2.s.replicaSetState.hasPrimary() && !self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed) {
          stateTransition(self2, DISCONNECTED);
        } else if (!self2.s.replicaSetState.hasPrimary()) {
          stateTransition(self2, DISCONNECTED);
        }
        addServerToList(self2.s.connectingServers, this);
      };
    }
    function shouldTriggerConnect(self2) {
      const isConnecting = self2.state === CONNECTING;
      const hasPrimary = self2.s.replicaSetState.hasPrimary();
      const hasSecondary = self2.s.replicaSetState.hasSecondary();
      const secondaryOnlyConnectionAllowed = self2.s.options.secondaryOnlyConnectionAllowed;
      const readPreferenceSecondary = self2.s.connectOptions.readPreference && self2.s.connectOptions.readPreference.equals(ReadPreference.secondary);
      return isConnecting && (readPreferenceSecondary && hasSecondary || !readPreferenceSecondary && hasPrimary) || hasSecondary && secondaryOnlyConnectionAllowed;
    }
    function handleInitialConnectEvent(self2, event) {
      return function() {
        var _this = this;
        if (self2.s.logger.isDebug()) {
          self2.s.logger.debug(f("handleInitialConnectEvent %s from server %s in replset with id %s", event, this.name, self2.id));
        }
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          return this.destroy({ force: true });
        }
        if (event === "connect") {
          var result = self2.s.replicaSetState.update(_this);
          if (result === true) {
            if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {
              self2.ismaster = _this.lastIsMaster();
            }
            if (self2.s.logger.isDebug()) {
              self2.s.logger.debug(f("handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]", event, _this.name, self2.id, JSON.stringify(self2.s.replicaSetState.set)));
            }
            for (let i2 = 0; i2 < handlers.length; i2++) {
              _this.removeAllListeners(handlers[i2]);
            }
            _this.on("error", handleEvent(self2, "error"));
            _this.on("close", handleEvent(self2, "close"));
            _this.on("timeout", handleEvent(self2, "timeout"));
            _this.on("parseError", handleEvent(self2, "parseError"));
            if (shouldTriggerConnect(self2)) {
              stateTransition(self2, CONNECTED);
              self2.initialConnectState.connect = true;
              process.nextTick(function() {
                self2.emit("connect", self2);
              });
              topologyMonitor(self2, {});
            }
          } else if (result instanceof MongoError) {
            _this.destroy({ force: true });
            self2.destroy({ force: true });
            return self2.emit("error", result);
          } else {
            _this.destroy({ force: true });
          }
        } else {
          self2.emit("failed", this);
          addServerToList(self2.s.connectingServers, this);
          self2.s.replicaSetState.remove(this);
        }
        if (self2.initialConnectState.connect && !self2.initialConnectState.fullsetup && self2.s.replicaSetState.hasPrimaryAndSecondary()) {
          self2.initialConnectState.fullsetup = true;
          self2.initialConnectState.all = true;
          process.nextTick(function() {
            self2.emit("fullsetup", self2);
            self2.emit("all", self2);
          });
        }
        for (var i = 0; i < self2.s.connectingServers.length; i++) {
          if (self2.s.connectingServers[i].equals(this)) {
            self2.s.connectingServers.splice(i, 1);
          }
        }
        if (self2.s.connectingServers.length === 0 && self2.state === CONNECTING) {
          topologyMonitor(self2, { haInterval: 1 });
        }
      };
    }
    function connectServers(self2, servers) {
      self2.s.connectingServers = self2.s.connectingServers.concat(servers);
      var timeoutInterval = 0;
      function connect(server, timeoutInterval2) {
        setTimeout(function() {
          if (self2.s.replicaSetState.update(server)) {
            if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
              self2.ismaster = server.lastIsMaster();
            }
          }
          server.once("close", handleInitialConnectEvent(self2, "close"));
          server.once("timeout", handleInitialConnectEvent(self2, "timeout"));
          server.once("parseError", handleInitialConnectEvent(self2, "parseError"));
          server.once("error", handleInitialConnectEvent(self2, "error"));
          server.once("connect", handleInitialConnectEvent(self2, "connect"));
          server.on("serverOpening", (e) => self2.emit("serverOpening", e));
          server.on("serverDescriptionChanged", (e) => self2.emit("serverDescriptionChanged", e));
          server.on("serverClosed", (e) => self2.emit("serverClosed", e));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          server.connect(self2.s.connectOptions);
        }, timeoutInterval2);
      }
      while (servers.length > 0) {
        connect(servers.shift(), timeoutInterval++);
      }
    }
    function emitSDAMEvent(self2, event, description) {
      if (self2.listeners(event).length > 0) {
        self2.emit(event, description);
      }
    }
    ReplSet.prototype.connect = function(options) {
      var self2 = this;
      this.s.connectOptions = options || {};
      stateTransition(this, CONNECTING);
      var servers = this.s.seedlist.map(function(x) {
        return new Server(Object.assign({}, self2.s.options, x, options, {
          reconnect: false,
          monitoring: false,
          parent: self2
        }));
      });
      if (this.s.options.socketTimeout > 0 && this.s.options.socketTimeout <= this.s.options.haInterval) {
        return self2.emit("error", new MongoError(f("haInterval [%s] MS must be set to less than socketTimeout [%s] MS", this.s.options.haInterval, this.s.options.socketTimeout)));
      }
      emitSDAMEvent(this, "topologyOpening", { topologyId: this.id });
      connectServers(self2, servers);
    };
    ReplSet.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    ReplSet.prototype.destroy = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      let destroyCount = this.s.connectingServers.length + 1;
      const serverDestroyed = () => {
        destroyCount--;
        if (destroyCount > 0) {
          return;
        }
        emitSDAMEvent(this, "topologyClosed", { topologyId: this.id });
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (this.state === DESTROYED) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      stateTransition(this, DESTROYED);
      if (this.haTimeoutId)
        clearTimeout(this.haTimeoutId);
      for (var i = 0; i < this.intervalIds.length; i++) {
        this.intervalIds[i].stop();
      }
      this.intervalIds = [];
      if (destroyCount === 0) {
        serverDestroyed();
        return;
      }
      this.s.replicaSetState.destroy(options, serverDestroyed);
      this.s.connectingServers.forEach(function(x) {
        x.destroy(options, serverDestroyed);
      });
    };
    ReplSet.prototype.unref = function() {
      stateTransition(this, UNREFERENCED);
      this.s.replicaSetState.allServers().forEach(function(x) {
        x.unref();
      });
      clearTimeout(this.haTimeoutId);
    };
    ReplSet.prototype.lastIsMaster = function() {
      if (this.s.options.secondaryOnlyConnectionAllowed && !this.s.replicaSetState.hasPrimary() && this.s.replicaSetState.hasSecondary()) {
        return this.s.replicaSetState.secondaries[0].lastIsMaster();
      }
      return this.s.replicaSetState.primary ? this.s.replicaSetState.primary.lastIsMaster() : this.ismaster;
    };
    ReplSet.prototype.connections = function() {
      var servers = this.s.replicaSetState.allServers();
      var connections = [];
      for (var i = 0; i < servers.length; i++) {
        connections = connections.concat(servers[i].connections());
      }
      return connections;
    };
    ReplSet.prototype.isConnected = function(options) {
      options = options || {};
      if (options.readPreference && options.readPreference.equals(ReadPreference.secondary)) {
        return this.s.replicaSetState.hasSecondary();
      }
      if (options.readPreference && options.readPreference.equals(ReadPreference.primary)) {
        return this.s.replicaSetState.hasPrimary();
      }
      if (options.readPreference && options.readPreference.equals(ReadPreference.primaryPreferred)) {
        return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
      }
      if (options.readPreference && options.readPreference.equals(ReadPreference.secondaryPreferred)) {
        return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
      }
      if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {
        return true;
      }
      return this.s.replicaSetState.hasPrimary();
    };
    ReplSet.prototype.isDestroyed = function() {
      return this.state === DESTROYED;
    };
    var SERVER_SELECTION_TIMEOUT_MS = 1e4;
    var SERVER_SELECTION_INTERVAL_MS = 1e3;
    ReplSet.prototype.selectServer = function(selector, options, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options = {};
      if (typeof options === "function")
        callback = options, options = selector;
      options = options || {};
      let readPreference;
      if (selector instanceof ReadPreference) {
        readPreference = selector;
      } else {
        readPreference = options.readPreference || ReadPreference.primary;
      }
      let lastError;
      const start = now();
      const _selectServer = () => {
        if (calculateDurationInMs(start) >= SERVER_SELECTION_TIMEOUT_MS) {
          if (lastError != null) {
            callback(lastError, null);
          } else {
            callback(new MongoError("Server selection timed out"));
          }
          return;
        }
        const server = this.s.replicaSetState.pickServer(readPreference);
        if (server == null) {
          setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
          return;
        }
        if (!(server instanceof Server)) {
          lastError = server;
          setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
          return;
        }
        if (this.s.debug)
          this.emit("pickedServer", options.readPreference, server);
        callback(null, server);
      };
      _selectServer();
    };
    ReplSet.prototype.getServers = function() {
      return this.s.replicaSetState.allServers();
    };
    function executeWriteOperation(args, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const self2 = args.self;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      if (self2.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      const willRetryWrite = !args.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction() && options.explain === void 0;
      if (!self2.s.replicaSetState.hasPrimary()) {
        if (self2.s.disconnectHandler) {
          return self2.s.disconnectHandler.add(op, ns, ops, options, callback);
        } else if (!willRetryWrite) {
          return callback(new MongoError("no primary server found"));
        }
      }
      const handler = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2)) {
          err = getMMAPError(err);
          return callback(err);
        }
        if (willRetryWrite) {
          const newArgs = Object.assign({}, args, { retrying: true });
          return executeWriteOperation(newArgs, options, callback);
        }
        if (self2.s.replicaSetState.primary) {
          self2.s.replicaSetState.primary.destroy();
          self2.s.replicaSetState.remove(self2.s.replicaSetState.primary, { force: true });
        }
        return callback(err);
      };
      if (callback.operationId) {
        handler.operationId = callback.operationId;
      }
      if (willRetryWrite) {
        options.session.incrementTransactionNumber();
        options.willRetryWrite = willRetryWrite;
      }
      self2.s.replicaSetState.primary[op](ns, ops, options, handler);
    }
    ReplSet.prototype.insert = function(ns, ops, options, callback) {
      executeWriteOperation({ self: this, op: "insert", ns, ops }, options, callback);
    };
    ReplSet.prototype.update = function(ns, ops, options, callback) {
      executeWriteOperation({ self: this, op: "update", ns, ops }, options, callback);
    };
    ReplSet.prototype.remove = function(ns, ops, options, callback) {
      executeWriteOperation({ self: this, op: "remove", ns, ops }, options, callback);
    };
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
    }
    ReplSet.prototype.command = function(ns, cmd, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      if (this.state === DESTROYED)
        return callback(new MongoError(f("topology was destroyed")));
      var self2 = this;
      var readPreference = options.readPreference ? options.readPreference : ReadPreference.primary;
      if (readPreference.preference === "primary" && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
      } else if (readPreference.preference === "secondary" && !this.s.replicaSetState.hasSecondary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
      } else if (readPreference.preference !== "primary" && !this.s.replicaSetState.hasSecondary() && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
      }
      var server = this.s.replicaSetState.pickServer(readPreference);
      if (!(server instanceof Server))
        return callback(server);
      if (self2.s.debug)
        self2.emit("pickedServer", ReadPreference.primary, server);
      if (server == null) {
        return callback(new MongoError(f("no server found that matches the provided readPreference %s", readPreference)));
      }
      const willRetryWrite = !options.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction() && isWriteCommand(cmd);
      const cb = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2)) {
          return callback(err);
        }
        if (willRetryWrite) {
          const newOptions = Object.assign({}, options, { retrying: true });
          return this.command(ns, cmd, newOptions, callback);
        }
        if (this.s.replicaSetState.primary) {
          this.s.replicaSetState.primary.destroy();
          this.s.replicaSetState.remove(this.s.replicaSetState.primary, { force: true });
        }
        return callback(err);
      };
      if (willRetryWrite) {
        options.session.incrementTransactionNumber();
        options.willRetryWrite = willRetryWrite;
      }
      server.command(ns, cmd, options, cb);
    };
    ReplSet.prototype.cursor = function(ns, cmd, options) {
      options = options || {};
      const topology = options.topology || this;
      var FinalCursor = options.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd, options);
    };
    module2.exports = ReplSet;
  }
});

// node_modules/mongodb/lib/core/topologies/mongos.js
var require_mongos = __commonJS({
  "node_modules/mongodb/lib/core/topologies/mongos.js"(exports2, module2) {
    "use strict";
    var inherits2 = require("util").inherits;
    var f = require("util").format;
    var EventEmitter = require("events").EventEmitter;
    var CoreCursor = require_cursor().CoreCursor;
    var Logger = require_logger();
    var retrieveBSON = require_utils5().retrieveBSON;
    var MongoError = require_error().MongoError;
    var Server = require_server();
    var diff = require_shared2().diff;
    var cloneOptions = require_shared2().cloneOptions;
    var SessionMixins = require_shared2().SessionMixins;
    var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
    var relayEvents = require_utils4().relayEvents;
    var BSON2 = retrieveBSON();
    var getMMAPError = require_shared2().getMMAPError;
    var makeClientMetadata = require_utils4().makeClientMetadata;
    var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var UNREFERENCED = "unreferenced";
    var DESTROYING = "destroying";
    var DESTROYED = "destroyed";
    function stateTransition(self2, newState) {
      var legalTransitions = {
        disconnected: [CONNECTING, DESTROYING, DESTROYED, DISCONNECTED],
        connecting: [CONNECTING, DESTROYING, DESTROYED, CONNECTED, DISCONNECTED],
        connected: [CONNECTED, DISCONNECTED, DESTROYING, DESTROYED, UNREFERENCED],
        unreferenced: [UNREFERENCED, DESTROYING, DESTROYED],
        destroyed: [DESTROYED]
      };
      var legalStates = legalTransitions[self2.state];
      if (legalStates && legalStates.indexOf(newState) !== -1) {
        self2.state = newState;
      } else {
        self2.s.logger.error(f("Mongos with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]", self2.id, self2.state, newState, legalStates));
      }
    }
    var id = 1;
    var handlers = ["connect", "close", "error", "timeout", "parseError"];
    var Mongos = function(seedlist, options) {
      options = options || {};
      this.id = id++;
      if (Array.isArray(seedlist)) {
        seedlist = seedlist.reduce((seeds, seed) => {
          if (seeds.find((s) => s.host === seed.host && s.port === seed.port)) {
            return seeds;
          }
          seeds.push(seed);
          return seeds;
        }, []);
      }
      this.s = {
        options: Object.assign({ metadata: makeClientMetadata(options) }, options),
        bson: options.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        Cursor: options.cursorFactory || CoreCursor,
        logger: Logger("Mongos", options),
        seedlist,
        haInterval: options.haInterval ? options.haInterval : 1e4,
        disconnectHandler: options.disconnectHandler,
        index: 0,
        connectOptions: {},
        debug: typeof options.debug === "boolean" ? options.debug : false,
        localThresholdMS: options.localThresholdMS || 15
      };
      if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
        this.s.logger.warn(f("warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts", this.s.options.socketTimeout, this.s.haInterval));
      }
      this.state = DISCONNECTED;
      this.connectingProxies = [];
      this.connectedProxies = [];
      this.disconnectedProxies = [];
      this.index = 0;
      this.haTimeoutId = null;
      this.ismaster = null;
      this.topologyDescription = {
        topologyType: "Unknown",
        servers: []
      };
      this.clusterTime = null;
      EventEmitter.call(this);
    };
    inherits2(Mongos, EventEmitter);
    Object.assign(Mongos.prototype, SessionMixins);
    Object.defineProperty(Mongos.prototype, "type", {
      enumerable: true,
      get: function() {
        return "mongos";
      }
    });
    Object.defineProperty(Mongos.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(Mongos.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        if (!this.ismaster)
          return null;
        return this.ismaster.logicalSessionTimeoutMinutes || null;
      }
    });
    function emitSDAMEvent(self2, event, description) {
      if (self2.listeners(event).length > 0) {
        self2.emit(event, description);
      }
    }
    var SERVER_EVENTS = ["serverDescriptionChanged", "error", "close", "timeout", "parseError"];
    function destroyServer(server, options, callback) {
      options = options || {};
      SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
      server.destroy(options, callback);
    }
    Mongos.prototype.connect = function(options) {
      var self2 = this;
      this.s.connectOptions = options || {};
      stateTransition(this, CONNECTING);
      var servers = this.s.seedlist.map(function(x) {
        const server = new Server(Object.assign({}, self2.s.options, x, options, {
          reconnect: false,
          monitoring: false,
          parent: self2
        }));
        relayEvents(server, self2, ["serverDescriptionChanged"]);
        return server;
      });
      emitSDAMEvent(this, "topologyOpening", { topologyId: this.id });
      connectProxies(self2, servers);
    };
    Mongos.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    function handleEvent(self2) {
      return function() {
        if (self2.state === DESTROYED || self2.state === DESTROYING) {
          return;
        }
        moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, this);
        emitTopologyDescriptionChanged(self2);
        self2.emit("left", "mongos", this);
        self2.emit("serverClosed", {
          topologyId: self2.id,
          address: this.name
        });
      };
    }
    function handleInitialConnectEvent(self2, event) {
      return function() {
        var _this = this;
        if (self2.state === DESTROYED) {
          emitTopologyDescriptionChanged(self2);
          moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, this);
          return this.destroy();
        }
        if (event === "connect") {
          self2.ismaster = _this.lastIsMaster();
          if (self2.ismaster.msg === "isdbgrid") {
            for (let i = 0; i < self2.connectedProxies.length; i++) {
              if (self2.connectedProxies[i].name === _this.name) {
                moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, _this);
                emitTopologyDescriptionChanged(self2);
                _this.destroy();
                return self2.emit("failed", _this);
              }
            }
            for (let i = 0; i < handlers.length; i++) {
              _this.removeAllListeners(handlers[i]);
            }
            _this.on("error", handleEvent(self2, "error"));
            _this.on("close", handleEvent(self2, "close"));
            _this.on("timeout", handleEvent(self2, "timeout"));
            _this.on("parseError", handleEvent(self2, "parseError"));
            moveServerFrom(self2.connectingProxies, self2.connectedProxies, _this);
            self2.emit("joined", "mongos", _this);
          } else {
            if (self2.s.logger.isWarn()) {
              var message = "expected mongos proxy, but found replicaset member mongod for server %s";
              if (!self2.ismaster.hosts) {
                message = "expected mongos proxy, but found standalone mongod for server %s";
              }
              self2.s.logger.warn(f(message, _this.name));
            }
            _this.destroy(true);
            removeProxyFrom(self2.connectingProxies, _this);
            self2.emit("left", "server", _this);
            self2.emit("failed", _this);
          }
        } else {
          moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, this);
          self2.emit("left", "mongos", this);
          self2.emit("failed", this);
        }
        emitTopologyDescriptionChanged(self2);
        if (self2.connectingProxies.length === 0) {
          if (self2.connectedProxies.length > 0 && self2.state === CONNECTING) {
            stateTransition(self2, CONNECTED);
            self2.emit("connect", self2);
            self2.emit("fullsetup", self2);
            self2.emit("all", self2);
          } else if (self2.disconnectedProxies.length === 0) {
            if (self2.s.logger.isWarn()) {
              self2.s.logger.warn(f("no mongos proxies found in seed list, did you mean to connect to a replicaset"));
            }
            return self2.emit("error", new MongoError("no mongos proxies found in seed list"));
          }
          topologyMonitor(self2, { firstConnect: true });
        }
      };
    }
    function connectProxies(self2, servers) {
      self2.connectingProxies = self2.connectingProxies.concat(servers);
      var timeoutInterval = 0;
      function connect(server, timeoutInterval2) {
        setTimeout(function() {
          self2.emit("serverOpening", {
            topologyId: self2.id,
            address: server.name
          });
          emitTopologyDescriptionChanged(self2);
          server.once("close", handleInitialConnectEvent(self2, "close"));
          server.once("timeout", handleInitialConnectEvent(self2, "timeout"));
          server.once("parseError", handleInitialConnectEvent(self2, "parseError"));
          server.once("error", handleInitialConnectEvent(self2, "error"));
          server.once("connect", handleInitialConnectEvent(self2, "connect"));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          server.connect(self2.s.connectOptions);
        }, timeoutInterval2);
      }
      servers.forEach((server) => connect(server, timeoutInterval++));
    }
    function pickProxy(self2, session) {
      const transaction = session && session.transaction;
      if (transaction && transaction.server) {
        if (transaction.server.isConnected()) {
          return transaction.server;
        } else {
          transaction.unpinServer();
        }
      }
      var connectedProxies = self2.connectedProxies.slice(0);
      var lowerBoundLatency = Number.MAX_VALUE;
      for (var i = 0; i < connectedProxies.length; i++) {
        if (connectedProxies[i].lastIsMasterMS < lowerBoundLatency) {
          lowerBoundLatency = connectedProxies[i].lastIsMasterMS;
        }
      }
      connectedProxies = connectedProxies.filter(function(server) {
        if (server.lastIsMasterMS <= lowerBoundLatency + self2.s.localThresholdMS && server.isConnected()) {
          return true;
        }
      });
      let proxy;
      if (connectedProxies.length === 0) {
        proxy = self2.connectedProxies[0];
      } else {
        proxy = connectedProxies[self2.index % connectedProxies.length];
        self2.index = (self2.index + 1) % connectedProxies.length;
      }
      if (transaction && transaction.isActive && proxy && proxy.isConnected()) {
        transaction.pinServer(proxy);
      }
      return proxy;
    }
    function moveServerFrom(from, to, proxy) {
      for (var i = 0; i < from.length; i++) {
        if (from[i].name === proxy.name) {
          from.splice(i, 1);
        }
      }
      for (i = 0; i < to.length; i++) {
        if (to[i].name === proxy.name) {
          to.splice(i, 1);
        }
      }
      to.push(proxy);
    }
    function removeProxyFrom(from, proxy) {
      for (var i = 0; i < from.length; i++) {
        if (from[i].name === proxy.name) {
          from.splice(i, 1);
        }
      }
    }
    function reconnectProxies(self2, proxies, callback) {
      var count = proxies.length;
      var _handleEvent = function(self3, event) {
        return function() {
          var _self = this;
          count = count - 1;
          if (self3.state === DESTROYED || self3.state === DESTROYING || self3.state === UNREFERENCED) {
            moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
            return this.destroy();
          }
          if (event === "connect") {
            if (self3.state === DESTROYED || self3.state === DESTROYING || self3.state === UNREFERENCED) {
              moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
              return _self.destroy();
            }
            for (var i2 = 0; i2 < handlers.length; i2++) {
              _self.removeAllListeners(handlers[i2]);
            }
            _self.on("error", handleEvent(self3, "error"));
            _self.on("close", handleEvent(self3, "close"));
            _self.on("timeout", handleEvent(self3, "timeout"));
            _self.on("parseError", handleEvent(self3, "parseError"));
            moveServerFrom(self3.connectingProxies, self3.connectedProxies, _self);
            emitTopologyDescriptionChanged(self3);
            self3.emit("joined", "mongos", _self);
          } else {
            moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
            this.destroy();
          }
          if (count === 0) {
            callback();
          }
        };
      };
      if (count === 0) {
        return callback();
      }
      function execute(_server, i2) {
        setTimeout(function() {
          if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
            return;
          }
          var server = new Server(Object.assign({}, self2.s.options, {
            host: _server.name.split(":")[0],
            port: parseInt(_server.name.split(":")[1], 10),
            reconnect: false,
            monitoring: false,
            parent: self2
          }));
          destroyServer(_server, { force: true });
          removeProxyFrom(self2.disconnectedProxies, _server);
          relayEvents(server, self2, ["serverDescriptionChanged"]);
          self2.emit("serverOpening", {
            topologyId: server.s.topologyId !== -1 ? server.s.topologyId : self2.id,
            address: server.name
          });
          server.once("connect", _handleEvent(self2, "connect"));
          server.once("close", _handleEvent(self2, "close"));
          server.once("timeout", _handleEvent(self2, "timeout"));
          server.once("error", _handleEvent(self2, "error"));
          server.once("parseError", _handleEvent(self2, "parseError"));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          self2.connectingProxies.push(server);
          server.connect(self2.s.connectOptions);
        }, i2);
      }
      for (var i = 0; i < proxies.length; i++) {
        execute(proxies[i], i);
      }
    }
    function topologyMonitor(self2, options) {
      options = options || {};
      if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
        return;
      }
      self2.haTimeoutId = setTimeout(function() {
        if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
          return;
        }
        if (self2.isConnected() && self2.s.disconnectHandler) {
          self2.s.disconnectHandler.execute();
        }
        var proxies = self2.connectedProxies.slice(0);
        var count = proxies.length;
        function pingServer(_self, _server, cb) {
          var start = new Date().getTime();
          emitSDAMEvent(self2, "serverHeartbeatStarted", { connectionId: _server.name });
          _server.command("admin.$cmd", {
            ismaster: true
          }, {
            monitoring: true,
            socketTimeout: self2.s.options.connectionTimeout || 2e3
          }, function(err, r) {
            if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
              moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, _server);
              _server.destroy();
              return cb(err, r);
            }
            var latencyMS = new Date().getTime() - start;
            if (err) {
              emitSDAMEvent(self2, "serverHeartbeatFailed", {
                durationMS: latencyMS,
                failure: err,
                connectionId: _server.name
              });
              moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, _server);
            } else {
              _server.ismaster = r.result;
              _server.lastIsMasterMS = latencyMS;
              emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
                durationMS: latencyMS,
                reply: r.result,
                connectionId: _server.name
              });
            }
            cb(err, r);
          });
        }
        if (proxies.length === 0) {
          if (self2.listeners("close").length > 0 && self2.state === CONNECTING) {
            self2.emit("error", new MongoError("no mongos proxy available"));
          } else {
            self2.emit("close", self2);
          }
          return reconnectProxies(self2, self2.disconnectedProxies, function() {
            if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
              return;
            }
            if (self2.state === CONNECTING && options.firstConnect) {
              self2.emit("connect", self2);
              self2.emit("fullsetup", self2);
              self2.emit("all", self2);
            } else if (self2.isConnected()) {
              self2.emit("reconnect", self2);
            } else if (!self2.isConnected() && self2.listeners("close").length > 0) {
              self2.emit("close", self2);
            }
            topologyMonitor(self2);
          });
        }
        for (var i = 0; i < proxies.length; i++) {
          pingServer(self2, proxies[i], function() {
            count = count - 1;
            if (count === 0) {
              if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
                return;
              }
              reconnectProxies(self2, self2.disconnectedProxies, function() {
                if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
                  return;
                }
                topologyMonitor(self2);
              });
            }
          });
        }
      }, self2.s.haInterval);
    }
    Mongos.prototype.lastIsMaster = function() {
      return this.ismaster;
    };
    Mongos.prototype.unref = function() {
      stateTransition(this, UNREFERENCED);
      var proxies = this.connectedProxies.concat(this.connectingProxies);
      proxies.forEach(function(x) {
        x.unref();
      });
      clearTimeout(this.haTimeoutId);
    };
    Mongos.prototype.destroy = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      stateTransition(this, DESTROYING);
      if (this.haTimeoutId) {
        clearTimeout(this.haTimeoutId);
      }
      const proxies = this.connectedProxies.concat(this.connectingProxies);
      let serverCount = proxies.length;
      const serverDestroyed = () => {
        serverCount--;
        if (serverCount > 0) {
          return;
        }
        emitTopologyDescriptionChanged(this);
        emitSDAMEvent(this, "topologyClosed", { topologyId: this.id });
        stateTransition(this, DESTROYED);
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (serverCount === 0) {
        serverDestroyed();
        return;
      }
      proxies.forEach((server) => {
        this.emit("serverClosed", {
          topologyId: this.id,
          address: server.name
        });
        destroyServer(server, options, serverDestroyed);
        moveServerFrom(this.connectedProxies, this.disconnectedProxies, server);
      });
    };
    Mongos.prototype.isConnected = function() {
      return this.connectedProxies.length > 0;
    };
    Mongos.prototype.isDestroyed = function() {
      return this.state === DESTROYED;
    };
    function executeWriteOperation(args, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const self2 = args.self;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      let server = pickProxy(self2, options.session);
      if (!server)
        return callback(new MongoError("no mongos proxy available"));
      const willRetryWrite = !args.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction() && options.explain === void 0;
      const handler = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2) || !willRetryWrite) {
          err = getMMAPError(err);
          return callback(err);
        }
        server = pickProxy(self2, options.session);
        if (!server) {
          return callback(err);
        }
        const newArgs = Object.assign({}, args, { retrying: true });
        return executeWriteOperation(newArgs, options, callback);
      };
      if (callback.operationId) {
        handler.operationId = callback.operationId;
      }
      if (willRetryWrite) {
        options.session.incrementTransactionNumber();
        options.willRetryWrite = willRetryWrite;
      }
      server[op](ns, ops, options, handler);
    }
    Mongos.prototype.insert = function(ns, ops, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("insert", ns, ops, options, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({ self: this, op: "insert", ns, ops }, options, callback);
    };
    Mongos.prototype.update = function(ns, ops, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("update", ns, ops, options, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({ self: this, op: "update", ns, ops }, options, callback);
    };
    Mongos.prototype.remove = function(ns, ops, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("remove", ns, ops, options, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({ self: this, op: "remove", ns, ops }, options, callback);
    };
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
    }
    Mongos.prototype.command = function(ns, cmd, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      var self2 = this;
      var server = pickProxy(self2, options.session);
      if ((server == null || !server.isConnected()) && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
      }
      if (server == null) {
        return callback(new MongoError("no mongos proxy available"));
      }
      var clonedOptions = cloneOptions(options);
      clonedOptions.topology = self2;
      const willRetryWrite = !options.retrying && options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction() && isWriteCommand(cmd);
      const cb = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2)) {
          return callback(err);
        }
        if (willRetryWrite) {
          const newOptions = Object.assign({}, clonedOptions, { retrying: true });
          return this.command(ns, cmd, newOptions, callback);
        }
        return callback(err);
      };
      if (willRetryWrite) {
        clonedOptions.session.incrementTransactionNumber();
        clonedOptions.willRetryWrite = willRetryWrite;
      }
      server.command(ns, cmd, clonedOptions, cb);
    };
    Mongos.prototype.cursor = function(ns, cmd, options) {
      options = options || {};
      const topology = options.topology || this;
      var FinalCursor = options.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd, options);
    };
    Mongos.prototype.selectServer = function(selector, options, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options = {};
      if (typeof options === "function")
        callback = options, options = selector, selector = void 0;
      options = options || {};
      const server = pickProxy(this, options.session);
      if (server == null) {
        callback(new MongoError("server selection failed"));
        return;
      }
      if (this.s.debug)
        this.emit("pickedServer", null, server);
      callback(null, server);
    };
    Mongos.prototype.connections = function() {
      var connections = [];
      for (var i = 0; i < this.connectedProxies.length; i++) {
        connections = connections.concat(this.connectedProxies[i].connections());
      }
      return connections;
    };
    function emitTopologyDescriptionChanged(self2) {
      if (self2.listeners("topologyDescriptionChanged").length > 0) {
        var topology = "Unknown";
        if (self2.connectedProxies.length > 0) {
          topology = "Sharded";
        }
        var description = {
          topologyType: topology,
          servers: []
        };
        var proxies = self2.disconnectedProxies.concat(self2.connectingProxies);
        description.servers = description.servers.concat(proxies.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "Unknown";
          return description2;
        }));
        description.servers = description.servers.concat(self2.connectedProxies.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "Mongos";
          return description2;
        }));
        var diffResult = diff(self2.topologyDescription, description);
        var result = {
          topologyId: self2.id,
          previousDescription: self2.topologyDescription,
          newDescription: description,
          diff: diffResult
        };
        if (diffResult.servers.length > 0) {
          self2.emit("topologyDescriptionChanged", result);
        }
        self2.topologyDescription = description;
      }
    }
    module2.exports = Mongos;
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports2, module2) {
    "use strict";
    function Denque(array, options) {
      var options = options || {};
      this._head = 0;
      this._tail = 0;
      this._capacity = options.capacity;
      this._capacityMask = 3;
      this._list = new Array(4);
      if (Array.isArray(array)) {
        this._fromArray(array);
      }
    }
    Denque.prototype.peekAt = function peekAt(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len)
        return void 0;
      if (i < 0)
        i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    };
    Denque.prototype.get = function get(i) {
      return this.peekAt(i);
    };
    Denque.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque.prototype, "length", {
      get: function length() {
        return this.size();
      }
    });
    Denque.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.unshift = function unshift(item) {
      if (item === void 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.push = function push(item) {
      if (item === void 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.removeOne = function removeOne(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size)
        return void 0;
      if (i < 0)
        i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index < size / 2) {
        for (k = index; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque.prototype.remove = function remove(index, count) {
      var i = index;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1)
        return void 0;
      if (i < 0)
        i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size)
        count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index + count + len & this._capacityMask;
        for (k = index; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index < 0)
          this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque.prototype.splice = function splice(index, count) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0)
        i += size;
      if (i > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    };
    Denque.prototype.clear = function clear() {
      this._head = 0;
      this._tail = 0;
    };
    Denque.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque.prototype._fromArray = function _fromArray(array) {
      for (var i = 0; i < array.length; i++)
        this.push(array[i]);
    };
    Denque.prototype._copyArray = function _copyArray(fullCopy) {
      var newArray = [];
      var list = this._list;
      var len = list.length;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < len; i++)
          newArray.push(list[i]);
        for (i = 0; i < this._tail; i++)
          newArray.push(list[i]);
      } else {
        for (i = this._head; i < this._tail; i++)
          newArray.push(list[i]);
      }
      return newArray;
    };
    Denque.prototype._growArray = function _growArray() {
      if (this._head) {
        this._list = this._copyArray(true);
        this._head = 0;
      }
      this._tail = this._list.length;
      this._list.length <<= 1;
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    module2.exports = Denque;
  }
});

// node_modules/mongodb/lib/core/sdam/events.js
var require_events = __commonJS({
  "node_modules/mongodb/lib/core/sdam/events.js"(exports2, module2) {
    "use strict";
    var ServerDescriptionChangedEvent = class {
      constructor(topologyId, address, previousDescription, newDescription) {
        Object.assign(this, { topologyId, address, previousDescription, newDescription });
      }
    };
    var ServerOpeningEvent = class {
      constructor(topologyId, address) {
        Object.assign(this, { topologyId, address });
      }
    };
    var ServerClosedEvent = class {
      constructor(topologyId, address) {
        Object.assign(this, { topologyId, address });
      }
    };
    var TopologyDescriptionChangedEvent = class {
      constructor(topologyId, previousDescription, newDescription) {
        Object.assign(this, { topologyId, previousDescription, newDescription });
      }
    };
    var TopologyOpeningEvent = class {
      constructor(topologyId) {
        Object.assign(this, { topologyId });
      }
    };
    var TopologyClosedEvent = class {
      constructor(topologyId) {
        Object.assign(this, { topologyId });
      }
    };
    var ServerHeartbeatStartedEvent = class {
      constructor(connectionId) {
        Object.assign(this, { connectionId });
      }
    };
    var ServerHeartbeatSucceededEvent = class {
      constructor(duration, reply, connectionId) {
        Object.assign(this, { connectionId, duration, reply });
      }
    };
    var ServerHeartbeatFailedEvent = class {
      constructor(duration, failure, connectionId) {
        Object.assign(this, { connectionId, duration, failure });
      }
    };
    module2.exports = {
      ServerDescriptionChangedEvent,
      ServerOpeningEvent,
      ServerClosedEvent,
      TopologyDescriptionChangedEvent,
      TopologyOpeningEvent,
      TopologyClosedEvent,
      ServerHeartbeatStartedEvent,
      ServerHeartbeatSucceededEvent,
      ServerHeartbeatFailedEvent
    };
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError2(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError2;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive2(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive2;
    exports2.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret2 = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret2;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret2 = "" + p.data;
        while (p = p.next) {
          ret2 += s + p.data;
        }
        return ret2;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret2 = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret2, i);
          i += p.data.length;
          p = p.next;
        }
        return ret2;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node5 = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node5()
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy2();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy2();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require("string_decoder/").StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret2 = dest.write(chunk);
        if (ret2 === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret2 = _this.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.head.data;
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret2;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret2;
      if (n < list.head.data.length) {
        ret2 = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret2 = list.shift();
      } else {
        ret2 = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret2;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret2 = p.data;
      n -= ret2.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret2 += str;
        else
          ret2 += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function copyFromBuffer(n, list) {
      var ret2 = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret2);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret2, ret2.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs2 = this._readableState;
      rs2.reading = false;
      if (rs2.needReadable || rs2.length < rs2.highWaterMark) {
        this._read(rs2.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs2 = this._readableState;
        if (ts.needTransform || rs2.needReadable || rs2.length < rs2.highWaterMark)
          this._read(rs2.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
    }
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports2, module2) {
    "use strict";
    var DuplexStream = require_readable().Duplex;
    var util = require("util");
    var Buffer2 = require_safe_buffer().Buffer;
    function BufferList(callback) {
      if (!(this instanceof BufferList))
        return new BufferList(callback);
      this._bufs = [];
      this.length = 0;
      if (typeof callback == "function") {
        this._callback = callback;
        var piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
      } else {
        this.append(callback);
      }
      DuplexStream.call(this);
    }
    util.inherits(BufferList, DuplexStream);
    BufferList.prototype._offset = function _offset(offset) {
      var tot = 0, i = 0, _t;
      if (offset === 0)
        return [0, 0];
      for (; i < this._bufs.length; i++) {
        _t = tot + this._bufs[i].length;
        if (offset < _t || i == this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      var bufferId = blOffset[0];
      var offset = blOffset[1];
      for (var i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.append = function append(buf) {
      var i = 0;
      if (Buffer2.isBuffer(buf)) {
        this._appendBuffer(buf);
      } else if (Array.isArray(buf)) {
        for (; i < buf.length; i++)
          this.append(buf[i]);
      } else if (buf instanceof BufferList) {
        for (; i < buf._bufs.length; i++)
          this.append(buf._bufs[i]);
      } else if (buf != null) {
        if (typeof buf == "number")
          buf = buf.toString();
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback == "function")
        callback();
    };
    BufferList.prototype._read = function _read(size) {
      if (!this.length)
        return this.push(null);
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferList.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferList.prototype.get = function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      var offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start == "number" && start < 0)
        start += this.length;
      if (typeof end == "number" && end < 0)
        end += this.length;
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart != "number" || srcStart < 0)
        srcStart = 0;
      if (typeof srcEnd != "number" || srcEnd > this.length)
        srcEnd = this.length;
      if (srcStart >= this.length)
        return dst || Buffer2.alloc(0);
      if (srcEnd <= 0)
        return dst || Buffer2.alloc(0);
      var copy2 = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes = len, bufoff = copy2 && dstStart || 0, start = off[1], l, i;
      if (srcStart === 0 && srcEnd == this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2)
        dst = Buffer2.allocUnsafe(len);
      for (i = off[0]; i < this._bufs.length; i++) {
        l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start)
          start = 0;
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0)
        start += this.length;
      if (end < 0)
        end += this.length;
      if (start === end) {
        return new BufferList();
      }
      var startOffset = this._offset(start), endOffset = this._offset(end), buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] == 0)
        buffers.pop();
      else
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      if (startOffset[1] != 0)
        buffers[0] = buffers[0].slice(startOffset[1]);
      return new BufferList(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      var i = 0, copy = new BufferList();
      for (; i < this._bufs.length; i++)
        copy.append(this._bufs[i]);
      return copy;
    };
    BufferList.prototype.destroy = function destroy() {
      this._bufs.length = 0;
      this.length = 0;
      this.push(null);
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (search instanceof BufferList) {
        search = search.slice();
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      var blOffset = this._offset(offset);
      var blIndex = blOffset[0];
      var buffOffset = blOffset[1];
      for (blIndex; blIndex < this._bufs.length; blIndex++) {
        var buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          var availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            var nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            var revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (var searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      var methods = {
        "readDoubleBE": 8,
        "readDoubleLE": 8,
        "readFloatBE": 4,
        "readFloatLE": 4,
        "readInt32BE": 4,
        "readInt32LE": 4,
        "readUInt32BE": 4,
        "readUInt32LE": 4,
        "readInt16BE": 2,
        "readInt16LE": 2,
        "readUInt16BE": 2,
        "readUInt16LE": 2,
        "readInt8": 1,
        "readUInt8": 1,
        "readIntBE": null,
        "readIntLE": null,
        "readUIntBE": null,
        "readUIntLE": null
      };
      for (var m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    module2.exports = BufferList;
  }
});

// node_modules/mongodb/lib/cmap/message_stream.js
var require_message_stream = __commonJS({
  "node_modules/mongodb/lib/cmap/message_stream.js"(exports2, module2) {
    "use strict";
    var Duplex = require("stream").Duplex;
    var BufferList = require_bl();
    var MongoParseError = require_error().MongoParseError;
    var decompress = require_compression().decompress;
    var Response = require_commands().Response;
    var BinMsg = require_msg().BinMsg;
    var MongoError = require_error().MongoError;
    var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
    var OP_MSG = require_shared().opcodes.OP_MSG;
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
    var opcodes = require_shared().opcodes;
    var compress = require_compression().compress;
    var compressorIDs = require_compression().compressorIDs;
    var uncompressibleCommands = require_compression().uncompressibleCommands;
    var Msg = require_msg().Msg;
    var kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;
    var kBuffer = Symbol("buffer");
    var MessageStream = class extends Duplex {
      constructor(options) {
        options = options || {};
        super(options);
        this.bson = options.bson;
        this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;
        this[kBuffer] = new BufferList();
      }
      _write(chunk, _, callback) {
        const buffer = this[kBuffer];
        buffer.append(chunk);
        processIncomingData(this, callback);
      }
      _read() {
        return;
      }
      writeCommand(command, operationDescription) {
        const shouldCompress = operationDescription && !!operationDescription.agreedCompressor;
        if (!shouldCompress || !canCompress(command)) {
          const data = command.toBin();
          this.push(Array.isArray(data) ? Buffer.concat(data) : data);
          return;
        }
        const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());
        const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
        const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
        compress({ options: operationDescription }, messageToBeCompressed, (err, compressedMessage) => {
          if (err) {
            operationDescription.cb(err, null);
            return;
          }
          const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
          msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
          msgHeader.writeInt32LE(command.requestId, 4);
          msgHeader.writeInt32LE(0, 8);
          msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
          const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
          compressionDetails.writeInt32LE(originalCommandOpCode, 0);
          compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
          compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8);
          this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));
        });
      }
    };
    function canCompress(command) {
      const commandDoc = command instanceof Msg ? command.command : command.query;
      const commandName = Object.keys(commandDoc)[0];
      return !uncompressibleCommands.has(commandName);
    }
    function processIncomingData(stream, callback) {
      const buffer = stream[kBuffer];
      if (buffer.length < 4) {
        callback();
        return;
      }
      const sizeOfMessage = buffer.readInt32LE(0);
      if (sizeOfMessage < 0) {
        callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));
        return;
      }
      if (sizeOfMessage > stream.maxBsonMessageSize) {
        callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));
        return;
      }
      if (sizeOfMessage > buffer.length) {
        callback();
        return;
      }
      const message = buffer.slice(0, sizeOfMessage);
      buffer.consume(sizeOfMessage);
      const messageHeader = {
        length: message.readInt32LE(0),
        requestId: message.readInt32LE(4),
        responseTo: message.readInt32LE(8),
        opCode: message.readInt32LE(12)
      };
      let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;
      const responseOptions = stream.responseOptions;
      if (messageHeader.opCode !== OP_COMPRESSED) {
        const messageBody = message.slice(MESSAGE_HEADER_SIZE);
        stream.emit("message", new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));
        if (buffer.length >= 4) {
          processIncomingData(stream, callback);
        } else {
          callback();
        }
        return;
      }
      messageHeader.fromCompressed = true;
      messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);
      messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);
      const compressorID = message[MESSAGE_HEADER_SIZE + 8];
      const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
      ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;
      decompress(compressorID, compressedBuffer, (err, messageBody) => {
        if (err) {
          callback(err);
          return;
        }
        if (messageBody.length !== messageHeader.length) {
          callback(new MongoError("Decompressing a compressed message from the server failed. The message is corrupt."));
          return;
        }
        stream.emit("message", new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));
        if (buffer.length >= 4) {
          processIncomingData(stream, callback);
        } else {
          callback();
        }
      });
    }
    module2.exports = MessageStream;
  }
});

// node_modules/mongodb/lib/cmap/stream_description.js
var require_stream_description = __commonJS({
  "node_modules/mongodb/lib/cmap/stream_description.js"(exports2, module2) {
    "use strict";
    var parseServerType = require_server_description().parseServerType;
    var RESPONSE_FIELDS = [
      "minWireVersion",
      "maxWireVersion",
      "maxBsonObjectSize",
      "maxMessageSizeBytes",
      "maxWriteBatchSize",
      "__nodejs_mock_server__"
    ];
    var StreamDescription = class {
      constructor(address, options) {
        this.address = address;
        this.type = parseServerType(null);
        this.minWireVersion = void 0;
        this.maxWireVersion = void 0;
        this.maxBsonObjectSize = 16777216;
        this.maxMessageSizeBytes = 48e6;
        this.maxWriteBatchSize = 1e5;
        this.compressors = options && options.compression && Array.isArray(options.compression.compressors) ? options.compression.compressors : [];
      }
      receiveResponse(response) {
        this.type = parseServerType(response);
        RESPONSE_FIELDS.forEach((field) => {
          if (typeof response[field] !== "undefined") {
            this[field] = response[field];
          }
        });
        if (response.compression) {
          this.compressor = this.compressors.filter((c) => response.compression.indexOf(c) !== -1)[0];
        }
      }
    };
    module2.exports = {
      StreamDescription
    };
  }
});

// node_modules/mongodb/lib/cmap/connection.js
var require_connection2 = __commonJS({
  "node_modules/mongodb/lib/cmap/connection.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var MessageStream = require_message_stream();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var CommandResult = require_command_result();
    var StreamDescription = require_stream_description().StreamDescription;
    var wp = require_wireprotocol();
    var apm = require_apm();
    var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
    var uuidV4 = require_utils4().uuidV4;
    var now = require_utils6().now;
    var calculateDurationInMs = require_utils6().calculateDurationInMs;
    var kStream = Symbol("stream");
    var kQueue = Symbol("queue");
    var kMessageStream = Symbol("messageStream");
    var kGeneration = Symbol("generation");
    var kLastUseTime = Symbol("lastUseTime");
    var kClusterTime = Symbol("clusterTime");
    var kDescription = Symbol("description");
    var kIsMaster = Symbol("ismaster");
    var kAutoEncrypter = Symbol("autoEncrypter");
    var Connection = class extends EventEmitter {
      constructor(stream, options) {
        super(options);
        this.id = options.id;
        this.address = streamIdentifier(stream);
        this.bson = options.bson;
        this.socketTimeout = typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
        this.host = options.host || "localhost";
        this.port = options.port || 27017;
        this.monitorCommands = typeof options.monitorCommands === "boolean" ? options.monitorCommands : false;
        this.closed = false;
        this.destroyed = false;
        this[kDescription] = new StreamDescription(this.address, options);
        this[kGeneration] = options.generation;
        this[kLastUseTime] = now();
        if (options.autoEncrypter) {
          this[kAutoEncrypter] = options.autoEncrypter;
        }
        this[kQueue] = new Map();
        this[kMessageStream] = new MessageStream(options);
        this[kMessageStream].on("message", messageHandler(this));
        this[kStream] = stream;
        stream.on("error", () => {
        });
        this[kMessageStream].on("error", (error) => this.handleIssue({ destroy: error }));
        stream.on("close", () => this.handleIssue({ isClose: true }));
        stream.on("timeout", () => this.handleIssue({ isTimeout: true, destroy: true }));
        stream.pipe(this[kMessageStream]);
        this[kMessageStream].pipe(stream);
      }
      get description() {
        return this[kDescription];
      }
      get ismaster() {
        return this[kIsMaster];
      }
      set ismaster(response) {
        this[kDescription].receiveResponse(response);
        this[kIsMaster] = response;
      }
      get generation() {
        return this[kGeneration] || 0;
      }
      get idleTime() {
        return calculateDurationInMs(this[kLastUseTime]);
      }
      get clusterTime() {
        return this[kClusterTime];
      }
      get stream() {
        return this[kStream];
      }
      markAvailable() {
        this[kLastUseTime] = now();
      }
      handleIssue(issue) {
        if (this.closed) {
          return;
        }
        if (issue.destroy) {
          this[kStream].destroy(typeof issue.destroy === "boolean" ? void 0 : issue.destroy);
        }
        this.closed = true;
        for (const idAndOp of this[kQueue]) {
          const op = idAndOp[1];
          if (issue.isTimeout) {
            op.cb(new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {
              beforeHandshake: this.ismaster == null
            }));
          } else if (issue.isClose) {
            op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`));
          } else {
            op.cb(typeof issue.destroy === "boolean" ? void 0 : issue.destroy);
          }
        }
        this[kQueue].clear();
        this.emit("close");
      }
      destroy(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = Object.assign({ force: false }, options);
        if (this[kStream] == null || this.destroyed) {
          this.destroyed = true;
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        if (options.force) {
          this[kStream].destroy();
          this.destroyed = true;
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        this[kStream].end((err) => {
          this.destroyed = true;
          if (typeof callback === "function") {
            callback(err);
          }
        });
      }
      command(ns, cmd, options, callback) {
        wp.command(makeServerTrampoline(this), ns, cmd, options, callback);
      }
      query(ns, cmd, cursorState, options, callback) {
        wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);
      }
      getMore(ns, cursorState, batchSize, options, callback) {
        wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);
      }
      killCursors(ns, cursorState, callback) {
        wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);
      }
      insert(ns, ops, options, callback) {
        wp.insert(makeServerTrampoline(this), ns, ops, options, callback);
      }
      update(ns, ops, options, callback) {
        wp.update(makeServerTrampoline(this), ns, ops, options, callback);
      }
      remove(ns, ops, options, callback) {
        wp.remove(makeServerTrampoline(this), ns, ops, options, callback);
      }
    };
    function makeServerTrampoline(connection) {
      const server = {
        description: connection.description,
        clusterTime: connection[kClusterTime],
        s: {
          bson: connection.bson,
          pool: { write: write.bind(connection), isConnected: () => true }
        }
      };
      if (connection[kAutoEncrypter]) {
        server.autoEncrypter = connection[kAutoEncrypter];
      }
      return server;
    }
    function messageHandler(conn) {
      return function messageHandler2(message) {
        conn.emit("message", message);
        if (!conn[kQueue].has(message.responseTo)) {
          return;
        }
        const operationDescription = conn[kQueue].get(message.responseTo);
        const callback = operationDescription.cb;
        conn[kQueue].delete(message.responseTo);
        if (message.moreToCome) {
          conn[kQueue].set(message.requestId, operationDescription);
        } else if (operationDescription.socketTimeoutOverride) {
          conn[kStream].setTimeout(conn.socketTimeout);
        }
        try {
          message.parse(operationDescription);
        } catch (err) {
          callback(new MongoError(err));
          return;
        }
        if (message.documents[0]) {
          const document2 = message.documents[0];
          const session = operationDescription.session;
          if (session) {
            updateSessionFromResponse(session, document2);
          }
          if (document2.$clusterTime) {
            conn[kClusterTime] = document2.$clusterTime;
            conn.emit("clusterTimeReceived", document2.$clusterTime);
          }
          if (operationDescription.command) {
            if (document2.writeConcernError) {
              callback(new MongoWriteConcernError(document2.writeConcernError, document2));
              return;
            }
            if (document2.ok === 0 || document2.$err || document2.errmsg || document2.code) {
              callback(new MongoError(document2));
              return;
            }
          }
        }
        callback(void 0, new CommandResult(operationDescription.fullResult ? message : message.documents[0], conn, message));
      };
    }
    function streamIdentifier(stream) {
      if (typeof stream.address === "function") {
        return `${stream.remoteAddress}:${stream.remotePort}`;
      }
      return uuidV4().toString("hex");
    }
    function write(command, options, callback) {
      if (typeof options === "function") {
        callback = options;
      }
      options = options || {};
      const operationDescription = {
        requestId: command.requestId,
        cb: callback,
        session: options.session,
        fullResult: typeof options.fullResult === "boolean" ? options.fullResult : false,
        noResponse: typeof options.noResponse === "boolean" ? options.noResponse : false,
        documentsReturnedIn: options.documentsReturnedIn,
        command: !!options.command,
        promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
        promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
        promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false,
        bsonRegExp: typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : false,
        raw: typeof options.raw === "boolean" ? options.raw : false
      };
      if (this[kDescription] && this[kDescription].compressor) {
        operationDescription.agreedCompressor = this[kDescription].compressor;
        if (this[kDescription].zlibCompressionLevel) {
          operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;
        }
      }
      if (typeof options.socketTimeout === "number") {
        operationDescription.socketTimeoutOverride = true;
        this[kStream].setTimeout(options.socketTimeout);
      }
      if (this.monitorCommands) {
        this.emit("commandStarted", new apm.CommandStartedEvent(this, command));
        operationDescription.started = now();
        operationDescription.cb = (err, reply) => {
          if (err) {
            this.emit("commandFailed", new apm.CommandFailedEvent(this, command, err, operationDescription.started));
          } else {
            if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
              this.emit("commandFailed", new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started));
            } else {
              this.emit("commandSucceeded", new apm.CommandSucceededEvent(this, command, reply, operationDescription.started));
            }
          }
          if (typeof callback === "function") {
            callback(err, reply);
          }
        };
      }
      if (!operationDescription.noResponse) {
        this[kQueue].set(operationDescription.requestId, operationDescription);
      }
      try {
        this[kMessageStream].writeCommand(command, operationDescription);
      } catch (e) {
        if (!operationDescription.noResponse) {
          this[kQueue].delete(operationDescription.requestId);
          operationDescription.cb(e);
          return;
        }
      }
      if (operationDescription.noResponse) {
        operationDescription.cb();
      }
    }
    module2.exports = {
      Connection
    };
  }
});

// node_modules/mongodb/lib/cmap/errors.js
var require_errors = __commonJS({
  "node_modules/mongodb/lib/cmap/errors.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var PoolClosedError = class extends MongoError {
      constructor(pool) {
        super("Attempted to check out a connection from closed connection pool");
        this.name = "MongoPoolClosedError";
        this.address = pool.address;
      }
    };
    var WaitQueueTimeoutError = class extends MongoError {
      constructor(pool) {
        super("Timed out while checking out a connection from connection pool");
        this.name = "MongoWaitQueueTimeoutError";
        this.address = pool.address;
      }
    };
    module2.exports = {
      PoolClosedError,
      WaitQueueTimeoutError
    };
  }
});

// node_modules/mongodb/lib/cmap/events.js
var require_events2 = __commonJS({
  "node_modules/mongodb/lib/cmap/events.js"(exports2, module2) {
    "use strict";
    var ConnectionPoolMonitoringEvent = class {
      constructor(pool) {
        this.time = new Date();
        this.address = pool.address;
      }
    };
    var ConnectionPoolCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
        this.options = pool.options;
      }
    };
    var ConnectionPoolClosedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var ConnectionCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionReadyEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionClosedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection, reason) {
        super(pool);
        this.connectionId = connection.id;
        this.reason = reason || "unknown";
      }
    };
    var ConnectionCheckOutStartedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var ConnectionCheckOutFailedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, reason) {
        super(pool);
        this.reason = reason;
      }
    };
    var ConnectionCheckedOutEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionCheckedInEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionPoolClearedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var CMAP_EVENT_NAMES = [
      "connectionPoolCreated",
      "connectionPoolClosed",
      "connectionCreated",
      "connectionReady",
      "connectionClosed",
      "connectionCheckOutStarted",
      "connectionCheckOutFailed",
      "connectionCheckedOut",
      "connectionCheckedIn",
      "connectionPoolCleared"
    ];
    module2.exports = {
      CMAP_EVENT_NAMES,
      ConnectionPoolCreatedEvent,
      ConnectionPoolClosedEvent,
      ConnectionCreatedEvent,
      ConnectionReadyEvent,
      ConnectionClosedEvent,
      ConnectionCheckOutStartedEvent,
      ConnectionCheckOutFailedEvent,
      ConnectionCheckedOutEvent,
      ConnectionCheckedInEvent,
      ConnectionPoolClearedEvent
    };
  }
});

// node_modules/mongodb/lib/cmap/connection_pool.js
var require_connection_pool = __commonJS({
  "node_modules/mongodb/lib/cmap/connection_pool.js"(exports2, module2) {
    "use strict";
    var Denque = require_denque();
    var EventEmitter = require("events").EventEmitter;
    var Logger = require_logger();
    var makeCounter = require_utils6().makeCounter;
    var MongoError = require_error().MongoError;
    var Connection = require_connection2().Connection;
    var eachAsync = require_utils4().eachAsync;
    var connect = require_connect();
    var relayEvents = require_utils4().relayEvents;
    var errors = require_errors();
    var PoolClosedError = errors.PoolClosedError;
    var WaitQueueTimeoutError = errors.WaitQueueTimeoutError;
    var events = require_events2();
    var ConnectionPoolCreatedEvent = events.ConnectionPoolCreatedEvent;
    var ConnectionPoolClosedEvent = events.ConnectionPoolClosedEvent;
    var ConnectionCreatedEvent = events.ConnectionCreatedEvent;
    var ConnectionReadyEvent = events.ConnectionReadyEvent;
    var ConnectionClosedEvent = events.ConnectionClosedEvent;
    var ConnectionCheckOutStartedEvent = events.ConnectionCheckOutStartedEvent;
    var ConnectionCheckOutFailedEvent = events.ConnectionCheckOutFailedEvent;
    var ConnectionCheckedOutEvent = events.ConnectionCheckedOutEvent;
    var ConnectionCheckedInEvent = events.ConnectionCheckedInEvent;
    var ConnectionPoolClearedEvent = events.ConnectionPoolClearedEvent;
    var kLogger = Symbol("logger");
    var kConnections = Symbol("connections");
    var kPermits = Symbol("permits");
    var kMinPoolSizeTimer = Symbol("minPoolSizeTimer");
    var kGeneration = Symbol("generation");
    var kConnectionCounter = Symbol("connectionCounter");
    var kCancellationToken = Symbol("cancellationToken");
    var kWaitQueue = Symbol("waitQueue");
    var kCancelled = Symbol("cancelled");
    var VALID_POOL_OPTIONS = new Set([
      "ssl",
      "bson",
      "connectionType",
      "monitorCommands",
      "socketTimeout",
      "credentials",
      "compression",
      "host",
      "port",
      "localAddress",
      "localPort",
      "family",
      "hints",
      "lookup",
      "path",
      "ca",
      "cert",
      "sigalgs",
      "ciphers",
      "clientCertEngine",
      "crl",
      "dhparam",
      "ecdhCurve",
      "honorCipherOrder",
      "key",
      "privateKeyEngine",
      "privateKeyIdentifier",
      "maxVersion",
      "minVersion",
      "passphrase",
      "pfx",
      "secureOptions",
      "secureProtocol",
      "sessionIdContext",
      "allowHalfOpen",
      "rejectUnauthorized",
      "pskCallback",
      "ALPNProtocols",
      "servername",
      "checkServerIdentity",
      "session",
      "minDHSize",
      "secureContext",
      "maxPoolSize",
      "minPoolSize",
      "maxIdleTimeMS",
      "waitQueueTimeoutMS"
    ]);
    function resolveOptions(options, defaults) {
      const newOptions = Array.from(VALID_POOL_OPTIONS).reduce((obj, key) => {
        if (Object.prototype.hasOwnProperty.call(options, key)) {
          obj[key] = options[key];
        }
        return obj;
      }, {});
      return Object.freeze(Object.assign({}, defaults, newOptions));
    }
    var ConnectionPool = class extends EventEmitter {
      constructor(options) {
        super();
        options = options || {};
        this.closed = false;
        this.options = resolveOptions(options, {
          connectionType: Connection,
          maxPoolSize: typeof options.maxPoolSize === "number" ? options.maxPoolSize : 100,
          minPoolSize: typeof options.minPoolSize === "number" ? options.minPoolSize : 0,
          maxIdleTimeMS: typeof options.maxIdleTimeMS === "number" ? options.maxIdleTimeMS : 0,
          waitQueueTimeoutMS: typeof options.waitQueueTimeoutMS === "number" ? options.waitQueueTimeoutMS : 0,
          autoEncrypter: options.autoEncrypter,
          metadata: options.metadata
        });
        if (options.minSize > options.maxSize) {
          throw new TypeError("Connection pool minimum size must not be greater than maxiumum pool size");
        }
        this[kLogger] = Logger("ConnectionPool", options);
        this[kConnections] = new Denque();
        this[kPermits] = this.options.maxPoolSize;
        this[kMinPoolSizeTimer] = void 0;
        this[kGeneration] = 0;
        this[kConnectionCounter] = makeCounter(1);
        this[kCancellationToken] = new EventEmitter();
        this[kCancellationToken].setMaxListeners(Infinity);
        this[kWaitQueue] = new Denque();
        process.nextTick(() => {
          this.emit("connectionPoolCreated", new ConnectionPoolCreatedEvent(this));
          ensureMinPoolSize(this);
        });
      }
      get address() {
        return `${this.options.host}:${this.options.port}`;
      }
      get generation() {
        return this[kGeneration];
      }
      get totalConnectionCount() {
        return this[kConnections].length + (this.options.maxPoolSize - this[kPermits]);
      }
      get availableConnectionCount() {
        return this[kConnections].length;
      }
      get waitQueueSize() {
        return this[kWaitQueue].length;
      }
      checkOut(callback) {
        this.emit("connectionCheckOutStarted", new ConnectionCheckOutStartedEvent(this));
        if (this.closed) {
          this.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(this, "poolClosed"));
          callback(new PoolClosedError(this));
          return;
        }
        const waitQueueMember = { callback };
        const pool = this;
        const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;
        if (waitQueueTimeoutMS) {
          waitQueueMember.timer = setTimeout(() => {
            waitQueueMember[kCancelled] = true;
            waitQueueMember.timer = void 0;
            pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, "timeout"));
            waitQueueMember.callback(new WaitQueueTimeoutError(pool));
          }, waitQueueTimeoutMS);
        }
        this[kWaitQueue].push(waitQueueMember);
        process.nextTick(() => processWaitQueue(this));
      }
      checkIn(connection) {
        const poolClosed = this.closed;
        const stale = connectionIsStale(this, connection);
        const willDestroy = !!(poolClosed || stale || connection.closed);
        if (!willDestroy) {
          connection.markAvailable();
          this[kConnections].push(connection);
        }
        this.emit("connectionCheckedIn", new ConnectionCheckedInEvent(this, connection));
        if (willDestroy) {
          const reason = connection.closed ? "error" : poolClosed ? "poolClosed" : "stale";
          destroyConnection(this, connection, reason);
        }
        process.nextTick(() => processWaitQueue(this));
      }
      clear() {
        this[kGeneration] += 1;
        this.emit("connectionPoolCleared", new ConnectionPoolClearedEvent(this));
      }
      close(options, callback) {
        if (typeof options === "function") {
          callback = options;
        }
        options = Object.assign({ force: false }, options);
        if (this.closed) {
          return callback();
        }
        this[kCancellationToken].emit("cancel");
        while (this.waitQueueSize) {
          const waitQueueMember = this[kWaitQueue].pop();
          clearTimeout(waitQueueMember.timer);
          if (!waitQueueMember[kCancelled]) {
            waitQueueMember.callback(new MongoError("connection pool closed"));
          }
        }
        if (this[kMinPoolSizeTimer]) {
          clearTimeout(this[kMinPoolSizeTimer]);
        }
        if (typeof this[kConnectionCounter].return === "function") {
          this[kConnectionCounter].return();
        }
        this.closed = true;
        eachAsync(this[kConnections].toArray(), (conn, cb) => {
          this.emit("connectionClosed", new ConnectionClosedEvent(this, conn, "poolClosed"));
          conn.destroy(options, cb);
        }, (err) => {
          this[kConnections].clear();
          this.emit("connectionPoolClosed", new ConnectionPoolClosedEvent(this));
          callback(err);
        });
      }
      withConnection(fn, callback) {
        this.checkOut((err, conn) => {
          fn(err, conn, (fnErr, result) => {
            if (typeof callback === "function") {
              if (fnErr) {
                callback(fnErr);
              } else {
                callback(void 0, result);
              }
            }
            if (conn) {
              this.checkIn(conn);
            }
          });
        });
      }
    };
    function ensureMinPoolSize(pool) {
      if (pool.closed || pool.options.minPoolSize === 0) {
        return;
      }
      const minPoolSize = pool.options.minPoolSize;
      for (let i = pool.totalConnectionCount; i < minPoolSize; ++i) {
        createConnection(pool);
      }
      pool[kMinPoolSizeTimer] = setTimeout(() => ensureMinPoolSize(pool), 10);
    }
    function connectionIsStale(pool, connection) {
      return connection.generation !== pool[kGeneration];
    }
    function connectionIsIdle(pool, connection) {
      return !!(pool.options.maxIdleTimeMS && connection.idleTime > pool.options.maxIdleTimeMS);
    }
    function createConnection(pool, callback) {
      const connectOptions = Object.assign({
        id: pool[kConnectionCounter].next().value,
        generation: pool[kGeneration]
      }, pool.options);
      pool[kPermits]--;
      connect(connectOptions, pool[kCancellationToken], (err, connection) => {
        if (err) {
          pool[kPermits]++;
          pool[kLogger].debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
          if (typeof callback === "function") {
            callback(err);
          }
          return;
        }
        if (pool.closed) {
          connection.destroy({ force: true });
          return;
        }
        relayEvents(connection, pool, [
          "commandStarted",
          "commandFailed",
          "commandSucceeded",
          "clusterTimeReceived"
        ]);
        pool.emit("connectionCreated", new ConnectionCreatedEvent(pool, connection));
        connection.markAvailable();
        pool.emit("connectionReady", new ConnectionReadyEvent(pool, connection));
        if (typeof callback === "function") {
          callback(void 0, connection);
          return;
        }
        pool[kConnections].push(connection);
        process.nextTick(() => processWaitQueue(pool));
      });
    }
    function destroyConnection(pool, connection, reason) {
      pool.emit("connectionClosed", new ConnectionClosedEvent(pool, connection, reason));
      pool[kPermits]++;
      process.nextTick(() => connection.destroy());
    }
    function processWaitQueue(pool) {
      if (pool.closed) {
        return;
      }
      while (pool.waitQueueSize) {
        const waitQueueMember = pool[kWaitQueue].peekFront();
        if (waitQueueMember[kCancelled]) {
          pool[kWaitQueue].shift();
          continue;
        }
        if (!pool.availableConnectionCount) {
          break;
        }
        const connection = pool[kConnections].shift();
        const isStale = connectionIsStale(pool, connection);
        const isIdle = connectionIsIdle(pool, connection);
        if (!isStale && !isIdle && !connection.closed) {
          pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection));
          clearTimeout(waitQueueMember.timer);
          pool[kWaitQueue].shift();
          waitQueueMember.callback(void 0, connection);
          return;
        }
        const reason = connection.closed ? "error" : isStale ? "stale" : "idle";
        destroyConnection(pool, connection, reason);
      }
      const maxPoolSize = pool.options.maxPoolSize;
      if (pool.waitQueueSize && (maxPoolSize <= 0 || pool.totalConnectionCount < maxPoolSize)) {
        createConnection(pool, (err, connection) => {
          const waitQueueMember = pool[kWaitQueue].shift();
          if (waitQueueMember == null || waitQueueMember[kCancelled]) {
            if (err == null) {
              pool[kConnections].push(connection);
            }
            return;
          }
          if (err) {
            pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, err));
          } else {
            pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection));
          }
          clearTimeout(waitQueueMember.timer);
          waitQueueMember.callback(err, connection);
        });
        return;
      }
    }
    module2.exports = {
      ConnectionPool
    };
  }
});

// node_modules/mongodb/lib/core/sdam/monitor.js
var require_monitor = __commonJS({
  "node_modules/mongodb/lib/core/sdam/monitor.js"(exports2, module2) {
    "use strict";
    var ServerType = require_common().ServerType;
    var EventEmitter = require("events");
    var connect = require_connect();
    var Connection = require_connection2().Connection;
    var common = require_common();
    var makeStateMachine = require_utils4().makeStateMachine;
    var MongoNetworkError = require_error().MongoNetworkError;
    var BSON2 = require_utils5().retrieveBSON();
    var makeInterruptableAsyncInterval = require_utils6().makeInterruptableAsyncInterval;
    var calculateDurationInMs = require_utils6().calculateDurationInMs;
    var now = require_utils6().now;
    var sdamEvents = require_events();
    var ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;
    var ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;
    var ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;
    var kServer = Symbol("server");
    var kMonitorId = Symbol("monitorId");
    var kConnection = Symbol("connection");
    var kCancellationToken = Symbol("cancellationToken");
    var kRTTPinger = Symbol("rttPinger");
    var kRoundTripTime = Symbol("roundTripTime");
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_IDLE = "idle";
    var STATE_MONITORING = "monitoring";
    var stateTransition = makeStateMachine({
      [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],
      [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],
      [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],
      [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]
    });
    var INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);
    function isInCloseState(monitor) {
      return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;
    }
    var Monitor = class extends EventEmitter {
      constructor(server, options) {
        super(options);
        this[kServer] = server;
        this[kConnection] = void 0;
        this[kCancellationToken] = new EventEmitter();
        this[kCancellationToken].setMaxListeners(Infinity);
        this[kMonitorId] = null;
        this.s = {
          state: STATE_CLOSED
        };
        this.address = server.description.address;
        this.options = Object.freeze({
          connectTimeoutMS: typeof options.connectionTimeout === "number" ? options.connectionTimeout : typeof options.connectTimeoutMS === "number" ? options.connectTimeoutMS : 1e4,
          heartbeatFrequencyMS: typeof options.heartbeatFrequencyMS === "number" ? options.heartbeatFrequencyMS : 1e4,
          minHeartbeatFrequencyMS: typeof options.minHeartbeatFrequencyMS === "number" ? options.minHeartbeatFrequencyMS : 500
        });
        const connectOptions = Object.assign({
          id: "<monitor>",
          host: server.description.host,
          port: server.description.port,
          bson: server.s.bson,
          connectionType: Connection
        }, server.s.options, this.options, {
          raw: false,
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: true,
          bsonRegExp: true
        });
        delete connectOptions.credentials;
        delete connectOptions.autoEncrypter;
        this.connectOptions = Object.freeze(connectOptions);
      }
      connect() {
        if (this.s.state !== STATE_CLOSED) {
          return;
        }
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
          interval: heartbeatFrequencyMS,
          minInterval: minHeartbeatFrequencyMS,
          immediate: true
        });
      }
      requestCheck() {
        if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
          return;
        }
        this[kMonitorId].wake();
      }
      reset() {
        const topologyVersion = this[kServer].description.topologyVersion;
        if (isInCloseState(this) || topologyVersion == null) {
          return;
        }
        stateTransition(this, STATE_CLOSING);
        resetMonitorState(this);
        stateTransition(this, STATE_IDLE);
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
          interval: heartbeatFrequencyMS,
          minInterval: minHeartbeatFrequencyMS
        });
      }
      close() {
        if (isInCloseState(this)) {
          return;
        }
        stateTransition(this, STATE_CLOSING);
        resetMonitorState(this);
        this.emit("close");
        stateTransition(this, STATE_CLOSED);
      }
    };
    function resetMonitorState(monitor) {
      if (monitor[kMonitorId]) {
        monitor[kMonitorId].stop();
        monitor[kMonitorId] = null;
      }
      if (monitor[kRTTPinger]) {
        monitor[kRTTPinger].close();
        monitor[kRTTPinger] = void 0;
      }
      monitor[kCancellationToken].emit("cancel");
      if (monitor[kMonitorId]) {
        clearTimeout(monitor[kMonitorId]);
        monitor[kMonitorId] = void 0;
      }
      if (monitor[kConnection]) {
        monitor[kConnection].destroy({ force: true });
      }
    }
    function checkServer(monitor, callback) {
      let start = now();
      monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
      function failureHandler(err) {
        if (monitor[kConnection]) {
          monitor[kConnection].destroy({ force: true });
          monitor[kConnection] = void 0;
        }
        monitor.emit("serverHeartbeatFailed", new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));
        monitor.emit("resetServer", err);
        monitor.emit("resetConnectionPool");
        callback(err);
      }
      if (monitor[kConnection] != null && !monitor[kConnection].closed) {
        const connectTimeoutMS = monitor.options.connectTimeoutMS;
        const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
        const topologyVersion = monitor[kServer].description.topologyVersion;
        const isAwaitable = topologyVersion != null;
        const cmd = { ismaster: true };
        const options = { socketTimeout: connectTimeoutMS };
        if (isAwaitable) {
          cmd.maxAwaitTimeMS = maxAwaitTimeMS;
          cmd.topologyVersion = makeTopologyVersion(topologyVersion);
          if (connectTimeoutMS) {
            options.socketTimeout = connectTimeoutMS + maxAwaitTimeMS;
          }
          options.exhaustAllowed = true;
          if (monitor[kRTTPinger] == null) {
            monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);
          }
        }
        monitor[kConnection].command("admin.$cmd", cmd, options, (err, result) => {
          if (err) {
            failureHandler(err);
            return;
          }
          const isMaster = result.result;
          const rttPinger = monitor[kRTTPinger];
          const duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : calculateDurationInMs(start);
          monitor.emit("serverHeartbeatSucceeded", new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address));
          if (isAwaitable && isMaster.topologyVersion) {
            monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
            start = now();
          } else {
            if (monitor[kRTTPinger]) {
              monitor[kRTTPinger].close();
              monitor[kRTTPinger] = void 0;
            }
            callback(void 0, isMaster);
          }
        });
        return;
      }
      connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {
        if (conn && isInCloseState(monitor)) {
          conn.destroy({ force: true });
          return;
        }
        if (err) {
          monitor[kConnection] = void 0;
          if (!(err instanceof MongoNetworkError)) {
            monitor.emit("resetConnectionPool");
          }
          failureHandler(err);
          return;
        }
        monitor[kConnection] = conn;
        monitor.emit("serverHeartbeatSucceeded", new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), conn.ismaster, monitor.address));
        callback(void 0, conn.ismaster);
      });
    }
    function monitorServer(monitor) {
      return (callback) => {
        stateTransition(monitor, STATE_MONITORING);
        function done() {
          if (!isInCloseState(monitor)) {
            stateTransition(monitor, STATE_IDLE);
          }
          callback();
        }
        process.nextTick(() => monitor.emit("monitoring", monitor[kServer]));
        checkServer(monitor, (err, isMaster) => {
          if (err) {
            if (monitor[kServer].description.type === ServerType.Unknown) {
              monitor.emit("resetServer", err);
              return done();
            }
          }
          if (isMaster && isMaster.topologyVersion) {
            setTimeout(() => {
              if (!isInCloseState(monitor)) {
                monitor[kMonitorId].wake();
              }
            });
          }
          done();
        });
      };
    }
    function makeTopologyVersion(tv) {
      return {
        processId: tv.processId,
        counter: BSON2.Long.fromNumber(tv.counter)
      };
    }
    var RTTPinger = class {
      constructor(cancellationToken, options) {
        this[kConnection] = null;
        this[kCancellationToken] = cancellationToken;
        this[kRoundTripTime] = 0;
        this.closed = false;
        const heartbeatFrequencyMS = options.heartbeatFrequencyMS;
        this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);
      }
      get roundTripTime() {
        return this[kRoundTripTime];
      }
      close() {
        this.closed = true;
        clearTimeout(this[kMonitorId]);
        this[kMonitorId] = void 0;
        if (this[kConnection]) {
          this[kConnection].destroy({ force: true });
        }
      }
    };
    function measureRoundTripTime(rttPinger, options) {
      const start = now();
      const cancellationToken = rttPinger[kCancellationToken];
      const heartbeatFrequencyMS = options.heartbeatFrequencyMS;
      if (rttPinger.closed) {
        return;
      }
      function measureAndReschedule(conn) {
        if (rttPinger.closed) {
          conn.destroy({ force: true });
          return;
        }
        if (rttPinger[kConnection] == null) {
          rttPinger[kConnection] = conn;
        }
        rttPinger[kRoundTripTime] = calculateDurationInMs(start);
        rttPinger[kMonitorId] = setTimeout(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);
      }
      if (rttPinger[kConnection] == null) {
        connect(options, cancellationToken, (err, conn) => {
          if (err) {
            rttPinger[kConnection] = void 0;
            rttPinger[kRoundTripTime] = 0;
            return;
          }
          measureAndReschedule(conn);
        });
        return;
      }
      rttPinger[kConnection].command("admin.$cmd", { ismaster: 1 }, (err) => {
        if (err) {
          rttPinger[kConnection] = void 0;
          rttPinger[kRoundTripTime] = 0;
          return;
        }
        measureAndReschedule();
      });
    }
    module2.exports = {
      Monitor
    };
  }
});

// node_modules/mongodb/lib/core/sdam/server.js
var require_server2 = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var ConnectionPool = require_connection_pool().ConnectionPool;
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var MongoError = require_error().MongoError;
    var relayEvents = require_utils4().relayEvents;
    var BSON2 = require_utils5().retrieveBSON();
    var Logger = require_logger();
    var ServerDescription = require_server_description().ServerDescription;
    var compareTopologyVersion = require_server_description().compareTopologyVersion;
    var ReadPreference = require_read_preference();
    var Monitor = require_monitor().Monitor;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var collationNotSupported = require_utils4().collationNotSupported;
    var debugOptions = require_utils5().debugOptions;
    var isSDAMUnrecoverableError = require_error().isSDAMUnrecoverableError;
    var isRetryableWriteError = require_error().isRetryableWriteError;
    var isNodeShuttingDownError = require_error().isNodeShuttingDownError;
    var isNetworkErrorBeforeHandshake = require_error().isNetworkErrorBeforeHandshake;
    var maxWireVersion = require_utils4().maxWireVersion;
    var makeStateMachine = require_utils4().makeStateMachine;
    var extractCommand = require_command_utils().extractCommand;
    var common = require_common();
    var ServerType = common.ServerType;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var DEBUG_FIELDS = [
      "reconnect",
      "reconnectTries",
      "reconnectInterval",
      "emitError",
      "cursorFactory",
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "checkServerIdentity",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "key",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "servername"
    ];
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CONNECTING = common.STATE_CONNECTING;
    var STATE_CONNECTED = common.STATE_CONNECTED;
    var stateTransition = makeStateMachine({
      [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
      [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
      [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
      [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
    });
    var kMonitor = Symbol("monitor");
    var Server = class extends EventEmitter {
      constructor(description, options, topology) {
        super();
        this.s = {
          description,
          options,
          logger: Logger("Server", options),
          bson: options.bson || new BSON2([
            BSON2.Binary,
            BSON2.Code,
            BSON2.DBRef,
            BSON2.Decimal128,
            BSON2.Double,
            BSON2.Int32,
            BSON2.Long,
            BSON2.Map,
            BSON2.MaxKey,
            BSON2.MinKey,
            BSON2.ObjectId,
            BSON2.BSONRegExp,
            BSON2.Symbol,
            BSON2.Timestamp
          ]),
          state: STATE_CLOSED,
          credentials: options.credentials,
          topology
        };
        const poolOptions = Object.assign({ host: this.description.host, port: this.description.port, bson: this.s.bson }, options);
        this.s.pool = new ConnectionPool(poolOptions);
        relayEvents(this.s.pool, this, ["commandStarted", "commandSucceeded", "commandFailed"].concat(CMAP_EVENT_NAMES));
        this.s.pool.on("clusterTimeReceived", (clusterTime) => {
          this.clusterTime = clusterTime;
        });
        this[kMonitor] = new Monitor(this, this.s.options);
        relayEvents(this[kMonitor], this, [
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "monitoring"
        ]);
        this[kMonitor].on("resetConnectionPool", () => {
          this.s.pool.clear();
        });
        this[kMonitor].on("resetServer", (error) => markServerUnknown(this, error));
        this[kMonitor].on("serverHeartbeatSucceeded", (event) => {
          this.emit("descriptionReceived", new ServerDescription(this.description.address, event.reply, {
            roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)
          }));
          if (this.s.state === STATE_CONNECTING) {
            stateTransition(this, STATE_CONNECTED);
            this.emit("connect", this);
          }
        });
      }
      get description() {
        return this.s.description;
      }
      get supportsRetryableWrites() {
        return supportsRetryableWrites(this);
      }
      get name() {
        return this.s.description.address;
      }
      get autoEncrypter() {
        if (this.s.options && this.s.options.autoEncrypter) {
          return this.s.options.autoEncrypter;
        }
        return null;
      }
      connect() {
        if (this.s.state !== STATE_CLOSED) {
          return;
        }
        stateTransition(this, STATE_CONNECTING);
        this[kMonitor].connect();
      }
      destroy(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = Object.assign({}, { force: false }, options);
        if (this.s.state === STATE_CLOSED) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CLOSING);
        this[kMonitor].close();
        this.s.pool.close(options, (err) => {
          stateTransition(this, STATE_CLOSED);
          this.emit("closed");
          if (typeof callback === "function") {
            callback(err);
          }
        });
      }
      requestCheck() {
        this[kMonitor].requestCheck();
      }
      command(ns, cmd, options, callback) {
        if (typeof options === "function") {
          callback = options, options = {}, options = options || {};
        }
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        const error = basicReadValidations(this, options);
        if (error) {
          return callback(error);
        }
        options = Object.assign({}, options, { wireProtocolCommand: false });
        if (this.s.logger.isDebug()) {
          const extractedCommand = extractCommand(cmd);
          this.s.logger.debug(`executing command [${JSON.stringify({
            ns,
            cmd: extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : cmd,
            options: debugOptions(DEBUG_FIELDS, options)
          })}] against ${this.name}`);
        }
        if (collationNotSupported(this, cmd)) {
          callback(new MongoError(`server ${this.name} does not support collation`));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.command(ns, cmd, options, makeOperationHandler(this, conn, cmd, options, cb));
        }, callback);
      }
      query(ns, cmd, cursorState, options, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.query(ns, cmd, cursorState, options, makeOperationHandler(this, conn, cmd, options, cb));
        }, callback);
      }
      getMore(ns, cursorState, batchSize, options, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.getMore(ns, cursorState, batchSize, options, makeOperationHandler(this, conn, null, options, cb));
        }, callback);
      }
      killCursors(ns, cursorState, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          if (typeof callback === "function") {
            callback(new MongoError("server is closed"));
          }
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.killCursors(ns, cursorState, makeOperationHandler(this, conn, null, void 0, cb));
        }, callback);
      }
      insert(ns, ops, options, callback) {
        executeWriteOperation({ server: this, op: "insert", ns, ops }, options, callback);
      }
      update(ns, ops, options, callback) {
        executeWriteOperation({ server: this, op: "update", ns, ops }, options, callback);
      }
      remove(ns, ops, options, callback) {
        executeWriteOperation({ server: this, op: "remove", ns, ops }, options, callback);
      }
    };
    Object.defineProperty(Server.prototype, "clusterTime", {
      get: function() {
        return this.s.topology.clusterTime;
      },
      set: function(clusterTime) {
        this.s.topology.clusterTime = clusterTime;
      }
    });
    function supportsRetryableWrites(server) {
      return server.description.maxWireVersion >= 6 && server.description.logicalSessionTimeoutMinutes && server.description.type !== ServerType.Standalone;
    }
    function calculateRoundTripTime(oldRtt, duration) {
      if (oldRtt === -1) {
        return duration;
      }
      const alpha = 0.2;
      return alpha * duration + (1 - alpha) * oldRtt;
    }
    function basicReadValidations(server, options) {
      if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {
        return new MongoError("readPreference must be an instance of ReadPreference");
      }
    }
    function executeWriteOperation(args, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const server = args.server;
      const op = args.op;
      const ns = args.ns;
      const ops = Array.isArray(args.ops) ? args.ops : [args.ops];
      if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {
        callback(new MongoError("server is closed"));
        return;
      }
      if (collationNotSupported(server, options)) {
        callback(new MongoError(`server ${server.name} does not support collation`));
        return;
      }
      const unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;
      if (unacknowledgedWrite || maxWireVersion(server) < 5) {
        if ((op === "update" || op === "remove") && ops.find((o) => o.hint)) {
          callback(new MongoError(`servers < 3.4 do not support hint on ${op}`));
          return;
        }
      }
      server.s.pool.withConnection((err, conn, cb) => {
        if (err) {
          markServerUnknown(server, err);
          return cb(err);
        }
        conn[op](ns, ops, options, makeOperationHandler(server, conn, ops, options, cb));
      }, callback);
    }
    function markServerUnknown(server, error) {
      if (error instanceof MongoNetworkError && !(error instanceof MongoNetworkTimeoutError)) {
        server[kMonitor].reset();
      }
      server.emit("descriptionReceived", new ServerDescription(server.description.address, null, {
        error,
        topologyVersion: error && error.topologyVersion ? error.topologyVersion : server.description.topologyVersion
      }));
    }
    function connectionIsStale(pool, connection) {
      return connection.generation !== pool.generation;
    }
    function shouldHandleStateChangeError(server, err) {
      const etv = err.topologyVersion;
      const stv = server.description.topologyVersion;
      return compareTopologyVersion(stv, etv) < 0;
    }
    function inActiveTransaction(session, cmd) {
      return session && session.inTransaction() && !isTransactionCommand(cmd);
    }
    function makeOperationHandler(server, connection, cmd, options, callback) {
      const session = options && options.session;
      return function handleOperationResult(err, result) {
        if (err && !connectionIsStale(server.s.pool, connection)) {
          if (err instanceof MongoNetworkError) {
            if (session && !session.hasEnded) {
              session.serverSession.isDirty = true;
            }
            if (supportsRetryableWrites(server) && !inActiveTransaction(session, cmd)) {
              err.addErrorLabel("RetryableWriteError");
            }
            if (!(err instanceof MongoNetworkTimeoutError) || isNetworkErrorBeforeHandshake(err)) {
              markServerUnknown(server, err);
              server.s.pool.clear();
            }
          } else {
            if (maxWireVersion(server) < 9 && isRetryableWriteError(err) && !inActiveTransaction(session, cmd)) {
              err.addErrorLabel("RetryableWriteError");
            }
            if (isSDAMUnrecoverableError(err)) {
              if (shouldHandleStateChangeError(server, err)) {
                if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {
                  server.s.pool.clear();
                }
                markServerUnknown(server, err);
                process.nextTick(() => server.requestCheck());
              }
            }
          }
        }
        callback(err, result);
      };
    }
    module2.exports = {
      Server
    };
  }
});

// node_modules/mongodb/lib/core/sdam/srv_polling.js
var require_srv_polling = __commonJS({
  "node_modules/mongodb/lib/core/sdam/srv_polling.js"(exports2, module2) {
    "use strict";
    var Logger = require_logger();
    var EventEmitter = require("events").EventEmitter;
    var dns = require("dns");
    function matchesParentDomain(srvAddress, parentDomain) {
      const regex = /^.*?\./;
      const srv = `.${srvAddress.replace(regex, "")}`;
      const parent = `.${parentDomain.replace(regex, "")}`;
      return srv.endsWith(parent);
    }
    var SrvPollingEvent = class {
      constructor(srvRecords) {
        this.srvRecords = srvRecords;
      }
      addresses() {
        return new Set(this.srvRecords.map((record) => `${record.name}:${record.port}`));
      }
    };
    var SrvPoller = class extends EventEmitter {
      constructor(options) {
        super();
        if (!options || !options.srvHost) {
          throw new TypeError("options for SrvPoller must exist and include srvHost");
        }
        this.srvHost = options.srvHost;
        this.rescanSrvIntervalMS = 6e4;
        this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 1e4;
        this.logger = Logger("srvPoller", options);
        this.haMode = false;
        this.generation = 0;
        this._timeout = null;
      }
      get srvAddress() {
        return `_mongodb._tcp.${this.srvHost}`;
      }
      get intervalMS() {
        return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
      }
      start() {
        if (!this._timeout) {
          this.schedule();
        }
      }
      stop() {
        if (this._timeout) {
          clearTimeout(this._timeout);
          this.generation += 1;
          this._timeout = null;
        }
      }
      schedule() {
        clearTimeout(this._timeout);
        this._timeout = setTimeout(() => this._poll(), this.intervalMS);
      }
      success(srvRecords) {
        this.haMode = false;
        this.schedule();
        this.emit("srvRecordDiscovery", new SrvPollingEvent(srvRecords));
      }
      failure(message, obj) {
        this.logger.warn(message, obj);
        this.haMode = true;
        this.schedule();
      }
      parentDomainMismatch(srvRecord) {
        this.logger.warn(`parent domain mismatch on SRV record (${srvRecord.name}:${srvRecord.port})`, srvRecord);
      }
      _poll() {
        const generation = this.generation;
        dns.resolveSrv(this.srvAddress, (err, srvRecords) => {
          if (generation !== this.generation) {
            return;
          }
          if (err) {
            this.failure("DNS error", err);
            return;
          }
          const finalAddresses = [];
          srvRecords.forEach((record) => {
            if (matchesParentDomain(record.name, this.srvHost)) {
              finalAddresses.push(record);
            } else {
              this.parentDomainMismatch(record);
            }
          });
          if (!finalAddresses.length) {
            this.failure("No valid addresses found at host");
            return;
          }
          this.success(finalAddresses);
        });
      }
    };
    module2.exports.SrvPollingEvent = SrvPollingEvent;
    module2.exports.SrvPoller = SrvPoller;
  }
});

// node_modules/mongodb/lib/core/sdam/server_selection.js
var require_server_selection = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server_selection.js"(exports2, module2) {
    "use strict";
    var ServerType = require_common().ServerType;
    var TopologyType = require_common().TopologyType;
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var IDLE_WRITE_PERIOD = 1e4;
    var SMALLEST_MAX_STALENESS_SECONDS = 90;
    function writableServerSelector() {
      return function(topologyDescription, servers) {
        return latencyWindowReducer(topologyDescription, servers.filter((s) => s.isWritable));
      };
    }
    function maxStalenessReducer(readPreference, topologyDescription, servers) {
      if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
        return servers;
      }
      const maxStaleness = readPreference.maxStalenessSeconds;
      const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1e3;
      if (maxStaleness < maxStalenessVariance) {
        throw new MongoError(`maxStalenessSeconds must be at least ${maxStalenessVariance} seconds`);
      }
      if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
        throw new MongoError(`maxStalenessSeconds must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);
      }
      if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {
        const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
        return servers.reduce((result, server) => {
          const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          if (staleness <= readPreference.maxStalenessSeconds)
            result.push(server);
          return result;
        }, []);
      }
      if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {
        if (servers.length === 0) {
          return servers;
        }
        const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);
        return servers.reduce((result, server) => {
          const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          if (staleness <= readPreference.maxStalenessSeconds)
            result.push(server);
          return result;
        }, []);
      }
      return servers;
    }
    function tagSetMatch(tagSet, serverTags) {
      const keys = Object.keys(tagSet);
      const serverTagKeys = Object.keys(serverTags);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
          return false;
        }
      }
      return true;
    }
    function tagSetReducer(readPreference, servers) {
      if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
        return servers;
      }
      for (let i = 0; i < readPreference.tags.length; ++i) {
        const tagSet = readPreference.tags[i];
        const serversMatchingTagset = servers.reduce((matched, server) => {
          if (tagSetMatch(tagSet, server.tags))
            matched.push(server);
          return matched;
        }, []);
        if (serversMatchingTagset.length) {
          return serversMatchingTagset;
        }
      }
      return [];
    }
    function latencyWindowReducer(topologyDescription, servers) {
      const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);
      const high = low + topologyDescription.localThresholdMS;
      return servers.reduce((result, server) => {
        if (server.roundTripTime <= high && server.roundTripTime >= low)
          result.push(server);
        return result;
      }, []);
    }
    function primaryFilter(server) {
      return server.type === ServerType.RSPrimary;
    }
    function secondaryFilter(server) {
      return server.type === ServerType.RSSecondary;
    }
    function nearestFilter(server) {
      return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;
    }
    function knownFilter(server) {
      return server.type !== ServerType.Unknown;
    }
    function readPreferenceServerSelector(readPreference) {
      if (!readPreference.isValid()) {
        throw new TypeError("Invalid read preference specified");
      }
      return function(topologyDescription, servers) {
        const commonWireVersion = topologyDescription.commonWireVersion;
        if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
          throw new MongoError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);
        }
        if (topologyDescription.type === TopologyType.Unknown) {
          return [];
        }
        if (topologyDescription.type === TopologyType.Single || topologyDescription.type === TopologyType.Sharded) {
          return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
        }
        const mode = readPreference.mode;
        if (mode === ReadPreference.PRIMARY) {
          return servers.filter(primaryFilter);
        }
        if (mode === ReadPreference.PRIMARY_PREFERRED) {
          const result = servers.filter(primaryFilter);
          if (result.length) {
            return result;
          }
        }
        const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
        const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));
        if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
          return servers.filter(primaryFilter);
        }
        return selectedServers;
      };
    }
    module2.exports = {
      writableServerSelector,
      readPreferenceServerSelector
    };
  }
});

// node_modules/mongodb/lib/core/sdam/topology.js
var require_topology = __commonJS({
  "node_modules/mongodb/lib/core/sdam/topology.js"(exports2, module2) {
    "use strict";
    var Denque = require_denque();
    var EventEmitter = require("events");
    var ServerDescription = require_server_description().ServerDescription;
    var ServerType = require_common().ServerType;
    var TopologyDescription = require_topology_description().TopologyDescription;
    var TopologyType = require_common().TopologyType;
    var events = require_events();
    var Server = require_server2().Server;
    var relayEvents = require_utils4().relayEvents;
    var ReadPreference = require_read_preference();
    var CoreCursor = require_cursor().CoreCursor;
    var deprecate = require("util").deprecate;
    var BSON2 = require_utils5().retrieveBSON();
    var createCompressionInfo = require_shared2().createCompressionInfo;
    var ClientSession = require_sessions().ClientSession;
    var MongoError = require_error().MongoError;
    var MongoServerSelectionError = require_error().MongoServerSelectionError;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var SrvPoller = require_srv_polling().SrvPoller;
    var getMMAPError = require_shared2().getMMAPError;
    var makeStateMachine = require_utils4().makeStateMachine;
    var eachAsync = require_utils4().eachAsync;
    var emitDeprecationWarning = require_utils6().emitDeprecationWarning;
    var ServerSessionPool = require_sessions().ServerSessionPool;
    var makeClientMetadata = require_utils4().makeClientMetadata;
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var compareTopologyVersion = require_server_description().compareTopologyVersion;
    var emitWarning = require_utils6().emitWarning;
    var common = require_common();
    var drainTimerQueue = common.drainTimerQueue;
    var clearAndRemoveTimerFrom = common.clearAndRemoveTimerFrom;
    var serverSelection = require_server_selection();
    var readPreferenceServerSelector = serverSelection.readPreferenceServerSelector;
    var writableServerSelector = serverSelection.writableServerSelector;
    var globalTopologyCounter = 0;
    var SERVER_RELAY_EVENTS = [
      "serverHeartbeatStarted",
      "serverHeartbeatSucceeded",
      "serverHeartbeatFailed",
      "commandStarted",
      "commandSucceeded",
      "commandFailed",
      "monitoring"
    ].concat(CMAP_EVENT_NAMES);
    var LOCAL_SERVER_EVENTS = ["connect", "descriptionReceived", "close", "ended"];
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CONNECTING = common.STATE_CONNECTING;
    var STATE_CONNECTED = common.STATE_CONNECTED;
    var stateTransition = makeStateMachine({
      [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
      [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
      [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
      [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
    });
    var DEPRECATED_OPTIONS = new Set([
      "autoReconnect",
      "reconnectTries",
      "reconnectInterval",
      "bufferMaxEntries"
    ]);
    var kCancelled = Symbol("cancelled");
    var kWaitQueue = Symbol("waitQueue");
    var Topology = class extends EventEmitter {
      constructor(seedlist, options) {
        super();
        if (typeof options === "undefined" && typeof seedlist !== "string") {
          options = seedlist;
          seedlist = [];
          if (options.host) {
            seedlist.push({ host: options.host, port: options.port });
          }
        }
        seedlist = seedlist || [];
        if (typeof seedlist === "string") {
          seedlist = parseStringSeedlist(seedlist);
        }
        options = Object.assign({}, common.TOPOLOGY_DEFAULTS, options);
        options = Object.freeze(Object.assign(options, {
          metadata: makeClientMetadata(options),
          compression: { compressors: createCompressionInfo(options) }
        }));
        DEPRECATED_OPTIONS.forEach((optionName) => {
          if (options[optionName]) {
            emitDeprecationWarning(`The option \`${optionName}\` is incompatible with the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, "DeprecationWarning");
          }
        });
        const topologyType = topologyTypeFromSeedlist(seedlist, options);
        const topologyId = globalTopologyCounter++;
        const serverDescriptions = seedlist.reduce((result, seed) => {
          if (seed.domain_socket)
            seed.host = seed.domain_socket;
          const address = seed.port ? `${seed.host}:${seed.port}` : `${seed.host}:27017`;
          result.set(address, new ServerDescription(address));
          return result;
        }, new Map());
        this[kWaitQueue] = new Denque();
        this.s = {
          id: topologyId,
          options,
          seedlist,
          state: STATE_CLOSED,
          description: new TopologyDescription(topologyType, serverDescriptions, options.replicaSet, null, null, null, options),
          serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
          heartbeatFrequencyMS: options.heartbeatFrequencyMS,
          minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,
          Cursor: options.cursorFactory || CoreCursor,
          bson: options.bson || new BSON2([
            BSON2.Binary,
            BSON2.Code,
            BSON2.DBRef,
            BSON2.Decimal128,
            BSON2.Double,
            BSON2.Int32,
            BSON2.Long,
            BSON2.Map,
            BSON2.MaxKey,
            BSON2.MinKey,
            BSON2.ObjectId,
            BSON2.BSONRegExp,
            BSON2.Symbol,
            BSON2.Timestamp
          ]),
          servers: new Map(),
          sessionPool: new ServerSessionPool(this),
          sessions: new Set(),
          promiseLibrary: options.promiseLibrary || Promise,
          credentials: options.credentials,
          clusterTime: null,
          connectionTimers: new Set()
        };
        if (options.srvHost) {
          this.s.srvPoller = options.srvPoller || new SrvPoller({
            heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
            srvHost: options.srvHost,
            logger: options.logger,
            loggerLevel: options.loggerLevel
          });
          this.s.detectTopologyDescriptionChange = (ev) => {
            const previousType = ev.previousDescription.type;
            const newType = ev.newDescription.type;
            if (previousType !== TopologyType.Sharded && newType === TopologyType.Sharded) {
              this.s.handleSrvPolling = srvPollingHandler(this);
              this.s.srvPoller.on("srvRecordDiscovery", this.s.handleSrvPolling);
              this.s.srvPoller.start();
            }
          };
          this.on("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
        }
        this.setMaxListeners(Infinity);
      }
      get description() {
        return this.s.description;
      }
      get parserType() {
        return BSON2.native ? "c++" : "js";
      }
      connect(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options || {};
        if (this.s.state === STATE_CONNECTED) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CONNECTING);
        this.emit("topologyOpening", new events.TopologyOpeningEvent(this.s.id));
        this.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(this.s.id, new TopologyDescription(TopologyType.Unknown), this.s.description));
        connectServers(this, Array.from(this.s.description.servers.values()));
        ReadPreference.translate(options);
        const readPreference = options.readPreference || ReadPreference.primary;
        const connectHandler = (err) => {
          if (err) {
            this.close();
            if (typeof callback === "function") {
              callback(err);
            } else {
              this.emit("error", err);
            }
            return;
          }
          stateTransition(this, STATE_CONNECTED);
          this.emit("open", err, this);
          this.emit("connect", this);
          if (typeof callback === "function")
            callback(err, this);
        };
        if (this.s.credentials) {
          this.command("admin.$cmd", { ping: 1 }, { readPreference }, connectHandler);
          return;
        }
        this.selectServer(readPreferenceServerSelector(readPreference), options, connectHandler);
      }
      close(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (typeof options === "boolean") {
          options = { force: options };
        }
        options = options || {};
        if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CLOSING);
        drainWaitQueue(this[kWaitQueue], new MongoError("Topology closed"));
        drainTimerQueue(this.s.connectionTimers);
        if (this.s.srvPoller) {
          this.s.srvPoller.stop();
          if (this.s.handleSrvPolling) {
            this.s.srvPoller.removeListener("srvRecordDiscovery", this.s.handleSrvPolling);
            delete this.s.handleSrvPolling;
          }
        }
        if (this.s.detectTopologyDescriptionChange) {
          this.removeListener("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
          delete this.s.detectTopologyDescriptionChange;
        }
        this.s.sessions.forEach((session) => session.endSession());
        this.s.sessionPool.endAllPooledSessions(() => {
          eachAsync(Array.from(this.s.servers.values()), (server, cb) => destroyServer(server, this, options, cb), (err) => {
            this.s.servers.clear();
            this.emit("topologyClosed", new events.TopologyClosedEvent(this.s.id));
            stateTransition(this, STATE_CLOSED);
            if (typeof callback === "function") {
              callback(err);
            }
          });
        });
      }
      selectServer(selector, options, callback) {
        if (typeof options === "function") {
          callback = options;
          if (typeof selector !== "function") {
            options = selector;
            let readPreference;
            if (selector instanceof ReadPreference) {
              readPreference = selector;
            } else if (typeof selector === "string") {
              readPreference = new ReadPreference(selector);
            } else {
              ReadPreference.translate(options);
              readPreference = options.readPreference || ReadPreference.primary;
            }
            selector = readPreferenceServerSelector(readPreference);
          } else {
            options = {};
          }
        }
        options = Object.assign({}, { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS }, options);
        const isSharded = this.description.type === TopologyType.Sharded;
        const session = options.session;
        const transaction = session && session.transaction;
        if (isSharded && transaction && transaction.server) {
          callback(void 0, transaction.server);
          return;
        }
        let serverSelector = selector;
        if (typeof selector === "object") {
          const readPreference = selector.readPreference ? selector.readPreference : ReadPreference.primary;
          serverSelector = readPreferenceServerSelector(readPreference);
        }
        const waitQueueMember = {
          serverSelector,
          transaction,
          callback
        };
        const serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;
        if (serverSelectionTimeoutMS) {
          waitQueueMember.timer = setTimeout(() => {
            waitQueueMember[kCancelled] = true;
            waitQueueMember.timer = void 0;
            const timeoutError = new MongoServerSelectionError(`Server selection timed out after ${serverSelectionTimeoutMS} ms`, this.description);
            waitQueueMember.callback(timeoutError);
          }, serverSelectionTimeoutMS);
        }
        this[kWaitQueue].push(waitQueueMember);
        processWaitQueue(this);
      }
      shouldCheckForSessionSupport() {
        if (this.description.type === TopologyType.Single) {
          return !this.description.hasKnownServers;
        }
        return !this.description.hasDataBearingServers;
      }
      hasSessionSupport() {
        return this.description.logicalSessionTimeoutMinutes != null;
      }
      startSession(options, clientOptions) {
        const session = new ClientSession(this, this.s.sessionPool, options, clientOptions);
        session.once("ended", () => {
          this.s.sessions.delete(session);
        });
        this.s.sessions.add(session);
        return session;
      }
      endSessions(sessions, callback) {
        if (!Array.isArray(sessions)) {
          sessions = [sessions];
        }
        this.command("admin.$cmd", { endSessions: sessions }, { readPreference: ReadPreference.primaryPreferred, noResponse: true }, () => {
          if (typeof callback === "function")
            callback();
        });
      }
      serverUpdateHandler(serverDescription) {
        if (!this.s.description.hasServer(serverDescription.address)) {
          return;
        }
        if (isStaleServerDescription(this.s.description, serverDescription)) {
          return;
        }
        const previousTopologyDescription = this.s.description;
        const previousServerDescription = this.s.description.servers.get(serverDescription.address);
        const clusterTime = serverDescription.$clusterTime;
        if (clusterTime) {
          resolveClusterTime(this, clusterTime);
        }
        const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
        this.s.description = this.s.description.update(serverDescription);
        if (this.s.description.compatibilityError) {
          this.emit("error", new MongoError(this.s.description.compatibilityError));
          return;
        }
        if (!equalDescriptions) {
          this.emit("serverDescriptionChanged", new events.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, this.s.description.servers.get(serverDescription.address)));
        }
        updateServers(this, serverDescription);
        if (this[kWaitQueue].length > 0) {
          processWaitQueue(this);
        }
        if (!equalDescriptions) {
          this.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
        }
      }
      auth(credentials, callback) {
        if (typeof credentials === "function")
          callback = credentials, credentials = null;
        if (typeof callback === "function")
          callback(null, true);
      }
      logout(callback) {
        if (typeof callback === "function")
          callback(null, true);
      }
      insert(ns, ops, options, callback) {
        executeWriteOperation({ topology: this, op: "insert", ns, ops }, options, callback);
      }
      update(ns, ops, options, callback) {
        executeWriteOperation({ topology: this, op: "update", ns, ops }, options, callback);
      }
      remove(ns, ops, options, callback) {
        executeWriteOperation({ topology: this, op: "remove", ns, ops }, options, callback);
      }
      command(ns, cmd, options, callback) {
        if (typeof options === "function") {
          callback = options, options = {}, options = options || {};
        }
        ReadPreference.translate(options);
        const readPreference = options.readPreference || ReadPreference.primary;
        this.selectServer(readPreferenceServerSelector(readPreference), options, (err, server) => {
          if (err) {
            callback(err);
            return;
          }
          const notAlreadyRetrying = !options.retrying;
          const retryWrites = !!options.retryWrites;
          const hasSession = !!options.session;
          const supportsRetryableWrites = server.supportsRetryableWrites;
          const notInTransaction = !hasSession || !options.session.inTransaction();
          const willRetryWrite = notAlreadyRetrying && retryWrites && hasSession && supportsRetryableWrites && notInTransaction && isWriteCommand(cmd);
          const cb = (err2, result) => {
            if (!err2)
              return callback(null, result);
            if (!shouldRetryOperation(err2)) {
              return callback(err2);
            }
            if (willRetryWrite) {
              const newOptions = Object.assign({}, options, { retrying: true });
              return this.command(ns, cmd, newOptions, callback);
            }
            return callback(err2);
          };
          if (willRetryWrite) {
            options.session.incrementTransactionNumber();
            options.willRetryWrite = willRetryWrite;
          }
          server.command(ns, cmd, options, cb);
        });
      }
      cursor(ns, cmd, options) {
        options = options || {};
        const topology = options.topology || this;
        const CursorClass = options.cursorFactory || this.s.Cursor;
        ReadPreference.translate(options);
        return new CursorClass(topology, ns, cmd, options);
      }
      get clientMetadata() {
        return this.s.options.metadata;
      }
      isConnected() {
        return this.s.state === STATE_CONNECTED;
      }
      isDestroyed() {
        return this.s.state === STATE_CLOSED;
      }
      unref() {
        emitWarning("not implemented: `unref`");
      }
      lastIsMaster() {
        const serverDescriptions = Array.from(this.description.servers.values());
        if (serverDescriptions.length === 0)
          return {};
        const sd = serverDescriptions.filter((sd2) => sd2.type !== ServerType.Unknown)[0];
        const result = sd || { maxWireVersion: this.description.commonWireVersion };
        return result;
      }
      get logicalSessionTimeoutMinutes() {
        return this.description.logicalSessionTimeoutMinutes;
      }
      get bson() {
        return this.s.bson;
      }
    };
    Object.defineProperty(Topology.prototype, "clusterTime", {
      enumerable: true,
      get: function() {
        return this.s.clusterTime;
      },
      set: function(clusterTime) {
        this.s.clusterTime = clusterTime;
      }
    });
    Topology.prototype.destroy = deprecate(Topology.prototype.close, "destroy() is deprecated, please use close() instead");
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
    }
    function isStaleServerDescription(topologyDescription, incomingServerDescription) {
      const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
      const currentTopologyVersion = currentServerDescription.topologyVersion;
      return compareTopologyVersion(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
    }
    function destroyServer(server, topology, options, callback) {
      options = options || {};
      LOCAL_SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
      server.destroy(options, () => {
        topology.emit("serverClosed", new events.ServerClosedEvent(topology.s.id, server.description.address));
        SERVER_RELAY_EVENTS.forEach((event) => server.removeAllListeners(event));
        if (typeof callback === "function") {
          callback();
        }
      });
    }
    function parseStringSeedlist(seedlist) {
      return seedlist.split(",").map((seed) => ({
        host: seed.split(":")[0],
        port: seed.split(":")[1] || 27017
      }));
    }
    function topologyTypeFromSeedlist(seedlist, options) {
      if (options.directConnection) {
        return TopologyType.Single;
      }
      const replicaSet = options.replicaSet || options.setName || options.rs_name;
      if (replicaSet == null) {
        return TopologyType.Unknown;
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    function randomSelection(array) {
      return array[Math.floor(Math.random() * array.length)];
    }
    function createAndConnectServer(topology, serverDescription, connectDelay) {
      topology.emit("serverOpening", new events.ServerOpeningEvent(topology.s.id, serverDescription.address));
      const server = new Server(serverDescription, topology.s.options, topology);
      relayEvents(server, topology, SERVER_RELAY_EVENTS);
      server.on("descriptionReceived", topology.serverUpdateHandler.bind(topology));
      if (connectDelay) {
        const connectTimer = setTimeout(() => {
          clearAndRemoveTimerFrom(connectTimer, topology.s.connectionTimers);
          server.connect();
        }, connectDelay);
        topology.s.connectionTimers.add(connectTimer);
        return server;
      }
      server.connect();
      return server;
    }
    function connectServers(topology, serverDescriptions) {
      topology.s.servers = serverDescriptions.reduce((servers, serverDescription) => {
        const server = createAndConnectServer(topology, serverDescription);
        servers.set(serverDescription.address, server);
        return servers;
      }, new Map());
    }
    function updateServers(topology, incomingServerDescription) {
      if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
        const server = topology.s.servers.get(incomingServerDescription.address);
        server.s.description = incomingServerDescription;
      }
      for (const serverDescription of topology.description.servers.values()) {
        if (!topology.s.servers.has(serverDescription.address)) {
          const server = createAndConnectServer(topology, serverDescription);
          topology.s.servers.set(serverDescription.address, server);
        }
      }
      for (const entry of topology.s.servers) {
        const serverAddress = entry[0];
        if (topology.description.hasServer(serverAddress)) {
          continue;
        }
        const server = topology.s.servers.get(serverAddress);
        topology.s.servers.delete(serverAddress);
        destroyServer(server, topology);
      }
    }
    function executeWriteOperation(args, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const topology = args.topology;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      topology.selectServer(writableServerSelector(), options, (err, server) => {
        if (err) {
          callback(err, null);
          return;
        }
        const notAlreadyRetrying = !args.retrying;
        const retryWrites = !!options.retryWrites;
        const hasSession = !!options.session;
        const supportsRetryableWrites = server.supportsRetryableWrites;
        const notInTransaction = !hasSession || !options.session.inTransaction();
        const notExplaining = options.explain === void 0;
        const willRetryWrite = notAlreadyRetrying && retryWrites && hasSession && supportsRetryableWrites && notInTransaction && notExplaining;
        const handler = (err2, result) => {
          if (!err2)
            return callback(null, result);
          if (!shouldRetryOperation(err2)) {
            err2 = getMMAPError(err2);
            return callback(err2);
          }
          if (willRetryWrite) {
            const newArgs = Object.assign({}, args, { retrying: true });
            return executeWriteOperation(newArgs, options, callback);
          }
          return callback(err2);
        };
        if (callback.operationId) {
          handler.operationId = callback.operationId;
        }
        if (willRetryWrite) {
          options.session.incrementTransactionNumber();
          options.willRetryWrite = willRetryWrite;
        }
        server[op](ns, ops, options, handler);
      });
    }
    function shouldRetryOperation(err) {
      return err instanceof MongoError && err.hasErrorLabel("RetryableWriteError");
    }
    function srvPollingHandler(topology) {
      return function handleSrvPolling(ev) {
        const previousTopologyDescription = topology.s.description;
        topology.s.description = topology.s.description.updateFromSrvPollingEvent(ev);
        if (topology.s.description === previousTopologyDescription) {
          return;
        }
        updateServers(topology);
        topology.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(topology.s.id, previousTopologyDescription, topology.s.description));
      };
    }
    function drainWaitQueue(queue, err) {
      while (queue.length) {
        const waitQueueMember = queue.shift();
        clearTimeout(waitQueueMember.timer);
        if (!waitQueueMember[kCancelled]) {
          waitQueueMember.callback(err);
        }
      }
    }
    function processWaitQueue(topology) {
      if (topology.s.state === STATE_CLOSED) {
        drainWaitQueue(topology[kWaitQueue], new MongoError("Topology is closed, please connect"));
        return;
      }
      const serverDescriptions = Array.from(topology.description.servers.values());
      const membersToProcess = topology[kWaitQueue].length;
      for (let i = 0; i < membersToProcess && topology[kWaitQueue].length; ++i) {
        const waitQueueMember = topology[kWaitQueue].shift();
        if (waitQueueMember[kCancelled]) {
          continue;
        }
        let selectedDescriptions;
        try {
          const serverSelector = waitQueueMember.serverSelector;
          selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;
        } catch (e) {
          clearTimeout(waitQueueMember.timer);
          waitQueueMember.callback(e);
          continue;
        }
        if (selectedDescriptions.length === 0) {
          topology[kWaitQueue].push(waitQueueMember);
          continue;
        }
        const selectedServerDescription = randomSelection(selectedDescriptions);
        const selectedServer = topology.s.servers.get(selectedServerDescription.address);
        const transaction = waitQueueMember.transaction;
        const isSharded = topology.description.type === TopologyType.Sharded;
        if (isSharded && transaction && transaction.isActive) {
          transaction.pinServer(selectedServer);
        }
        clearTimeout(waitQueueMember.timer);
        waitQueueMember.callback(void 0, selectedServer);
      }
      if (topology[kWaitQueue].length > 0) {
        topology.s.servers.forEach((server) => process.nextTick(() => server.requestCheck()));
      }
    }
    module2.exports = {
      Topology
    };
  }
});

// node_modules/mongodb/lib/core/uri_parser.js
var require_uri_parser = __commonJS({
  "node_modules/mongodb/lib/core/uri_parser.js"(exports2, module2) {
    "use strict";
    var URL = require("url");
    var qs = require("querystring");
    var dns = require("dns");
    var MongoParseError = require_error().MongoParseError;
    var ReadPreference = require_read_preference();
    var emitWarningOnce = require_utils6().emitWarningOnce;
    var HOSTS_RX = /(mongodb(?:\+srv|)):\/\/(?: (?:[^:]*) (?: : ([^@]*) )? @ )?([^/?]*)(?:\/|)(.*)/;
    var FILE_PATH_OPTIONS = new Set(["sslCA", "sslCert", "sslKey", "tlsCAFile", "tlsCertificateKeyFile"].map((key) => key.toLowerCase()));
    function matchesParentDomain(srvAddress, parentDomain) {
      const regex = /^.*?\./;
      const srv = `.${srvAddress.replace(regex, "")}`;
      const parent = `.${parentDomain.replace(regex, "")}`;
      return srv.endsWith(parent);
    }
    function parseSrvConnectionString(uri, options, callback) {
      const result = URL.parse(uri, true);
      if (options.directConnection || options.directconnection) {
        return callback(new MongoParseError("directConnection not supported with SRV URI"));
      }
      if (result.hostname.split(".").length < 3) {
        return callback(new MongoParseError("URI does not have hostname, domain name and tld"));
      }
      result.domainLength = result.hostname.split(".").length;
      const hostname = uri.substring("mongodb+srv://".length).split("/")[0];
      if (hostname.match(",")) {
        return callback(new MongoParseError("Invalid URI, cannot contain multiple hostnames"));
      }
      if (result.port) {
        return callback(new MongoParseError(`Ports not accepted with '${PROTOCOL_MONGODB_SRV}' URIs`));
      }
      const lookupAddress = result.host;
      dns.resolveSrv(`_mongodb._tcp.${lookupAddress}`, (err, addresses) => {
        if (err)
          return callback(err);
        if (addresses.length === 0) {
          return callback(new MongoParseError("No addresses found at host"));
        }
        for (let i = 0; i < addresses.length; i++) {
          if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
            return callback(new MongoParseError("Server record does not share hostname with parent URI"));
          }
        }
        result.protocol = "mongodb";
        result.host = addresses.map((address) => `${address.name}:${address.port}`).join(",");
        if (!("ssl" in options) && (!result.search || !("ssl" in result.query) || result.query.ssl === null)) {
          result.query.ssl = true;
        }
        dns.resolveTxt(lookupAddress, (err2, record) => {
          if (err2) {
            if (err2.code !== "ENODATA" && err2.code !== "ENOTFOUND") {
              return callback(err2);
            }
            record = null;
          }
          if (record) {
            if (record.length > 1) {
              return callback(new MongoParseError("Multiple text records not allowed"));
            }
            record = qs.parse(record[0].join(""));
            if (Object.keys(record).some((key) => key !== "authSource" && key !== "replicaSet")) {
              return callback(new MongoParseError("Text record must only set `authSource` or `replicaSet`"));
            }
            result.query = Object.assign({}, record, result.query);
          }
          result.search = qs.stringify(result.query);
          const finalString = URL.format(result);
          parseConnectionString(finalString, options, (err3, ret2) => {
            if (err3) {
              callback(err3);
              return;
            }
            callback(null, Object.assign({}, ret2, { srvHost: lookupAddress }));
          });
        });
      });
    }
    function parseQueryStringItemValue(key, value) {
      if (Array.isArray(value)) {
        value = value.filter((v, idx) => value.indexOf(v) === idx);
        if (value.length === 1)
          value = value[0];
      } else if (value.indexOf(":") > 0) {
        value = value.split(",").reduce((result, pair) => {
          const parts = pair.split(":");
          result[parts[0]] = parseQueryStringItemValue(key, parts[1]);
          return result;
        }, {});
      } else if (value.indexOf(",") > 0) {
        value = value.split(",").map((v) => {
          return parseQueryStringItemValue(key, v);
        });
      } else if (value.toLowerCase() === "true" || value.toLowerCase() === "false") {
        value = value.toLowerCase() === "true";
      } else if (!Number.isNaN(value) && !STRING_OPTIONS.has(key)) {
        const numericValue = parseFloat(value);
        if (!Number.isNaN(numericValue)) {
          value = parseFloat(value);
        }
      }
      return value;
    }
    var BOOLEAN_OPTIONS = new Set([
      "slaveok",
      "slave_ok",
      "sslvalidate",
      "fsync",
      "safe",
      "retrywrites",
      "j"
    ]);
    var STRING_OPTIONS = new Set(["authsource", "replicaset"]);
    var AUTH_MECHANISMS = new Set([
      "GSSAPI",
      "MONGODB-AWS",
      "MONGODB-X509",
      "MONGODB-CR",
      "DEFAULT",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256",
      "PLAIN"
    ]);
    var CASE_TRANSLATION = {
      replicaset: "replicaSet",
      connecttimeoutms: "connectTimeoutMS",
      sockettimeoutms: "socketTimeoutMS",
      maxpoolsize: "maxPoolSize",
      minpoolsize: "minPoolSize",
      maxidletimems: "maxIdleTimeMS",
      waitqueuemultiple: "waitQueueMultiple",
      waitqueuetimeoutms: "waitQueueTimeoutMS",
      wtimeoutms: "wtimeoutMS",
      readconcern: "readConcern",
      readconcernlevel: "readConcernLevel",
      readpreference: "readPreference",
      maxstalenessseconds: "maxStalenessSeconds",
      readpreferencetags: "readPreferenceTags",
      authsource: "authSource",
      authmechanism: "authMechanism",
      authmechanismproperties: "authMechanismProperties",
      gssapiservicename: "gssapiServiceName",
      localthresholdms: "localThresholdMS",
      serverselectiontimeoutms: "serverSelectionTimeoutMS",
      serverselectiontryonce: "serverSelectionTryOnce",
      heartbeatfrequencyms: "heartbeatFrequencyMS",
      retrywrites: "retryWrites",
      uuidrepresentation: "uuidRepresentation",
      zlibcompressionlevel: "zlibCompressionLevel",
      tlsallowinvalidcertificates: "tlsAllowInvalidCertificates",
      tlsallowinvalidhostnames: "tlsAllowInvalidHostnames",
      tlsinsecure: "tlsInsecure",
      tlscafile: "tlsCAFile",
      tlscertificatekeyfile: "tlsCertificateKeyFile",
      tlscertificatekeyfilepassword: "tlsCertificateKeyFilePassword",
      wtimeout: "wTimeoutMS",
      j: "journal",
      directconnection: "directConnection"
    };
    function applyConnectionStringOption(obj, key, value, options) {
      if (key === "journal") {
        key = "j";
      } else if (key === "wtimeoutms") {
        key = "wtimeout";
      }
      if (BOOLEAN_OPTIONS.has(key)) {
        value = value === "true" || value === true;
      } else if (key === "appname") {
        value = decodeURIComponent(value);
      } else if (key === "readconcernlevel") {
        obj["readConcernLevel"] = value;
        key = "readconcern";
        value = { level: value };
      }
      if (key === "compressors") {
        value = Array.isArray(value) ? value : [value];
        if (!value.every((c) => c === "snappy" || c === "zlib")) {
          throw new MongoParseError("Value for `compressors` must be at least one of: `snappy`, `zlib`");
        }
      }
      if (key === "authmechanism" && !AUTH_MECHANISMS.has(value)) {
        throw new MongoParseError(`Value for authMechanism must be one of: ${Array.from(AUTH_MECHANISMS).join(", ")}, found: ${value}`);
      }
      if (key === "readpreference" && !ReadPreference.isValid(value)) {
        throw new MongoParseError("Value for `readPreference` must be one of: `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred`, `nearest`");
      }
      if (key === "zlibcompressionlevel" && (value < -1 || value > 9)) {
        throw new MongoParseError("zlibCompressionLevel must be an integer between -1 and 9");
      }
      if (key === "compressors" || key === "zlibcompressionlevel") {
        obj.compression = obj.compression || {};
        obj = obj.compression;
      }
      if (key === "authmechanismproperties") {
        if (typeof value.SERVICE_NAME === "string")
          obj.gssapiServiceName = value.SERVICE_NAME;
        if (typeof value.SERVICE_REALM === "string")
          obj.gssapiServiceRealm = value.SERVICE_REALM;
        if (typeof value.CANONICALIZE_HOST_NAME !== "undefined") {
          obj.gssapiCanonicalizeHostName = value.CANONICALIZE_HOST_NAME;
        }
      }
      if (key === "readpreferencetags") {
        value = Array.isArray(value) ? splitArrayOfMultipleReadPreferenceTags(value) : [value];
      }
      if (options.caseTranslate && CASE_TRANSLATION[key]) {
        obj[CASE_TRANSLATION[key]] = value;
        return;
      }
      obj[key] = value;
    }
    var USERNAME_REQUIRED_MECHANISMS = new Set([
      "GSSAPI",
      "MONGODB-CR",
      "PLAIN",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256"
    ]);
    function splitArrayOfMultipleReadPreferenceTags(value) {
      const parsedTags = [];
      for (let i = 0; i < value.length; i++) {
        parsedTags[i] = {};
        value[i].split(",").forEach((individualTag) => {
          const splitTag = individualTag.split(":");
          parsedTags[i][splitTag[0]] = splitTag[1];
        });
      }
      return parsedTags;
    }
    function applyAuthExpectations(parsed) {
      if (parsed.options == null) {
        return;
      }
      const options = parsed.options;
      const authSource = options.authsource || options.authSource;
      if (authSource != null) {
        parsed.auth = Object.assign({}, parsed.auth, { db: authSource });
      }
      const authMechanism = options.authmechanism || options.authMechanism;
      if (authMechanism != null) {
        if (USERNAME_REQUIRED_MECHANISMS.has(authMechanism) && (!parsed.auth || parsed.auth.username == null)) {
          throw new MongoParseError(`Username required for mechanism \`${authMechanism}\``);
        }
        if (authMechanism === "GSSAPI") {
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
          }
          parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
        }
        if (authMechanism === "MONGODB-AWS") {
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
          }
          parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
        }
        if (authMechanism === "MONGODB-X509") {
          if (parsed.auth && parsed.auth.password != null) {
            throw new MongoParseError(`Password not allowed for mechanism \`${authMechanism}\``);
          }
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
          }
          parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
        }
        if (authMechanism === "PLAIN") {
          if (parsed.auth && parsed.auth.db == null) {
            parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
          }
        }
      }
      if (parsed.auth && parsed.auth.db == null) {
        parsed.auth = Object.assign({}, parsed.auth, { db: "admin" });
      }
      return parsed;
    }
    function parseQueryString(query, options) {
      const result = {};
      let parsedQueryString = qs.parse(query);
      checkTLSOptions(parsedQueryString);
      for (const key in parsedQueryString) {
        const value = parsedQueryString[key];
        if (value === "" || value == null) {
          throw new MongoParseError("Incomplete key value pair for option");
        }
        const normalizedKey = key.toLowerCase();
        const parsedValue = FILE_PATH_OPTIONS.has(normalizedKey) ? value : parseQueryStringItemValue(normalizedKey, value);
        applyConnectionStringOption(result, normalizedKey, parsedValue, options);
      }
      if (result.wtimeout && result.wtimeoutms) {
        delete result.wtimeout;
        emitWarningOnce("Unsupported option `wtimeout` specified");
      }
      return Object.keys(result).length ? result : null;
    }
    function translateTLSOptions(queryString) {
      if (queryString.tls) {
        queryString.ssl = queryString.tls;
      }
      if (queryString.tlsInsecure) {
        queryString.checkServerIdentity = false;
        queryString.sslValidate = false;
      } else {
        Object.assign(queryString, {
          checkServerIdentity: queryString.tlsAllowInvalidHostnames ? false : true,
          sslValidate: queryString.tlsAllowInvalidCertificates ? false : true
        });
      }
      if (queryString.tlsCAFile) {
        queryString.ssl = true;
        queryString.sslCA = queryString.tlsCAFile;
      }
      if (queryString.tlsCertificateKeyFile) {
        queryString.ssl = true;
        if (queryString.tlsCertificateFile) {
          queryString.sslCert = queryString.tlsCertificateFile;
          queryString.sslKey = queryString.tlsCertificateKeyFile;
        } else {
          queryString.sslKey = queryString.tlsCertificateKeyFile;
          queryString.sslCert = queryString.tlsCertificateKeyFile;
        }
      }
      if (queryString.tlsCertificateKeyFilePassword) {
        queryString.ssl = true;
        queryString.sslPass = queryString.tlsCertificateKeyFilePassword;
      }
      return queryString;
    }
    function checkTLSOptions(queryString) {
      const queryStringKeys = Object.keys(queryString);
      if (queryStringKeys.indexOf("tlsInsecure") !== -1 && (queryStringKeys.indexOf("tlsAllowInvalidCertificates") !== -1 || queryStringKeys.indexOf("tlsAllowInvalidHostnames") !== -1)) {
        throw new MongoParseError("The `tlsInsecure` option cannot be used with `tlsAllowInvalidCertificates` or `tlsAllowInvalidHostnames`.");
      }
      const tlsValue = assertTlsOptionsAreEqual("tls", queryString, queryStringKeys);
      const sslValue = assertTlsOptionsAreEqual("ssl", queryString, queryStringKeys);
      if (tlsValue != null && sslValue != null) {
        if (tlsValue !== sslValue) {
          throw new MongoParseError("All values of `tls` and `ssl` must be the same.");
        }
      }
    }
    function assertTlsOptionsAreEqual(optionName, queryString, queryStringKeys) {
      const queryStringHasTLSOption = queryStringKeys.indexOf(optionName) !== -1;
      let optionValue;
      if (Array.isArray(queryString[optionName])) {
        optionValue = queryString[optionName][0];
      } else {
        optionValue = queryString[optionName];
      }
      if (queryStringHasTLSOption) {
        if (Array.isArray(queryString[optionName])) {
          const firstValue = queryString[optionName][0];
          queryString[optionName].forEach((tlsValue) => {
            if (tlsValue !== firstValue) {
              throw new MongoParseError(`All values of ${optionName} must be the same.`);
            }
          });
        }
      }
      return optionValue;
    }
    var PROTOCOL_MONGODB = "mongodb";
    var PROTOCOL_MONGODB_SRV = "mongodb+srv";
    var SUPPORTED_PROTOCOLS = [PROTOCOL_MONGODB, PROTOCOL_MONGODB_SRV];
    function parseConnectionString(uri, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, { caseTranslate: true }, options);
      try {
        URL.parse(uri);
      } catch (e) {
        return callback(new MongoParseError("URI malformed, cannot be parsed"));
      }
      const cap = uri.match(HOSTS_RX);
      if (!cap) {
        return callback(new MongoParseError("Invalid connection string"));
      }
      const protocol = cap[1];
      if (SUPPORTED_PROTOCOLS.indexOf(protocol) === -1) {
        return callback(new MongoParseError("Invalid protocol provided"));
      }
      const dbAndQuery = cap[4].split("?");
      const db = dbAndQuery.length > 0 ? dbAndQuery[0] : null;
      const query = dbAndQuery.length > 1 ? dbAndQuery[1] : null;
      let parsedOptions;
      try {
        parsedOptions = parseQueryString(query, options);
      } catch (parseError) {
        return callback(parseError);
      }
      parsedOptions = Object.assign({}, parsedOptions, options);
      if (protocol === PROTOCOL_MONGODB_SRV) {
        return parseSrvConnectionString(uri, parsedOptions, callback);
      }
      const auth = { username: null, password: null, db: db && db !== "" ? qs.unescape(db) : null };
      if (parsedOptions.auth) {
        if (parsedOptions.auth.username)
          auth.username = parsedOptions.auth.username;
        if (parsedOptions.auth.user)
          auth.username = parsedOptions.auth.user;
        if (parsedOptions.auth.password)
          auth.password = parsedOptions.auth.password;
      } else {
        if (parsedOptions.username)
          auth.username = parsedOptions.username;
        if (parsedOptions.user)
          auth.username = parsedOptions.user;
        if (parsedOptions.password)
          auth.password = parsedOptions.password;
      }
      if (cap[4].split("?")[0].indexOf("@") !== -1) {
        return callback(new MongoParseError("Unescaped slash in userinfo section"));
      }
      const authorityParts = cap[3].split("@");
      if (authorityParts.length > 2) {
        return callback(new MongoParseError("Unescaped at-sign in authority section"));
      }
      if (authorityParts[0] == null || authorityParts[0] === "") {
        return callback(new MongoParseError("No username provided in authority section"));
      }
      if (authorityParts.length > 1) {
        const authParts = authorityParts.shift().split(":");
        if (authParts.length > 2) {
          return callback(new MongoParseError("Unescaped colon in authority section"));
        }
        if (authParts[0] === "") {
          return callback(new MongoParseError("Invalid empty username provided"));
        }
        if (!auth.username)
          auth.username = qs.unescape(authParts[0]);
        if (!auth.password)
          auth.password = authParts[1] ? qs.unescape(authParts[1]) : null;
      }
      let hostParsingError = null;
      const hosts = authorityParts.shift().split(",").map((host) => {
        let parsedHost = URL.parse(`mongodb://${host}`);
        if (parsedHost.path === "/:") {
          hostParsingError = new MongoParseError("Double colon in host identifier");
          return null;
        }
        if (host.match(/\.sock/)) {
          parsedHost.hostname = qs.unescape(host);
          parsedHost.port = null;
        }
        if (Number.isNaN(parsedHost.port)) {
          hostParsingError = new MongoParseError("Invalid port (non-numeric string)");
          return;
        }
        const result2 = {
          host: parsedHost.hostname,
          port: parsedHost.port ? parseInt(parsedHost.port) : 27017
        };
        if (result2.port === 0) {
          hostParsingError = new MongoParseError("Invalid port (zero) with hostname");
          return;
        }
        if (result2.port > 65535) {
          hostParsingError = new MongoParseError("Invalid port (larger than 65535) with hostname");
          return;
        }
        if (result2.port < 0) {
          hostParsingError = new MongoParseError("Invalid port (negative number)");
          return;
        }
        return result2;
      }).filter((host) => !!host);
      if (hostParsingError) {
        return callback(hostParsingError);
      }
      if (hosts.length === 0 || hosts[0].host === "" || hosts[0].host === null) {
        return callback(new MongoParseError("No hostname or hostnames provided in connection string"));
      }
      const directConnection = !!parsedOptions.directConnection;
      if (directConnection && hosts.length !== 1) {
        return callback(new MongoParseError("directConnection option requires exactly one host"));
      }
      if (parsedOptions.directConnection == null && hosts.length === 1 && parsedOptions.replicaSet == null) {
        parsedOptions.directConnection = true;
      }
      const result = {
        hosts,
        auth: auth.db || auth.username ? auth : null,
        options: Object.keys(parsedOptions).length ? parsedOptions : null
      };
      if (result.auth && result.auth.db) {
        result.defaultDatabase = result.auth.db;
      } else {
        result.defaultDatabase = "test";
      }
      result.options = translateTLSOptions(result.options);
      try {
        applyAuthExpectations(result);
      } catch (authError) {
        return callback(authError);
      }
      callback(null, result);
    }
    module2.exports = parseConnectionString;
  }
});

// node_modules/mongodb/lib/core/index.js
var require_core = __commonJS({
  "node_modules/mongodb/lib/core/index.js"(exports2, module2) {
    "use strict";
    var BSON2 = require_bson2();
    var require_optional = require_optional_require()(require);
    var EJSON = require_utils4().retrieveEJSON();
    try {
      const BSONNative = require_optional("bson-ext");
      if (BSONNative) {
        BSON2 = BSONNative;
      }
    } catch (err) {
    }
    module2.exports = {
      MongoError: require_error().MongoError,
      MongoNetworkError: require_error().MongoNetworkError,
      MongoParseError: require_error().MongoParseError,
      MongoTimeoutError: require_error().MongoTimeoutError,
      MongoServerSelectionError: require_error().MongoServerSelectionError,
      MongoWriteConcernError: require_error().MongoWriteConcernError,
      Connection: require_connection(),
      Server: require_server(),
      ReplSet: require_replset(),
      Mongos: require_mongos(),
      Logger: require_logger(),
      Cursor: require_cursor().CoreCursor,
      ReadPreference: require_read_preference(),
      Sessions: require_sessions(),
      BSON: BSON2,
      EJSON,
      Topology: require_topology().Topology,
      Query: require_commands().Query,
      MongoCredentials: require_mongo_credentials().MongoCredentials,
      defaultAuthProviders: require_defaultAuthProviders().defaultAuthProviders,
      MongoCR: require_mongocr(),
      X509: require_x509(),
      Plain: require_plain(),
      GSSAPI: require_gssapi(),
      ScramSHA1: require_scram().ScramSHA1,
      ScramSHA256: require_scram().ScramSHA256,
      parseConnectionString: require_uri_parser()
    };
  }
});

// node_modules/mongodb/lib/apm.js
var require_apm2 = __commonJS({
  "node_modules/mongodb/lib/apm.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var Instrumentation = class extends EventEmitter {
      constructor() {
        super();
      }
      instrument(MongoClient, callback) {
        this.$MongoClient = MongoClient;
        const $prototypeConnect = this.$prototypeConnect = MongoClient.prototype.connect;
        const instrumentation = this;
        MongoClient.prototype.connect = function(callback2) {
          this.s.options.monitorCommands = true;
          this.on("commandStarted", (event) => instrumentation.emit("started", event));
          this.on("commandSucceeded", (event) => instrumentation.emit("succeeded", event));
          this.on("commandFailed", (event) => instrumentation.emit("failed", event));
          return $prototypeConnect.call(this, callback2);
        };
        if (typeof callback === "function")
          callback(null, this);
      }
      uninstrument() {
        this.$MongoClient.prototype.connect = this.$prototypeConnect;
      }
    };
    module2.exports = Instrumentation;
  }
});

// node_modules/mongodb/lib/error.js
var require_error2 = __commonJS({
  "node_modules/mongodb/lib/error.js"(exports2, module2) {
    "use strict";
    var MongoNetworkError = require_core().MongoNetworkError;
    var GET_MORE_RESUMABLE_CODES = new Set([
      6,
      7,
      89,
      91,
      189,
      262,
      9001,
      10107,
      11600,
      11602,
      13435,
      13436,
      63,
      150,
      13388,
      234,
      133,
      43
    ]);
    function isResumableError(error, wireVersion) {
      if (error instanceof MongoNetworkError) {
        return true;
      }
      if (wireVersion >= 9) {
        if (error.code === 43) {
          return true;
        }
        return error.hasErrorLabel("ResumableChangeStreamError");
      }
      return GET_MORE_RESUMABLE_CODES.has(error.code);
    }
    module2.exports = { GET_MORE_RESUMABLE_CODES, isResumableError };
  }
});

// node_modules/mongodb/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/mongodb/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      SYSTEM_NAMESPACE_COLLECTION: "system.namespaces",
      SYSTEM_INDEX_COLLECTION: "system.indexes",
      SYSTEM_PROFILE_COLLECTION: "system.profile",
      SYSTEM_USER_COLLECTION: "system.users",
      SYSTEM_COMMAND_COLLECTION: "$cmd",
      SYSTEM_JS_COLLECTION: "system.js"
    };
  }
});

// node_modules/mongodb/lib/operations/db_ops.js
var require_db_ops = __commonJS({
  "node_modules/mongodb/lib/operations/db_ops.js"(exports2, module2) {
    "use strict";
    var applyWriteConcern = require_utils6().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var debugOptions = require_utils6().debugOptions;
    var handleCallback = require_utils6().handleCallback;
    var MongoError = require_core().MongoError;
    var parseIndexOptions = require_utils6().parseIndexOptions;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils6().toError;
    var extractCommand = require_command_utils().extractCommand;
    var CONSTANTS = require_constants2();
    var MongoDBNamespace = require_utils6().MongoDBNamespace;
    var debugFields = [
      "authSource",
      "w",
      "wtimeout",
      "j",
      "native_parser",
      "forceServerObjectId",
      "serializeFunctions",
      "raw",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "bufferMaxEntries",
      "numberOfRetries",
      "retryMiliSeconds",
      "readPreference",
      "pkFactory",
      "parentDb",
      "promiseLibrary",
      "noListener"
    ];
    function createIndex(db, name, fieldOrSpec, options, callback) {
      let finalOptions = Object.assign({}, { readPreference: ReadPreference.PRIMARY }, options);
      finalOptions = applyWriteConcern(finalOptions, { db }, options);
      if (finalOptions.writeConcern && typeof callback !== "function") {
        throw MongoError.create({
          message: "Cannot use a writeConcern without a provided callback",
          driver: true
        });
      }
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, (err, result) => {
        if (err == null)
          return handleCallback(callback, err, result);
        if (err.code === 67 || err.code === 11e3 || err.code === 85 || err.code === 86 || err.code === 11600 || err.code === 197) {
          return handleCallback(callback, err, result);
        }
        const doc = createCreateIndexCommand(db, name, fieldOrSpec, options);
        finalOptions.checkKeys = false;
        db.s.topology.insert(db.s.namespace.withCollection(CONSTANTS.SYSTEM_INDEX_COLLECTION), doc, finalOptions, (err2, result2) => {
          if (callback == null)
            return;
          if (err2)
            return handleCallback(callback, err2);
          if (result2 == null)
            return handleCallback(callback, null, null);
          if (result2.result.writeErrors)
            return handleCallback(callback, MongoError.create(result2.result.writeErrors[0]), null);
          handleCallback(callback, null, doc.name);
        });
      });
    }
    function createListener(db, e, object) {
      function listener(err) {
        if (object.listeners(e).length > 0) {
          object.emit(e, err, db);
          for (let i = 0; i < db.s.children.length; i++) {
            db.s.children[i].emit(e, err, db.s.children[i]);
          }
        }
      }
      return listener;
    }
    function ensureIndex(db, name, fieldOrSpec, options, callback) {
      const finalOptions = applyWriteConcern({}, { db }, options);
      const selector = createCreateIndexCommand(db, name, fieldOrSpec, options);
      const index_name = selector.name;
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      finalOptions.readPreference = ReadPreference.PRIMARY;
      indexInformation(db, name, finalOptions, (err, indexInformation2) => {
        if (err != null && err.code !== 26)
          return handleCallback(callback, err, null);
        if (indexInformation2 == null || !indexInformation2[index_name]) {
          createIndex(db, name, fieldOrSpec, options, callback);
        } else {
          if (typeof callback === "function")
            return handleCallback(callback, null, index_name);
        }
      });
    }
    function evaluate(db, code, parameters, options, callback) {
      let finalCode = code;
      let finalParameters = [];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      if (!(finalCode && finalCode._bsontype === "Code"))
        finalCode = new Code2(finalCode);
      if (parameters != null && !Array.isArray(parameters) && typeof parameters !== "function") {
        finalParameters = [parameters];
      } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== "function") {
        finalParameters = parameters;
      }
      let cmd = { $eval: finalCode, args: finalParameters };
      if (options["nolock"]) {
        cmd["nolock"] = options["nolock"];
      }
      options.readPreference = new ReadPreference(ReadPreference.PRIMARY);
      executeCommand(db, cmd, options, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result && result.ok === 1)
          return handleCallback(callback, null, result.retval);
        if (result)
          return handleCallback(callback, MongoError.create({ message: `eval failed: ${result.errmsg}`, driver: true }), null);
        handleCallback(callback, err, result);
      });
    }
    function executeCommand(db, command, options, callback) {
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      const dbName = options.dbName || options.authdb || db.databaseName;
      options.readPreference = ReadPreference.resolve(db, options);
      if (db.s.logger.isDebug()) {
        const extractedCommand = extractCommand(command);
        db.s.logger.debug(`executing command ${JSON.stringify(extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options))}]`);
      }
      db.s.topology.command(db.s.namespace.withCollection("$cmd"), command, options, (err, result) => {
        if (err)
          return handleCallback(callback, err);
        if (options.full)
          return handleCallback(callback, null, result);
        handleCallback(callback, null, result.result);
      });
    }
    function executeDbAdminCommand(db, command, options, callback) {
      const namespace = new MongoDBNamespace("admin", "$cmd");
      db.s.topology.command(namespace, command, options, (err, result) => {
        if (db.serverConfig && db.serverConfig.isDestroyed()) {
          return callback(new MongoError("topology was destroyed"));
        }
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, result.result);
      });
    }
    function indexInformation(db, name, options, callback) {
      const full = options["full"] == null ? false : options["full"];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      function processResults(indexes) {
        let info = {};
        for (let i = 0; i < indexes.length; i++) {
          const index = indexes[i];
          info[index.name] = [];
          for (let name2 in index.key) {
            info[index.name].push([name2, index.key[name2]]);
          }
        }
        return info;
      }
      db.collection(name).listIndexes(options).toArray((err, indexes) => {
        if (err)
          return callback(toError(err));
        if (!Array.isArray(indexes))
          return handleCallback(callback, null, []);
        if (full)
          return handleCallback(callback, null, indexes);
        handleCallback(callback, null, processResults(indexes));
      });
    }
    function profilingInfo(db, options, callback) {
      try {
        db.collection("system.profile").find({}, options).toArray(callback);
      } catch (err) {
        return callback(err, null);
      }
    }
    function validateDatabaseName(databaseName) {
      if (typeof databaseName !== "string")
        throw MongoError.create({ message: "database name must be a string", driver: true });
      if (databaseName.length === 0)
        throw MongoError.create({ message: "database name cannot be the empty string", driver: true });
      if (databaseName === "$external")
        return;
      const invalidChars = [" ", ".", "$", "/", "\\"];
      for (let i = 0; i < invalidChars.length; i++) {
        if (databaseName.indexOf(invalidChars[i]) !== -1)
          throw MongoError.create({
            message: "database names cannot contain the character '" + invalidChars[i] + "'",
            driver: true
          });
      }
    }
    function createCreateIndexCommand(db, name, fieldOrSpec, options) {
      const indexParameters = parseIndexOptions(fieldOrSpec);
      const fieldHash = indexParameters.fieldHash;
      const indexName = typeof options.name === "string" ? options.name : indexParameters.name;
      const selector = {
        ns: db.s.namespace.withCollection(name).toString(),
        key: fieldHash,
        name: indexName
      };
      const finalUnique = options == null || typeof options === "object" ? false : options;
      options = options == null || typeof options === "boolean" ? {} : options;
      const keysToOmit = Object.keys(selector);
      for (let optionName in options) {
        if (keysToOmit.indexOf(optionName) === -1) {
          selector[optionName] = options[optionName];
        }
      }
      if (selector["unique"] == null)
        selector["unique"] = finalUnique;
      const removeKeys = ["w", "wtimeout", "j", "fsync", "readPreference", "session"];
      for (let i = 0; i < removeKeys.length; i++) {
        delete selector[removeKeys[i]];
      }
      return selector;
    }
    function createIndexUsingCreateIndexes(db, name, fieldOrSpec, options, callback) {
      const indexParameters = parseIndexOptions(fieldOrSpec);
      const indexName = typeof options.name === "string" ? options.name : indexParameters.name;
      const indexes = [{ name: indexName, key: indexParameters.fieldHash }];
      const keysToOmit = Object.keys(indexes[0]).concat([
        "writeConcern",
        "w",
        "wtimeout",
        "j",
        "fsync",
        "readPreference",
        "session"
      ]);
      for (let optionName in options) {
        if (keysToOmit.indexOf(optionName) === -1) {
          indexes[0][optionName] = options[optionName];
        }
      }
      const capabilities = db.s.topology.capabilities();
      if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {
        const error = new MongoError("server/primary/mongos does not support collation");
        error.code = 67;
        return callback(error);
      }
      const cmd = applyWriteConcern({ createIndexes: name, indexes }, { db }, options);
      options.readPreference = ReadPreference.PRIMARY;
      executeCommand(db, cmd, options, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result.ok === 0)
          return handleCallback(callback, toError(result), null);
        handleCallback(callback, null, indexName);
      });
    }
    module2.exports = {
      createListener,
      createIndex,
      ensureIndex,
      evaluate,
      executeCommand,
      executeDbAdminCommand,
      indexInformation,
      profilingInfo,
      validateDatabaseName
    };
  }
});

// node_modules/mongodb/lib/operations/common_functions.js
var require_common_functions = __commonJS({
  "node_modules/mongodb/lib/operations/common_functions.js"(exports2, module2) {
    "use strict";
    var applyRetryableWrites = require_utils6().applyRetryableWrites;
    var applyWriteConcern = require_utils6().applyWriteConcern;
    var decorateWithCollation = require_utils6().decorateWithCollation;
    var decorateWithReadConcern = require_utils6().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var formattedOrderClause = require_utils6().formattedOrderClause;
    var handleCallback = require_utils6().handleCallback;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils6().toError;
    var CursorState = require_cursor().CursorState;
    var maxWireVersion = require_utils4().maxWireVersion;
    function buildCountCommand(collectionOrCursor, query, options) {
      const skip = options.skip;
      const limit = options.limit;
      let hint = options.hint;
      const maxTimeMS = options.maxTimeMS;
      query = query || {};
      const cmd = {
        count: options.collectionName,
        query
      };
      if (collectionOrCursor.s.numberOfRetries) {
        if (collectionOrCursor.options.hint) {
          hint = collectionOrCursor.options.hint;
        } else if (collectionOrCursor.cmd.hint) {
          hint = collectionOrCursor.cmd.hint;
        }
        decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.cmd);
      } else {
        decorateWithCollation(cmd, collectionOrCursor, options);
      }
      if (typeof skip === "number")
        cmd.skip = skip;
      if (typeof limit === "number")
        cmd.limit = limit;
      if (typeof maxTimeMS === "number")
        cmd.maxTimeMS = maxTimeMS;
      if (hint)
        cmd.hint = hint;
      decorateWithReadConcern(cmd, collectionOrCursor);
      return cmd;
    }
    function findAndModify(coll, query, sort, doc, options, callback) {
      const queryObject = {
        findAndModify: coll.collectionName,
        query
      };
      sort = formattedOrderClause(sort);
      if (sort) {
        queryObject.sort = sort;
      }
      queryObject.new = options.new ? true : false;
      queryObject.remove = options.remove ? true : false;
      queryObject.upsert = options.upsert ? true : false;
      const projection = options.projection || options.fields;
      if (projection) {
        queryObject.fields = projection;
      }
      if (options.arrayFilters) {
        queryObject.arrayFilters = options.arrayFilters;
        delete options.arrayFilters;
      }
      if (doc && !options.remove) {
        queryObject.update = doc;
      }
      if (options.maxTimeMS)
        queryObject.maxTimeMS = options.maxTimeMS;
      options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
      options.checkKeys = false;
      let finalOptions = Object.assign({}, options);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);
      if (finalOptions.writeConcern) {
        queryObject.writeConcern = finalOptions.writeConcern;
      }
      if (finalOptions.bypassDocumentValidation === true) {
        queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
      }
      finalOptions.readPreference = ReadPreference.primary;
      try {
        decorateWithCollation(queryObject, coll, finalOptions);
      } catch (err) {
        return callback(err, null);
      }
      executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        return handleCallback(callback, null, result);
      });
    }
    function indexInformation(db, name, options, callback) {
      const full = options["full"] == null ? false : options["full"];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      function processResults(indexes) {
        let info = {};
        for (let i = 0; i < indexes.length; i++) {
          const index = indexes[i];
          info[index.name] = [];
          for (let name2 in index.key) {
            info[index.name].push([name2, index.key[name2]]);
          }
        }
        return info;
      }
      db.collection(name).listIndexes(options).toArray((err, indexes) => {
        if (err)
          return callback(toError(err));
        if (!Array.isArray(indexes))
          return handleCallback(callback, null, []);
        if (full)
          return handleCallback(callback, null, indexes);
        handleCallback(callback, null, processResults(indexes));
      });
    }
    function prepareDocs(coll, docs, options) {
      const forceServerObjectId = typeof options.forceServerObjectId === "boolean" ? options.forceServerObjectId : coll.s.db.options.forceServerObjectId;
      if (forceServerObjectId === true) {
        return docs;
      }
      return docs.map((doc) => {
        if (forceServerObjectId !== true && doc._id == null) {
          doc._id = coll.s.pkFactory.createPk();
        }
        return doc;
      });
    }
    function nextObject(cursor, callback) {
      if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
        return handleCallback(callback, MongoError.create({ message: "Cursor is closed", driver: true }));
      }
      if (cursor.s.state === CursorState.INIT && cursor.cmd && cursor.cmd.sort) {
        try {
          cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
        } catch (err) {
          return handleCallback(callback, err);
        }
      }
      cursor._next((err, doc) => {
        cursor.s.state = CursorState.OPEN;
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, doc);
      });
    }
    function insertDocuments(coll, docs, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      docs = Array.isArray(docs) ? docs : [docs];
      let finalOptions = Object.assign({}, options);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);
      if (finalOptions.keepGoing === true)
        finalOptions.ordered = false;
      finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
      docs = prepareDocs(coll, docs, options);
      coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors)
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        result.ops = docs;
        handleCallback(callback, null, result);
      });
    }
    function removeDocuments(coll, selector, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {};
      } else if (typeof selector === "function") {
        callback = selector;
        options = {};
        selector = {};
      }
      options = options || {};
      let finalOptions = Object.assign({}, options);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);
      if (selector == null)
        selector = {};
      const op = { q: selector, limit: 0 };
      if (options.single) {
        op.limit = 1;
      } else if (finalOptions.retryWrites) {
        finalOptions.retryWrites = false;
      }
      if (options.hint) {
        op.hint = options.hint;
      }
      try {
        decorateWithCollation(finalOptions, coll, options);
      } catch (err) {
        return callback(err, null);
      }
      if (options.explain !== void 0 && maxWireVersion(coll.s.topology) < 3) {
        return callback ? callback(new MongoError(`server does not support explain on remove`)) : void 0;
      }
      coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors) {
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        }
        handleCallback(callback, null, result);
      });
    }
    function updateDocuments(coll, selector, document2, options, callback) {
      if (typeof options === "function")
        callback = options, options = null;
      if (options == null)
        options = {};
      if (!(typeof callback === "function"))
        callback = null;
      if (selector == null || typeof selector !== "object")
        return callback(toError("selector must be a valid JavaScript object"));
      if (document2 == null || typeof document2 !== "object")
        return callback(toError("document must be a valid JavaScript object"));
      let finalOptions = Object.assign({}, options);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);
      finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
      const op = { q: selector, u: document2 };
      op.upsert = options.upsert !== void 0 ? !!options.upsert : false;
      op.multi = options.multi !== void 0 ? !!options.multi : false;
      if (options.hint) {
        op.hint = options.hint;
      }
      if (finalOptions.arrayFilters) {
        op.arrayFilters = finalOptions.arrayFilters;
        delete finalOptions.arrayFilters;
      }
      if (finalOptions.retryWrites && op.multi) {
        finalOptions.retryWrites = false;
      }
      try {
        decorateWithCollation(finalOptions, coll, options);
      } catch (err) {
        return callback(err, null);
      }
      if (options.explain !== void 0 && maxWireVersion(coll.s.topology) < 3) {
        return callback ? callback(new MongoError(`server does not support explain on update`)) : void 0;
      }
      coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors)
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        handleCallback(callback, null, result);
      });
    }
    module2.exports = {
      buildCountCommand,
      findAndModify,
      indexInformation,
      nextObject,
      prepareDocs,
      insertDocuments,
      removeDocuments,
      updateDocuments
    };
  }
});

// node_modules/mongodb/lib/operations/collection_ops.js
var require_collection_ops = __commonJS({
  "node_modules/mongodb/lib/operations/collection_ops.js"(exports2, module2) {
    "use strict";
    var applyWriteConcern = require_utils6().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var createIndexDb = require_db_ops().createIndex;
    var decorateWithCollation = require_utils6().decorateWithCollation;
    var decorateWithReadConcern = require_utils6().decorateWithReadConcern;
    var ensureIndexDb = require_db_ops().ensureIndex;
    var evaluate = require_db_ops().evaluate;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils6().handleCallback;
    var indexInformationDb = require_db_ops().indexInformation;
    var Long2 = require_core().BSON.Long;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var insertDocuments = require_common_functions().insertDocuments;
    var updateDocuments = require_common_functions().updateDocuments;
    var groupFunction = 'function () {\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) {\nvar obj = c.next();\nvar key = {};\n\nfor (var i = 0, len = keys.length; i < len; ++i) {\nvar k = keys[i];\nkey[k] = obj[k];\n}\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) {\nvar newObj = Object.extend({}, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n}\n\nreduce_function(obj, aggObj);\n}\n\nreturn { "result": map.values() };\n}';
    function createIndex(coll, fieldOrSpec, options, callback) {
      createIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);
    }
    function createIndexes(coll, indexSpecs, options, callback) {
      const capabilities = coll.s.topology.capabilities();
      for (let i = 0; i < indexSpecs.length; i++) {
        if (indexSpecs[i].name == null) {
          const keys = [];
          if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {
            return callback(new MongoError("server/primary/mongos does not support collation"));
          }
          for (let name in indexSpecs[i].key) {
            keys.push(`${name}_${indexSpecs[i].key[name]}`);
          }
          indexSpecs[i].name = keys.join("_");
        }
      }
      options = Object.assign({}, options, { readPreference: ReadPreference.PRIMARY });
      executeCommand(coll.s.db, {
        createIndexes: coll.collectionName,
        indexes: indexSpecs
      }, options, callback);
    }
    function ensureIndex(coll, fieldOrSpec, options, callback) {
      ensureIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);
    }
    function group(coll, keys, condition, initial, reduce, finalize, command, options, callback) {
      if (command) {
        const reduceFunction = reduce && reduce._bsontype === "Code" ? reduce : new Code2(reduce);
        const selector = {
          group: {
            ns: coll.collectionName,
            $reduce: reduceFunction,
            cond: condition,
            initial,
            out: "inline"
          }
        };
        if (finalize != null)
          selector.group["finalize"] = finalize;
        if (typeof keys === "function" || keys && keys._bsontype === "Code") {
          selector.group.$keyf = keys && keys._bsontype === "Code" ? keys : new Code2(keys);
        } else {
          const hash = {};
          keys.forEach((key) => {
            hash[key] = 1;
          });
          selector.group.key = hash;
        }
        options = Object.assign({}, options);
        options.readPreference = ReadPreference.resolve(coll, options);
        decorateWithReadConcern(selector, coll, options);
        try {
          decorateWithCollation(selector, coll, options);
        } catch (err) {
          return callback(err, null);
        }
        executeCommand(coll.s.db, selector, options, (err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, result.retval);
        });
      } else {
        const scope = reduce != null && reduce._bsontype === "Code" ? reduce.scope : {};
        scope.ns = coll.collectionName;
        scope.keys = keys;
        scope.condition = condition;
        scope.initial = initial;
        const groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ";");
        evaluate(coll.s.db, new Code2(groupfn, scope), null, options, (err, results) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, results.result || results);
        });
      }
    }
    function indexes(coll, options, callback) {
      options = Object.assign({}, { full: true }, options);
      indexInformationDb(coll.s.db, coll.collectionName, options, callback);
    }
    function indexExists(coll, indexes2, options, callback) {
      indexInformation(coll, options, (err, indexInformation2) => {
        if (err != null)
          return handleCallback(callback, err, null);
        if (!Array.isArray(indexes2))
          return handleCallback(callback, null, indexInformation2[indexes2] != null);
        for (let i = 0; i < indexes2.length; i++) {
          if (indexInformation2[indexes2[i]] == null) {
            return handleCallback(callback, null, false);
          }
        }
        return handleCallback(callback, null, true);
      });
    }
    function indexInformation(coll, options, callback) {
      indexInformationDb(coll.s.db, coll.collectionName, options, callback);
    }
    function parallelCollectionScan(coll, options, callback) {
      const commandObject = {
        parallelCollectionScan: coll.collectionName,
        numCursors: options.numCursors
      };
      decorateWithReadConcern(commandObject, coll, options);
      const raw = options.raw;
      delete options["raw"];
      executeCommand(coll.s.db, commandObject, options, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, new Error("no result returned for parallelCollectionScan"), null);
        options = Object.assign({ explicitlyIgnoreSession: true }, options);
        const cursors = [];
        if (raw)
          options.raw = raw;
        for (let i = 0; i < result.cursors.length; i++) {
          const rawId = result.cursors[i].cursor.id;
          const cursorId = typeof rawId === "number" ? Long2.fromNumber(rawId) : rawId;
          cursors.push(coll.s.topology.cursor(coll.namespace, cursorId, options));
        }
        handleCallback(callback, null, cursors);
      });
    }
    function save(coll, doc, options, callback) {
      const finalOptions = applyWriteConcern(Object.assign({}, options), { db: coll.s.db, collection: coll }, options);
      if (doc._id != null) {
        finalOptions.upsert = true;
        return updateDocuments(coll, { _id: doc._id }, doc, finalOptions, callback);
      }
      insertDocuments(coll, [doc], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (doc == null)
          return handleCallback(callback, null, null);
        if (err)
          return handleCallback(callback, err, null);
        handleCallback(callback, null, result);
      });
    }
    module2.exports = {
      createIndex,
      createIndexes,
      ensureIndex,
      group,
      indexes,
      indexExists,
      indexInformation,
      parallelCollectionScan,
      save
    };
  }
});

// node_modules/mongodb/lib/operations/cursor_ops.js
var require_cursor_ops = __commonJS({
  "node_modules/mongodb/lib/operations/cursor_ops.js"(exports2, module2) {
    "use strict";
    var buildCountCommand = require_collection_ops().buildCountCommand;
    var handleCallback = require_utils6().handleCallback;
    var MongoError = require_core().MongoError;
    var push = Array.prototype.push;
    var CursorState = require_cursor().CursorState;
    function count(cursor, applySkipLimit, opts, callback) {
      if (applySkipLimit) {
        if (typeof cursor.cursorSkip() === "number")
          opts.skip = cursor.cursorSkip();
        if (typeof cursor.cursorLimit() === "number")
          opts.limit = cursor.cursorLimit();
      }
      if (opts.readPreference) {
        cursor.setReadPreference(opts.readPreference);
      }
      if (typeof opts.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
        opts.maxTimeMS = cursor.cmd.maxTimeMS;
      }
      let options = {};
      options.skip = opts.skip;
      options.limit = opts.limit;
      options.hint = opts.hint;
      options.maxTimeMS = opts.maxTimeMS;
      options.collectionName = cursor.namespace.collection;
      let command;
      try {
        command = buildCountCommand(cursor, cursor.cmd.query, options);
      } catch (err) {
        return callback(err);
      }
      cursor.server = cursor.topology.s.coreTopology;
      cursor.topology.command(cursor.namespace.withCollection("$cmd"), command, cursor.options, (err, result) => {
        callback(err, result ? result.result.n : null);
      });
    }
    function each(cursor, callback) {
      if (!callback)
        throw MongoError.create({ message: "callback is mandatory", driver: true });
      if (cursor.isNotified())
        return;
      if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {
        return handleCallback(callback, MongoError.create({ message: "Cursor is closed", driver: true }));
      }
      if (cursor.s.state === CursorState.INIT) {
        cursor.s.state = CursorState.OPEN;
      }
      let fn = null;
      if (cursor.bufferedCount() > 0) {
        while (fn = loop(cursor, callback))
          fn(cursor, callback);
        each(cursor, callback);
      } else {
        cursor.next((err, item) => {
          if (err)
            return handleCallback(callback, err);
          if (item == null) {
            return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, null));
          }
          if (handleCallback(callback, null, item) === false)
            return;
          each(cursor, callback);
        });
      }
    }
    function loop(cursor, callback) {
      if (cursor.bufferedCount() === 0)
        return;
      cursor._next(callback);
      return loop;
    }
    function toArray(cursor, callback) {
      const items = [];
      cursor.rewind();
      cursor.s.state = CursorState.INIT;
      const fetchDocs = () => {
        cursor._next((err, doc) => {
          if (err) {
            return handleCallback(callback, err);
          }
          if (doc == null) {
            return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, items));
          }
          items.push(doc);
          if (cursor.bufferedCount() > 0) {
            let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
            if (cursor.s.transforms && typeof cursor.s.transforms.doc === "function") {
              docs = docs.map(cursor.s.transforms.doc);
            }
            push.apply(items, docs);
          }
          fetchDocs();
        });
      };
      fetchDocs();
    }
    module2.exports = { count, each, toArray };
  }
});

// node_modules/mongodb/lib/operations/count.js
var require_count = __commonJS({
  "node_modules/mongodb/lib/operations/count.js"(exports2, module2) {
    "use strict";
    var buildCountCommand = require_common_functions().buildCountCommand;
    var OperationBase = require_operation().OperationBase;
    var CountOperation = class extends OperationBase {
      constructor(cursor, applySkipLimit, options) {
        super(options);
        this.cursor = cursor;
        this.applySkipLimit = applySkipLimit;
      }
      execute(callback) {
        const cursor = this.cursor;
        const applySkipLimit = this.applySkipLimit;
        const options = this.options;
        if (applySkipLimit) {
          if (typeof cursor.cursorSkip() === "number")
            options.skip = cursor.cursorSkip();
          if (typeof cursor.cursorLimit() === "number")
            options.limit = cursor.cursorLimit();
        }
        if (options.readPreference) {
          cursor.setReadPreference(options.readPreference);
        }
        if (typeof options.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
          options.maxTimeMS = cursor.cmd.maxTimeMS;
        }
        let finalOptions = {};
        finalOptions.skip = options.skip;
        finalOptions.limit = options.limit;
        finalOptions.hint = options.hint;
        finalOptions.maxTimeMS = options.maxTimeMS;
        finalOptions.collectionName = cursor.namespace.collection;
        let command;
        try {
          command = buildCountCommand(cursor, cursor.cmd.query, finalOptions);
        } catch (err) {
          return callback(err);
        }
        cursor.server = cursor.topology.s.coreTopology;
        cursor.topology.command(cursor.namespace.withCollection("$cmd"), command, cursor.options, (err, result) => {
          callback(err, result ? result.result.n : null);
        });
      }
    };
    module2.exports = CountOperation;
  }
});

// node_modules/mongodb/lib/cursor.js
var require_cursor2 = __commonJS({
  "node_modules/mongodb/lib/cursor.js"(exports2, module2) {
    "use strict";
    var Transform = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var deprecate = require("util").deprecate;
    var handleCallback = require_utils6().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var CoreCursor = require_cursor().CoreCursor;
    var CursorState = require_cursor().CursorState;
    var Map2 = require_core().BSON.Map;
    var maybePromise = require_utils6().maybePromise;
    var executeOperation = require_execute_operation();
    var formattedOrderClause = require_utils6().formattedOrderClause;
    var Explain = require_explain().Explain;
    var Aspect = require_operation().Aspect;
    var each = require_cursor_ops().each;
    var CountOperation = require_count();
    var flags = ["tailable", "oplogReplay", "noCursorTimeout", "awaitData", "exhaust", "partial"];
    var fields = ["numberOfRetries", "tailableRetryInterval"];
    var Cursor = class extends CoreCursor {
      constructor(topology, ns, cmd, options) {
        super(topology, ns, cmd, options);
        if (this.operation) {
          options = this.operation.options;
        }
        const numberOfRetries = options.numberOfRetries || 5;
        const tailableRetryInterval = options.tailableRetryInterval || 500;
        const currentNumberOfRetries = numberOfRetries;
        const promiseLibrary = options.promiseLibrary || Promise;
        this.s = {
          numberOfRetries,
          tailableRetryInterval,
          currentNumberOfRetries,
          state: CursorState.INIT,
          promiseLibrary,
          explicitlyIgnoreSession: !!options.explicitlyIgnoreSession
        };
        if (!options.explicitlyIgnoreSession && options.session) {
          this.cursorState.session = options.session;
        }
        if (this.options.noCursorTimeout === true) {
          this.addCursorFlag("noCursorTimeout", true);
        }
        let batchSize = 1e3;
        if (this.cmd.cursor && this.cmd.cursor.batchSize) {
          batchSize = this.cmd.cursor.batchSize;
        } else if (options.cursor && options.cursor.batchSize) {
          batchSize = options.cursor.batchSize;
        } else if (typeof options.batchSize === "number") {
          batchSize = options.batchSize;
        }
        this.setCursorBatchSize(batchSize);
      }
      get readPreference() {
        if (this.operation) {
          return this.operation.readPreference;
        }
        return this.options.readPreference;
      }
      get sortValue() {
        return this.cmd.sort;
      }
      _initializeCursor(callback) {
        if (this.operation && this.operation.session != null) {
          this.cursorState.session = this.operation.session;
        } else {
          if (!this.s.explicitlyIgnoreSession && !this.cursorState.session && this.topology.hasSessionSupport()) {
            this.cursorState.session = this.topology.startSession({ owner: this });
            if (this.operation) {
              this.operation.session = this.cursorState.session;
            }
          }
        }
        super._initializeCursor(callback);
      }
      hasNext(callback) {
        if (this.s.state === CursorState.CLOSED || this.isDead && this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          if (cursor.isNotified()) {
            return cb(null, false);
          }
          cursor._next((err, doc) => {
            if (err)
              return cb(err);
            if (doc == null || cursor.s.state === Cursor.CLOSED || cursor.isDead()) {
              return cb(null, false);
            }
            cursor.s.state = CursorState.OPEN;
            cursor.cursorState.cursorIndex--;
            if (cursor.cursorState.limit > 0) {
              cursor.cursorState.currentLimit--;
            }
            cb(null, true);
          });
        });
      }
      next(callback) {
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
            cb(MongoError.create({ message: "Cursor is closed", driver: true }));
            return;
          }
          if (cursor.s.state === CursorState.INIT && cursor.cmd.sort) {
            try {
              cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
            } catch (err) {
              return cb(err);
            }
          }
          cursor._next((err, doc) => {
            if (err)
              return cb(err);
            cursor.s.state = CursorState.OPEN;
            cb(null, doc);
          });
        });
      }
      filter(filter) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.query = filter;
        return this;
      }
      maxScan(maxScan) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.maxScan = maxScan;
        return this;
      }
      hint(hint) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.hint = hint;
        return this;
      }
      min(min) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.min = min;
        return this;
      }
      max(max) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.max = max;
        return this;
      }
      returnKey(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.returnKey = value;
        return this;
      }
      showRecordId(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.showDiskLoc = value;
        return this;
      }
      snapshot(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.snapshot = value;
        return this;
      }
      setCursorOption(field, value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (fields.indexOf(field) === -1) {
          throw MongoError.create({
            message: `option ${field} is not a supported option ${fields}`,
            driver: true
          });
        }
        this.s[field] = value;
        if (field === "numberOfRetries")
          this.s.currentNumberOfRetries = value;
        return this;
      }
      addCursorFlag(flag, value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (flags.indexOf(flag) === -1) {
          throw MongoError.create({
            message: `flag ${flag} is not a supported flag ${flags}`,
            driver: true
          });
        }
        if (typeof value !== "boolean") {
          throw MongoError.create({ message: `flag ${flag} must be a boolean value`, driver: true });
        }
        this.cmd[flag] = value;
        return this;
      }
      addQueryModifier(name, value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (name[0] !== "$") {
          throw MongoError.create({ message: `${name} is not a valid query modifier`, driver: true });
        }
        const field = name.substr(1);
        this.cmd[field] = value;
        if (field === "orderby")
          this.cmd.sort = this.cmd[field];
        return this;
      }
      comment(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.comment = value;
        return this;
      }
      maxAwaitTimeMS(value) {
        if (typeof value !== "number") {
          throw MongoError.create({ message: "maxAwaitTimeMS must be a number", driver: true });
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.maxAwaitTimeMS = value;
        return this;
      }
      maxTimeMS(value) {
        if (typeof value !== "number") {
          throw MongoError.create({ message: "maxTimeMS must be a number", driver: true });
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.maxTimeMS = value;
        return this;
      }
      project(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.fields = value;
        return this;
      }
      sort(keyOrList, direction) {
        if (this.options.tailable) {
          throw MongoError.create({ message: "Tailable cursor doesn't support sorting", driver: true });
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        let order = keyOrList;
        if (Array.isArray(order) && Array.isArray(order[0])) {
          order = new Map2(order.map((x) => {
            const value = [x[0], null];
            if (x[1] === "asc") {
              value[1] = 1;
            } else if (x[1] === "desc") {
              value[1] = -1;
            } else if (x[1] === 1 || x[1] === -1 || x[1].$meta) {
              value[1] = x[1];
            } else {
              throw new MongoError("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
            }
            return value;
          }));
        }
        if (direction != null) {
          order = [[keyOrList, direction]];
        }
        this.cmd.sort = order;
        return this;
      }
      batchSize(value) {
        if (this.options.tailable) {
          throw MongoError.create({
            message: "Tailable cursor doesn't support batchSize",
            driver: true
          });
        }
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value !== "number") {
          throw MongoError.create({ message: "batchSize requires an integer", driver: true });
        }
        this.cmd.batchSize = value;
        this.setCursorBatchSize(value);
        return this;
      }
      collation(value) {
        this.cmd.collation = value;
        return this;
      }
      limit(value) {
        if (this.options.tailable) {
          throw MongoError.create({ message: "Tailable cursor doesn't support limit", driver: true });
        }
        if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value !== "number") {
          throw MongoError.create({ message: "limit requires an integer", driver: true });
        }
        this.cmd.limit = value;
        this.setCursorLimit(value);
        return this;
      }
      skip(value) {
        if (this.options.tailable) {
          throw MongoError.create({ message: "Tailable cursor doesn't support skip", driver: true });
        }
        if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value !== "number") {
          throw MongoError.create({ message: "skip requires an integer", driver: true });
        }
        this.cmd.skip = value;
        this.setCursorSkip(value);
        return this;
      }
      each(callback) {
        this.rewind();
        this.s.state = CursorState.INIT;
        each(this, callback);
      }
      forEach(iterator, callback) {
        this.rewind();
        this.s.state = CursorState.INIT;
        if (typeof callback === "function") {
          each(this, (err, doc) => {
            if (err) {
              callback(err);
              return false;
            }
            if (doc != null) {
              try {
                iterator(doc);
              } catch (error) {
                callback(error);
                return false;
              }
              return true;
            }
            if (doc == null && callback) {
              const internalCallback = callback;
              callback = null;
              internalCallback(null);
              return false;
            }
          });
        } else {
          return new this.s.promiseLibrary((fulfill, reject) => {
            each(this, (err, doc) => {
              if (err) {
                reject(err);
                return false;
              } else if (doc == null) {
                fulfill(null);
                return false;
              } else {
                try {
                  iterator(doc);
                } catch (error) {
                  reject(error);
                  return false;
                }
                return true;
              }
            });
          });
        }
      }
      setReadPreference(readPreference) {
        if (this.s.state !== CursorState.INIT) {
          throw MongoError.create({
            message: "cannot change cursor readPreference after cursor has been accessed",
            driver: true
          });
        }
        if (readPreference instanceof ReadPreference) {
          this.options.readPreference = readPreference;
        } else if (typeof readPreference === "string") {
          this.options.readPreference = new ReadPreference(readPreference);
        } else {
          throw new TypeError("Invalid read preference: " + readPreference);
        }
        return this;
      }
      toArray(callback) {
        if (this.options.tailable) {
          throw MongoError.create({
            message: "Tailable cursor cannot be converted to array",
            driver: true
          });
        }
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          const items = [];
          cursor.rewind();
          cursor.s.state = CursorState.INIT;
          const fetchDocs = () => {
            cursor._next((err, doc) => {
              if (err) {
                return handleCallback(cb, err);
              }
              if (doc == null) {
                return cursor.close({ skipKillCursors: true }, () => handleCallback(cb, null, items));
              }
              items.push(doc);
              if (cursor.bufferedCount() > 0) {
                let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
                Array.prototype.push.apply(items, docs);
              }
              fetchDocs();
            });
          };
          fetchDocs();
        });
      }
      count(applySkipLimit, opts, callback) {
        if (this.cmd.query == null)
          throw MongoError.create({
            message: "count can only be used with find command",
            driver: true
          });
        if (typeof opts === "function")
          callback = opts, opts = {};
        opts = opts || {};
        if (typeof applySkipLimit === "function") {
          callback = applySkipLimit;
          applySkipLimit = true;
        }
        if (this.cursorState.session) {
          opts = Object.assign({}, opts, { session: this.cursorState.session });
        }
        const countOperation = new CountOperation(this, applySkipLimit, opts);
        return executeOperation(this.topology, countOperation, callback);
      }
      close(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = Object.assign({}, { skipKillCursors: false }, options);
        return maybePromise(this, callback, (cb) => {
          this.s.state = CursorState.CLOSED;
          if (!options.skipKillCursors) {
            this.kill();
          }
          this._endSession(() => {
            this.emit("close");
            cb(null, this);
          });
        });
      }
      map(transform) {
        if (this.cursorState.transforms && this.cursorState.transforms.doc) {
          const oldTransform = this.cursorState.transforms.doc;
          this.cursorState.transforms.doc = (doc) => {
            return transform(oldTransform(doc));
          };
        } else {
          this.cursorState.transforms = { doc: transform };
        }
        return this;
      }
      isClosed() {
        return this.isDead();
      }
      destroy(err) {
        if (err)
          this.emit("error", err);
        this.pause();
        this.close();
      }
      stream(options) {
        this.cursorState.streamOptions = options || {};
        return this;
      }
      transformStream(options) {
        const streamOptions = options || {};
        if (typeof streamOptions.transform === "function") {
          const stream = new Transform({
            objectMode: true,
            transform: function(chunk, encoding, callback) {
              this.push(streamOptions.transform(chunk));
              callback();
            }
          });
          return this.pipe(stream);
        }
        return this.pipe(new PassThrough({ objectMode: true }));
      }
      explain(verbosity, callback) {
        if (typeof verbosity === "function")
          callback = verbosity, verbosity = true;
        if (verbosity === void 0)
          verbosity = true;
        if (!this.operation || !this.operation.hasAspect(Aspect.EXPLAINABLE)) {
          throw new MongoError("This command cannot be explained");
        }
        this.operation.explain = new Explain(verbosity);
        return maybePromise(this, callback, (cb) => {
          CoreCursor.prototype._next.apply(this, [cb]);
        });
      }
      getLogger() {
        return this.logger;
      }
    };
    Cursor.prototype.maxTimeMs = Cursor.prototype.maxTimeMS;
    deprecate(Cursor.prototype.each, "Cursor.each is deprecated. Use Cursor.forEach instead.");
    deprecate(Cursor.prototype.maxScan, "Cursor.maxScan is deprecated, and will be removed in a later version");
    deprecate(Cursor.prototype.snapshot, "Cursor Snapshot is deprecated, and will be removed in a later version");
    module2.exports = Cursor;
  }
});

// node_modules/mongodb/lib/operations/command_v2.js
var require_command_v2 = __commonJS({
  "node_modules/mongodb/lib/operations/command_v2.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_core().ReadPreference;
    var ReadConcern = require_read_concern();
    var WriteConcern = require_write_concern();
    var maxWireVersion = require_utils4().maxWireVersion;
    var decorateWithExplain = require_utils6().decorateWithExplain;
    var commandSupportsReadConcern = require_sessions().commandSupportsReadConcern;
    var MongoError = require_error().MongoError;
    var extractCommand = require_command_utils().extractCommand;
    var SUPPORTS_WRITE_CONCERN_AND_COLLATION = 5;
    var CommandOperationV2 = class extends OperationBase {
      constructor(parent, options, operationOptions) {
        super(options);
        this.ns = parent.s.namespace.withCollection("$cmd");
        const propertyProvider = this.hasAspect(Aspect.NO_INHERIT_OPTIONS) ? void 0 : parent;
        this.readPreference = this.hasAspect(Aspect.WRITE_OPERATION) ? ReadPreference.primary : ReadPreference.resolve(propertyProvider, this.options);
        this.readConcern = resolveReadConcern(propertyProvider, this.options);
        this.writeConcern = resolveWriteConcern(propertyProvider, this.options);
        if (operationOptions && typeof operationOptions.fullResponse === "boolean") {
          this.fullResponse = true;
        }
        this.options.readPreference = this.readPreference;
        if (parent.s.logger) {
          this.logger = parent.s.logger;
        } else if (parent.s.db && parent.s.db.logger) {
          this.logger = parent.s.db.logger;
        }
      }
      executeCommand(server, cmd, callback) {
        this.server = server;
        const options = this.options;
        const serverWireVersion = maxWireVersion(server);
        const inTransaction = this.session && this.session.inTransaction();
        if (this.readConcern && commandSupportsReadConcern(cmd) && !inTransaction) {
          Object.assign(cmd, { readConcern: this.readConcern });
        }
        if (options.collation && serverWireVersion < SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
          callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));
          return;
        }
        if (serverWireVersion >= SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
          if (this.writeConcern && this.hasAspect(Aspect.WRITE_OPERATION)) {
            Object.assign(cmd, { writeConcern: this.writeConcern });
          }
          if (options.collation && typeof options.collation === "object") {
            Object.assign(cmd, { collation: options.collation });
          }
        }
        if (typeof options.maxTimeMS === "number") {
          cmd.maxTimeMS = options.maxTimeMS;
        }
        if (typeof options.comment === "string") {
          cmd.comment = options.comment;
        }
        if (this.hasAspect(Aspect.EXPLAINABLE) && this.explain) {
          if (serverWireVersion < 6 && cmd.aggregate) {
            cmd.explain = true;
          } else {
            cmd = decorateWithExplain(cmd, this.explain);
          }
        }
        if (this.logger && this.logger.isDebug()) {
          const extractedCommand = extractCommand(cmd);
          this.logger.debug(`executing command ${JSON.stringify(extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : cmd)} against ${this.ns}`);
        }
        server.command(this.ns.toString(), cmd, this.options, (err, result) => {
          if (err) {
            callback(err, null);
            return;
          }
          if (this.fullResponse) {
            callback(null, result);
            return;
          }
          callback(null, result.result);
        });
      }
    };
    function resolveWriteConcern(parent, options) {
      return WriteConcern.fromOptions(options) || parent && parent.writeConcern;
    }
    function resolveReadConcern(parent, options) {
      return ReadConcern.fromOptions(options) || parent && parent.readConcern;
    }
    module2.exports = CommandOperationV2;
  }
});

// node_modules/mongodb/lib/operations/aggregate.js
var require_aggregate = __commonJS({
  "node_modules/mongodb/lib/operations/aggregate.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var MongoError = require_core().MongoError;
    var maxWireVersion = require_utils4().maxWireVersion;
    var ReadPreference = require_core().ReadPreference;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DB_AGGREGATE_COLLECTION = 1;
    var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;
    var AggregateOperation = class extends CommandOperationV2 {
      constructor(parent, pipeline, options) {
        super(parent, options, { fullResponse: true });
        this.target = parent.s.namespace && parent.s.namespace.collection ? parent.s.namespace.collection : DB_AGGREGATE_COLLECTION;
        this.pipeline = pipeline;
        this.hasWriteStage = false;
        if (typeof options.out === "string") {
          this.pipeline = this.pipeline.concat({ $out: options.out });
          this.hasWriteStage = true;
        } else if (pipeline.length > 0) {
          const finalStage = pipeline[pipeline.length - 1];
          if (finalStage.$out || finalStage.$merge) {
            this.hasWriteStage = true;
          }
        }
        if (this.hasWriteStage) {
          this.readPreference = ReadPreference.primary;
        }
        if (this.explain && this.writeConcern) {
          throw new MongoError('"explain" cannot be used on an aggregate call with writeConcern');
        }
        if (options.cursor != null && typeof options.cursor !== "object") {
          throw new MongoError("cursor options must be an object");
        }
      }
      get canRetryRead() {
        return !this.hasWriteStage;
      }
      addToPipeline(stage) {
        this.pipeline.push(stage);
      }
      execute(server, callback) {
        const options = this.options;
        const serverWireVersion = maxWireVersion(server);
        const command = { aggregate: this.target, pipeline: this.pipeline };
        if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
          this.readConcern = null;
        }
        if (serverWireVersion >= 5) {
          if (this.hasWriteStage && this.writeConcern) {
            Object.assign(command, { writeConcern: this.writeConcern });
          }
        }
        if (options.bypassDocumentValidation === true) {
          command.bypassDocumentValidation = options.bypassDocumentValidation;
        }
        if (typeof options.allowDiskUse === "boolean") {
          command.allowDiskUse = options.allowDiskUse;
        }
        if (options.hint) {
          command.hint = options.hint;
        }
        if (this.explain) {
          options.full = false;
        }
        command.cursor = options.cursor || {};
        if (options.batchSize && !this.hasWriteStage) {
          command.cursor.batchSize = options.batchSize;
        }
        super.executeCommand(server, command, callback);
      }
    };
    defineAspects(AggregateOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = AggregateOperation;
  }
});

// node_modules/mongodb/lib/bulk/common.js
var require_common2 = __commonJS({
  "node_modules/mongodb/lib/bulk/common.js"(exports2, module2) {
    "use strict";
    var Long2 = require_core().BSON.Long;
    var MongoError = require_core().MongoError;
    var ObjectID2 = require_core().BSON.ObjectID;
    var BSON2 = require_core().BSON;
    var MongoWriteConcernError = require_core().MongoWriteConcernError;
    var emitWarningOnce = require_utils6().emitWarningOnce;
    var toError = require_utils6().toError;
    var handleCallback = require_utils6().handleCallback;
    var applyRetryableWrites = require_utils6().applyRetryableWrites;
    var applyWriteConcern = require_utils6().applyWriteConcern;
    var executeLegacyOperation = require_utils6().executeLegacyOperation;
    var isPromiseLike = require_utils6().isPromiseLike;
    var hasAtomicOperators = require_utils6().hasAtomicOperators;
    var maxWireVersion = require_utils4().maxWireVersion;
    var WRITE_CONCERN_ERROR = 64;
    var INSERT = 1;
    var UPDATE = 2;
    var REMOVE = 3;
    var bson = new BSON2([
      BSON2.Binary,
      BSON2.Code,
      BSON2.DBRef,
      BSON2.Decimal128,
      BSON2.Double,
      BSON2.Int32,
      BSON2.Long,
      BSON2.Map,
      BSON2.MaxKey,
      BSON2.MinKey,
      BSON2.ObjectId,
      BSON2.BSONRegExp,
      BSON2.Symbol,
      BSON2.Timestamp
    ]);
    var Batch = class {
      constructor(batchType, originalZeroIndex) {
        this.originalZeroIndex = originalZeroIndex;
        this.currentIndex = 0;
        this.originalIndexes = [];
        this.batchType = batchType;
        this.operations = [];
        this.size = 0;
        this.sizeBytes = 0;
      }
    };
    var kUpsertedIds = Symbol("upsertedIds");
    var kInsertedIds = Symbol("insertedIds");
    var BulkWriteResult = class {
      constructor(bulkResult) {
        this.result = bulkResult;
        this[kUpsertedIds] = void 0;
        this[kInsertedIds] = void 0;
      }
      get insertedCount() {
        return typeof this.result.nInserted !== "number" ? 0 : this.result.nInserted;
      }
      get matchedCount() {
        return typeof this.result.nMatched !== "number" ? 0 : this.result.nMatched;
      }
      get modifiedCount() {
        return typeof this.result.nModified !== "number" ? 0 : this.result.nModified;
      }
      get deletedCount() {
        return typeof this.result.nRemoved !== "number" ? 0 : this.result.nRemoved;
      }
      get upsertedCount() {
        return !this.result.upserted ? 0 : this.result.upserted.length;
      }
      get upsertedIds() {
        if (this[kUpsertedIds]) {
          return this[kUpsertedIds];
        }
        this[kUpsertedIds] = {};
        for (const doc of this.result.upserted || []) {
          this[kUpsertedIds][doc.index] = doc._id;
        }
        return this[kUpsertedIds];
      }
      get insertedIds() {
        if (this[kInsertedIds]) {
          return this[kInsertedIds];
        }
        this[kInsertedIds] = {};
        for (const doc of this.result.insertedIds || []) {
          this[kInsertedIds][doc.index] = doc._id;
        }
        return this[kInsertedIds];
      }
      get n() {
        return this.result.insertedCount;
      }
      get ok() {
        return this.result.ok;
      }
      get nInserted() {
        return this.result.nInserted;
      }
      get nUpserted() {
        return this.result.nUpserted;
      }
      get nMatched() {
        return this.result.nMatched;
      }
      get nModified() {
        return this.result.nModified;
      }
      get nRemoved() {
        return this.result.nRemoved;
      }
      getInsertedIds() {
        return this.result.insertedIds;
      }
      getUpsertedIds() {
        return this.result.upserted;
      }
      getUpsertedIdAt(index) {
        return this.result.upserted[index];
      }
      getRawResponse() {
        return this.result;
      }
      hasWriteErrors() {
        return this.result.writeErrors.length > 0;
      }
      getWriteErrorCount() {
        return this.result.writeErrors.length;
      }
      getWriteErrorAt(index) {
        if (index < this.result.writeErrors.length) {
          return this.result.writeErrors[index];
        }
        return null;
      }
      getWriteErrors() {
        return this.result.writeErrors;
      }
      getLastOp() {
        return this.result.lastOp;
      }
      getWriteConcernError() {
        if (this.result.writeConcernErrors.length === 0) {
          return null;
        } else if (this.result.writeConcernErrors.length === 1) {
          return this.result.writeConcernErrors[0];
        } else {
          let errmsg = "";
          for (let i = 0; i < this.result.writeConcernErrors.length; i++) {
            const err = this.result.writeConcernErrors[i];
            errmsg = errmsg + err.errmsg;
            if (i === 0)
              errmsg = errmsg + " and ";
          }
          return new WriteConcernError({ errmsg, code: WRITE_CONCERN_ERROR });
        }
      }
      toJSON() {
        return this.result;
      }
      toString() {
        return `BulkWriteResult(${this.toJSON(this.result)})`;
      }
      isOk() {
        return this.result.ok === 1;
      }
    };
    var WriteConcernError = class {
      constructor(err) {
        this.err = err;
      }
      get code() {
        return this.err.code;
      }
      get errmsg() {
        return this.err.errmsg;
      }
      toJSON() {
        return { code: this.err.code, errmsg: this.err.errmsg };
      }
      toString() {
        return `WriteConcernError(${this.err.errmsg})`;
      }
    };
    var WriteError = class {
      constructor(err) {
        this.err = err;
      }
      get code() {
        return this.err.code;
      }
      get index() {
        return this.err.index;
      }
      get errmsg() {
        return this.err.errmsg;
      }
      getOperation() {
        return this.err.op;
      }
      toJSON() {
        return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };
      }
      toString() {
        return `WriteError(${JSON.stringify(this.toJSON())})`;
      }
    };
    function mergeBatchResults(batch, bulkResult, err, result) {
      if (err) {
        result = err;
      } else if (result && result.result) {
        result = result.result;
      } else if (result == null) {
        return;
      }
      if (result.ok === 0 && bulkResult.ok === 1) {
        bulkResult.ok = 0;
        const writeError = {
          index: 0,
          code: result.code || 0,
          errmsg: result.message,
          op: batch.operations[0]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
        return;
      } else if (result.ok === 0 && bulkResult.ok === 0) {
        return;
      }
      if (result.opTime || result.lastOp) {
        const opTime = result.lastOp || result.opTime;
        let lastOpTS = null;
        let lastOpT = null;
        if (opTime && opTime._bsontype === "Timestamp") {
          if (bulkResult.lastOp == null) {
            bulkResult.lastOp = opTime;
          } else if (opTime.greaterThan(bulkResult.lastOp)) {
            bulkResult.lastOp = opTime;
          }
        } else {
          if (bulkResult.lastOp) {
            lastOpTS = typeof bulkResult.lastOp.ts === "number" ? Long2.fromNumber(bulkResult.lastOp.ts) : bulkResult.lastOp.ts;
            lastOpT = typeof bulkResult.lastOp.t === "number" ? Long2.fromNumber(bulkResult.lastOp.t) : bulkResult.lastOp.t;
          }
          const opTimeTS = typeof opTime.ts === "number" ? Long2.fromNumber(opTime.ts) : opTime.ts;
          const opTimeT = typeof opTime.t === "number" ? Long2.fromNumber(opTime.t) : opTime.t;
          if (bulkResult.lastOp == null) {
            bulkResult.lastOp = opTime;
          } else if (opTimeTS.greaterThan(lastOpTS)) {
            bulkResult.lastOp = opTime;
          } else if (opTimeTS.equals(lastOpTS)) {
            if (opTimeT.greaterThan(lastOpT)) {
              bulkResult.lastOp = opTime;
            }
          }
        }
      }
      if (batch.batchType === INSERT && result.n) {
        bulkResult.nInserted = bulkResult.nInserted + result.n;
      }
      if (batch.batchType === REMOVE && result.n) {
        bulkResult.nRemoved = bulkResult.nRemoved + result.n;
      }
      let nUpserted = 0;
      if (Array.isArray(result.upserted)) {
        nUpserted = result.upserted.length;
        for (let i = 0; i < result.upserted.length; i++) {
          bulkResult.upserted.push({
            index: result.upserted[i].index + batch.originalZeroIndex,
            _id: result.upserted[i]._id
          });
        }
      } else if (result.upserted) {
        nUpserted = 1;
        bulkResult.upserted.push({
          index: batch.originalZeroIndex,
          _id: result.upserted
        });
      }
      if (batch.batchType === UPDATE && result.n) {
        const nModified = result.nModified;
        bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
        bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
        if (typeof nModified === "number") {
          bulkResult.nModified = bulkResult.nModified + nModified;
        } else {
          bulkResult.nModified = null;
        }
      }
      if (Array.isArray(result.writeErrors)) {
        for (let i = 0; i < result.writeErrors.length; i++) {
          const writeError = {
            index: batch.originalIndexes[result.writeErrors[i].index],
            code: result.writeErrors[i].code,
            errmsg: result.writeErrors[i].errmsg,
            op: batch.operations[result.writeErrors[i].index]
          };
          bulkResult.writeErrors.push(new WriteError(writeError));
        }
      }
      if (result.writeConcernError) {
        bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
      }
    }
    function executeCommands(bulkOperation, options, callback) {
      if (bulkOperation.s.batches.length === 0) {
        return handleCallback(callback, null, new BulkWriteResult(bulkOperation.s.bulkResult));
      }
      const batch = bulkOperation.s.batches.shift();
      function resultHandler(err, result) {
        if ((err && err.driver || err && err.message) && !(err instanceof MongoWriteConcernError)) {
          return handleCallback(callback, err);
        }
        if (err)
          err.ok = 0;
        if (err instanceof MongoWriteConcernError) {
          return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);
        }
        const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);
        const mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);
        if (mergeResult != null) {
          return handleCallback(callback, null, writeResult);
        }
        if (bulkOperation.handleWriteError(callback, writeResult))
          return;
        executeCommands(bulkOperation, options, callback);
      }
      bulkOperation.finalOptionsHandler({ options, batch, resultHandler }, callback);
    }
    function handleMongoWriteConcernError(batch, bulkResult, err, callback) {
      mergeBatchResults(batch, bulkResult, null, err.result);
      const wrappedWriteConcernError = new WriteConcernError({
        errmsg: err.result.writeConcernError.errmsg,
        code: err.result.writeConcernError.result
      });
      return handleCallback(callback, new BulkWriteError(toError(wrappedWriteConcernError), new BulkWriteResult(bulkResult)), null);
    }
    var BulkWriteError = class extends MongoError {
      constructor(error, result) {
        const message = error.err || error.errmsg || error.errMessage || error;
        super(message);
        Object.assign(this, error);
        this.name = "BulkWriteError";
        this.result = result;
      }
      get insertedCount() {
        return this.result.insertedCount;
      }
      get matchedCount() {
        return this.result.matchedCount;
      }
      get modifiedCount() {
        return this.result.modifiedCount;
      }
      get deletedCount() {
        return this.result.deletedCount;
      }
      get upsertedCount() {
        return this.result.upsertedCount;
      }
      get insertedIds() {
        return this.result.insertedIds;
      }
      get upsertedIds() {
        return this.result.upsertedIds;
      }
    };
    var FindOperators = class {
      constructor(bulkOperation) {
        this.s = bulkOperation.s;
      }
      update(updateDocument) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document2 = {
          q: this.s.currentOp.selector,
          u: updateDocument,
          multi: true,
          upsert
        };
        if (updateDocument.hint) {
          document2.hint = updateDocument.hint;
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document2);
      }
      updateOne(updateDocument) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document2 = {
          q: this.s.currentOp.selector,
          u: updateDocument,
          multi: false,
          upsert
        };
        if (updateDocument.hint) {
          document2.hint = updateDocument.hint;
        }
        if (!hasAtomicOperators(updateDocument)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document2);
      }
      replaceOne(replacement) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document2 = {
          q: this.s.currentOp.selector,
          u: replacement,
          multi: false,
          upsert
        };
        if (replacement.hint) {
          document2.hint = replacement.hint;
        }
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not use atomic operators");
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document2);
      }
      upsert() {
        this.s.currentOp.upsert = true;
        return this;
      }
      deleteOne() {
        const document2 = {
          q: this.s.currentOp.selector,
          limit: 1
        };
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, REMOVE, document2);
      }
      delete() {
        const document2 = {
          q: this.s.currentOp.selector,
          limit: 0
        };
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, REMOVE, document2);
      }
      removeOne() {
        emitWarningOnce("bulk operation `removeOne` has been deprecated, please use `deleteOne`");
        return this.deleteOne();
      }
      remove() {
        emitWarningOnce("bulk operation `remove` has been deprecated, please use `delete`");
        return this.delete();
      }
    };
    var BulkOperationBase = class {
      constructor(topology, collection, options, isOrdered) {
        this.isOrdered = isOrdered;
        options = options == null ? {} : options;
        const namespace = collection.s.namespace;
        const executed = false;
        const currentOp = null;
        const bson2 = topology.bson;
        const isMaster = topology.lastIsMaster();
        const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
        const maxBsonObjectSize = isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;
        const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
        const maxWriteBatchSize = isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1e3;
        const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
        let finalOptions = Object.assign({}, options);
        finalOptions = applyRetryableWrites(finalOptions, collection.s.db);
        finalOptions = applyWriteConcern(finalOptions, { collection }, options);
        const writeConcern = finalOptions.writeConcern;
        const promiseLibrary = options.promiseLibrary || Promise;
        const bulkResult = {
          ok: 1,
          writeErrors: [],
          writeConcernErrors: [],
          insertedIds: [],
          nInserted: 0,
          nUpserted: 0,
          nMatched: 0,
          nModified: 0,
          nRemoved: 0,
          upserted: []
        };
        this.s = {
          bulkResult,
          currentBatch: null,
          currentIndex: 0,
          currentBatchSize: 0,
          currentBatchSizeBytes: 0,
          currentInsertBatch: null,
          currentUpdateBatch: null,
          currentRemoveBatch: null,
          batches: [],
          writeConcern,
          maxBsonObjectSize,
          maxBatchSizeBytes,
          maxWriteBatchSize,
          maxKeySize,
          namespace,
          bson: bson2,
          topology,
          options: finalOptions,
          currentOp,
          executed,
          collection,
          promiseLibrary,
          err: null,
          checkKeys: typeof options.checkKeys === "boolean" ? options.checkKeys : true
        };
        if (options.bypassDocumentValidation === true) {
          this.s.bypassDocumentValidation = true;
        }
      }
      insert(document2) {
        if (this.s.collection.s.db.options.forceServerObjectId !== true && document2._id == null)
          document2._id = new ObjectID2();
        return this.s.options.addToOperationsList(this, INSERT, document2);
      }
      find(selector) {
        if (!selector) {
          throw toError("Bulk find operation must specify a selector");
        }
        this.s.currentOp = {
          selector
        };
        return new FindOperators(this);
      }
      raw(op) {
        const key = Object.keys(op)[0];
        const forceServerObjectId = typeof this.s.options.forceServerObjectId === "boolean" ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId;
        if (op.updateOne && op.updateOne.q || op.updateMany && op.updateMany.q || op.replaceOne && op.replaceOne.q) {
          op[key].multi = op.updateOne || op.replaceOne ? false : true;
          return this.s.options.addToOperationsList(this, UPDATE, op[key]);
        }
        if (op.updateOne || op.updateMany || op.replaceOne) {
          if (op.replaceOne && hasAtomicOperators(op[key].replacement)) {
            throw new TypeError("Replacement document must not use atomic operators");
          } else if ((op.updateOne || op.updateMany) && !hasAtomicOperators(op[key].update)) {
            throw new TypeError("Update document requires atomic operators");
          }
          const multi = op.updateOne || op.replaceOne ? false : true;
          const operation = {
            q: op[key].filter,
            u: op[key].update || op[key].replacement,
            multi
          };
          if (op[key].hint) {
            operation.hint = op[key].hint;
          }
          if (this.isOrdered) {
            operation.upsert = op[key].upsert ? true : false;
            if (op.collation)
              operation.collation = op.collation;
          } else {
            if (op[key].upsert)
              operation.upsert = true;
          }
          if (op[key].arrayFilters) {
            if (maxWireVersion(this.s.topology) < 6) {
              throw new TypeError("arrayFilters are only supported on MongoDB 3.6+");
            }
            operation.arrayFilters = op[key].arrayFilters;
          }
          return this.s.options.addToOperationsList(this, UPDATE, operation);
        }
        if (op.removeOne || op.removeMany || op.deleteOne && op.deleteOne.q || op.deleteMany && op.deleteMany.q) {
          op[key].limit = op.removeOne ? 1 : 0;
          return this.s.options.addToOperationsList(this, REMOVE, op[key]);
        }
        if (op.deleteOne || op.deleteMany) {
          const limit = op.deleteOne ? 1 : 0;
          const operation = { q: op[key].filter, limit };
          if (op[key].hint) {
            operation.hint = op[key].hint;
          }
          if (this.isOrdered) {
            if (op.collation)
              operation.collation = op.collation;
          }
          return this.s.options.addToOperationsList(this, REMOVE, operation);
        }
        if (op.insertOne && op.insertOne.document == null) {
          if (forceServerObjectId !== true && op.insertOne._id == null)
            op.insertOne._id = new ObjectID2();
          return this.s.options.addToOperationsList(this, INSERT, op.insertOne);
        } else if (op.insertOne && op.insertOne.document) {
          if (forceServerObjectId !== true && op.insertOne.document._id == null)
            op.insertOne.document._id = new ObjectID2();
          return this.s.options.addToOperationsList(this, INSERT, op.insertOne.document);
        }
        if (op.insertMany) {
          emitWarningOnce("bulk operation `insertMany` has been deprecated; use multiple `insertOne` ops instead");
          for (let i = 0; i < op.insertMany.length; i++) {
            if (forceServerObjectId !== true && op.insertMany[i]._id == null)
              op.insertMany[i]._id = new ObjectID2();
            this.s.options.addToOperationsList(this, INSERT, op.insertMany[i]);
          }
          return;
        }
        throw toError("bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany");
      }
      _handleEarlyError(err, callback) {
        if (typeof callback === "function") {
          callback(err, null);
          return;
        }
        return this.s.promiseLibrary.reject(err);
      }
      bulkExecute(_writeConcern, options, callback) {
        if (typeof options === "function") {
          callback = options;
        }
        const finalOptions = Object.assign({}, this.s.options, options);
        if (typeof _writeConcern === "function") {
          callback = _writeConcern;
        } else if (_writeConcern && typeof _writeConcern === "object") {
          this.s.writeConcern = _writeConcern;
        }
        if (this.s.executed) {
          const executedError = toError("batch cannot be re-executed");
          return this._handleEarlyError(executedError, callback);
        }
        if (this.isOrdered) {
          if (this.s.currentBatch)
            this.s.batches.push(this.s.currentBatch);
        } else {
          if (this.s.currentInsertBatch)
            this.s.batches.push(this.s.currentInsertBatch);
          if (this.s.currentUpdateBatch)
            this.s.batches.push(this.s.currentUpdateBatch);
          if (this.s.currentRemoveBatch)
            this.s.batches.push(this.s.currentRemoveBatch);
        }
        if (this.s.batches.length === 0) {
          const emptyBatchError = toError("Invalid Operation, no operations specified");
          return this._handleEarlyError(emptyBatchError, callback);
        }
        return { options: finalOptions, callback };
      }
      execute(_writeConcern, options, callback) {
        const ret2 = this.bulkExecute(_writeConcern, options, callback);
        if (!ret2 || isPromiseLike(ret2)) {
          return ret2;
        }
        options = ret2.options;
        callback = ret2.callback;
        return executeLegacyOperation(this.s.topology, executeCommands, [this, options, callback]);
      }
      finalOptionsHandler(config, callback) {
        const finalOptions = Object.assign({ ordered: this.isOrdered }, config.options);
        if (this.s.writeConcern != null) {
          finalOptions.writeConcern = this.s.writeConcern;
        }
        if (finalOptions.bypassDocumentValidation !== true) {
          delete finalOptions.bypassDocumentValidation;
        }
        if (this.operationId) {
          config.resultHandler.operationId = this.operationId;
        }
        if (this.s.options.serializeFunctions) {
          finalOptions.serializeFunctions = true;
        }
        if (this.s.options.ignoreUndefined) {
          finalOptions.ignoreUndefined = true;
        }
        if (this.s.bypassDocumentValidation === true) {
          finalOptions.bypassDocumentValidation = true;
        }
        if (this.s.checkKeys === false) {
          finalOptions.checkKeys = false;
        }
        if (finalOptions.retryWrites) {
          if (config.batch.batchType === UPDATE) {
            finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some((op) => op.multi);
          }
          if (config.batch.batchType === REMOVE) {
            finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some((op) => op.limit === 0);
          }
        }
        try {
          if (config.batch.batchType === INSERT) {
            this.s.topology.insert(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
          } else if (config.batch.batchType === UPDATE) {
            this.s.topology.update(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
          } else if (config.batch.batchType === REMOVE) {
            this.s.topology.remove(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
          }
        } catch (err) {
          err.ok = 0;
          handleCallback(callback, null, mergeBatchResults(config.batch, this.s.bulkResult, err, null));
        }
      }
      handleWriteError(callback, writeResult) {
        if (this.s.bulkResult.writeErrors.length > 0) {
          const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : "write operation failed";
          handleCallback(callback, new BulkWriteError(toError({
            message: msg,
            code: this.s.bulkResult.writeErrors[0].code,
            writeErrors: this.s.bulkResult.writeErrors
          }), writeResult), null);
          return true;
        }
        if (writeResult.getWriteConcernError()) {
          handleCallback(callback, new BulkWriteError(toError(writeResult.getWriteConcernError()), writeResult), null);
          return true;
        }
      }
    };
    Object.defineProperty(BulkOperationBase.prototype, "length", {
      enumerable: true,
      get: function() {
        return this.s.currentIndex;
      }
    });
    module2.exports = {
      Batch,
      BulkOperationBase,
      bson,
      INSERT,
      UPDATE,
      REMOVE,
      BulkWriteError,
      BulkWriteResult
    };
  }
});

// node_modules/mongodb/lib/bulk/unordered.js
var require_unordered = __commonJS({
  "node_modules/mongodb/lib/bulk/unordered.js"(exports2, module2) {
    "use strict";
    var common = require_common2();
    var BulkOperationBase = common.BulkOperationBase;
    var Batch = common.Batch;
    var bson = common.bson;
    var utils2 = require_utils6();
    var toError = utils2.toError;
    function addToOperationsList(bulkOperation, docType, document2) {
      const bsonSize = bson.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
        throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
      bulkOperation.s.currentBatch = null;
      if (docType === common.INSERT) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentInsertBatch;
      } else if (docType === common.UPDATE) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentUpdateBatch;
      } else if (docType === common.REMOVE) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentRemoveBatch;
      }
      const maxKeySize = bulkOperation.s.maxKeySize;
      if (bulkOperation.s.currentBatch == null)
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      if (bulkOperation.s.currentBatch.size + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatch.size > 0 && bulkOperation.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
        bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      }
      if (Array.isArray(document2)) {
        throw toError("operation passed in cannot be an Array");
      }
      bulkOperation.s.currentBatch.operations.push(document2);
      bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
      bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1;
      if (docType === common.INSERT) {
        bulkOperation.s.currentInsertBatch = bulkOperation.s.currentBatch;
        bulkOperation.s.bulkResult.insertedIds.push({
          index: bulkOperation.s.bulkResult.insertedIds.length,
          _id: document2._id
        });
      } else if (docType === common.UPDATE) {
        bulkOperation.s.currentUpdateBatch = bulkOperation.s.currentBatch;
      } else if (docType === common.REMOVE) {
        bulkOperation.s.currentRemoveBatch = bulkOperation.s.currentBatch;
      }
      bulkOperation.s.currentBatch.size += 1;
      bulkOperation.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
      return bulkOperation;
    }
    var UnorderedBulkOperation = class extends BulkOperationBase {
      constructor(topology, collection, options) {
        options = options || {};
        options = Object.assign(options, { addToOperationsList });
        super(topology, collection, options, false);
      }
      handleWriteError(callback, writeResult) {
        if (this.s.batches.length) {
          return false;
        }
        return super.handleWriteError(callback, writeResult);
      }
    };
    function initializeUnorderedBulkOp(topology, collection, options) {
      return new UnorderedBulkOperation(topology, collection, options);
    }
    initializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;
    module2.exports = initializeUnorderedBulkOp;
    module2.exports.Bulk = UnorderedBulkOperation;
  }
});

// node_modules/mongodb/lib/bulk/ordered.js
var require_ordered = __commonJS({
  "node_modules/mongodb/lib/bulk/ordered.js"(exports2, module2) {
    "use strict";
    var common = require_common2();
    var BulkOperationBase = common.BulkOperationBase;
    var Batch = common.Batch;
    var bson = common.bson;
    var utils2 = require_utils6();
    var toError = utils2.toError;
    function addToOperationsList(bulkOperation, docType, document2) {
      const bsonSize = bson.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
        throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
      if (bulkOperation.s.currentBatch == null)
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      const maxKeySize = bulkOperation.s.maxKeySize;
      if (bulkOperation.s.currentBatchSize + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatchSize > 0 && bulkOperation.s.currentBatchSizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
        bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
        bulkOperation.s.currentBatchSize = 0;
        bulkOperation.s.currentBatchSizeBytes = 0;
      }
      if (docType === common.INSERT) {
        bulkOperation.s.bulkResult.insertedIds.push({
          index: bulkOperation.s.currentIndex,
          _id: document2._id
        });
      }
      if (Array.isArray(document2)) {
        throw toError("operation passed in cannot be an Array");
      }
      bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
      bulkOperation.s.currentBatch.operations.push(document2);
      bulkOperation.s.currentBatchSize += 1;
      bulkOperation.s.currentBatchSizeBytes += maxKeySize + bsonSize;
      bulkOperation.s.currentIndex += 1;
      return bulkOperation;
    }
    var OrderedBulkOperation = class extends BulkOperationBase {
      constructor(topology, collection, options) {
        options = options || {};
        options = Object.assign(options, { addToOperationsList });
        super(topology, collection, options, true);
      }
    };
    function initializeOrderedBulkOp(topology, collection, options) {
      return new OrderedBulkOperation(topology, collection, options);
    }
    initializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;
    module2.exports = initializeOrderedBulkOp;
    module2.exports.Bulk = OrderedBulkOperation;
  }
});

// node_modules/mongodb/lib/aggregation_cursor.js
var require_aggregation_cursor = __commonJS({
  "node_modules/mongodb/lib/aggregation_cursor.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var CursorState = require_cursor().CursorState;
    var AggregationCursor = class extends Cursor {
      constructor(topology, operation, options) {
        super(topology, operation, options);
      }
      batchSize(value) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value !== "number") {
          throw MongoError.create({ message: "batchSize requires an integer", driver: true });
        }
        this.operation.options.batchSize = value;
        this.setCursorBatchSize(value);
        return this;
      }
      geoNear(document2) {
        this.operation.addToPipeline({ $geoNear: document2 });
        return this;
      }
      group(document2) {
        this.operation.addToPipeline({ $group: document2 });
        return this;
      }
      limit(value) {
        this.operation.addToPipeline({ $limit: value });
        return this;
      }
      match(document2) {
        this.operation.addToPipeline({ $match: document2 });
        return this;
      }
      maxTimeMS(value) {
        this.operation.options.maxTimeMS = value;
        return this;
      }
      out(destination) {
        this.operation.addToPipeline({ $out: destination });
        return this;
      }
      project(document2) {
        this.operation.addToPipeline({ $project: document2 });
        return this;
      }
      lookup(document2) {
        this.operation.addToPipeline({ $lookup: document2 });
        return this;
      }
      redact(document2) {
        this.operation.addToPipeline({ $redact: document2 });
        return this;
      }
      skip(value) {
        this.operation.addToPipeline({ $skip: value });
        return this;
      }
      sort(document2) {
        this.operation.addToPipeline({ $sort: document2 });
        return this;
      }
      unwind(field) {
        this.operation.addToPipeline({ $unwind: field });
        return this;
      }
      getLogger() {
        return this.logger;
      }
    };
    AggregationCursor.prototype.get = AggregationCursor.prototype.toArray;
    module2.exports = AggregationCursor;
  }
});

// node_modules/mongodb/lib/command_cursor.js
var require_command_cursor = __commonJS({
  "node_modules/mongodb/lib/command_cursor.js"(exports2, module2) {
    "use strict";
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var CursorState = require_cursor().CursorState;
    var CommandCursor = class extends Cursor {
      constructor(topology, ns, cmd, options) {
        super(topology, ns, cmd, options);
      }
      setReadPreference(readPreference) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (this.s.state !== CursorState.INIT) {
          throw MongoError.create({
            message: "cannot change cursor readPreference after cursor has been accessed",
            driver: true
          });
        }
        if (readPreference instanceof ReadPreference) {
          this.options.readPreference = readPreference;
        } else if (typeof readPreference === "string") {
          this.options.readPreference = new ReadPreference(readPreference);
        } else {
          throw new TypeError("Invalid read preference: " + readPreference);
        }
        return this;
      }
      batchSize(value) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value !== "number") {
          throw MongoError.create({ message: "batchSize requires an integer", driver: true });
        }
        if (this.cmd.cursor) {
          this.cmd.cursor.batchSize = value;
        }
        this.setCursorBatchSize(value);
        return this;
      }
      maxTimeMS(value) {
        if (this.topology.lastIsMaster().minWireVersion > 2) {
          this.cmd.maxTimeMS = value;
        }
        return this;
      }
      getLogger() {
        return this.logger;
      }
    };
    CommandCursor.prototype.get = CommandCursor.prototype.toArray;
    module2.exports = CommandCursor;
  }
});

// node_modules/mongodb/lib/operations/bulk_write.js
var require_bulk_write = __commonJS({
  "node_modules/mongodb/lib/operations/bulk_write.js"(exports2, module2) {
    "use strict";
    var applyRetryableWrites = require_utils6().applyRetryableWrites;
    var applyWriteConcern = require_utils6().applyWriteConcern;
    var MongoError = require_core().MongoError;
    var OperationBase = require_operation().OperationBase;
    var BulkWriteOperation = class extends OperationBase {
      constructor(collection, operations, options) {
        super(options);
        this.collection = collection;
        this.operations = operations;
      }
      execute(callback) {
        const coll = this.collection;
        const operations = this.operations;
        let options = this.options;
        if (coll.s.options.ignoreUndefined) {
          options = Object.assign({}, options);
          options.ignoreUndefined = coll.s.options.ignoreUndefined;
        }
        const bulk = options.ordered === true || options.ordered == null ? coll.initializeOrderedBulkOp(options) : coll.initializeUnorderedBulkOp(options);
        let collation = false;
        try {
          for (let i = 0; i < operations.length; i++) {
            const key = Object.keys(operations[i])[0];
            if (operations[i][key].collation) {
              collation = true;
            }
            bulk.raw(operations[i]);
          }
        } catch (err) {
          return callback(err, null);
        }
        let finalOptions = Object.assign({}, options);
        finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
        finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);
        const writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};
        const capabilities = coll.s.topology.capabilities();
        if (collation && capabilities && !capabilities.commandsTakeCollation) {
          return callback(new MongoError("server/primary/mongos does not support collation"));
        }
        bulk.execute(writeCon, finalOptions, (err, r) => {
          if (!r && err) {
            return callback(err, null);
          }
          callback(null, r);
        });
      }
    };
    module2.exports = BulkWriteOperation;
  }
});

// node_modules/mongodb/lib/operations/count_documents.js
var require_count_documents = __commonJS({
  "node_modules/mongodb/lib/operations/count_documents.js"(exports2, module2) {
    "use strict";
    var AggregateOperation = require_aggregate();
    var CountDocumentsOperation = class extends AggregateOperation {
      constructor(collection, query, options) {
        const pipeline = [{ $match: query }];
        if (typeof options.skip === "number") {
          pipeline.push({ $skip: options.skip });
        }
        if (typeof options.limit === "number") {
          pipeline.push({ $limit: options.limit });
        }
        pipeline.push({ $group: { _id: 1, n: { $sum: 1 } } });
        super(collection, pipeline, options);
      }
      execute(server, callback) {
        super.execute(server, (err, result) => {
          if (err) {
            callback(err, null);
            return;
          }
          const response = result.result;
          if (response.cursor == null || response.cursor.firstBatch == null) {
            callback(null, 0);
            return;
          }
          const docs = response.cursor.firstBatch;
          callback(null, docs.length ? docs[0].n : 0);
        });
      }
    };
    module2.exports = CountDocumentsOperation;
  }
});

// node_modules/mongodb/lib/operations/create_indexes.js
var require_create_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/create_indexes.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var MongoError = require_core().MongoError;
    var parseIndexOptions = require_utils6().parseIndexOptions;
    var maxWireVersion = require_utils4().maxWireVersion;
    var VALID_INDEX_OPTIONS = new Set([
      "background",
      "unique",
      "name",
      "partialFilterExpression",
      "sparse",
      "expireAfterSeconds",
      "storageEngine",
      "collation",
      "weights",
      "default_language",
      "language_override",
      "textIndexVersion",
      "2dsphereIndexVersion",
      "bits",
      "min",
      "max",
      "bucketSize",
      "wildcardProjection"
    ]);
    var CreateIndexesOperation = class extends CommandOperationV2 {
      constructor(parent, collection, indexes, options) {
        super(parent, options);
        this.collection = collection;
        if (!Array.isArray(indexes) || Array.isArray(indexes[0])) {
          this.onlyReturnNameOfCreatedIndex = true;
          const indexParameters = parseIndexOptions(indexes);
          const name = typeof options.name === "string" ? options.name : indexParameters.name;
          const indexSpec = { name, key: indexParameters.fieldHash };
          for (let optionName in options) {
            if (VALID_INDEX_OPTIONS.has(optionName)) {
              indexSpec[optionName] = options[optionName];
            }
          }
          this.indexes = [indexSpec];
          return;
        }
        this.indexes = indexes;
      }
      execute(server, callback) {
        const options = this.options;
        const indexes = this.indexes;
        const serverWireVersion = maxWireVersion(server);
        for (let i = 0; i < indexes.length; i++) {
          if (indexes[i].collation && serverWireVersion < 5) {
            callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));
            return;
          }
          if (indexes[i].name == null) {
            const keys = [];
            for (let name in indexes[i].key) {
              keys.push(`${name}_${indexes[i].key[name]}`);
            }
            indexes[i].name = keys.join("_");
          }
        }
        const cmd = { createIndexes: this.collection, indexes };
        if (options.commitQuorum != null) {
          if (serverWireVersion < 9) {
            callback(new MongoError("`commitQuorum` option for `createIndexes` not supported on servers < 4.4"));
            return;
          }
          cmd.commitQuorum = options.commitQuorum;
        }
        this.options.collation = void 0;
        super.executeCommand(server, cmd, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, this.onlyReturnNameOfCreatedIndex ? indexes[0].name : result);
        });
      }
    };
    defineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION, Aspect.EXECUTE_WITH_SELECTION]);
    module2.exports = CreateIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/delete_many.js
var require_delete_many = __commonJS({
  "node_modules/mongodb/lib/operations/delete_many.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var removeDocuments = require_common_functions().removeDocuments;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DeleteManyOperation = class extends OperationBase {
      constructor(collection, filter, options) {
        super(options);
        this.collection = collection;
        this.filter = filter;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const options = this.options;
        options.single = false;
        removeDocuments(coll, filter, options, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.deletedCount = r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(DeleteManyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = DeleteManyOperation;
  }
});

// node_modules/mongodb/lib/operations/delete_one.js
var require_delete_one = __commonJS({
  "node_modules/mongodb/lib/operations/delete_one.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var removeDocuments = require_common_functions().removeDocuments;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DeleteOneOperation = class extends OperationBase {
      constructor(collection, filter, options) {
        super(options);
        this.collection = collection;
        this.filter = filter;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const options = this.options;
        options.single = true;
        removeDocuments(coll, filter, options, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.deletedCount = r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(DeleteOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = DeleteOneOperation;
  }
});

// node_modules/mongodb/lib/operations/distinct.js
var require_distinct = __commonJS({
  "node_modules/mongodb/lib/operations/distinct.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var decorateWithCollation = require_utils6().decorateWithCollation;
    var decorateWithReadConcern = require_utils6().decorateWithReadConcern;
    var maxWireVersion = require_utils4().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var DistinctOperation = class extends CommandOperationV2 {
      constructor(collection, key, query, options) {
        super(collection, options);
        this.collection = collection;
        this.key = key;
        this.query = query;
      }
      execute(server, callback) {
        const coll = this.collection;
        const key = this.key;
        const query = this.query;
        const options = this.options;
        const cmd = {
          distinct: coll.collectionName,
          key,
          query
        };
        if (typeof options.maxTimeMS === "number") {
          cmd.maxTimeMS = options.maxTimeMS;
        }
        decorateWithReadConcern(cmd, coll, options);
        try {
          decorateWithCollation(cmd, coll, options);
        } catch (err) {
          return callback(err, null);
        }
        if (this.explain && maxWireVersion(server) < 4) {
          callback(new MongoError(`server does not support explain on distinct`));
          return;
        }
        super.executeCommand(server, cmd, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, this.options.full || this.explain ? result : result.values);
        });
      }
    };
    defineAspects(DistinctOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = DistinctOperation;
  }
});

// node_modules/mongodb/lib/operations/command.js
var require_command2 = __commonJS({
  "node_modules/mongodb/lib/operations/command.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var applyWriteConcern = require_utils6().applyWriteConcern;
    var debugOptions = require_utils6().debugOptions;
    var handleCallback = require_utils6().handleCallback;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var MongoDBNamespace = require_utils6().MongoDBNamespace;
    var extractCommand = require_command_utils().extractCommand;
    var debugFields = [
      "authSource",
      "w",
      "wtimeout",
      "j",
      "native_parser",
      "forceServerObjectId",
      "serializeFunctions",
      "raw",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "bufferMaxEntries",
      "numberOfRetries",
      "retryMiliSeconds",
      "readPreference",
      "pkFactory",
      "parentDb",
      "promiseLibrary",
      "noListener"
    ];
    var CommandOperation = class extends OperationBase {
      constructor(db, options, collection, command) {
        super(options);
        if (!this.hasAspect(Aspect.WRITE_OPERATION)) {
          if (collection != null) {
            this.options.readPreference = ReadPreference.resolve(collection, options);
          } else {
            this.options.readPreference = ReadPreference.resolve(db, options);
          }
        } else {
          if (collection != null) {
            applyWriteConcern(this.options, { db, coll: collection }, this.options);
          } else {
            applyWriteConcern(this.options, { db }, this.options);
          }
          this.options.readPreference = ReadPreference.primary;
        }
        this.db = db;
        if (command != null) {
          this.command = command;
        }
        if (collection != null) {
          this.collection = collection;
        }
      }
      _buildCommand() {
        if (this.command != null) {
          return this.command;
        }
      }
      execute(callback) {
        const db = this.db;
        const options = Object.assign({}, this.options);
        if (db.serverConfig && db.serverConfig.isDestroyed()) {
          return callback(new MongoError("topology was destroyed"));
        }
        let command;
        try {
          command = this._buildCommand();
        } catch (e) {
          return callback(e);
        }
        const dbName = options.dbName || options.authdb || db.databaseName;
        if (this.hasAspect(Aspect.WRITE_OPERATION)) {
          if (options.writeConcern && (!options.session || !options.session.inTransaction())) {
            command.writeConcern = options.writeConcern;
          }
        }
        if (db.s.logger.isDebug()) {
          const extractedCommand = extractCommand(command);
          db.s.logger.debug(`executing command ${JSON.stringify(extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options))}]`);
        }
        const namespace = this.namespace != null ? this.namespace : new MongoDBNamespace(dbName, "$cmd");
        db.s.topology.command(namespace, command, options, (err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (options.full)
            return handleCallback(callback, null, result);
          handleCallback(callback, null, result.result);
        });
      }
    };
    module2.exports = CommandOperation;
  }
});

// node_modules/mongodb/lib/operations/drop.js
var require_drop = __commonJS({
  "node_modules/mongodb/lib/operations/drop.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var handleCallback = require_utils6().handleCallback;
    var DropOperation = class extends CommandOperation {
      constructor(db, options) {
        const finalOptions = Object.assign({}, options, db.s.options);
        if (options.session) {
          finalOptions.session = options.session;
        }
        super(db, finalOptions);
      }
      execute(callback) {
        super.execute((err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (result.ok)
            return handleCallback(callback, null, true);
          handleCallback(callback, null, false);
        });
      }
    };
    defineAspects(DropOperation, Aspect.WRITE_OPERATION);
    var DropCollectionOperation = class extends DropOperation {
      constructor(db, name, options) {
        super(db, options);
        this.name = name;
        this.namespace = `${db.namespace}.${name}`;
      }
      _buildCommand() {
        return { drop: this.name };
      }
    };
    var DropDatabaseOperation = class extends DropOperation {
      _buildCommand() {
        return { dropDatabase: 1 };
      }
    };
    module2.exports = {
      DropOperation,
      DropCollectionOperation,
      DropDatabaseOperation
    };
  }
});

// node_modules/mongodb/lib/operations/drop_index.js
var require_drop_index = __commonJS({
  "node_modules/mongodb/lib/operations/drop_index.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperation = require_command2();
    var applyWriteConcern = require_utils6().applyWriteConcern;
    var handleCallback = require_utils6().handleCallback;
    var DropIndexOperation = class extends CommandOperation {
      constructor(collection, indexName, options) {
        super(collection.s.db, options, collection);
        this.collection = collection;
        this.indexName = indexName;
      }
      _buildCommand() {
        const collection = this.collection;
        const indexName = this.indexName;
        const options = this.options;
        let cmd = { dropIndexes: collection.collectionName, index: indexName };
        cmd = applyWriteConcern(cmd, { db: collection.s.db, collection }, options);
        return cmd;
      }
      execute(callback) {
        super.execute((err, result) => {
          if (typeof callback !== "function")
            return;
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, result);
        });
      }
    };
    defineAspects(DropIndexOperation, Aspect.WRITE_OPERATION);
    module2.exports = DropIndexOperation;
  }
});

// node_modules/mongodb/lib/operations/drop_indexes.js
var require_drop_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/drop_indexes.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DropIndexOperation = require_drop_index();
    var handleCallback = require_utils6().handleCallback;
    var DropIndexesOperation = class extends DropIndexOperation {
      constructor(collection, options) {
        super(collection, "*", options);
      }
      execute(callback) {
        super.execute((err) => {
          if (err)
            return handleCallback(callback, err, false);
          handleCallback(callback, null, true);
        });
      }
    };
    defineAspects(DropIndexesOperation, Aspect.WRITE_OPERATION);
    module2.exports = DropIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/estimated_document_count.js
var require_estimated_document_count = __commonJS({
  "node_modules/mongodb/lib/operations/estimated_document_count.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var EstimatedDocumentCountOperation = class extends CommandOperationV2 {
      constructor(collection, query, options) {
        if (typeof options === "undefined") {
          options = query;
          query = void 0;
        }
        super(collection, options);
        this.collectionName = collection.s.namespace.collection;
        if (query) {
          this.query = query;
        }
      }
      execute(server, callback) {
        const options = this.options;
        const cmd = { count: this.collectionName };
        if (this.query) {
          cmd.query = this.query;
        }
        if (typeof options.skip === "number") {
          cmd.skip = options.skip;
        }
        if (typeof options.limit === "number") {
          cmd.limit = options.limit;
        }
        if (options.hint) {
          cmd.hint = options.hint;
        }
        super.executeCommand(server, cmd, (err, response) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, response.n);
        });
      }
    };
    defineAspects(EstimatedDocumentCountOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = EstimatedDocumentCountOperation;
  }
});

// node_modules/mongodb/lib/operations/find.js
var require_find = __commonJS({
  "node_modules/mongodb/lib/operations/find.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var ReadPreference = require_core().ReadPreference;
    var maxWireVersion = require_utils4().maxWireVersion;
    var MongoError = require_error().MongoError;
    var FindOperation = class extends OperationBase {
      constructor(collection, ns, command, options) {
        super(options);
        this.ns = ns;
        this.cmd = command;
        this.readPreference = ReadPreference.resolve(collection, this.options);
      }
      execute(server, callback) {
        this.server = server;
        this.readPreference = ReadPreference.resolve(this, this.options);
        if (typeof this.cmd.allowDiskUse !== "undefined" && maxWireVersion(server) < 4) {
          callback(new MongoError("The `allowDiskUse` option is not supported on MongoDB < 3.2"));
          return;
        }
        if (this.explain) {
          this.options.explain = this.explain.verbosity;
        }
        const cursorState = this.cursorState || {};
        server.query(this.ns.toString(), this.cmd, cursorState, this.options, callback);
      }
    };
    defineAspects(FindOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = FindOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one.js
var require_find_one = __commonJS({
  "node_modules/mongodb/lib/operations/find_one.js"(exports2, module2) {
    "use strict";
    var handleCallback = require_utils6().handleCallback;
    var OperationBase = require_operation().OperationBase;
    var toError = require_utils6().toError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var FindOneOperation = class extends OperationBase {
      constructor(collection, query, options) {
        super(options);
        this.collection = collection;
        this.query = query;
      }
      execute(callback) {
        const coll = this.collection;
        const query = this.query;
        const options = this.options;
        try {
          const cursor = coll.find(query, options).limit(-1).batchSize(1);
          cursor.next((err, item) => {
            if (err != null)
              return handleCallback(callback, toError(err), null);
            handleCallback(callback, null, item);
          });
        } catch (e) {
          callback(e);
        }
      }
    };
    defineAspects(FindOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = FindOneOperation;
  }
});

// node_modules/mongodb/lib/operations/find_and_modify.js
var require_find_and_modify = __commonJS({
  "node_modules/mongodb/lib/operations/find_and_modify.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var applyRetryableWrites = require_utils6().applyRetryableWrites;
    var applyWriteConcern = require_utils6().applyWriteConcern;
    var decorateWithCollation = require_utils6().decorateWithCollation;
    var executeCommand = require_db_ops().executeCommand;
    var formattedOrderClause = require_utils6().formattedOrderClause;
    var handleCallback = require_utils6().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var maxWireVersion = require_utils4().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var decorateWithExplain = require_utils6().decorateWithExplain;
    var FindAndModifyOperation = class extends OperationBase {
      constructor(collection, query, sort, doc, options) {
        super(options);
        this.collection = collection;
        this.query = query;
        this.sort = sort;
        this.doc = doc;
      }
      execute(callback) {
        const coll = this.collection;
        const query = this.query;
        const sort = formattedOrderClause(this.sort);
        const doc = this.doc;
        let options = this.options;
        let queryObject = {
          findAndModify: coll.collectionName,
          query
        };
        if (sort) {
          queryObject.sort = sort;
        }
        queryObject.new = options.new ? true : false;
        queryObject.remove = options.remove ? true : false;
        queryObject.upsert = options.upsert ? true : false;
        const projection = options.projection || options.fields;
        if (projection) {
          queryObject.fields = projection;
        }
        if (options.arrayFilters) {
          queryObject.arrayFilters = options.arrayFilters;
        }
        if (doc && !options.remove) {
          queryObject.update = doc;
        }
        if (options.maxTimeMS)
          queryObject.maxTimeMS = options.maxTimeMS;
        options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
        options.checkKeys = false;
        options = applyRetryableWrites(options, coll.s.db);
        options = applyWriteConcern(options, { db: coll.s.db, collection: coll }, options);
        if (options.writeConcern) {
          queryObject.writeConcern = options.writeConcern;
        }
        if (options.bypassDocumentValidation === true) {
          queryObject.bypassDocumentValidation = options.bypassDocumentValidation;
        }
        options.readPreference = ReadPreference.primary;
        try {
          decorateWithCollation(queryObject, coll, options);
        } catch (err) {
          return callback(err, null);
        }
        if (options.hint) {
          const unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;
          if (unacknowledgedWrite || maxWireVersion(coll.s.topology) < 8) {
            callback(new MongoError("The current topology does not support a hint on findAndModify commands"));
            return;
          }
          queryObject.hint = options.hint;
        }
        if (this.explain) {
          if (maxWireVersion(coll.s.topology) < 4) {
            callback(new MongoError(`server does not support explain on findAndModify`));
            return;
          }
          queryObject = decorateWithExplain(queryObject, this.explain);
        }
        executeCommand(coll.s.db, queryObject, options, (err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          return handleCallback(callback, null, result);
        });
      }
    };
    defineAspects(FindAndModifyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = FindAndModifyOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_delete.js
var require_find_one_and_delete = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_delete.js"(exports2, module2) {
    "use strict";
    var FindAndModifyOperation = require_find_and_modify();
    var FindOneAndDeleteOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, options) {
        const finalOptions = Object.assign({}, options);
        finalOptions.fields = options.projection;
        finalOptions.remove = true;
        if (filter == null || typeof filter !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        super(collection, filter, finalOptions.sort, null, finalOptions);
      }
    };
    module2.exports = FindOneAndDeleteOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_replace.js
var require_find_one_and_replace = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_replace.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var FindAndModifyOperation = require_find_and_modify();
    var hasAtomicOperators = require_utils6().hasAtomicOperators;
    var FindOneAndReplaceOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, replacement, options) {
        if ("returnDocument" in options && "returnOriginal" in options) {
          throw new MongoError("findOneAndReplace option returnOriginal is deprecated in favor of returnDocument and cannot be combined");
        }
        const finalOptions = Object.assign({}, options);
        finalOptions.fields = options.projection;
        finalOptions.update = true;
        finalOptions.new = options.returnDocument === "after" || options.returnOriginal === false;
        finalOptions.upsert = options.upsert === true;
        if (filter == null || typeof filter !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        if (replacement == null || typeof replacement !== "object") {
          throw new TypeError("Replacement parameter must be an object");
        }
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not contain atomic operators");
        }
        super(collection, filter, finalOptions.sort, replacement, finalOptions);
      }
    };
    module2.exports = FindOneAndReplaceOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_update.js
var require_find_one_and_update = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_update.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var FindAndModifyOperation = require_find_and_modify();
    var hasAtomicOperators = require_utils6().hasAtomicOperators;
    var FindOneAndUpdateOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, update, options) {
        if ("returnDocument" in options && "returnOriginal" in options) {
          throw new MongoError("findOneAndUpdate option returnOriginal is deprecated in favor of returnDocument and cannot be combined");
        }
        const finalOptions = Object.assign({}, options);
        finalOptions.fields = options.projection;
        finalOptions.update = true;
        finalOptions.new = options.returnDocument === "after" || options.returnOriginal === false;
        finalOptions.upsert = options.upsert === true;
        if (filter == null || typeof filter !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        if (update == null || typeof update !== "object") {
          throw new TypeError("Update parameter must be an object");
        }
        if (!hasAtomicOperators(update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        super(collection, filter, finalOptions.sort, update, finalOptions);
      }
    };
    module2.exports = FindOneAndUpdateOperation;
  }
});

// node_modules/mongodb/lib/operations/geo_haystack_search.js
var require_geo_haystack_search = __commonJS({
  "node_modules/mongodb/lib/operations/geo_haystack_search.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var OperationBase = require_operation().OperationBase;
    var decorateCommand = require_utils6().decorateCommand;
    var decorateWithReadConcern = require_utils6().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils6().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils6().toError;
    var GeoHaystackSearchOperation = class extends OperationBase {
      constructor(collection, x, y, options) {
        super(options);
        this.collection = collection;
        this.x = x;
        this.y = y;
      }
      execute(callback) {
        const coll = this.collection;
        const x = this.x;
        const y = this.y;
        let options = this.options;
        let commandObject = {
          geoSearch: coll.collectionName,
          near: [x, y]
        };
        commandObject = decorateCommand(commandObject, options, ["readPreference", "session"]);
        options = Object.assign({}, options);
        options.readPreference = ReadPreference.resolve(coll, options);
        decorateWithReadConcern(commandObject, coll, options);
        executeCommand(coll.s.db, commandObject, options, (err, res) => {
          if (err)
            return handleCallback(callback, err);
          if (res.err || res.errmsg)
            handleCallback(callback, toError(res));
          handleCallback(callback, null, res);
        });
      }
    };
    defineAspects(GeoHaystackSearchOperation, Aspect.READ_OPERATION);
    module2.exports = GeoHaystackSearchOperation;
  }
});

// node_modules/mongodb/lib/operations/indexes.js
var require_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/indexes.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var indexInformation = require_common_functions().indexInformation;
    var IndexesOperation = class extends OperationBase {
      constructor(collection, options) {
        super(options);
        this.collection = collection;
      }
      execute(callback) {
        const coll = this.collection;
        let options = this.options;
        options = Object.assign({}, { full: true }, options);
        indexInformation(coll.s.db, coll.collectionName, options, callback);
      }
    };
    module2.exports = IndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/index_exists.js
var require_index_exists = __commonJS({
  "node_modules/mongodb/lib/operations/index_exists.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils6().handleCallback;
    var indexInformationDb = require_db_ops().indexInformation;
    var IndexExistsOperation = class extends OperationBase {
      constructor(collection, indexes, options) {
        super(options);
        this.collection = collection;
        this.indexes = indexes;
      }
      execute(callback) {
        const coll = this.collection;
        const indexes = this.indexes;
        const options = this.options;
        indexInformationDb(coll.s.db, coll.collectionName, options, (err, indexInformation) => {
          if (err != null)
            return handleCallback(callback, err, null);
          if (!Array.isArray(indexes))
            return handleCallback(callback, null, indexInformation[indexes] != null);
          for (let i = 0; i < indexes.length; i++) {
            if (indexInformation[indexes[i]] == null) {
              return handleCallback(callback, null, false);
            }
          }
          return handleCallback(callback, null, true);
        });
      }
    };
    module2.exports = IndexExistsOperation;
  }
});

// node_modules/mongodb/lib/operations/index_information.js
var require_index_information = __commonJS({
  "node_modules/mongodb/lib/operations/index_information.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var indexInformation = require_common_functions().indexInformation;
    var IndexInformationOperation = class extends OperationBase {
      constructor(db, name, options) {
        super(options);
        this.db = db;
        this.name = name;
      }
      execute(callback) {
        const db = this.db;
        const name = this.name;
        const options = this.options;
        indexInformation(db, name, options, callback);
      }
    };
    module2.exports = IndexInformationOperation;
  }
});

// node_modules/mongodb/lib/operations/insert_many.js
var require_insert_many = __commonJS({
  "node_modules/mongodb/lib/operations/insert_many.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var BulkWriteOperation = require_bulk_write();
    var MongoError = require_core().MongoError;
    var prepareDocs = require_common_functions().prepareDocs;
    var InsertManyOperation = class extends OperationBase {
      constructor(collection, docs, options) {
        super(options);
        this.collection = collection;
        this.docs = docs;
      }
      execute(callback) {
        const coll = this.collection;
        let docs = this.docs;
        const options = this.options;
        if (!Array.isArray(docs)) {
          return callback(MongoError.create({ message: "docs parameter must be an array of documents", driver: true }));
        }
        options["serializeFunctions"] = options["serializeFunctions"] || coll.s.serializeFunctions;
        docs = prepareDocs(coll, docs, options);
        const operations = docs.map((document2) => ({ insertOne: { document: document2 } }));
        const bulkWriteOperation = new BulkWriteOperation(coll, operations, options);
        bulkWriteOperation.execute((err, result) => {
          if (err)
            return callback(err, null);
          callback(null, mapInsertManyResults(docs, result));
        });
      }
    };
    function mapInsertManyResults(docs, r) {
      const finalResult = {
        result: { ok: 1, n: r.insertedCount },
        ops: docs,
        insertedCount: r.insertedCount,
        insertedIds: r.insertedIds
      };
      if (r.getLastOp()) {
        finalResult.result.opTime = r.getLastOp();
      }
      return finalResult;
    }
    module2.exports = InsertManyOperation;
  }
});

// node_modules/mongodb/lib/operations/insert_one.js
var require_insert_one = __commonJS({
  "node_modules/mongodb/lib/operations/insert_one.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var OperationBase = require_operation().OperationBase;
    var insertDocuments = require_common_functions().insertDocuments;
    var InsertOneOperation = class extends OperationBase {
      constructor(collection, doc, options) {
        super(options);
        this.collection = collection;
        this.doc = doc;
      }
      execute(callback) {
        const coll = this.collection;
        const doc = this.doc;
        const options = this.options;
        if (Array.isArray(doc)) {
          return callback(MongoError.create({ message: "doc parameter must be an object", driver: true }));
        }
        insertDocuments(coll, [doc], options, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          r.insertedCount = r.result.n;
          r.insertedId = doc._id;
          if (callback)
            callback(null, r);
        });
      }
    };
    module2.exports = InsertOneOperation;
  }
});

// node_modules/mongodb/lib/operations/options_operation.js
var require_options_operation = __commonJS({
  "node_modules/mongodb/lib/operations/options_operation.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils6().handleCallback;
    var MongoError = require_core().MongoError;
    var OptionsOperation = class extends OperationBase {
      constructor(collection, options) {
        super(options);
        this.collection = collection;
      }
      execute(callback) {
        const coll = this.collection;
        const opts = this.options;
        coll.s.db.listCollections({ name: coll.collectionName }, opts).toArray((err, collections) => {
          if (err)
            return handleCallback(callback, err);
          if (collections.length === 0) {
            return handleCallback(callback, MongoError.create({ message: `collection ${coll.namespace} not found`, driver: true }));
          }
          handleCallback(callback, err, collections[0].options || null);
        });
      }
    };
    module2.exports = OptionsOperation;
  }
});

// node_modules/mongodb/lib/operations/is_capped.js
var require_is_capped = __commonJS({
  "node_modules/mongodb/lib/operations/is_capped.js"(exports2, module2) {
    "use strict";
    var OptionsOperation = require_options_operation();
    var handleCallback = require_utils6().handleCallback;
    var IsCappedOperation = class extends OptionsOperation {
      constructor(collection, options) {
        super(collection, options);
      }
      execute(callback) {
        super.execute((err, document2) => {
          if (err)
            return handleCallback(callback, err);
          handleCallback(callback, null, !!(document2 && document2.capped));
        });
      }
    };
    module2.exports = IsCappedOperation;
  }
});

// node_modules/mongodb/lib/operations/list_indexes.js
var require_list_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/list_indexes.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var maxWireVersion = require_utils4().maxWireVersion;
    var LIST_INDEXES_WIRE_VERSION = 3;
    var ListIndexesOperation = class extends CommandOperationV2 {
      constructor(collection, options) {
        super(collection, options, { fullResponse: true });
        this.collectionNamespace = collection.s.namespace;
      }
      execute(server, callback) {
        const serverWireVersion = maxWireVersion(server);
        if (serverWireVersion < LIST_INDEXES_WIRE_VERSION) {
          const systemIndexesNS = this.collectionNamespace.withCollection("system.indexes").toString();
          const collectionNS = this.collectionNamespace.toString();
          server.query(systemIndexesNS, { query: { ns: collectionNS } }, {}, this.options, callback);
          return;
        }
        const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};
        super.executeCommand(server, { listIndexes: this.collectionNamespace.collection, cursor }, callback);
      }
    };
    defineAspects(ListIndexesOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/add_user.js
var require_add_user = __commonJS({
  "node_modules/mongodb/lib/operations/add_user.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var crypto = require("crypto");
    var handleCallback = require_utils6().handleCallback;
    var toError = require_utils6().toError;
    var emitWarning = require_utils6().emitWarning;
    var AddUserOperation = class extends CommandOperation {
      constructor(db, username, password, options) {
        super(db, options);
        this.username = username;
        this.password = password;
      }
      _buildCommand() {
        const db = this.db;
        const username = this.username;
        const password = this.password;
        const options = this.options;
        let roles = [];
        if (Array.isArray(options.roles))
          roles = options.roles;
        if (typeof options.roles === "string")
          roles = [options.roles];
        if (roles.length === 0) {
          emitWarning("Creating a user without roles is deprecated in MongoDB >= 2.6");
        }
        if ((db.databaseName.toLowerCase() === "admin" || options.dbName === "admin") && !Array.isArray(options.roles)) {
          roles = ["root"];
        } else if (!Array.isArray(options.roles)) {
          roles = ["dbOwner"];
        }
        const digestPassword = db.s.topology.lastIsMaster().maxWireVersion >= 7;
        let userPassword = password;
        if (!digestPassword) {
          const md5 = crypto.createHash("md5");
          md5.update(username + ":mongo:" + password);
          userPassword = md5.digest("hex");
        }
        const command = {
          createUser: username,
          customData: options.customData || {},
          roles,
          digestPassword
        };
        if (typeof password === "string") {
          command.pwd = userPassword;
        }
        return command;
      }
      execute(callback) {
        const options = this.options;
        if (options.digestPassword != null) {
          return callback(toError("The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option."));
        }
        super.execute((err, r) => {
          if (!err) {
            return handleCallback(callback, err, r);
          }
          return handleCallback(callback, err, null);
        });
      }
    };
    defineAspects(AddUserOperation, Aspect.WRITE_OPERATION);
    module2.exports = AddUserOperation;
  }
});

// node_modules/mongodb/lib/operations/collections.js
var require_collections = __commonJS({
  "node_modules/mongodb/lib/operations/collections.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils6().handleCallback;
    var collection;
    function loadCollection() {
      if (!collection) {
        collection = require_collection();
      }
      return collection;
    }
    var CollectionsOperation = class extends OperationBase {
      constructor(db, options) {
        super(options);
        this.db = db;
      }
      execute(callback) {
        const db = this.db;
        let options = this.options;
        let Collection = loadCollection();
        options = Object.assign({}, options, { nameOnly: true });
        db.listCollections({}, options).toArray((err, documents) => {
          if (err != null)
            return handleCallback(callback, err, null);
          documents = documents.filter((doc) => {
            return doc.name.indexOf("$") === -1;
          });
          handleCallback(callback, null, documents.map((d) => {
            return new Collection(db, db.s.topology, db.databaseName, d.name, db.s.pkFactory, db.s.options);
          }));
        });
      }
    };
    module2.exports = CollectionsOperation;
  }
});

// node_modules/mongodb/lib/operations/run_command.js
var require_run_command = __commonJS({
  "node_modules/mongodb/lib/operations/run_command.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var defineAspects = require_operation().defineAspects;
    var Aspect = require_operation().Aspect;
    var RunCommandOperation = class extends CommandOperationV2 {
      constructor(parent, command, options) {
        super(parent, options);
        this.command = command;
      }
      execute(server, callback) {
        const command = this.command;
        this.executeCommand(server, command, callback);
      }
    };
    defineAspects(RunCommandOperation, [Aspect.EXECUTE_WITH_SELECTION, Aspect.NO_INHERIT_OPTIONS]);
    module2.exports = RunCommandOperation;
  }
});

// node_modules/mongodb/lib/operations/create_collection.js
var require_create_collection = __commonJS({
  "node_modules/mongodb/lib/operations/create_collection.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperation = require_command2();
    var applyWriteConcern = require_utils6().applyWriteConcern;
    var loadCollection = require_dynamic_loaders().loadCollection;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var ILLEGAL_COMMAND_FIELDS = new Set([
      "w",
      "wtimeout",
      "j",
      "fsync",
      "autoIndexId",
      "strict",
      "serializeFunctions",
      "pkFactory",
      "raw",
      "readPreference",
      "session",
      "readConcern",
      "writeConcern"
    ]);
    var CreateCollectionOperation = class extends CommandOperation {
      constructor(db, name, options) {
        super(db, options);
        this.name = name;
      }
      _buildCommand() {
        const name = this.name;
        const options = this.options;
        const cmd = { create: name };
        for (let n in options) {
          if (options[n] != null && typeof options[n] !== "function" && !ILLEGAL_COMMAND_FIELDS.has(n)) {
            cmd[n] = options[n];
          }
        }
        return cmd;
      }
      execute(callback) {
        const db = this.db;
        const name = this.name;
        const options = this.options;
        const Collection = loadCollection();
        let listCollectionOptions = Object.assign({ nameOnly: true, strict: false }, options);
        listCollectionOptions = applyWriteConcern(listCollectionOptions, { db }, listCollectionOptions);
        function done(err) {
          if (err) {
            return callback(err);
          }
          try {
            callback(null, new Collection(db, db.s.topology, db.databaseName, name, db.s.pkFactory, options));
          } catch (err2) {
            callback(err2);
          }
        }
        const strictMode = listCollectionOptions.strict;
        if (strictMode) {
          db.listCollections({ name }, listCollectionOptions).setReadPreference(ReadPreference.PRIMARY).toArray((err, collections) => {
            if (err) {
              return callback(err);
            }
            if (collections.length > 0) {
              return callback(new MongoError(`Collection ${name} already exists. Currently in strict mode.`));
            }
            super.execute(done);
          });
          return;
        }
        super.execute(done);
      }
    };
    defineAspects(CreateCollectionOperation, Aspect.WRITE_OPERATION);
    module2.exports = CreateCollectionOperation;
  }
});

// node_modules/mongodb/lib/operations/execute_db_admin_command.js
var require_execute_db_admin_command = __commonJS({
  "node_modules/mongodb/lib/operations/execute_db_admin_command.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils6().handleCallback;
    var MongoError = require_core().MongoError;
    var MongoDBNamespace = require_utils6().MongoDBNamespace;
    var ExecuteDbAdminCommandOperation = class extends OperationBase {
      constructor(db, selector, options) {
        super(options);
        this.db = db;
        this.selector = selector;
      }
      execute(callback) {
        const db = this.db;
        const selector = this.selector;
        const options = this.options;
        const namespace = new MongoDBNamespace("admin", "$cmd");
        db.s.topology.command(namespace, selector, options, (err, result) => {
          if (db.serverConfig && db.serverConfig.isDestroyed()) {
            return callback(new MongoError("topology was destroyed"));
          }
          if (err)
            return handleCallback(callback, err);
          handleCallback(callback, null, result.result);
        });
      }
    };
    module2.exports = ExecuteDbAdminCommandOperation;
  }
});

// node_modules/mongodb/lib/operations/list_collections.js
var require_list_collections = __commonJS({
  "node_modules/mongodb/lib/operations/list_collections.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var maxWireVersion = require_utils4().maxWireVersion;
    var CONSTANTS = require_constants2();
    var LIST_COLLECTIONS_WIRE_VERSION = 3;
    function listCollectionsTransforms(databaseName) {
      const matching = `${databaseName}.`;
      return {
        doc: (doc) => {
          const index = doc.name.indexOf(matching);
          if (doc.name && index === 0) {
            doc.name = doc.name.substr(index + matching.length);
          }
          return doc;
        }
      };
    }
    var ListCollectionsOperation = class extends CommandOperationV2 {
      constructor(db, filter, options) {
        super(db, options, { fullResponse: true });
        this.db = db;
        this.filter = filter;
        this.nameOnly = !!this.options.nameOnly;
        if (typeof this.options.batchSize === "number") {
          this.batchSize = this.options.batchSize;
        }
      }
      execute(server, callback) {
        if (maxWireVersion(server) < LIST_COLLECTIONS_WIRE_VERSION) {
          let filter = this.filter;
          const databaseName = this.db.s.namespace.db;
          if (typeof filter.name === "string" && !new RegExp("^" + databaseName + "\\.").test(filter.name)) {
            filter = Object.assign({}, filter);
            filter.name = this.db.s.namespace.withCollection(filter.name).toString();
          }
          if (filter == null) {
            filter.name = `/${databaseName}/`;
          }
          if (filter.name) {
            filter = { $and: [{ name: filter.name }, { name: /^((?!\$).)*$/ }] };
          } else {
            filter = { name: /^((?!\$).)*$/ };
          }
          const transforms = listCollectionsTransforms(databaseName);
          server.query(`${databaseName}.${CONSTANTS.SYSTEM_NAMESPACE_COLLECTION}`, { query: filter }, { batchSize: this.batchSize || 1e3 }, {}, (err, result) => {
            if (result && result.message && result.message.documents && Array.isArray(result.message.documents)) {
              result.message.documents = result.message.documents.map(transforms.doc);
            }
            callback(err, result);
          });
          return;
        }
        const command = {
          listCollections: 1,
          filter: this.filter,
          cursor: this.batchSize ? { batchSize: this.batchSize } : {},
          nameOnly: this.nameOnly
        };
        return super.executeCommand(server, command, callback);
      }
    };
    defineAspects(ListCollectionsOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListCollectionsOperation;
  }
});

// node_modules/mongodb/lib/operations/profiling_level.js
var require_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/profiling_level.js"(exports2, module2) {
    "use strict";
    var CommandOperation = require_command2();
    var ProfilingLevelOperation = class extends CommandOperation {
      constructor(db, command, options) {
        super(db, options);
      }
      _buildCommand() {
        const command = { profile: -1 };
        return command;
      }
      execute(callback) {
        super.execute((err, doc) => {
          if (err == null && doc.ok === 1) {
            const was = doc.was;
            if (was === 0)
              return callback(null, "off");
            if (was === 1)
              return callback(null, "slow_only");
            if (was === 2)
              return callback(null, "all");
            return callback(new Error("Error: illegal profiling level value " + was), null);
          } else {
            err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
          }
        });
      }
    };
    module2.exports = ProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/remove_user.js
var require_remove_user = __commonJS({
  "node_modules/mongodb/lib/operations/remove_user.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var handleCallback = require_utils6().handleCallback;
    var WriteConcern = require_write_concern();
    var RemoveUserOperation = class extends CommandOperation {
      constructor(db, username, options) {
        const commandOptions = {};
        const writeConcern = WriteConcern.fromOptions(options);
        if (writeConcern != null) {
          commandOptions.writeConcern = writeConcern;
        }
        if (options.dbName) {
          commandOptions.dbName = options.dbName;
        }
        if (typeof options.maxTimeMS === "number") {
          commandOptions.maxTimeMS = options.maxTimeMS;
        }
        super(db, commandOptions);
        this.username = username;
      }
      _buildCommand() {
        const username = this.username;
        const command = { dropUser: username };
        return command;
      }
      execute(callback) {
        super.execute((err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, err, result.ok ? true : false);
        });
      }
    };
    defineAspects(RemoveUserOperation, Aspect.WRITE_OPERATION);
    module2.exports = RemoveUserOperation;
  }
});

// node_modules/mongodb/lib/operations/rename.js
var require_rename = __commonJS({
  "node_modules/mongodb/lib/operations/rename.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var applyWriteConcern = require_utils6().applyWriteConcern;
    var checkCollectionName = require_utils6().checkCollectionName;
    var executeDbAdminCommand = require_db_ops().executeDbAdminCommand;
    var handleCallback = require_utils6().handleCallback;
    var loadCollection = require_dynamic_loaders().loadCollection;
    var toError = require_utils6().toError;
    var RenameOperation = class extends OperationBase {
      constructor(collection, newName, options) {
        super(options);
        this.collection = collection;
        this.newName = newName;
      }
      execute(callback) {
        const coll = this.collection;
        const newName = this.newName;
        const options = this.options;
        let Collection = loadCollection();
        checkCollectionName(newName);
        const renameCollection = coll.namespace;
        const toCollection = coll.s.namespace.withCollection(newName).toString();
        const dropTarget = typeof options.dropTarget === "boolean" ? options.dropTarget : false;
        const cmd = { renameCollection, to: toCollection, dropTarget };
        applyWriteConcern(cmd, { db: coll.s.db, collection: coll }, options);
        executeDbAdminCommand(coll.s.db.admin().s.db, cmd, options, (err, doc) => {
          if (err)
            return handleCallback(callback, err, null);
          if (doc.errmsg)
            return handleCallback(callback, toError(doc), null);
          try {
            return handleCallback(callback, null, new Collection(coll.s.db, coll.s.topology, coll.s.namespace.db, newName, coll.s.pkFactory, coll.s.options));
          } catch (err2) {
            return handleCallback(callback, toError(err2), null);
          }
        });
      }
    };
    module2.exports = RenameOperation;
  }
});

// node_modules/mongodb/lib/operations/set_profiling_level.js
var require_set_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/set_profiling_level.js"(exports2, module2) {
    "use strict";
    var CommandOperation = require_command2();
    var levelValues = new Set(["off", "slow_only", "all"]);
    var SetProfilingLevelOperation = class extends CommandOperation {
      constructor(db, level, options) {
        let profile2 = 0;
        if (level === "off") {
          profile2 = 0;
        } else if (level === "slow_only") {
          profile2 = 1;
        } else if (level === "all") {
          profile2 = 2;
        }
        super(db, options);
        this.level = level;
        this.profile = profile2;
      }
      _buildCommand() {
        const profile2 = this.profile;
        const command = { profile: profile2 };
        return command;
      }
      execute(callback) {
        const level = this.level;
        if (!levelValues.has(level)) {
          return callback(new Error("Error: illegal profiling level value " + level));
        }
        super.execute((err, doc) => {
          if (err == null && doc.ok === 1)
            return callback(null, level);
          return err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
        });
      }
    };
    module2.exports = SetProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/validate_collection.js
var require_validate_collection = __commonJS({
  "node_modules/mongodb/lib/operations/validate_collection.js"(exports2, module2) {
    "use strict";
    var CommandOperation = require_command2();
    var ValidateCollectionOperation = class extends CommandOperation {
      constructor(admin, collectionName, options) {
        let command = { validate: collectionName };
        const keys = Object.keys(options);
        for (let i = 0; i < keys.length; i++) {
          if (Object.prototype.hasOwnProperty.call(options, keys[i]) && keys[i] !== "session") {
            command[keys[i]] = options[keys[i]];
          }
        }
        super(admin.s.db, options, null, command);
        this.collectionName = collectionName;
      }
      execute(callback) {
        const collectionName = this.collectionName;
        super.execute((err, doc) => {
          if (err != null)
            return callback(err, null);
          if (doc.ok === 0)
            return callback(new Error("Error with validate command"), null);
          if (doc.result != null && doc.result.constructor !== String)
            return callback(new Error("Error with validation data"), null);
          if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
            return callback(new Error("Error: invalid collection " + collectionName), null);
          if (doc.valid != null && !doc.valid)
            return callback(new Error("Error: invalid collection " + collectionName), null);
          return callback(null, doc);
        });
      }
    };
    module2.exports = ValidateCollectionOperation;
  }
});

// node_modules/mongodb/lib/operations/list_databases.js
var require_list_databases = __commonJS({
  "node_modules/mongodb/lib/operations/list_databases.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var MongoDBNamespace = require_utils6().MongoDBNamespace;
    var ListDatabasesOperation = class extends CommandOperationV2 {
      constructor(db, options) {
        super(db, options);
        this.ns = new MongoDBNamespace("admin", "$cmd");
      }
      execute(server, callback) {
        const cmd = { listDatabases: 1 };
        if (this.options.nameOnly) {
          cmd.nameOnly = Number(cmd.nameOnly);
        }
        if (this.options.filter) {
          cmd.filter = this.options.filter;
        }
        if (typeof this.options.authorizedDatabases === "boolean") {
          cmd.authorizedDatabases = this.options.authorizedDatabases;
        }
        super.executeCommand(server, cmd, callback);
      }
    };
    defineAspects(ListDatabasesOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListDatabasesOperation;
  }
});

// node_modules/mongodb/lib/admin.js
var require_admin = __commonJS({
  "node_modules/mongodb/lib/admin.js"(exports2, module2) {
    "use strict";
    var applyWriteConcern = require_utils6().applyWriteConcern;
    var AddUserOperation = require_add_user();
    var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
    var RemoveUserOperation = require_remove_user();
    var ValidateCollectionOperation = require_validate_collection();
    var ListDatabasesOperation = require_list_databases();
    var executeOperation = require_execute_operation();
    function Admin(db, topology, promiseLibrary) {
      if (!(this instanceof Admin))
        return new Admin(db, topology);
      this.s = {
        db,
        topology,
        promiseLibrary
      };
    }
    Admin.prototype.command = function(command, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() : {};
      const commandOperation = new ExecuteDbAdminCommandOperation(this.s.db, command, options);
      return executeOperation(this.s.db.s.topology, commandOperation, callback);
    };
    Admin.prototype.buildInfo = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const cmd = { buildinfo: 1 };
      const buildInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options);
      return executeOperation(this.s.db.s.topology, buildInfoOperation, callback);
    };
    Admin.prototype.serverInfo = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const cmd = { buildinfo: 1 };
      const serverInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options);
      return executeOperation(this.s.db.s.topology, serverInfoOperation, callback);
    };
    Admin.prototype.serverStatus = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const serverStatusOperation = new ExecuteDbAdminCommandOperation(this.s.db, { serverStatus: 1 }, options);
      return executeOperation(this.s.db.s.topology, serverStatusOperation, callback);
    };
    Admin.prototype.ping = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const cmd = { ping: 1 };
      const pingOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options);
      return executeOperation(this.s.db.s.topology, pingOperation, callback);
    };
    Admin.prototype.addUser = function(username, password, options, callback) {
      const args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      if (typeof username === "string" && password != null && typeof password === "object") {
        options = password;
        password = null;
      }
      options = args.length ? args.shift() : {};
      options = Object.assign({}, options);
      options = applyWriteConcern(options, { db: this.s.db });
      options.dbName = "admin";
      const addUserOperation = new AddUserOperation(this.s.db, username, password, options);
      return executeOperation(this.s.db.s.topology, addUserOperation, callback);
    };
    Admin.prototype.removeUser = function(username, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() : {};
      options = Object.assign({}, options);
      options = applyWriteConcern(options, { db: this.s.db });
      options.dbName = "admin";
      const removeUserOperation = new RemoveUserOperation(this.s.db, username, options);
      return executeOperation(this.s.db.s.topology, removeUserOperation, callback);
    };
    Admin.prototype.validateCollection = function(collectionName, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const validateCollectionOperation = new ValidateCollectionOperation(this, collectionName, options);
      return executeOperation(this.s.db.s.topology, validateCollectionOperation, callback);
    };
    Admin.prototype.listDatabases = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeOperation(this.s.db.s.topology, new ListDatabasesOperation(this.s.db, options), callback);
    };
    Admin.prototype.replSetGetStatus = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const replSetGetStatusOperation = new ExecuteDbAdminCommandOperation(this.s.db, { replSetGetStatus: 1 }, options);
      return executeOperation(this.s.db.s.topology, replSetGetStatusOperation, callback);
    };
    module2.exports = Admin;
  }
});

// node_modules/mongodb/lib/db.js
var require_db2 = __commonJS({
  "node_modules/mongodb/lib/db.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var inherits2 = require("util").inherits;
    var getSingleProperty = require_utils6().getSingleProperty;
    var CommandCursor = require_command_cursor();
    var handleCallback = require_utils6().handleCallback;
    var filterOptions = require_utils6().filterOptions;
    var toError = require_utils6().toError;
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var ObjectID2 = require_core().ObjectID;
    var Logger = require_core().Logger;
    var Collection = require_collection();
    var conditionallyMergeWriteConcern = require_utils6().conditionallyMergeWriteConcern;
    var executeLegacyOperation = require_utils6().executeLegacyOperation;
    var ChangeStream = require_change_stream();
    var deprecate = require("util").deprecate;
    var deprecateOptions = require_utils6().deprecateOptions;
    var MongoDBNamespace = require_utils6().MongoDBNamespace;
    var CONSTANTS = require_constants2();
    var WriteConcern = require_write_concern();
    var ReadConcern = require_read_concern();
    var AggregationCursor = require_aggregation_cursor();
    var createListener = require_db_ops().createListener;
    var ensureIndex = require_db_ops().ensureIndex;
    var evaluate = require_db_ops().evaluate;
    var profilingInfo = require_db_ops().profilingInfo;
    var validateDatabaseName = require_db_ops().validateDatabaseName;
    var AggregateOperation = require_aggregate();
    var AddUserOperation = require_add_user();
    var CollectionsOperation = require_collections();
    var CommandOperation = require_command2();
    var RunCommandOperation = require_run_command();
    var CreateCollectionOperation = require_create_collection();
    var CreateIndexesOperation = require_create_indexes();
    var DropCollectionOperation = require_drop().DropCollectionOperation;
    var DropDatabaseOperation = require_drop().DropDatabaseOperation;
    var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
    var IndexInformationOperation = require_index_information();
    var ListCollectionsOperation = require_list_collections();
    var ProfilingLevelOperation = require_profiling_level();
    var RemoveUserOperation = require_remove_user();
    var RenameOperation = require_rename();
    var SetProfilingLevelOperation = require_set_profiling_level();
    var executeOperation = require_execute_operation();
    var legalOptionNames = [
      "w",
      "wtimeout",
      "fsync",
      "j",
      "writeConcern",
      "readPreference",
      "readPreferenceTags",
      "native_parser",
      "forceServerObjectId",
      "pkFactory",
      "serializeFunctions",
      "raw",
      "bufferMaxEntries",
      "authSource",
      "ignoreUndefined",
      "promiseLibrary",
      "readConcern",
      "retryMiliSeconds",
      "numberOfRetries",
      "parentDb",
      "noListener",
      "loggerLevel",
      "logger",
      "promoteBuffers",
      "promoteLongs",
      "promoteValues",
      "bsonRegExp",
      "compression",
      "retryWrites"
    ];
    function Db(databaseName, topology, options) {
      options = options || {};
      if (!(this instanceof Db))
        return new Db(databaseName, topology, options);
      EventEmitter.call(this);
      const promiseLibrary = options.promiseLibrary || Promise;
      options = filterOptions(options, legalOptionNames);
      options.promiseLibrary = promiseLibrary;
      this.s = {
        dbCache: {},
        children: [],
        topology,
        options,
        logger: Logger("Db", options),
        bson: topology ? topology.bson : null,
        readPreference: ReadPreference.fromOptions(options),
        bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : -1,
        parentDb: options.parentDb || null,
        pkFactory: options.pkFactory || ObjectID2,
        nativeParser: options.nativeParser || options.native_parser,
        promiseLibrary,
        noListener: typeof options.noListener === "boolean" ? options.noListener : false,
        readConcern: ReadConcern.fromOptions(options),
        writeConcern: WriteConcern.fromOptions(options),
        namespace: new MongoDBNamespace(databaseName)
      };
      validateDatabaseName(databaseName);
      getSingleProperty(this, "serverConfig", this.s.topology);
      getSingleProperty(this, "bufferMaxEntries", this.s.bufferMaxEntries);
      getSingleProperty(this, "databaseName", this.s.namespace.db);
      if (options.parentDb)
        return;
      if (this.s.noListener)
        return;
      topology.on("error", createListener(this, "error", this));
      topology.on("timeout", createListener(this, "timeout", this));
      topology.on("close", createListener(this, "close", this));
      topology.on("parseError", createListener(this, "parseError", this));
      topology.once("open", createListener(this, "open", this));
      topology.once("fullsetup", createListener(this, "fullsetup", this));
      topology.once("all", createListener(this, "all", this));
      topology.on("reconnect", createListener(this, "reconnect", this));
    }
    inherits2(Db, EventEmitter);
    Db.prototype.on = deprecate(function() {
      return Db.super_.prototype.on.apply(this, arguments);
    }, "Listening to events on the Db class has been deprecated and will be removed in the next major version.");
    Db.prototype.once = deprecate(function() {
      return Db.super_.prototype.once.apply(this, arguments);
    }, "Listening to events on the Db class has been deprecated and will be removed in the next major version.");
    Object.defineProperty(Db.prototype, "topology", {
      enumerable: true,
      get: function() {
        return this.s.topology;
      }
    });
    Object.defineProperty(Db.prototype, "options", {
      enumerable: true,
      get: function() {
        return this.s.options;
      }
    });
    Object.defineProperty(Db.prototype, "slaveOk", {
      enumerable: true,
      get: function() {
        if (this.s.options.readPreference != null && (this.s.options.readPreference !== "primary" || this.s.options.readPreference.mode !== "primary")) {
          return true;
        }
        return false;
      }
    });
    Object.defineProperty(Db.prototype, "readConcern", {
      enumerable: true,
      get: function() {
        return this.s.readConcern;
      }
    });
    Object.defineProperty(Db.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        if (this.s.readPreference == null) {
          return ReadPreference.primary;
        }
        return this.s.readPreference;
      }
    });
    Object.defineProperty(Db.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(Db.prototype, "namespace", {
      enumerable: true,
      get: function() {
        return this.s.namespace.toString();
      }
    });
    Db.prototype.command = function(command, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options);
      const commandOperation = new RunCommandOperation(this, command, options);
      return executeOperation(this.s.topology, commandOperation, callback);
    };
    Db.prototype.aggregate = function(pipeline, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (options == null && callback == null) {
        options = {};
      }
      const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline, options), options);
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    };
    Db.prototype.admin = function() {
      const Admin = require_admin();
      return new Admin(this, this.s.topology, this.s.promiseLibrary);
    };
    var COLLECTION_OPTION_KEYS = [
      "pkFactory",
      "readPreference",
      "serializeFunctions",
      "strict",
      "readConcern",
      "ignoreUndefined",
      "promoteValues",
      "promoteBuffers",
      "promoteLongs",
      "bsonRegExp"
    ];
    Db.prototype.collection = deprecateOptions({
      name: "Db.collection",
      deprecatedOptions: ["strict"],
      optionsIndex: 1
    }, function(name, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      options = Object.assign({}, options);
      options.promiseLibrary = this.s.promiseLibrary;
      options.readConcern = options.readConcern ? new ReadConcern(options.readConcern.level) : this.readConcern;
      if (this.s.options.ignoreUndefined) {
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      for (const collectionOptionKey of COLLECTION_OPTION_KEYS) {
        if (!(collectionOptionKey in options) && this.s.options[collectionOptionKey] !== void 0) {
          options[collectionOptionKey] = this.s.options[collectionOptionKey];
        }
      }
      options = conditionallyMergeWriteConcern(options, this.s.options);
      if (options == null || !options.strict) {
        try {
          const collection = new Collection(this, this.s.topology, this.databaseName, name, this.s.pkFactory, options);
          if (callback)
            callback(null, collection);
          return collection;
        } catch (err) {
          if (err instanceof MongoError && callback)
            return callback(err);
          throw err;
        }
      }
      if (typeof callback !== "function") {
        throw toError(`A callback is required in strict mode. While getting collection ${name}`);
      }
      if (this.serverConfig && this.serverConfig.isDestroyed()) {
        return callback(new MongoError("topology was destroyed"));
      }
      const listCollectionOptions = Object.assign({}, options, { nameOnly: true });
      this.listCollections({ name }, listCollectionOptions).toArray((err, collections) => {
        if (err != null)
          return handleCallback(callback, err, null);
        if (collections.length === 0)
          return handleCallback(callback, toError(`Collection ${name} does not exist. Currently in strict mode.`), null);
        try {
          return handleCallback(callback, null, new Collection(this, this.s.topology, this.databaseName, name, this.s.pkFactory, options));
        } catch (err2) {
          return handleCallback(callback, err2, null);
        }
      });
    });
    Db.prototype.createCollection = deprecateOptions({
      name: "Db.createCollection",
      deprecatedOptions: ["autoIndexId", "strict", "w", "wtimeout", "j"],
      optionsIndex: 1
    }, function(name, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      options.promiseLibrary = options.promiseLibrary || this.s.promiseLibrary;
      options.readConcern = options.readConcern ? new ReadConcern(options.readConcern.level) : this.readConcern;
      const createCollectionOperation = new CreateCollectionOperation(this, name, options);
      return executeOperation(this.s.topology, createCollectionOperation, callback);
    });
    Db.prototype.stats = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const commandObject = { dbStats: true };
      if (options["scale"] != null)
        commandObject["scale"] = options["scale"];
      if (options.readPreference == null && this.s.readPreference) {
        options.readPreference = this.s.readPreference;
      }
      const statsOperation = new CommandOperation(this, options, null, commandObject);
      return executeOperation(this.s.topology, statsOperation, callback);
    };
    Db.prototype.listCollections = function(filter, options) {
      filter = filter || {};
      options = options || {};
      return new CommandCursor(this.s.topology, new ListCollectionsOperation(this, filter, options), options);
    };
    Db.prototype.eval = deprecate(function(code, parameters, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      parameters = args.length ? args.shift() : parameters;
      options = args.length ? args.shift() || {} : {};
      return executeLegacyOperation(this.s.topology, evaluate, [
        this,
        code,
        parameters,
        options,
        callback
      ]);
    }, "Db.eval is deprecated as of MongoDB version 3.2");
    Db.prototype.renameCollection = function(fromCollection, toCollection, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options, { readPreference: ReadPreference.PRIMARY });
      options.new_collection = true;
      const renameOperation = new RenameOperation(this.collection(fromCollection), toCollection, options);
      return executeOperation(this.s.topology, renameOperation, callback);
    };
    Db.prototype.dropCollection = function(name, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const dropCollectionOperation = new DropCollectionOperation(this, name, options);
      return executeOperation(this.s.topology, dropCollectionOperation, callback);
    };
    Db.prototype.dropDatabase = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const dropDatabaseOperation = new DropDatabaseOperation(this, options);
      return executeOperation(this.s.topology, dropDatabaseOperation, callback);
    };
    Db.prototype.collections = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const collectionsOperation = new CollectionsOperation(this, options);
      return executeOperation(this.s.topology, collectionsOperation, callback);
    };
    Db.prototype.executeDbAdminCommand = function(selector, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      options.readPreference = ReadPreference.resolve(this, options);
      const executeDbAdminCommandOperation = new ExecuteDbAdminCommandOperation(this, selector, options);
      return executeOperation(this.s.topology, executeDbAdminCommandOperation, callback);
    };
    Db.prototype.createIndex = function(name, fieldOrSpec, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options ? Object.assign({}, options) : {};
      const createIndexesOperation = new CreateIndexesOperation(this, name, fieldOrSpec, options);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Db.prototype.ensureIndex = deprecate(function(name, fieldOrSpec, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.s.topology, ensureIndex, [
        this,
        name,
        fieldOrSpec,
        options,
        callback
      ]);
    }, "Db.ensureIndex is deprecated as of MongoDB version 3.0 / driver version 2.0");
    Db.prototype.addChild = function(db) {
      if (this.s.parentDb)
        return this.s.parentDb.addChild(db);
      this.s.children.push(db);
    };
    Db.prototype.addUser = function(username, password, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (typeof username === "string" && password != null && typeof password === "object") {
        options = password;
        password = null;
      }
      const addUserOperation = new AddUserOperation(this, username, password, options);
      return executeOperation(this.s.topology, addUserOperation, callback);
    };
    Db.prototype.removeUser = function(username, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const removeUserOperation = new RemoveUserOperation(this, username, options);
      return executeOperation(this.s.topology, removeUserOperation, callback);
    };
    Db.prototype.setProfilingLevel = function(level, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const setProfilingLevelOperation = new SetProfilingLevelOperation(this, level, options);
      return executeOperation(this.s.topology, setProfilingLevelOperation, callback);
    };
    Db.prototype.profilingInfo = deprecate(function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.s.topology, profilingInfo, [this, options, callback]);
    }, "Db.profilingInfo is deprecated. Query the system.profile collection directly.");
    Db.prototype.profilingLevel = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const profilingLevelOperation = new ProfilingLevelOperation(this, options);
      return executeOperation(this.s.topology, profilingLevelOperation, callback);
    };
    Db.prototype.indexInformation = function(name, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const indexInformationOperation = new IndexInformationOperation(this, name, options);
      return executeOperation(this.s.topology, indexInformationOperation, callback);
    };
    Db.prototype.unref = function() {
      this.s.topology.unref();
    };
    Db.prototype.watch = function(pipeline, options) {
      pipeline = pipeline || [];
      options = options || {};
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }
      return new ChangeStream(this, pipeline, options);
    };
    Db.prototype.getLogger = function() {
      return this.s.logger;
    };
    Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
    Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
    Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
    Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
    Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
    Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
    module2.exports = Db;
  }
});

// node_modules/mongodb/lib/dynamic_loaders.js
var require_dynamic_loaders = __commonJS({
  "node_modules/mongodb/lib/dynamic_loaders.js"(exports2, module2) {
    "use strict";
    var collection;
    var cursor;
    var db;
    function loadCollection() {
      if (!collection) {
        collection = require_collection();
      }
      return collection;
    }
    function loadCursor() {
      if (!cursor) {
        cursor = require_cursor2();
      }
      return cursor;
    }
    function loadDb() {
      if (!db) {
        db = require_db2();
      }
      return db;
    }
    module2.exports = {
      loadCollection,
      loadCursor,
      loadDb
    };
  }
});

// node_modules/mongodb/lib/operations/map_reduce.js
var require_map_reduce = __commonJS({
  "node_modules/mongodb/lib/operations/map_reduce.js"(exports2, module2) {
    "use strict";
    var applyWriteConcern = require_utils6().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var decorateWithCollation = require_utils6().decorateWithCollation;
    var decorateWithReadConcern = require_utils6().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils6().handleCallback;
    var isObject2 = require_utils6().isObject;
    var loadDb = require_dynamic_loaders().loadDb;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils6().toError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var decorateWithExplain = require_utils6().decorateWithExplain;
    var maxWireVersion = require_utils4().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var exclusionList = [
      "explain",
      "readPreference",
      "session",
      "bypassDocumentValidation",
      "w",
      "wtimeout",
      "j",
      "writeConcern"
    ];
    var MapReduceOperation = class extends OperationBase {
      constructor(collection, map, reduce, options) {
        super(options);
        this.collection = collection;
        this.map = map;
        this.reduce = reduce;
      }
      execute(callback) {
        const coll = this.collection;
        const map = this.map;
        const reduce = this.reduce;
        let options = this.options;
        let mapCommandHash = {
          mapReduce: coll.collectionName,
          map,
          reduce
        };
        for (let n in options) {
          if (n === "scope") {
            mapCommandHash[n] = processScope(options[n]);
          } else {
            if (exclusionList.indexOf(n) === -1) {
              mapCommandHash[n] = options[n];
            }
          }
        }
        options = Object.assign({}, options);
        options.readPreference = ReadPreference.resolve(coll, options);
        if (options.readPreference !== false && options.readPreference !== "primary" && options["out"] && options["out"].inline !== 1 && options["out"] !== "inline") {
          options.readPreference = "primary";
          applyWriteConcern(mapCommandHash, { db: coll.s.db, collection: coll }, options);
        } else {
          decorateWithReadConcern(mapCommandHash, coll, options);
        }
        if (options.bypassDocumentValidation === true) {
          mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;
        }
        try {
          decorateWithCollation(mapCommandHash, coll, options);
        } catch (err) {
          return callback(err, null);
        }
        if (this.explain) {
          if (maxWireVersion(coll.s.topology) < 9) {
            callback(new MongoError(`server does not support explain on mapReduce`));
            return;
          }
          mapCommandHash = decorateWithExplain(mapCommandHash, this.explain);
        }
        executeCommand(coll.s.db, mapCommandHash, options, (err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (result.ok !== 1 || result.err || result.errmsg) {
            return handleCallback(callback, toError(result));
          }
          if (this.explain)
            return callback(void 0, result);
          const stats = {};
          if (result.timeMillis)
            stats["processtime"] = result.timeMillis;
          if (result.counts)
            stats["counts"] = result.counts;
          if (result.timing)
            stats["timing"] = result.timing;
          if (result.results) {
            if (options["verbose"] == null || !options["verbose"]) {
              return handleCallback(callback, null, result.results);
            }
            return handleCallback(callback, null, { results: result.results, stats });
          }
          let collection = null;
          if (result.result != null && typeof result.result === "object") {
            const doc = result.result;
            let Db = loadDb();
            collection = new Db(doc.db, coll.s.db.s.topology, coll.s.db.s.options).collection(doc.collection);
          } else {
            collection = coll.s.db.collection(result.result);
          }
          if (options["verbose"] == null || !options["verbose"]) {
            return handleCallback(callback, err, collection);
          }
          handleCallback(callback, err, { collection, stats });
        });
      }
    };
    function processScope(scope) {
      if (!isObject2(scope) || scope._bsontype === "ObjectID") {
        return scope;
      }
      const keys = Object.keys(scope);
      let key;
      const new_scope = {};
      for (let i = keys.length - 1; i >= 0; i--) {
        key = keys[i];
        if (typeof scope[key] === "function") {
          new_scope[key] = new Code2(String(scope[key]));
        } else {
          new_scope[key] = processScope(scope[key]);
        }
      }
      return new_scope;
    }
    defineAspects(MapReduceOperation, [Aspect.EXPLAINABLE]);
    module2.exports = MapReduceOperation;
  }
});

// node_modules/mongodb/lib/operations/re_index.js
var require_re_index = __commonJS({
  "node_modules/mongodb/lib/operations/re_index.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var serverType = require_common().serverType;
    var ServerType = require_common().ServerType;
    var MongoError = require_core().MongoError;
    var ReIndexOperation = class extends CommandOperationV2 {
      constructor(collection, options) {
        super(collection, options);
        this.collectionName = collection.collectionName;
      }
      execute(server, callback) {
        if (serverType(server) !== ServerType.Standalone) {
          callback(new MongoError(`reIndex can only be executed on standalone servers.`));
          return;
        }
        super.executeCommand(server, { reIndex: this.collectionName }, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, !!result.ok);
        });
      }
    };
    defineAspects(ReIndexOperation, [Aspect.EXECUTE_WITH_SELECTION]);
    module2.exports = ReIndexOperation;
  }
});

// node_modules/mongodb/lib/operations/replace_one.js
var require_replace_one = __commonJS({
  "node_modules/mongodb/lib/operations/replace_one.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils6().hasAtomicOperators;
    var ReplaceOneOperation = class extends OperationBase {
      constructor(collection, filter, replacement, options) {
        super(options);
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not contain atomic operators");
        }
        this.collection = collection;
        this.filter = filter;
        this.replacement = replacement;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const replacement = this.replacement;
        const options = this.options;
        options.multi = false;
        updateDocuments(coll, filter, replacement, options, (err, r) => replaceCallback(err, r, replacement, callback));
      }
    };
    function replaceCallback(err, r, doc, callback) {
      if (callback == null)
        return;
      if (err && callback)
        return callback(err);
      if (r == null)
        return callback(null, { result: { ok: 1 } });
      r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
      r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
      r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
      r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
      r.ops = [doc];
      if (callback)
        callback(null, r);
    }
    module2.exports = ReplaceOneOperation;
  }
});

// node_modules/mongodb/lib/operations/stats.js
var require_stats = __commonJS({
  "node_modules/mongodb/lib/operations/stats.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var StatsOperation = class extends CommandOperation {
      constructor(collection, options) {
        super(collection.s.db, options, collection);
      }
      _buildCommand() {
        const collection = this.collection;
        const options = this.options;
        const command = {
          collStats: collection.collectionName
        };
        if (options["scale"] != null) {
          command["scale"] = options["scale"];
        }
        return command;
      }
    };
    defineAspects(StatsOperation, Aspect.READ_OPERATION);
    module2.exports = StatsOperation;
  }
});

// node_modules/mongodb/lib/operations/update_many.js
var require_update_many = __commonJS({
  "node_modules/mongodb/lib/operations/update_many.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils6().hasAtomicOperators;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var UpdateManyOperation = class extends OperationBase {
      constructor(collection, filter, update, options) {
        super(options);
        if (!hasAtomicOperators(update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.collection = collection;
        this.filter = filter;
        this.update = update;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const update = this.update;
        const options = this.options;
        options.multi = true;
        updateDocuments(coll, filter, update, options, (err, r) => {
          if (callback == null)
            return;
          if (err)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
          r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
          r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
          r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(UpdateManyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = UpdateManyOperation;
  }
});

// node_modules/mongodb/lib/operations/update_one.js
var require_update_one = __commonJS({
  "node_modules/mongodb/lib/operations/update_one.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils6().hasAtomicOperators;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var UpdateOneOperation = class extends OperationBase {
      constructor(collection, filter, update, options) {
        super(options);
        if (!hasAtomicOperators(update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.collection = collection;
        this.filter = filter;
        this.update = update;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const update = this.update;
        const options = this.options;
        options.multi = false;
        updateDocuments(coll, filter, update, options, (err, r) => {
          if (callback == null)
            return;
          if (err)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
          r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
          r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
          r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(UpdateOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = UpdateOneOperation;
  }
});

// node_modules/mongodb/lib/collection.js
var require_collection = __commonJS({
  "node_modules/mongodb/lib/collection.js"(exports2, module2) {
    "use strict";
    var deprecate = require("util").deprecate;
    var deprecateOptions = require_utils6().deprecateOptions;
    var emitWarningOnce = require_utils6().emitWarningOnce;
    var checkCollectionName = require_utils6().checkCollectionName;
    var ObjectID2 = require_core().BSON.ObjectID;
    var MongoError = require_core().MongoError;
    var normalizeHintField = require_utils6().normalizeHintField;
    var decorateCommand = require_utils6().decorateCommand;
    var decorateWithCollation = require_utils6().decorateWithCollation;
    var decorateWithReadConcern = require_utils6().decorateWithReadConcern;
    var formattedOrderClause = require_utils6().formattedOrderClause;
    var ReadPreference = require_core().ReadPreference;
    var unordered = require_unordered();
    var ordered = require_ordered();
    var ChangeStream = require_change_stream();
    var executeLegacyOperation = require_utils6().executeLegacyOperation;
    var WriteConcern = require_write_concern();
    var ReadConcern = require_read_concern();
    var MongoDBNamespace = require_utils6().MongoDBNamespace;
    var AggregationCursor = require_aggregation_cursor();
    var CommandCursor = require_command_cursor();
    var ensureIndex = require_collection_ops().ensureIndex;
    var group = require_collection_ops().group;
    var parallelCollectionScan = require_collection_ops().parallelCollectionScan;
    var removeDocuments = require_common_functions().removeDocuments;
    var save = require_collection_ops().save;
    var updateDocuments = require_common_functions().updateDocuments;
    var AggregateOperation = require_aggregate();
    var BulkWriteOperation = require_bulk_write();
    var CountDocumentsOperation = require_count_documents();
    var CreateIndexesOperation = require_create_indexes();
    var DeleteManyOperation = require_delete_many();
    var DeleteOneOperation = require_delete_one();
    var DistinctOperation = require_distinct();
    var DropCollectionOperation = require_drop().DropCollectionOperation;
    var DropIndexOperation = require_drop_index();
    var DropIndexesOperation = require_drop_indexes();
    var EstimatedDocumentCountOperation = require_estimated_document_count();
    var FindOperation = require_find();
    var FindOneOperation = require_find_one();
    var FindAndModifyOperation = require_find_and_modify();
    var FindOneAndDeleteOperation = require_find_one_and_delete();
    var FindOneAndReplaceOperation = require_find_one_and_replace();
    var FindOneAndUpdateOperation = require_find_one_and_update();
    var GeoHaystackSearchOperation = require_geo_haystack_search();
    var IndexesOperation = require_indexes();
    var IndexExistsOperation = require_index_exists();
    var IndexInformationOperation = require_index_information();
    var InsertManyOperation = require_insert_many();
    var InsertOneOperation = require_insert_one();
    var IsCappedOperation = require_is_capped();
    var ListIndexesOperation = require_list_indexes();
    var MapReduceOperation = require_map_reduce();
    var OptionsOperation = require_options_operation();
    var RenameOperation = require_rename();
    var ReIndexOperation = require_re_index();
    var ReplaceOneOperation = require_replace_one();
    var StatsOperation = require_stats();
    var UpdateManyOperation = require_update_many();
    var UpdateOneOperation = require_update_one();
    var executeOperation = require_execute_operation();
    var mergeKeys = ["ignoreUndefined"];
    function Collection(db, topology, dbName, name, pkFactory, options) {
      checkCollectionName(name);
      const internalHint = null;
      const slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;
      const serializeFunctions = options == null || options.serializeFunctions == null ? db.s.options.serializeFunctions : options.serializeFunctions;
      const raw = options == null || options.raw == null ? db.s.options.raw : options.raw;
      const promoteLongs = options == null || options.promoteLongs == null ? db.s.options.promoteLongs : options.promoteLongs;
      const promoteValues = options == null || options.promoteValues == null ? db.s.options.promoteValues : options.promoteValues;
      const promoteBuffers = options == null || options.promoteBuffers == null ? db.s.options.promoteBuffers : options.promoteBuffers;
      const bsonRegExp = options == null || options.bsonRegExp == null ? db.s.options.bsonRegExp : options.bsonRegExp;
      const collectionHint = null;
      const namespace = new MongoDBNamespace(dbName, name);
      const promiseLibrary = options.promiseLibrary || Promise;
      pkFactory = pkFactory == null ? ObjectID2 : pkFactory;
      this.s = {
        pkFactory,
        db,
        topology,
        options,
        namespace,
        readPreference: ReadPreference.fromOptions(options),
        slaveOk,
        serializeFunctions,
        raw,
        promoteLongs,
        promoteValues,
        promoteBuffers,
        bsonRegExp,
        internalHint,
        collectionHint,
        promiseLibrary,
        readConcern: ReadConcern.fromOptions(options),
        writeConcern: WriteConcern.fromOptions(options)
      };
    }
    Object.defineProperty(Collection.prototype, "dbName", {
      enumerable: true,
      get: function() {
        return this.s.namespace.db;
      }
    });
    Object.defineProperty(Collection.prototype, "collectionName", {
      enumerable: true,
      get: function() {
        return this.s.namespace.collection;
      }
    });
    Object.defineProperty(Collection.prototype, "namespace", {
      enumerable: true,
      get: function() {
        return this.s.namespace.toString();
      }
    });
    Object.defineProperty(Collection.prototype, "readConcern", {
      enumerable: true,
      get: function() {
        if (this.s.readConcern == null) {
          return this.s.db.readConcern;
        }
        return this.s.readConcern;
      }
    });
    Object.defineProperty(Collection.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        if (this.s.readPreference == null) {
          return this.s.db.readPreference;
        }
        return this.s.readPreference;
      }
    });
    Object.defineProperty(Collection.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        if (this.s.writeConcern == null) {
          return this.s.db.writeConcern;
        }
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(Collection.prototype, "hint", {
      enumerable: true,
      get: function() {
        return this.s.collectionHint;
      },
      set: function(v) {
        this.s.collectionHint = normalizeHintField(v);
      }
    });
    var DEPRECATED_FIND_OPTIONS = ["maxScan", "fields", "snapshot", "oplogReplay"];
    Collection.prototype.find = deprecateOptions({
      name: "collection.find",
      deprecatedOptions: DEPRECATED_FIND_OPTIONS,
      optionsIndex: 1
    }, function(query, options, callback) {
      if (typeof callback === "object") {
        emitWarningOnce("Third parameter to `find()` must be a callback or undefined");
      }
      let selector = query;
      if (typeof callback !== "function") {
        if (typeof options === "function") {
          callback = options;
          options = void 0;
        } else if (options == null) {
          callback = typeof selector === "function" ? selector : void 0;
          selector = typeof selector === "object" ? selector : void 0;
        }
      }
      selector = selector == null ? {} : selector;
      const object = selector;
      if (Buffer.isBuffer(object)) {
        const object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
        if (object_size !== object.length) {
          const error = new Error("query selector raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
          error.name = "MongoError";
          throw error;
        }
      }
      if (selector != null && selector._bsontype === "ObjectID") {
        selector = { _id: selector };
      }
      if (!options)
        options = {};
      let projection = options.projection || options.fields;
      if (projection && !Buffer.isBuffer(projection) && Array.isArray(projection)) {
        projection = projection.length ? projection.reduce((result, field) => {
          result[field] = 1;
          return result;
        }, {}) : { _id: 1 };
      }
      let newOptions = Object.assign({}, options);
      for (let key in this.s.options) {
        if (mergeKeys.indexOf(key) !== -1) {
          newOptions[key] = this.s.options[key];
        }
      }
      newOptions.skip = options.skip ? options.skip : 0;
      newOptions.limit = options.limit ? options.limit : 0;
      newOptions.raw = typeof options.raw === "boolean" ? options.raw : this.s.raw;
      newOptions.hint = options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;
      newOptions.timeout = typeof options.timeout === "undefined" ? void 0 : options.timeout;
      newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk;
      newOptions.readPreference = ReadPreference.resolve(this, newOptions);
      if (newOptions.readPreference != null && (newOptions.readPreference !== "primary" || newOptions.readPreference.mode !== "primary")) {
        newOptions.slaveOk = true;
      }
      if (selector != null && typeof selector !== "object") {
        throw MongoError.create({ message: "query selector must be an object", driver: true });
      }
      const findCommand = {
        find: this.s.namespace.toString(),
        limit: newOptions.limit,
        skip: newOptions.skip,
        query: selector
      };
      if (typeof options.allowDiskUse === "boolean") {
        findCommand.allowDiskUse = options.allowDiskUse;
      }
      if (typeof newOptions.awaitdata === "boolean") {
        newOptions.awaitData = newOptions.awaitdata;
      }
      if (typeof newOptions.timeout === "boolean")
        newOptions.noCursorTimeout = !newOptions.timeout;
      decorateCommand(findCommand, newOptions, ["session", "collation"]);
      if (projection)
        findCommand.fields = projection;
      newOptions.db = this.s.db;
      newOptions.promiseLibrary = this.s.promiseLibrary;
      if (newOptions.raw == null && typeof this.s.raw === "boolean")
        newOptions.raw = this.s.raw;
      if (newOptions.promoteLongs == null && typeof this.s.promoteLongs === "boolean")
        newOptions.promoteLongs = this.s.promoteLongs;
      if (newOptions.promoteValues == null && typeof this.s.promoteValues === "boolean")
        newOptions.promoteValues = this.s.promoteValues;
      if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers === "boolean")
        newOptions.promoteBuffers = this.s.promoteBuffers;
      if (newOptions.bsonRegExp == null && typeof this.s.bsonRegExp === "boolean")
        newOptions.bsonRegExp = this.s.bsonRegExp;
      if (findCommand.sort) {
        findCommand.sort = formattedOrderClause(findCommand.sort);
      }
      decorateWithReadConcern(findCommand, this, options);
      try {
        decorateWithCollation(findCommand, this, options);
      } catch (err) {
        if (typeof callback === "function")
          return callback(err, null);
        throw err;
      }
      const cursor = this.s.topology.cursor(new FindOperation(this, this.s.namespace, findCommand, newOptions), newOptions);
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    });
    Collection.prototype.insertOne = function(doc, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const insertOneOperation = new InsertOneOperation(this, doc, options);
      return executeOperation(this.s.topology, insertOneOperation, callback);
    };
    Collection.prototype.insertMany = function(docs, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options ? Object.assign({}, options) : { ordered: true };
      const insertManyOperation = new InsertManyOperation(this, docs, options);
      return executeOperation(this.s.topology, insertManyOperation, callback);
    };
    Collection.prototype.bulkWrite = function(operations, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || { ordered: true };
      if (!Array.isArray(operations)) {
        throw MongoError.create({ message: "operations must be an array of documents", driver: true });
      }
      const bulkWriteOperation = new BulkWriteOperation(this, operations, options);
      return executeOperation(this.s.topology, bulkWriteOperation, callback);
    };
    Collection.prototype.insert = deprecate(function(docs, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || { ordered: false };
      docs = !Array.isArray(docs) ? [docs] : docs;
      if (options.keepGoing === true) {
        options.ordered = false;
      }
      return this.insertMany(docs, options, callback);
    }, "collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.");
    Collection.prototype.updateOne = function(filter, update, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options);
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new UpdateOneOperation(this, filter, update, options), callback);
    };
    Collection.prototype.replaceOne = function(filter, doc, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options);
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new ReplaceOneOperation(this, filter, doc, options), callback);
    };
    Collection.prototype.updateMany = function(filter, update, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options);
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new UpdateManyOperation(this, filter, update, options), callback);
    };
    Collection.prototype.update = deprecate(function(selector, update, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, updateDocuments, [
        this,
        selector,
        update,
        options,
        callback
      ]);
    }, "collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.");
    Collection.prototype.deleteOne = function(filter, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options);
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const deleteOneOperation = new DeleteOneOperation(this, filter, options);
      return executeOperation(this.s.topology, deleteOneOperation, callback);
    };
    Collection.prototype.removeOne = Collection.prototype.deleteOne;
    Collection.prototype.deleteMany = function(filter, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options);
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const deleteManyOperation = new DeleteManyOperation(this, filter, options);
      return executeOperation(this.s.topology, deleteManyOperation, callback);
    };
    Collection.prototype.removeMany = Collection.prototype.deleteMany;
    Collection.prototype.remove = deprecate(function(selector, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, removeDocuments, [
        this,
        selector,
        options,
        callback
      ]);
    }, "collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.");
    Collection.prototype.save = deprecate(function(doc, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, save, [this, doc, options, callback]);
    }, "collection.save is deprecated. Use insertOne, insertMany, updateOne, or updateMany instead.");
    Collection.prototype.findOne = deprecateOptions({
      name: "collection.find",
      deprecatedOptions: DEPRECATED_FIND_OPTIONS,
      optionsIndex: 1
    }, function(query, options, callback) {
      if (typeof callback === "object") {
        emitWarningOnce("Third parameter to `findOne()` must be a callback or undefined");
      }
      if (typeof query === "function")
        callback = query, query = {}, options = {};
      if (typeof options === "function")
        callback = options, options = {};
      query = query || {};
      options = options || {};
      const findOneOperation = new FindOneOperation(this, query, options);
      return executeOperation(this.s.topology, findOneOperation, callback);
    });
    Collection.prototype.rename = function(newName, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options, { readPreference: ReadPreference.PRIMARY });
      const renameOperation = new RenameOperation(this, newName, options);
      return executeOperation(this.s.topology, renameOperation, callback);
    };
    Collection.prototype.drop = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const dropCollectionOperation = new DropCollectionOperation(this.s.db, this.collectionName, options);
      return executeOperation(this.s.topology, dropCollectionOperation, callback);
    };
    Collection.prototype.options = function(opts, callback) {
      if (typeof opts === "function")
        callback = opts, opts = {};
      opts = opts || {};
      const optionsOperation = new OptionsOperation(this, opts);
      return executeOperation(this.s.topology, optionsOperation, callback);
    };
    Collection.prototype.isCapped = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const isCappedOperation = new IsCappedOperation(this, options);
      return executeOperation(this.s.topology, isCappedOperation, callback);
    };
    Collection.prototype.createIndex = function(fieldOrSpec, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, fieldOrSpec, options);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Collection.prototype.createIndexes = function(indexSpecs, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options ? Object.assign({}, options) : {};
      if (typeof options.maxTimeMS !== "number")
        delete options.maxTimeMS;
      const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, indexSpecs, options);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Collection.prototype.dropIndex = function(indexName, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() || {} : {};
      options.readPreference = ReadPreference.PRIMARY;
      const dropIndexOperation = new DropIndexOperation(this, indexName, options);
      return executeOperation(this.s.topology, dropIndexOperation, callback);
    };
    Collection.prototype.dropIndexes = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options ? Object.assign({}, options) : {};
      if (typeof options.maxTimeMS !== "number")
        delete options.maxTimeMS;
      const dropIndexesOperation = new DropIndexesOperation(this, options);
      return executeOperation(this.s.topology, dropIndexesOperation, callback);
    };
    Collection.prototype.dropAllIndexes = deprecate(Collection.prototype.dropIndexes, "collection.dropAllIndexes is deprecated. Use dropIndexes instead.");
    Collection.prototype.reIndex = deprecate(function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const reIndexOperation = new ReIndexOperation(this, options);
      return executeOperation(this.s.topology, reIndexOperation, callback);
    }, "collection.reIndex is deprecated. Use db.command instead.");
    Collection.prototype.listIndexes = function(options) {
      const cursor = new CommandCursor(this.s.topology, new ListIndexesOperation(this, options), options);
      return cursor;
    };
    Collection.prototype.ensureIndex = deprecate(function(fieldOrSpec, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.s.topology, ensureIndex, [
        this,
        fieldOrSpec,
        options,
        callback
      ]);
    }, "collection.ensureIndex is deprecated. Use createIndexes instead.");
    Collection.prototype.indexExists = function(indexes, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const indexExistsOperation = new IndexExistsOperation(this, indexes, options);
      return executeOperation(this.s.topology, indexExistsOperation, callback);
    };
    Collection.prototype.indexInformation = function(options, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() || {} : {};
      const indexInformationOperation = new IndexInformationOperation(this.s.db, this.collectionName, options);
      return executeOperation(this.s.topology, indexInformationOperation, callback);
    };
    Collection.prototype.count = deprecate(function(query, options, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      query = args.length ? args.shift() || {} : {};
      options = args.length ? args.shift() || {} : {};
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeOperation(this.s.topology, new EstimatedDocumentCountOperation(this, query, options), callback);
    }, "collection.count is deprecated, and will be removed in a future version. Use Collection.countDocuments or Collection.estimatedDocumentCount instead");
    Collection.prototype.estimatedDocumentCount = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const estimatedDocumentCountOperation = new EstimatedDocumentCountOperation(this, options);
      return executeOperation(this.s.topology, estimatedDocumentCountOperation, callback);
    };
    Collection.prototype.countDocuments = function(query, options, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      query = args.length ? args.shift() || {} : {};
      options = args.length ? args.shift() || {} : {};
      const countDocumentsOperation = new CountDocumentsOperation(this, query, options);
      return executeOperation(this.s.topology, countDocumentsOperation, callback);
    };
    Collection.prototype.distinct = function(key, query, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      const queryOption = args.length ? args.shift() || {} : {};
      const optionsOption = args.length ? args.shift() || {} : {};
      const distinctOperation = new DistinctOperation(this, key, queryOption, optionsOption);
      return executeOperation(this.s.topology, distinctOperation, callback);
    };
    Collection.prototype.indexes = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const indexesOperation = new IndexesOperation(this, options);
      return executeOperation(this.s.topology, indexesOperation, callback);
    };
    Collection.prototype.stats = function(options, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() || {} : {};
      const statsOperation = new StatsOperation(this, options);
      return executeOperation(this.s.topology, statsOperation, callback);
    };
    Collection.prototype.findOneAndDelete = function(filter, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new FindOneAndDeleteOperation(this, filter, options), callback);
    };
    Collection.prototype.findOneAndReplace = deprecateOptions({
      name: "collection.findOneAndReplace",
      deprecatedOptions: ["returnOriginal"],
      optionsIndex: 2
    }, function(filter, replacement, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new FindOneAndReplaceOperation(this, filter, replacement, options), callback);
    });
    Collection.prototype.findOneAndUpdate = deprecateOptions({
      name: "collection.findOneAndUpdate",
      deprecatedOptions: ["returnOriginal"],
      optionsIndex: 2
    }, function(filter, update, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new FindOneAndUpdateOperation(this, filter, update, options), callback);
    });
    Collection.prototype.findAndModify = deprecate(_findAndModify, "collection.findAndModify is deprecated. Use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead.");
    Collection.prototype._findAndModify = _findAndModify;
    function _findAndModify(query, sort, doc, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      sort = args.length ? args.shift() || [] : [];
      doc = args.length ? args.shift() : null;
      options = args.length ? args.shift() || {} : {};
      options = Object.assign({}, options);
      options.readPreference = ReadPreference.PRIMARY;
      return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, doc, options), callback);
    }
    Collection.prototype.findAndRemove = deprecate(function(query, sort, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      sort = args.length ? args.shift() || [] : [];
      options = args.length ? args.shift() || {} : {};
      options.remove = true;
      return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, null, options), callback);
    }, "collection.findAndRemove is deprecated. Use findOneAndDelete instead.");
    Collection.prototype.aggregate = function(pipeline, options, callback) {
      if (Array.isArray(pipeline)) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (options == null && callback == null) {
          options = {};
        }
      } else {
        const args = Array.prototype.slice.call(arguments, 0);
        callback = args.pop();
        const opts = args[args.length - 1];
        options = opts && (opts.readPreference || opts.explain || opts.cursor || opts.out || opts.maxTimeMS || opts.hint || opts.allowDiskUse) ? args.pop() : {};
        pipeline = args;
      }
      const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline, options), options);
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    };
    Collection.prototype.watch = function(pipeline, options) {
      pipeline = pipeline || [];
      options = options || {};
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }
      return new ChangeStream(this, pipeline, options);
    };
    Collection.prototype.parallelCollectionScan = deprecate(function(options, callback) {
      if (typeof options === "function")
        callback = options, options = { numCursors: 1 };
      options.numCursors = options.numCursors || 1;
      options.batchSize = options.batchSize || 1e3;
      options = Object.assign({}, options);
      options.readPreference = ReadPreference.resolve(this, options);
      options.promiseLibrary = this.s.promiseLibrary;
      if (options.session) {
        options.session = void 0;
      }
      return executeLegacyOperation(this.s.topology, parallelCollectionScan, [this, options, callback], { skipSessions: true });
    }, "parallelCollectionScan is deprecated in MongoDB v4.1");
    Collection.prototype.geoHaystackSearch = deprecate(function(x, y, options, callback) {
      const args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() || {} : {};
      const geoHaystackSearchOperation = new GeoHaystackSearchOperation(this, x, y, options);
      return executeOperation(this.s.topology, geoHaystackSearchOperation, callback);
    }, "geoHaystackSearch is deprecated, and will be removed in a future version.");
    Collection.prototype.group = deprecate(function(keys, condition, initial, reduce, finalize, command, options, callback) {
      const args = Array.prototype.slice.call(arguments, 3);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      reduce = args.length ? args.shift() : null;
      finalize = args.length ? args.shift() : null;
      command = args.length ? args.shift() : null;
      options = args.length ? args.shift() || {} : {};
      if (!(typeof finalize === "function")) {
        command = finalize;
        finalize = null;
      }
      if (!Array.isArray(keys) && keys instanceof Object && typeof keys !== "function" && !(keys._bsontype === "Code")) {
        keys = Object.keys(keys);
      }
      if (typeof reduce === "function") {
        reduce = reduce.toString();
      }
      if (typeof finalize === "function") {
        finalize = finalize.toString();
      }
      command = command == null ? true : command;
      return executeLegacyOperation(this.s.topology, group, [
        this,
        keys,
        condition,
        initial,
        reduce,
        finalize,
        command,
        options,
        callback
      ]);
    }, "MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.");
    Collection.prototype.mapReduce = function(map, reduce, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      if (options.out == null) {
        throw new Error("the out option parameter must be defined, see mongodb docs for possible values");
      }
      if (typeof map === "function") {
        map = map.toString();
      }
      if (typeof reduce === "function") {
        reduce = reduce.toString();
      }
      if (typeof options.finalize === "function") {
        options.finalize = options.finalize.toString();
      }
      const mapReduceOperation = new MapReduceOperation(this, map, reduce, options);
      return executeOperation(this.s.topology, mapReduceOperation, callback);
    };
    Collection.prototype.initializeUnorderedBulkOp = function(options) {
      options = options || {};
      if (options.ignoreUndefined == null) {
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      options.promiseLibrary = this.s.promiseLibrary;
      return unordered(this.s.topology, this, options);
    };
    Collection.prototype.initializeOrderedBulkOp = function(options) {
      options = options || {};
      if (options.ignoreUndefined == null) {
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      options.promiseLibrary = this.s.promiseLibrary;
      return ordered(this.s.topology, this, options);
    };
    Collection.prototype.getLogger = function() {
      return this.s.db.s.logger;
    };
    module2.exports = Collection;
  }
});

// node_modules/mongodb/lib/change_stream.js
var require_change_stream = __commonJS({
  "node_modules/mongodb/lib/change_stream.js"(exports2, module2) {
    "use strict";
    var Denque = require_denque();
    var EventEmitter = require("events");
    var isResumableError = require_error2().isResumableError;
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var relayEvents = require_utils4().relayEvents;
    var maxWireVersion = require_utils4().maxWireVersion;
    var maybePromise = require_utils6().maybePromise;
    var now = require_utils6().now;
    var calculateDurationInMs = require_utils6().calculateDurationInMs;
    var AggregateOperation = require_aggregate();
    var kResumeQueue = Symbol("resumeQueue");
    var CHANGE_STREAM_OPTIONS = ["resumeAfter", "startAfter", "startAtOperationTime", "fullDocument"];
    var CURSOR_OPTIONS = ["batchSize", "maxAwaitTimeMS", "collation", "readPreference"].concat(CHANGE_STREAM_OPTIONS);
    var CHANGE_DOMAIN_TYPES = {
      COLLECTION: Symbol("Collection"),
      DATABASE: Symbol("Database"),
      CLUSTER: Symbol("Cluster")
    };
    var ChangeStream = class extends EventEmitter {
      constructor(parent, pipeline, options) {
        super();
        const Collection = require_collection();
        const Db = require_db2();
        const MongoClient = require_mongo_client();
        this.pipeline = pipeline || [];
        this.options = options || {};
        this.parent = parent;
        this.namespace = parent.s.namespace;
        if (parent instanceof Collection) {
          this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
          this.topology = parent.s.db.serverConfig;
        } else if (parent instanceof Db) {
          this.type = CHANGE_DOMAIN_TYPES.DATABASE;
          this.topology = parent.serverConfig;
        } else if (parent instanceof MongoClient) {
          this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
          this.topology = parent.topology;
        } else {
          throw new TypeError("parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient");
        }
        this.promiseLibrary = parent.s.promiseLibrary;
        if (!this.options.readPreference && parent.s.readPreference) {
          this.options.readPreference = parent.s.readPreference;
        }
        this[kResumeQueue] = new Denque();
        this.cursor = createChangeStreamCursor(this, options);
        this.closed = false;
        this.on("newListener", (eventName) => {
          if (eventName === "change" && this.cursor && this.listenerCount("change") === 0) {
            this.cursor.on("data", (change) => processNewChange(this, change));
          }
        });
        this.on("removeListener", (eventName) => {
          if (eventName === "change" && this.listenerCount("change") === 0 && this.cursor) {
            this.cursor.removeAllListeners("data");
          }
        });
      }
      get resumeToken() {
        return this.cursor.resumeToken;
      }
      hasNext(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          getCursor(this, (err, cursor) => {
            if (err)
              return cb(err);
            cursor.hasNext(cb);
          });
        });
      }
      next(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          getCursor(this, (err, cursor) => {
            if (err)
              return cb(err);
            cursor.next((error, change) => {
              if (error) {
                this[kResumeQueue].push(() => this.next(cb));
                processError(this, error, cb);
                return;
              }
              processNewChange(this, change, cb);
            });
          });
        });
      }
      isClosed() {
        return this.closed || this.cursor && this.cursor.isClosed();
      }
      close(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          if (this.closed)
            return cb();
          this.closed = true;
          if (!this.cursor)
            return cb();
          const cursor = this.cursor;
          return cursor.close((err) => {
            ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
            this.cursor = void 0;
            return cb(err);
          });
        });
      }
      pipe(destination, options) {
        if (!this.pipeDestinations) {
          this.pipeDestinations = [];
        }
        this.pipeDestinations.push(destination);
        return this.cursor.pipe(destination, options);
      }
      unpipe(destination) {
        if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {
          this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);
        }
        return this.cursor.unpipe(destination);
      }
      stream(options) {
        this.streamOptions = options;
        return this.cursor.stream(options);
      }
      pause() {
        return this.cursor.pause();
      }
      resume() {
        return this.cursor.resume();
      }
    };
    var ChangeStreamCursor = class extends Cursor {
      constructor(topology, operation, options) {
        super(topology, operation, options);
        options = options || {};
        this._resumeToken = null;
        this.startAtOperationTime = options.startAtOperationTime;
        if (options.startAfter) {
          this.resumeToken = options.startAfter;
        } else if (options.resumeAfter) {
          this.resumeToken = options.resumeAfter;
        }
      }
      set resumeToken(token) {
        this._resumeToken = token;
        this.emit("resumeTokenChanged", token);
      }
      get resumeToken() {
        return this._resumeToken;
      }
      get resumeOptions() {
        const result = {};
        for (const optionName of CURSOR_OPTIONS) {
          if (this.options[optionName])
            result[optionName] = this.options[optionName];
        }
        if (this.resumeToken || this.startAtOperationTime) {
          ["resumeAfter", "startAfter", "startAtOperationTime"].forEach((key) => delete result[key]);
          if (this.resumeToken) {
            const resumeKey = this.options.startAfter && !this.hasReceived ? "startAfter" : "resumeAfter";
            result[resumeKey] = this.resumeToken;
          } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {
            result.startAtOperationTime = this.startAtOperationTime;
          }
        }
        return result;
      }
      cacheResumeToken(resumeToken) {
        if (this.bufferedCount() === 0 && this.cursorState.postBatchResumeToken) {
          this.resumeToken = this.cursorState.postBatchResumeToken;
        } else {
          this.resumeToken = resumeToken;
        }
        this.hasReceived = true;
      }
      _processBatch(batchName, response) {
        const cursor = response.cursor;
        if (cursor.postBatchResumeToken) {
          this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;
          if (cursor[batchName].length === 0) {
            this.resumeToken = cursor.postBatchResumeToken;
          }
        }
      }
      _initializeCursor(callback) {
        super._initializeCursor((err, result) => {
          if (err || result == null) {
            callback(err, result);
            return;
          }
          const response = result.documents[0];
          if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && maxWireVersion(this.server) >= 7) {
            this.startAtOperationTime = response.operationTime;
          }
          this._processBatch("firstBatch", response);
          this.emit("init", result);
          this.emit("response");
          callback(err, result);
        });
      }
      _getMore(callback) {
        super._getMore((err, response) => {
          if (err) {
            callback(err);
            return;
          }
          this._processBatch("nextBatch", response);
          this.emit("more", response);
          this.emit("response");
          callback(err, response);
        });
      }
    };
    function createChangeStreamCursor(self2, options) {
      const changeStreamStageOptions = { fullDocument: options.fullDocument || "default" };
      applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);
      if (self2.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
        changeStreamStageOptions.allChangesForCluster = true;
      }
      const pipeline = [{ $changeStream: changeStreamStageOptions }].concat(self2.pipeline);
      const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);
      const changeStreamCursor = new ChangeStreamCursor(self2.topology, new AggregateOperation(self2.parent, pipeline, options), cursorOptions);
      relayEvents(changeStreamCursor, self2, ["resumeTokenChanged", "end", "close"]);
      if (self2.listenerCount("change") > 0) {
        changeStreamCursor.on("data", function(change) {
          processNewChange(self2, change);
        });
      }
      changeStreamCursor.on("error", function(error) {
        processError(self2, error);
      });
      if (self2.pipeDestinations) {
        const cursorStream = changeStreamCursor.stream(self2.streamOptions);
        for (let pipeDestination of self2.pipeDestinations) {
          cursorStream.pipe(pipeDestination);
        }
      }
      return changeStreamCursor;
    }
    function applyKnownOptions(target, source, optionNames) {
      optionNames.forEach((name) => {
        if (source[name]) {
          target[name] = source[name];
        }
      });
      return target;
    }
    var SELECTION_TIMEOUT = 3e4;
    function waitForTopologyConnected(topology, options, callback) {
      setTimeout(() => {
        if (options && options.start == null) {
          options.start = now();
        }
        const start = options.start || now();
        const timeout = options.timeout || SELECTION_TIMEOUT;
        const readPreference = options.readPreference;
        if (topology.isConnected({ readPreference })) {
          return callback();
        }
        if (calculateDurationInMs(start) > timeout) {
          return callback(new MongoError("Timed out waiting for connection"));
        }
        waitForTopologyConnected(topology, options, callback);
      }, 500);
    }
    function processNewChange(changeStream, change, callback) {
      const cursor = changeStream.cursor;
      if (change == null) {
        changeStream.closed = true;
      }
      if (changeStream.closed) {
        if (callback)
          callback(new MongoError("ChangeStream is closed"));
        return;
      }
      if (change && !change._id) {
        const noResumeTokenError = new Error("A change stream document has been received that lacks a resume token (_id).");
        if (!callback)
          return changeStream.emit("error", noResumeTokenError);
        return callback(noResumeTokenError);
      }
      cursor.cacheResumeToken(change._id);
      changeStream.options.startAtOperationTime = void 0;
      if (!callback)
        return changeStream.emit("change", change);
      return callback(void 0, change);
    }
    function processError(changeStream, error, callback) {
      const topology = changeStream.topology;
      const cursor = changeStream.cursor;
      if (changeStream.closed) {
        if (callback)
          callback(new MongoError("ChangeStream is closed"));
        return;
      }
      function resumeWithCursor(newCursor) {
        changeStream.cursor = newCursor;
        processResumeQueue(changeStream);
      }
      function unresumableError(err) {
        if (!callback) {
          changeStream.emit("error", err);
          changeStream.emit("close");
        }
        processResumeQueue(changeStream, err);
        changeStream.closed = true;
      }
      if (cursor && isResumableError(error, maxWireVersion(cursor.server))) {
        changeStream.cursor = void 0;
        ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
        cursor.close();
        waitForTopologyConnected(topology, { readPreference: cursor.options.readPreference }, (err) => {
          if (err)
            return unresumableError(err);
          const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);
          if (!callback)
            return resumeWithCursor(newCursor);
          newCursor.hasNext((err2) => {
            if (err2)
              return unresumableError(err2);
            resumeWithCursor(newCursor);
          });
        });
        return;
      }
      if (!callback)
        return changeStream.emit("error", error);
      return callback(error);
    }
    function getCursor(changeStream, callback) {
      if (changeStream.isClosed()) {
        callback(new MongoError("ChangeStream is closed."));
        return;
      }
      if (changeStream.cursor) {
        callback(void 0, changeStream.cursor);
        return;
      }
      changeStream[kResumeQueue].push(callback);
    }
    function processResumeQueue(changeStream, err) {
      while (changeStream[kResumeQueue].length) {
        const request = changeStream[kResumeQueue].pop();
        if (changeStream.isClosed() && !err) {
          request(new MongoError("Change Stream is not open."));
          return;
        }
        request(err, changeStream.cursor);
      }
    }
    module2.exports = ChangeStream;
  }
});

// node_modules/mongodb/lib/topologies/topology_base.js
var require_topology_base = __commonJS({
  "node_modules/mongodb/lib/topologies/topology_base.js"(exports2) {
    "use strict";
    var EventEmitter = require("events");
    var MongoError = require_core().MongoError;
    var f = require("util").format;
    var ReadPreference = require_core().ReadPreference;
    var ClientSession = require_core().Sessions.ClientSession;
    var Store = function(topology, storeOptions) {
      var self2 = this;
      var storedOps = [];
      storeOptions = storeOptions || { force: false, bufferMaxEntries: -1 };
      this.s = {
        storedOps,
        storeOptions,
        topology
      };
      Object.defineProperty(this, "length", {
        enumerable: true,
        get: function() {
          return self2.s.storedOps.length;
        }
      });
    };
    Store.prototype.add = function(opType, ns, ops, options, callback) {
      if (this.s.storeOptions.force) {
        return callback(MongoError.create({ message: "db closed by application", driver: true }));
      }
      if (this.s.storeOptions.bufferMaxEntries === 0) {
        return callback(MongoError.create({
          message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
          driver: true
        }));
      }
      if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
        while (this.s.storedOps.length > 0) {
          var op = this.s.storedOps.shift();
          op.c(MongoError.create({
            message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
            driver: true
          }));
        }
        return;
      }
      this.s.storedOps.push({ t: opType, n: ns, o: ops, op: options, c: callback });
    };
    Store.prototype.addObjectAndMethod = function(opType, object, method, params, callback) {
      if (this.s.storeOptions.force) {
        return callback(MongoError.create({ message: "db closed by application", driver: true }));
      }
      if (this.s.storeOptions.bufferMaxEntries === 0) {
        return callback(MongoError.create({
          message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
          driver: true
        }));
      }
      if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
        while (this.s.storedOps.length > 0) {
          var op = this.s.storedOps.shift();
          op.c(MongoError.create({
            message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
            driver: true
          }));
        }
        return;
      }
      this.s.storedOps.push({ t: opType, m: method, o: object, p: params, c: callback });
    };
    Store.prototype.flush = function(err) {
      while (this.s.storedOps.length > 0) {
        this.s.storedOps.shift().c(err || MongoError.create({ message: f("no connection available for operation"), driver: true }));
      }
    };
    var primaryOptions = ["primary", "primaryPreferred", "nearest", "secondaryPreferred"];
    var secondaryOptions = ["secondary", "secondaryPreferred"];
    Store.prototype.execute = function(options) {
      options = options || {};
      var ops = this.s.storedOps;
      this.s.storedOps = [];
      var executePrimary = typeof options.executePrimary === "boolean" ? options.executePrimary : true;
      var executeSecondary = typeof options.executeSecondary === "boolean" ? options.executeSecondary : true;
      while (ops.length > 0) {
        var op = ops.shift();
        if (op.t === "cursor") {
          if (executePrimary && executeSecondary) {
            op.o[op.m].apply(op.o, op.p);
          } else if (executePrimary && op.o.options && op.o.options.readPreference && primaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
            op.o[op.m].apply(op.o, op.p);
          } else if (!executePrimary && executeSecondary && op.o.options && op.o.options.readPreference && secondaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
            op.o[op.m].apply(op.o, op.p);
          }
        } else if (op.t === "auth") {
          this.s.topology[op.t].apply(this.s.topology, op.o);
        } else {
          if (executePrimary && executeSecondary) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          } else if (executePrimary && op.op && op.op.readPreference && primaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          } else if (!executePrimary && executeSecondary && op.op && op.op.readPreference && secondaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          }
        }
      }
    };
    Store.prototype.all = function() {
      return this.s.storedOps;
    };
    var ServerCapabilities = function(ismaster) {
      var setup_get_property = function(object, name, value) {
        Object.defineProperty(object, name, {
          enumerable: true,
          get: function() {
            return value;
          }
        });
      };
      var aggregationCursor = false;
      var writeCommands = false;
      var textSearch = false;
      var authCommands = false;
      var listCollections = false;
      var listIndexes = false;
      var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1e3;
      var commandsTakeWriteConcern = false;
      var commandsTakeCollation = false;
      if (ismaster.minWireVersion >= 0) {
        textSearch = true;
      }
      if (ismaster.maxWireVersion >= 1) {
        aggregationCursor = true;
        authCommands = true;
      }
      if (ismaster.maxWireVersion >= 2) {
        writeCommands = true;
      }
      if (ismaster.maxWireVersion >= 3) {
        listCollections = true;
        listIndexes = true;
      }
      if (ismaster.maxWireVersion >= 5) {
        commandsTakeWriteConcern = true;
        commandsTakeCollation = true;
      }
      if (ismaster.minWireVersion == null) {
        ismaster.minWireVersion = 0;
      }
      if (ismaster.maxWireVersion == null) {
        ismaster.maxWireVersion = 0;
      }
      setup_get_property(this, "hasAggregationCursor", aggregationCursor);
      setup_get_property(this, "hasWriteCommands", writeCommands);
      setup_get_property(this, "hasTextSearch", textSearch);
      setup_get_property(this, "hasAuthCommands", authCommands);
      setup_get_property(this, "hasListCollectionsCommand", listCollections);
      setup_get_property(this, "hasListIndexesCommand", listIndexes);
      setup_get_property(this, "minWireVersion", ismaster.minWireVersion);
      setup_get_property(this, "maxWireVersion", ismaster.maxWireVersion);
      setup_get_property(this, "maxNumberOfDocsInBatch", maxNumberOfDocsInBatch);
      setup_get_property(this, "commandsTakeWriteConcern", commandsTakeWriteConcern);
      setup_get_property(this, "commandsTakeCollation", commandsTakeCollation);
    };
    var TopologyBase = class extends EventEmitter {
      constructor() {
        super();
        this.setMaxListeners(Infinity);
      }
      hasSessionSupport() {
        return this.logicalSessionTimeoutMinutes != null;
      }
      startSession(options, clientOptions) {
        const session = new ClientSession(this, this.s.sessionPool, options, clientOptions);
        session.once("ended", () => {
          this.s.sessions.delete(session);
        });
        this.s.sessions.add(session);
        return session;
      }
      endSessions(sessions, callback) {
        return this.s.coreTopology.endSessions(sessions, callback);
      }
      get clientMetadata() {
        return this.s.coreTopology.s.options.metadata;
      }
      capabilities() {
        if (this.s.sCapabilities)
          return this.s.sCapabilities;
        if (this.s.coreTopology.lastIsMaster() == null)
          return null;
        this.s.sCapabilities = new ServerCapabilities(this.s.coreTopology.lastIsMaster());
        return this.s.sCapabilities;
      }
      command(ns, cmd, options, callback) {
        this.s.coreTopology.command(ns.toString(), cmd, ReadPreference.translate(options), callback);
      }
      insert(ns, ops, options, callback) {
        this.s.coreTopology.insert(ns.toString(), ops, options, callback);
      }
      update(ns, ops, options, callback) {
        this.s.coreTopology.update(ns.toString(), ops, options, callback);
      }
      remove(ns, ops, options, callback) {
        this.s.coreTopology.remove(ns.toString(), ops, options, callback);
      }
      isConnected(options) {
        options = options || {};
        options = ReadPreference.translate(options);
        return this.s.coreTopology.isConnected(options);
      }
      isDestroyed() {
        return this.s.coreTopology.isDestroyed();
      }
      cursor(ns, cmd, options) {
        options = options || {};
        options = ReadPreference.translate(options);
        options.disconnectHandler = this.s.store;
        options.topology = this;
        return this.s.coreTopology.cursor(ns, cmd, options);
      }
      lastIsMaster() {
        return this.s.coreTopology.lastIsMaster();
      }
      selectServer(selector, options, callback) {
        return this.s.coreTopology.selectServer(selector, options, callback);
      }
      unref() {
        return this.s.coreTopology.unref();
      }
      connections() {
        return this.s.coreTopology.connections();
      }
      close(forceClosed, callback) {
        this.s.sessions.forEach((session) => session.endSession());
        if (this.s.sessionPool) {
          this.s.sessionPool.endAllPooledSessions();
        }
        if (forceClosed === true) {
          this.s.storeOptions.force = forceClosed;
          this.s.store.flush();
        }
        this.s.coreTopology.destroy({
          force: typeof forceClosed === "boolean" ? forceClosed : false
        }, callback);
      }
    };
    Object.defineProperty(TopologyBase.prototype, "bson", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.bson;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.parserType;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.logicalSessionTimeoutMinutes;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "type", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.type;
      }
    });
    exports2.Store = Store;
    exports2.ServerCapabilities = ServerCapabilities;
    exports2.TopologyBase = TopologyBase;
  }
});

// node_modules/mongodb/lib/topologies/native_topology.js
var require_native_topology = __commonJS({
  "node_modules/mongodb/lib/topologies/native_topology.js"(exports2, module2) {
    "use strict";
    var Topology = require_core().Topology;
    var ServerCapabilities = require_topology_base().ServerCapabilities;
    var Cursor = require_cursor2();
    var translateOptions = require_utils6().translateOptions;
    var NativeTopology = class extends Topology {
      constructor(servers, options) {
        options = options || {};
        let clonedOptions = Object.assign({}, {
          cursorFactory: Cursor,
          reconnect: false,
          emitError: typeof options.emitError === "boolean" ? options.emitError : true,
          maxPoolSize: typeof options.maxPoolSize === "number" ? options.maxPoolSize : typeof options.poolSize === "number" ? options.poolSize : 10,
          minPoolSize: typeof options.minPoolSize === "number" ? options.minPoolSize : typeof options.minSize === "number" ? options.minSize : 0,
          monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options);
        var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        super(servers, clonedOptions);
      }
      capabilities() {
        if (this.s.sCapabilities)
          return this.s.sCapabilities;
        if (this.lastIsMaster() == null)
          return null;
        this.s.sCapabilities = new ServerCapabilities(this.lastIsMaster());
        return this.s.sCapabilities;
      }
      command(ns, cmd, options, callback) {
        super.command(ns.toString(), cmd, options, callback);
      }
      insert(ns, ops, options, callback) {
        super.insert(ns.toString(), ops, options, callback);
      }
      update(ns, ops, options, callback) {
        super.update(ns.toString(), ops, options, callback);
      }
      remove(ns, ops, options, callback) {
        super.remove(ns.toString(), ops, options, callback);
      }
    };
    module2.exports = NativeTopology;
  }
});

// node_modules/mongodb/lib/topologies/server.js
var require_server3 = __commonJS({
  "node_modules/mongodb/lib/topologies/server.js"(exports2, module2) {
    "use strict";
    var CServer = require_core().Server;
    var Cursor = require_cursor2();
    var TopologyBase = require_topology_base().TopologyBase;
    var Store = require_topology_base().Store;
    var MongoError = require_core().MongoError;
    var MAX_JS_INT = require_utils6().MAX_JS_INT;
    var translateOptions = require_utils6().translateOptions;
    var filterOptions = require_utils6().filterOptions;
    var mergeOptions = require_utils6().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "acceptableLatencyMS",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCRL",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "family",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "reconnectInterval",
      "monitoring",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "compression",
      "promiseLibrary",
      "monitorCommands"
    ];
    var Server = class extends TopologyBase {
      constructor(host, port, options) {
        super();
        var self2 = this;
        options = filterOptions(options, legalOptionNames);
        const promiseLibrary = options.promiseLibrary;
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : MAX_JS_INT
        };
        var store = options.store || new Store(self2, storeOptions);
        if (host.indexOf("/") !== -1) {
          if (port != null && typeof port === "object") {
            options = port;
            port = null;
          }
        } else if (port == null) {
          throw MongoError.create({ message: "port must be specified", driver: true });
        }
        var reconnect = typeof options.auto_reconnect === "boolean" ? options.auto_reconnect : true;
        reconnect = typeof options.autoReconnect === "boolean" ? options.autoReconnect : reconnect;
        var clonedOptions = mergeOptions({}, {
          host,
          port,
          disconnectHandler: store,
          cursorFactory: Cursor,
          reconnect,
          emitError: typeof options.emitError === "boolean" ? options.emitError : true,
          size: typeof options.poolSize === "number" ? options.poolSize : 5,
          monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options);
        var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        this.s = {
          coreTopology: new CServer(clonedOptions),
          sCapabilities: null,
          clonedOptions,
          reconnect: clonedOptions.reconnect,
          emitError: clonedOptions.emitError,
          poolSize: clonedOptions.size,
          storeOptions,
          store,
          host,
          port,
          options,
          sessionPool: null,
          sessions: new Set(),
          promiseLibrary: promiseLibrary || Promise
        };
      }
      connect(_options, callback) {
        var self2 = this;
        if (typeof _options === "function")
          callback = _options, _options = {};
        if (_options == null)
          _options = this.s.clonedOptions;
        if (!(typeof callback === "function"))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self2.s.options = _options;
        self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var connectErrorHandler = function() {
          return function(err) {
            var events = ["timeout", "error", "close"];
            events.forEach(function(e) {
              self2.s.coreTopology.removeListener(e, connectHandlers[e]);
            });
            self2.s.coreTopology.removeListener("connect", connectErrorHandler);
            try {
              callback(err);
            } catch (err2) {
              process.nextTick(function() {
                throw err2;
              });
            }
          };
        };
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self2.emit(event, err);
            }
          };
        };
        var reconnectHandler = function() {
          self2.emit("reconnect", self2);
          self2.s.store.execute();
        };
        var reconnectFailedHandler = function(err) {
          self2.emit("reconnectFailed", err);
          self2.s.store.flush(err);
        };
        var destroyHandler = function() {
          self2.s.store.flush();
        };
        var relay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server);
          };
        };
        var connectHandler = function() {
          ["timeout", "error", "close", "destroy"].forEach(function(e) {
            self2.s.coreTopology.removeAllListeners(e);
          });
          self2.s.coreTopology.on("timeout", errorHandler("timeout"));
          self2.s.coreTopology.once("error", errorHandler("error"));
          self2.s.coreTopology.on("close", errorHandler("close"));
          self2.s.coreTopology.on("destroy", destroyHandler);
          self2.emit("open", null, self2);
          try {
            callback(null, self2);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var connectHandlers = {
          timeout: connectErrorHandler("timeout"),
          error: connectErrorHandler("error"),
          close: connectErrorHandler("close")
        };
        [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed"
        ].forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        self2.s.coreTopology.once("timeout", connectHandlers.timeout);
        self2.s.coreTopology.once("error", connectHandlers.error);
        self2.s.coreTopology.once("close", connectHandlers.close);
        self2.s.coreTopology.once("connect", connectHandler);
        self2.s.coreTopology.on("reconnect", reconnectHandler);
        self2.s.coreTopology.on("reconnectFailed", reconnectFailedHandler);
        self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self2.s.coreTopology.on("attemptReconnect", relay("attemptReconnect"));
        self2.s.coreTopology.on("monitoring", relay("monitoring"));
        self2.s.coreTopology.connect(_options);
      }
    };
    Object.defineProperty(Server.prototype, "poolSize", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.connections().length;
      }
    });
    Object.defineProperty(Server.prototype, "autoReconnect", {
      enumerable: true,
      get: function() {
        return this.s.reconnect;
      }
    });
    Object.defineProperty(Server.prototype, "host", {
      enumerable: true,
      get: function() {
        return this.s.host;
      }
    });
    Object.defineProperty(Server.prototype, "port", {
      enumerable: true,
      get: function() {
        return this.s.port;
      }
    });
    module2.exports = Server;
  }
});

// node_modules/mongodb/lib/topologies/mongos.js
var require_mongos2 = __commonJS({
  "node_modules/mongodb/lib/topologies/mongos.js"(exports2, module2) {
    "use strict";
    var TopologyBase = require_topology_base().TopologyBase;
    var MongoError = require_core().MongoError;
    var CMongos = require_core().Mongos;
    var Cursor = require_cursor2();
    var Server = require_server3();
    var Store = require_topology_base().Store;
    var MAX_JS_INT = require_utils6().MAX_JS_INT;
    var translateOptions = require_utils6().translateOptions;
    var filterOptions = require_utils6().filterOptions;
    var mergeOptions = require_utils6().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "acceptableLatencyMS",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCRL",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "promiseLibrary",
      "monitorCommands"
    ];
    var Mongos = class extends TopologyBase {
      constructor(servers, options) {
        super();
        options = options || {};
        var self2 = this;
        options = filterOptions(options, legalOptionNames);
        for (var i = 0; i < servers.length; i++) {
          if (!(servers[i] instanceof Server)) {
            throw MongoError.create({
              message: "all seed list instances must be of the Server type",
              driver: true
            });
          }
        }
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : MAX_JS_INT
        };
        var store = options.store || new Store(self2, storeOptions);
        var seedlist = servers.map(function(x) {
          return { host: x.host, port: x.port };
        });
        var reconnect = typeof options.auto_reconnect === "boolean" ? options.auto_reconnect : true;
        reconnect = typeof options.autoReconnect === "boolean" ? options.autoReconnect : reconnect;
        var clonedOptions = mergeOptions({}, {
          disconnectHandler: store,
          cursorFactory: Cursor,
          reconnect,
          emitError: typeof options.emitError === "boolean" ? options.emitError : true,
          size: typeof options.poolSize === "number" ? options.poolSize : 5,
          monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options);
        var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        this.s = {
          coreTopology: new CMongos(seedlist, clonedOptions),
          sCapabilities: null,
          debug: clonedOptions.debug,
          storeOptions,
          clonedOptions,
          store,
          options,
          sessionPool: null,
          sessions: new Set(),
          promiseLibrary: options.promiseLibrary || Promise
        };
      }
      connect(_options, callback) {
        var self2 = this;
        if (typeof _options === "function")
          callback = _options, _options = {};
        if (_options == null)
          _options = {};
        if (!(typeof callback === "function"))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self2.s.options = _options;
        self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var connectErrorHandler = function() {
          return function(err) {
            var events2 = ["timeout", "error", "close"];
            events2.forEach(function(e) {
              self2.removeListener(e, connectErrorHandler);
            });
            self2.s.coreTopology.removeListener("connect", connectErrorHandler);
            self2.close(true);
            try {
              callback(err);
            } catch (err2) {
              process.nextTick(function() {
                throw err2;
              });
            }
          };
        };
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self2.emit(event, err);
            }
          };
        };
        var reconnectHandler = function() {
          self2.emit("reconnect");
          self2.s.store.execute();
        };
        var relay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server);
          };
        };
        var connectHandler = function() {
          var events2 = ["timeout", "error", "close", "fullsetup"];
          events2.forEach(function(e) {
            self2.s.coreTopology.removeAllListeners(e);
          });
          self2.s.coreTopology.on("timeout", errorHandler("timeout"));
          self2.s.coreTopology.on("error", errorHandler("error"));
          self2.s.coreTopology.on("close", errorHandler("close"));
          self2.s.coreTopology.on("fullsetup", function() {
            self2.emit("fullsetup", self2);
          });
          self2.emit("open", null, self2);
          try {
            callback(null, self2);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var events = [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed"
        ];
        events.forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self2.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
        self2.s.coreTopology.once("error", connectErrorHandler("error"));
        self2.s.coreTopology.once("close", connectErrorHandler("close"));
        self2.s.coreTopology.once("connect", connectHandler);
        self2.s.coreTopology.on("joined", relay("joined"));
        self2.s.coreTopology.on("left", relay("left"));
        self2.s.coreTopology.on("reconnect", reconnectHandler);
        self2.s.coreTopology.connect(_options);
      }
    };
    Object.defineProperty(Mongos.prototype, "haInterval", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.haInterval;
      }
    });
    module2.exports = Mongos;
  }
});

// node_modules/mongodb/lib/topologies/replset.js
var require_replset2 = __commonJS({
  "node_modules/mongodb/lib/topologies/replset.js"(exports2, module2) {
    "use strict";
    var Server = require_server3();
    var Cursor = require_cursor2();
    var MongoError = require_core().MongoError;
    var TopologyBase = require_topology_base().TopologyBase;
    var Store = require_topology_base().Store;
    var CReplSet = require_core().ReplSet;
    var MAX_JS_INT = require_utils6().MAX_JS_INT;
    var translateOptions = require_utils6().translateOptions;
    var filterOptions = require_utils6().filterOptions;
    var mergeOptions = require_utils6().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "replicaSet",
      "rs_name",
      "secondaryAcceptableLatencyMS",
      "connectWithNoPrimary",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslCRL",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "strategy",
      "debug",
      "family",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "maxStalenessSeconds",
      "promiseLibrary",
      "minSize",
      "monitorCommands"
    ];
    var ReplSet = class extends TopologyBase {
      constructor(servers, options) {
        super();
        options = options || {};
        var self2 = this;
        options = filterOptions(options, legalOptionNames);
        for (var i = 0; i < servers.length; i++) {
          if (!(servers[i] instanceof Server)) {
            throw MongoError.create({
              message: "all seed list instances must be of the Server type",
              driver: true
            });
          }
        }
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : MAX_JS_INT
        };
        var store = options.store || new Store(self2, storeOptions);
        var seedlist = servers.map(function(x) {
          return { host: x.host, port: x.port };
        });
        var clonedOptions = mergeOptions({}, {
          disconnectHandler: store,
          cursorFactory: Cursor,
          reconnect: false,
          emitError: typeof options.emitError === "boolean" ? options.emitError : true,
          size: typeof options.poolSize === "number" ? options.poolSize : 5,
          monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options);
        var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        var coreTopology = new CReplSet(seedlist, clonedOptions);
        coreTopology.on("reconnect", function() {
          self2.emit("reconnect");
          store.execute();
        });
        this.s = {
          coreTopology,
          sCapabilities: null,
          tag: options.tag,
          storeOptions,
          clonedOptions,
          store,
          options,
          sessionPool: null,
          sessions: new Set(),
          promiseLibrary: options.promiseLibrary || Promise
        };
        if (clonedOptions.debug) {
          Object.defineProperty(this, "replset", {
            enumerable: true,
            get: function() {
              return coreTopology;
            }
          });
        }
      }
      connect(_options, callback) {
        var self2 = this;
        if (typeof _options === "function")
          callback = _options, _options = {};
        if (_options == null)
          _options = {};
        if (!(typeof callback === "function"))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self2.s.options = _options;
        self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self2.emit(event, err);
            }
          };
        };
        var events = [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed",
          "joined",
          "left",
          "ping",
          "ha"
        ];
        events.forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        var relay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server);
          };
        };
        var replsetRelay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server.lastIsMaster(), server);
          };
        };
        var relayHa = function(t, state) {
          self2.emit("ha", t, state);
          if (t === "start") {
            self2.emit("ha_connect", t, state);
          } else if (t === "end") {
            self2.emit("ha_ismaster", t, state);
          }
        };
        self2.s.coreTopology.on("joined", replsetRelay("joined"));
        self2.s.coreTopology.on("left", relay("left"));
        self2.s.coreTopology.on("ping", relay("ping"));
        self2.s.coreTopology.on("ha", relayHa);
        self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self2.s.coreTopology.on("fullsetup", function() {
          self2.emit("fullsetup", self2, self2);
        });
        self2.s.coreTopology.on("all", function() {
          self2.emit("all", null, self2);
        });
        var connectHandler = function() {
          self2.s.coreTopology.once("timeout", errorHandler("timeout"));
          self2.s.coreTopology.once("error", errorHandler("error"));
          self2.s.coreTopology.once("close", errorHandler("close"));
          self2.emit("open", null, self2);
          try {
            callback(null, self2);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var connectErrorHandler = function() {
          return function(err) {
            ["timeout", "error", "close"].forEach(function(e) {
              self2.s.coreTopology.removeListener(e, connectErrorHandler);
            });
            self2.s.coreTopology.removeListener("connect", connectErrorHandler);
            self2.s.coreTopology.destroy();
            try {
              callback(err);
            } catch (err2) {
              if (!self2.s.coreTopology.isConnected())
                process.nextTick(function() {
                  throw err2;
                });
            }
          };
        };
        self2.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
        self2.s.coreTopology.once("error", connectErrorHandler("error"));
        self2.s.coreTopology.once("close", connectErrorHandler("close"));
        self2.s.coreTopology.once("connect", connectHandler);
        self2.s.coreTopology.connect(_options);
      }
      close(forceClosed, callback) {
        ["timeout", "error", "close", "joined", "left"].forEach((e) => this.removeAllListeners(e));
        super.close(forceClosed, callback);
      }
    };
    Object.defineProperty(ReplSet.prototype, "haInterval", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.haInterval;
      }
    });
    module2.exports = ReplSet;
  }
});

// node_modules/mongodb/lib/url_parser.js
var require_url_parser = __commonJS({
  "node_modules/mongodb/lib/url_parser.js"(exports2, module2) {
    "use strict";
    var ReadPreference = require_core().ReadPreference;
    var parser = require("url");
    var f = require("util").format;
    var Logger = require_core().Logger;
    var dns = require("dns");
    var ReadConcern = require_read_concern();
    var qs = require("querystring");
    var MongoParseError = require_error().MongoParseError;
    module2.exports = function(url, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      let result;
      try {
        result = parser.parse(url, true);
      } catch (e) {
        return callback(new Error("URL malformed, cannot be parsed"));
      }
      if (result.protocol !== "mongodb:" && result.protocol !== "mongodb+srv:") {
        return callback(new Error("Invalid schema, expected `mongodb` or `mongodb+srv`"));
      }
      if (result.protocol === "mongodb:") {
        return parseHandler(url, options, callback);
      }
      if (result.hostname.split(".").length < 3) {
        return callback(new Error("URI does not have hostname, domain name and tld"));
      }
      result.domainLength = result.hostname.split(".").length;
      const hostname = url.substring("mongodb+srv://".length).split("/")[0];
      if (hostname.match(",")) {
        return callback(new Error("Invalid URI, cannot contain multiple hostnames"));
      }
      if (result.port) {
        return callback(new Error("Ports not accepted with `mongodb+srv` URIs"));
      }
      let srvAddress = `_mongodb._tcp.${result.host}`;
      dns.resolveSrv(srvAddress, function(err, addresses) {
        if (err)
          return callback(err);
        if (addresses.length === 0) {
          return callback(new Error("No addresses found at host"));
        }
        for (let i = 0; i < addresses.length; i++) {
          if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
            return callback(new Error("Server record does not share hostname with parent URI"));
          }
        }
        let base = result.auth ? `mongodb://${result.auth}@` : `mongodb://`;
        let connectionStrings = addresses.map(function(address, i) {
          if (i === 0)
            return `${base}${address.name}:${address.port}`;
          else
            return `${address.name}:${address.port}`;
        });
        let connectionString = connectionStrings.join(",") + "/";
        let connectionStringOptions = [];
        if (result.path) {
          let defaultDb = result.path.slice(1);
          if (defaultDb.indexOf("?") !== -1) {
            defaultDb = defaultDb.slice(0, defaultDb.indexOf("?"));
          }
          connectionString += defaultDb;
        }
        if (!options.ssl && !result.search) {
          connectionStringOptions.push("ssl=true");
        } else if (!options.ssl && result.search && !result.search.match("ssl")) {
          connectionStringOptions.push("ssl=true");
        }
        if (result.search) {
          connectionStringOptions.push(result.search.replace("?", ""));
        }
        dns.resolveTxt(result.host, function(err2, record) {
          if (err2 && err2.code !== "ENODATA" && err2.code !== "ENOTFOUND")
            return callback(err2);
          if (err2 && err2.code === "ENODATA")
            record = null;
          if (record) {
            if (record.length > 1) {
              return callback(new MongoParseError("Multiple text records not allowed"));
            }
            record = record[0].join("");
            const parsedRecord = qs.parse(record);
            const items = Object.keys(parsedRecord);
            if (items.some((item) => item !== "authSource" && item !== "replicaSet")) {
              return callback(new MongoParseError("Text record must only set `authSource` or `replicaSet`"));
            }
            if (items.length > 0) {
              connectionStringOptions.push(record);
            }
          }
          if (connectionStringOptions.length) {
            connectionString += `?${connectionStringOptions.join("&")}`;
          }
          parseHandler(connectionString, options, callback);
        });
      });
    };
    function matchesParentDomain(srvAddress, parentDomain) {
      let regex = /^.*?\./;
      let srv = `.${srvAddress.replace(regex, "")}`;
      let parent = `.${parentDomain.replace(regex, "")}`;
      if (srv.endsWith(parent))
        return true;
      else
        return false;
    }
    function parseHandler(address, options, callback) {
      let result, err;
      try {
        result = parseConnectionString(address, options);
      } catch (e) {
        err = e;
      }
      return err ? callback(err, null) : callback(null, result);
    }
    function parseConnectionString(url, options) {
      let connection_part = "";
      let auth_part = "";
      let query_string_part = "";
      let dbName = "admin";
      let result = parser.parse(url, true);
      if ((result.hostname == null || result.hostname === "") && url.indexOf(".sock") === -1) {
        throw new Error("No hostname or hostnames provided in connection string");
      }
      if (result.port === "0") {
        throw new Error("Invalid port (zero) with hostname");
      }
      if (!isNaN(parseInt(result.port, 10)) && parseInt(result.port, 10) > 65535) {
        throw new Error("Invalid port (larger than 65535) with hostname");
      }
      if (result.path && result.path.length > 0 && result.path[0] !== "/" && url.indexOf(".sock") === -1) {
        throw new Error("Missing delimiting slash between hosts and options");
      }
      if (result.query) {
        for (let name in result.query) {
          if (name.indexOf("::") !== -1) {
            throw new Error("Double colon in host identifier");
          }
          if (result.query[name] === "") {
            throw new Error("Query parameter " + name + " is an incomplete value pair");
          }
        }
      }
      if (result.auth) {
        let parts = result.auth.split(":");
        if (url.indexOf(result.auth) !== -1 && parts.length > 2) {
          throw new Error("Username with password containing an unescaped colon");
        }
        if (url.indexOf(result.auth) !== -1 && result.auth.indexOf("@") !== -1) {
          throw new Error("Username containing an unescaped at-sign");
        }
      }
      let clean = url.split("?").shift();
      let strings = clean.split(",");
      let hosts = [];
      for (let i = 0; i < strings.length; i++) {
        let hostString = strings[i];
        if (hostString.indexOf("mongodb") !== -1) {
          if (hostString.indexOf("@") !== -1) {
            hosts.push(hostString.split("@").pop());
          } else {
            hosts.push(hostString.substr("mongodb://".length));
          }
        } else if (hostString.indexOf("/") !== -1) {
          hosts.push(hostString.split("/").shift());
        } else if (hostString.indexOf("/") === -1) {
          hosts.push(hostString.trim());
        }
      }
      for (let i = 0; i < hosts.length; i++) {
        let r = parser.parse(f("mongodb://%s", hosts[i].trim()));
        if (r.path && r.path.indexOf(".sock") !== -1)
          continue;
        if (r.path && r.path.indexOf(":") !== -1) {
          if (r.path.split("/").length > 1 && r.path.indexOf("::") === -1) {
            throw new Error("Slash in host identifier");
          } else {
            throw new Error("Double colon in host identifier");
          }
        }
      }
      if (url.indexOf("?") !== -1) {
        query_string_part = url.substr(url.indexOf("?") + 1);
        connection_part = url.substring("mongodb://".length, url.indexOf("?"));
      } else {
        connection_part = url.substring("mongodb://".length);
      }
      if (connection_part.indexOf("@") !== -1) {
        auth_part = connection_part.split("@")[0];
        connection_part = connection_part.split("@")[1];
      }
      if (connection_part.split("/").length > 2) {
        throw new Error("Unsupported host '" + connection_part.split("?")[0] + "', hosts must be URL encoded and contain at most one unencoded slash");
      }
      if (connection_part.indexOf(".sock") !== -1) {
        if (connection_part.indexOf(".sock/") !== -1) {
          dbName = connection_part.split(".sock/")[1];
          if (dbName.indexOf("/") !== -1) {
            if (dbName.split("/").length === 2 && dbName.split("/")[1].length === 0) {
              throw new Error("Illegal trailing backslash after database name");
            }
            throw new Error("More than 1 database name in URL");
          }
          connection_part = connection_part.split("/", connection_part.indexOf(".sock") + ".sock".length);
        }
      } else if (connection_part.indexOf("/") !== -1) {
        if (connection_part.split("/").length > 2) {
          if (connection_part.split("/")[2].length === 0) {
            throw new Error("Illegal trailing backslash after database name");
          }
          throw new Error("More than 1 database name in URL");
        }
        dbName = connection_part.split("/")[1];
        connection_part = connection_part.split("/")[0];
      }
      connection_part = decodeURIComponent(connection_part);
      let object = {};
      let authPart = auth_part || "";
      let auth = authPart.split(":", 2);
      let user = decodeURIComponent(auth[0]);
      if (auth[0] !== encodeURIComponent(user)) {
        throw new Error("Username contains an illegal unescaped character");
      }
      auth[0] = user;
      if (auth[1]) {
        let pass = decodeURIComponent(auth[1]);
        if (auth[1] !== encodeURIComponent(pass)) {
          throw new Error("Password contains an illegal unescaped character");
        }
        auth[1] = pass;
      }
      if (auth.length === 2)
        object.auth = { user: auth[0], password: auth[1] };
      if (options && options.auth != null)
        object.auth = options.auth;
      let hostPart;
      let urlOptions;
      let servers;
      let compression;
      let serverOptions = { socketOptions: {} };
      let dbOptions = { read_preference_tags: [] };
      let replSetServersOptions = { socketOptions: {} };
      let mongosOptions = { socketOptions: {} };
      object.server_options = serverOptions;
      object.db_options = dbOptions;
      object.rs_options = replSetServersOptions;
      object.mongos_options = mongosOptions;
      if (url.match(/\.sock/)) {
        let domainSocket = url.substring(url.indexOf("mongodb://") + "mongodb://".length, url.lastIndexOf(".sock") + ".sock".length);
        if (domainSocket.indexOf("@") !== -1)
          domainSocket = domainSocket.split("@")[1];
        domainSocket = decodeURIComponent(domainSocket);
        servers = [{ domain_socket: domainSocket }];
      } else {
        hostPart = connection_part;
        let deduplicatedServers = {};
        servers = hostPart.split(",").map(function(h) {
          let _host, _port, ipv6match;
          if (ipv6match = /\[([^\]]+)\](?::(.+))?/.exec(h)) {
            _host = ipv6match[1];
            _port = parseInt(ipv6match[2], 10) || 27017;
          } else {
            let hostPort = h.split(":", 2);
            _host = hostPort[0] || "localhost";
            _port = hostPort[1] != null ? parseInt(hostPort[1], 10) : 27017;
            if (_host.indexOf("?") !== -1)
              _host = _host.split(/\?/)[0];
          }
          if (deduplicatedServers[_host + "_" + _port])
            return null;
          deduplicatedServers[_host + "_" + _port] = 1;
          return { host: _host, port: _port };
        }).filter(function(x) {
          return x != null;
        });
      }
      object.dbName = dbName || "admin";
      urlOptions = (query_string_part || "").split(/[&;]/);
      urlOptions.forEach(function(opt) {
        if (!opt)
          return;
        var splitOpt = opt.split("="), name = splitOpt[0], value = splitOpt[1];
        switch (name) {
          case "slaveOk":
          case "slave_ok":
            serverOptions.slave_ok = value === "true";
            dbOptions.slaveOk = value === "true";
            break;
          case "maxPoolSize":
          case "poolSize":
            serverOptions.poolSize = parseInt(value, 10);
            replSetServersOptions.poolSize = parseInt(value, 10);
            break;
          case "appname":
            object.appname = decodeURIComponent(value);
            break;
          case "autoReconnect":
          case "auto_reconnect":
            serverOptions.auto_reconnect = value === "true";
            break;
          case "ssl":
            if (value === "prefer") {
              serverOptions.ssl = value;
              replSetServersOptions.ssl = value;
              mongosOptions.ssl = value;
              break;
            }
            serverOptions.ssl = value === "true";
            replSetServersOptions.ssl = value === "true";
            mongosOptions.ssl = value === "true";
            break;
          case "sslValidate":
            serverOptions.sslValidate = value === "true";
            replSetServersOptions.sslValidate = value === "true";
            mongosOptions.sslValidate = value === "true";
            break;
          case "replicaSet":
          case "rs_name":
            replSetServersOptions.rs_name = value;
            break;
          case "reconnectWait":
            replSetServersOptions.reconnectWait = parseInt(value, 10);
            break;
          case "retries":
            replSetServersOptions.retries = parseInt(value, 10);
            break;
          case "readSecondary":
          case "read_secondary":
            replSetServersOptions.read_secondary = value === "true";
            break;
          case "fsync":
            dbOptions.fsync = value === "true";
            break;
          case "journal":
            dbOptions.j = value === "true";
            break;
          case "safe":
            dbOptions.safe = value === "true";
            break;
          case "nativeParser":
          case "native_parser":
            dbOptions.native_parser = value === "true";
            break;
          case "readConcernLevel":
            dbOptions.readConcern = new ReadConcern(value);
            break;
          case "connectTimeoutMS":
            serverOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
            replSetServersOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
            mongosOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
            break;
          case "socketTimeoutMS":
            serverOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
            replSetServersOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
            mongosOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
            break;
          case "w":
            dbOptions.w = parseInt(value, 10);
            if (isNaN(dbOptions.w))
              dbOptions.w = value;
            break;
          case "authSource":
            dbOptions.authSource = value;
            break;
          case "gssapiServiceName":
            dbOptions.gssapiServiceName = value;
            break;
          case "authMechanism":
            if (value === "GSSAPI") {
              if (object.auth == null) {
                let urlDecodeAuthPart = decodeURIComponent(authPart);
                if (urlDecodeAuthPart.indexOf("@") === -1)
                  throw new Error("GSSAPI requires a provided principal");
                object.auth = { user: urlDecodeAuthPart, password: null };
              } else {
                object.auth.user = decodeURIComponent(object.auth.user);
              }
            } else if (value === "MONGODB-X509") {
              object.auth = { user: decodeURIComponent(authPart) };
            }
            if (value !== "GSSAPI" && value !== "MONGODB-X509" && value !== "MONGODB-CR" && value !== "DEFAULT" && value !== "SCRAM-SHA-1" && value !== "SCRAM-SHA-256" && value !== "PLAIN")
              throw new Error("Only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, or SCRAM-SHA-1 is supported by authMechanism");
            dbOptions.authMechanism = value;
            break;
          case "authMechanismProperties":
            {
              let values = value.split(",");
              let o = {};
              values.forEach(function(x) {
                let v = x.split(":");
                o[v[0]] = v[1];
              });
              dbOptions.authMechanismProperties = o;
              if (typeof o.SERVICE_NAME === "string")
                dbOptions.gssapiServiceName = o.SERVICE_NAME;
              if (typeof o.SERVICE_REALM === "string")
                dbOptions.gssapiServiceRealm = o.SERVICE_REALM;
              if (typeof o.CANONICALIZE_HOST_NAME === "string")
                dbOptions.gssapiCanonicalizeHostName = o.CANONICALIZE_HOST_NAME === "true" ? true : false;
            }
            break;
          case "wtimeoutMS":
            dbOptions.wtimeout = parseInt(value, 10);
            break;
          case "readPreference":
            if (!ReadPreference.isValid(value))
              throw new Error("readPreference must be either primary/primaryPreferred/secondary/secondaryPreferred/nearest");
            dbOptions.readPreference = value;
            break;
          case "maxStalenessSeconds":
            dbOptions.maxStalenessSeconds = parseInt(value, 10);
            break;
          case "readPreferenceTags":
            {
              value = decodeURIComponent(value);
              let tagObject = {};
              if (value == null || value === "") {
                dbOptions.read_preference_tags.push(tagObject);
                break;
              }
              let tags = value.split(/,/);
              for (let i = 0; i < tags.length; i++) {
                let parts = tags[i].trim().split(/:/);
                tagObject[parts[0]] = parts[1];
              }
              dbOptions.read_preference_tags.push(tagObject);
            }
            break;
          case "compressors":
            {
              compression = serverOptions.compression || {};
              let compressors = value.split(",");
              if (!compressors.every(function(compressor) {
                return compressor === "snappy" || compressor === "zlib";
              })) {
                throw new Error("Compressors must be at least one of snappy or zlib");
              }
              compression.compressors = compressors;
              serverOptions.compression = compression;
            }
            break;
          case "zlibCompressionLevel":
            {
              compression = serverOptions.compression || {};
              let zlibCompressionLevel = parseInt(value, 10);
              if (zlibCompressionLevel < -1 || zlibCompressionLevel > 9) {
                throw new Error("zlibCompressionLevel must be an integer between -1 and 9");
              }
              compression.zlibCompressionLevel = zlibCompressionLevel;
              serverOptions.compression = compression;
            }
            break;
          case "retryWrites":
            dbOptions.retryWrites = value === "true";
            break;
          case "minSize":
            dbOptions.minSize = parseInt(value, 10);
            break;
          default:
            {
              let logger = Logger("URL Parser");
              logger.warn(`${name} is not supported as a connection string option`);
            }
            break;
        }
      });
      if (dbOptions.read_preference_tags.length === 0) {
        dbOptions.read_preference_tags = null;
      }
      if ((dbOptions.w === -1 || dbOptions.w === 0) && (dbOptions.journal === true || dbOptions.fsync === true || dbOptions.safe === true))
        throw new Error("w set to -1 or 0 cannot be combined with safe/w/journal/fsync");
      if (!dbOptions.readPreference) {
        dbOptions.readPreference = "primary";
      }
      dbOptions = Object.assign(dbOptions, options);
      object.servers = servers;
      return object;
    }
  }
});

// node_modules/mongodb/lib/encrypter.js
var require_encrypter = __commonJS({
  "node_modules/mongodb/lib/encrypter.js"(exports2, module2) {
    "use strict";
    var MongoClient = require_mongo_client();
    var BSON2 = require_utils5().retrieveBSON();
    var MongoError = require_error().MongoError;
    var mongodbClientEncryption = void 0;
    try {
      mongodbClientEncryption = require("mongodb-client-encryption");
    } catch (err) {
      throw new MongoError("Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project");
    }
    if (mongodbClientEncryption === void 0 || typeof mongodbClientEncryption.extension !== "function") {
      throw new MongoError("loaded version of `mongodb-client-encryption` does not have property `extension`. Please make sure you are loading the correct version of `mongodb-client-encryption`");
    }
    var AutoEncrypter = mongodbClientEncryption.extension(require_mongodb()).AutoEncrypter;
    var kInternalClient = Symbol("internalClient");
    var Encrypter = class {
      constructor(client, options) {
        this.bypassAutoEncryption = !!options.autoEncryption.bypassAutoEncryption;
        this.needsConnecting = false;
        if (options.maxPoolSize === 0 && options.autoEncryption.keyVaultClient == null) {
          options.autoEncryption.keyVaultClient = client;
        } else if (options.autoEncryption.keyVaultClient == null) {
          options.autoEncryption.keyVaultClient = this.getInternalClient(client);
        }
        if (this.bypassAutoEncryption) {
          options.autoEncryption.metadataClient = void 0;
        } else if (options.maxPoolSize === 0) {
          options.autoEncryption.metadataClient = client;
        } else {
          options.autoEncryption.metadataClient = this.getInternalClient(client);
        }
        options.autoEncryption.bson = Encrypter.makeBSON(options);
        this.autoEncrypter = new AutoEncrypter(client, options.autoEncryption);
      }
      getInternalClient(client) {
        if (!this[kInternalClient]) {
          const clonedOptions = {};
          for (const key of Object.keys(client.s.options)) {
            if (["autoEncryption", "minPoolSize", "servers", "caseTranslate", "dbName"].indexOf(key) !== -1)
              continue;
            clonedOptions[key] = client.s.options[key];
          }
          clonedOptions.minPoolSize = 0;
          const allEvents = [
            "commandStarted",
            "commandSucceeded",
            "commandFailed",
            "serverOpening",
            "serverClosed",
            "serverDescriptionChanged",
            "serverHeartbeatStarted",
            "serverHeartbeatSucceeded",
            "serverHeartbeatFailed",
            "topologyOpening",
            "topologyClosed",
            "topologyDescriptionChanged",
            "joined",
            "left",
            "ping",
            "ha",
            "connectionPoolCreated",
            "connectionPoolClosed",
            "connectionCreated",
            "connectionReady",
            "connectionClosed",
            "connectionCheckOutStarted",
            "connectionCheckOutFailed",
            "connectionCheckedOut",
            "connectionCheckedIn",
            "connectionPoolCleared"
          ];
          this[kInternalClient] = new MongoClient(client.s.url, clonedOptions);
          for (const eventName of allEvents) {
            for (const listener of client.listeners(eventName)) {
              this[kInternalClient].on(eventName, listener);
            }
          }
          client.on("newListener", (eventName, listener) => {
            this[kInternalClient].on(eventName, listener);
          });
          this.needsConnecting = true;
        }
        return this[kInternalClient];
      }
      connectInternalClient(callback) {
        if (this.needsConnecting) {
          this.needsConnecting = false;
          return this[kInternalClient].connect(callback);
        }
        return callback();
      }
      close(client, force, callback) {
        this.autoEncrypter.teardown((e) => {
          if (this[kInternalClient] && client !== this[kInternalClient]) {
            return this[kInternalClient].close(force, callback);
          }
          callback(e);
        });
      }
      static makeBSON(options) {
        return (options || {}).bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]);
      }
    };
    module2.exports = { Encrypter };
  }
});

// node_modules/mongodb/lib/operations/connect.js
var require_connect2 = __commonJS({
  "node_modules/mongodb/lib/operations/connect.js"(exports2, module2) {
    "use strict";
    var deprecate = require("util").deprecate;
    var Logger = require_core().Logger;
    var MongoCredentials = require_core().MongoCredentials;
    var MongoError = require_core().MongoError;
    var Mongos = require_mongos2();
    var NativeTopology = require_native_topology();
    var parse = require_core().parseConnectionString;
    var ReadConcern = require_read_concern();
    var ReadPreference = require_core().ReadPreference;
    var ReplSet = require_replset2();
    var Server = require_server3();
    var ServerSessionPool = require_core().Sessions.ServerSessionPool;
    var emitDeprecationWarning = require_utils6().emitDeprecationWarning;
    var emitWarningOnce = require_utils6().emitWarningOnce;
    var fs = require("fs");
    var WriteConcern = require_write_concern();
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var client;
    function loadClient() {
      if (!client) {
        client = require_mongo_client();
      }
      return client;
    }
    var legacyParse = deprecate(require_url_parser(), "current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.");
    var AUTH_MECHANISM_INTERNAL_MAP = {
      DEFAULT: "default",
      PLAIN: "plain",
      GSSAPI: "gssapi",
      "MONGODB-CR": "mongocr",
      "MONGODB-X509": "x509",
      "MONGODB-AWS": "mongodb-aws",
      "SCRAM-SHA-1": "scram-sha-1",
      "SCRAM-SHA-256": "scram-sha-256"
    };
    var monitoringEvents = [
      "timeout",
      "close",
      "serverOpening",
      "serverDescriptionChanged",
      "serverHeartbeatStarted",
      "serverHeartbeatSucceeded",
      "serverHeartbeatFailed",
      "serverClosed",
      "topologyOpening",
      "topologyClosed",
      "topologyDescriptionChanged",
      "commandStarted",
      "commandSucceeded",
      "commandFailed",
      "joined",
      "left",
      "ping",
      "ha",
      "all",
      "fullsetup",
      "open"
    ];
    var VALID_AUTH_MECHANISMS = new Set([
      "DEFAULT",
      "PLAIN",
      "GSSAPI",
      "MONGODB-CR",
      "MONGODB-X509",
      "MONGODB-AWS",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256"
    ]);
    var validOptionNames = [
      "poolSize",
      "ssl",
      "sslValidate",
      "sslCA",
      "sslCert",
      "sslKey",
      "sslPass",
      "sslCRL",
      "autoReconnect",
      "noDelay",
      "keepAlive",
      "keepAliveInitialDelay",
      "connectTimeoutMS",
      "family",
      "socketTimeoutMS",
      "reconnectTries",
      "reconnectInterval",
      "ha",
      "haInterval",
      "replicaSet",
      "secondaryAcceptableLatencyMS",
      "acceptableLatencyMS",
      "connectWithNoPrimary",
      "authSource",
      "w",
      "wtimeout",
      "j",
      "writeConcern",
      "forceServerObjectId",
      "serializeFunctions",
      "ignoreUndefined",
      "raw",
      "bufferMaxEntries",
      "readPreference",
      "pkFactory",
      "promiseLibrary",
      "readConcern",
      "maxStalenessSeconds",
      "loggerLevel",
      "logger",
      "promoteValues",
      "promoteBuffers",
      "promoteLongs",
      "bsonRegExp",
      "domainsEnabled",
      "checkServerIdentity",
      "validateOptions",
      "appname",
      "auth",
      "user",
      "password",
      "authMechanism",
      "compression",
      "fsync",
      "readPreferenceTags",
      "numberOfRetries",
      "auto_reconnect",
      "minSize",
      "monitorCommands",
      "retryWrites",
      "retryReads",
      "useNewUrlParser",
      "useUnifiedTopology",
      "serverSelectionTimeoutMS",
      "useRecoveryToken",
      "autoEncryption",
      "driverInfo",
      "tls",
      "tlsInsecure",
      "tlsinsecure",
      "tlsAllowInvalidCertificates",
      "tlsAllowInvalidHostnames",
      "tlsCAFile",
      "tlsCertificateFile",
      "tlsCertificateKeyFile",
      "tlsCertificateKeyFilePassword",
      "minHeartbeatFrequencyMS",
      "heartbeatFrequencyMS",
      "directConnection",
      "appName",
      "maxPoolSize",
      "minPoolSize",
      "maxIdleTimeMS",
      "waitQueueTimeoutMS"
    ];
    var ignoreOptionNames = ["native_parser"];
    var legacyOptionNames = ["server", "replset", "replSet", "mongos", "db"];
    function validOptions(options) {
      const _validOptions = validOptionNames.concat(legacyOptionNames);
      for (const name in options) {
        if (ignoreOptionNames.indexOf(name) !== -1) {
          continue;
        }
        if (_validOptions.indexOf(name) === -1) {
          if (options.validateOptions) {
            return new MongoError(`option ${name} is not supported`);
          } else {
            emitWarningOnce(`the options [${name}] is not supported`);
          }
        }
        if (legacyOptionNames.indexOf(name) !== -1) {
          emitWarningOnce(`the server/replset/mongos/db options are deprecated, all their options are supported at the top level of the options object [${validOptionNames}]`);
        }
      }
    }
    var LEGACY_OPTIONS_MAP = validOptionNames.reduce((obj, name) => {
      obj[name.toLowerCase()] = name;
      return obj;
    }, {});
    function addListeners(mongoClient, topology) {
      topology.on("authenticated", createListener(mongoClient, "authenticated"));
      topology.on("error", createListener(mongoClient, "error"));
      topology.on("timeout", createListener(mongoClient, "timeout"));
      topology.on("close", createListener(mongoClient, "close"));
      topology.on("parseError", createListener(mongoClient, "parseError"));
      topology.once("open", createListener(mongoClient, "open"));
      topology.once("fullsetup", createListener(mongoClient, "fullsetup"));
      topology.once("all", createListener(mongoClient, "all"));
      topology.on("reconnect", createListener(mongoClient, "reconnect"));
    }
    function assignTopology(client2, topology) {
      client2.topology = topology;
      if (!(topology instanceof NativeTopology)) {
        topology.s.sessionPool = new ServerSessionPool(topology.s.coreTopology);
      }
    }
    function clearAllEvents(topology) {
      monitoringEvents.forEach((event) => topology.removeAllListeners(event));
    }
    function collectEvents(mongoClient, topology) {
      let MongoClient = loadClient();
      const collectedEvents = [];
      if (mongoClient instanceof MongoClient) {
        monitoringEvents.forEach((event) => {
          topology.on(event, (object1, object2) => {
            if (event === "open") {
              collectedEvents.push({ event, object1: mongoClient });
            } else {
              collectedEvents.push({ event, object1, object2 });
            }
          });
        });
      }
      return collectedEvents;
    }
    function resolveTLSOptions(options) {
      if (options.tls == null) {
        return;
      }
      ["sslCA", "sslKey", "sslCert"].forEach((optionName) => {
        if (options[optionName]) {
          options[optionName] = fs.readFileSync(options[optionName]);
        }
      });
    }
    function connect(mongoClient, url, options, callback) {
      options = Object.assign({}, options);
      if (callback == null) {
        throw new Error("no callback function provided");
      }
      let didRequestAuthentication = false;
      const logger = Logger("MongoClient", options);
      if (url instanceof Server || url instanceof ReplSet || url instanceof Mongos) {
        return connectWithUrl(mongoClient, url, options, connectCallback);
      }
      const useNewUrlParser = options.useNewUrlParser !== false;
      const parseFn = useNewUrlParser ? parse : legacyParse;
      const transform = useNewUrlParser ? transformUrlOptions : legacyTransformUrlOptions;
      parseFn(url, options, (err, _object) => {
        if (err)
          return callback(err);
        const object = transform(_object);
        const _finalOptions = createUnifiedOptions(object, options);
        if (_finalOptions.socketTimeoutMS == null)
          _finalOptions.socketTimeoutMS = 0;
        if (_finalOptions.connectTimeoutMS == null)
          _finalOptions.connectTimeoutMS = 1e4;
        if (_finalOptions.retryWrites == null)
          _finalOptions.retryWrites = true;
        if (_finalOptions.useRecoveryToken == null)
          _finalOptions.useRecoveryToken = true;
        if (_finalOptions.readPreference == null)
          _finalOptions.readPreference = "primary";
        if (_finalOptions.db_options && _finalOptions.db_options.auth) {
          delete _finalOptions.db_options.auth;
        }
        resolveTLSOptions(_finalOptions);
        mongoClient.s.options = _finalOptions;
        mongoClient.s.readPreference = ReadPreference.fromOptions(_finalOptions);
        mongoClient.s.writeConcern = WriteConcern.fromOptions(_finalOptions);
        if (object.servers.length === 0) {
          return callback(new Error("connection string must contain at least one seed host"));
        }
        if (_finalOptions.auth && !_finalOptions.credentials) {
          try {
            didRequestAuthentication = true;
            _finalOptions.credentials = generateCredentials(mongoClient, _finalOptions.auth.user, _finalOptions.auth.password, _finalOptions);
          } catch (err2) {
            return callback(err2);
          }
        }
        if (_finalOptions.useUnifiedTopology) {
          return createTopology(mongoClient, "unified", _finalOptions, connectCallback);
        }
        emitWarningOnce("Current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.");
        if (_finalOptions.replicaSet || _finalOptions.rs_name) {
          return createTopology(mongoClient, "replicaset", _finalOptions, connectCallback);
        } else if (object.servers.length > 1) {
          return createTopology(mongoClient, "mongos", _finalOptions, connectCallback);
        } else {
          return createServer(mongoClient, _finalOptions, connectCallback);
        }
      });
      function connectCallback(err, topology) {
        const warningMessage = `seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name`;
        if (err && err.message === "no mongos proxies found in seed list") {
          if (logger.isWarn()) {
            logger.warn(warningMessage);
          }
          return callback(new MongoError(warningMessage));
        }
        if (didRequestAuthentication) {
          mongoClient.emit("authenticated", null, true);
        }
        callback(err, topology);
      }
    }
    function connectWithUrl(mongoClient, url, options, connectCallback) {
      assignTopology(mongoClient, url);
      addListeners(mongoClient, url);
      relayEvents(mongoClient, url);
      let finalOptions = Object.assign({}, options);
      if (typeof options.readPreference === "string" || typeof options.read_preference === "string") {
        finalOptions.readPreference = new ReadPreference(options.readPreference || options.read_preference);
      }
      const isDoingAuth = finalOptions.user || finalOptions.password || finalOptions.authMechanism;
      if (isDoingAuth && !finalOptions.credentials) {
        try {
          finalOptions.credentials = generateCredentials(mongoClient, finalOptions.user, finalOptions.password, finalOptions);
        } catch (err) {
          return connectCallback(err, url);
        }
      }
      return url.connect(finalOptions, connectCallback);
    }
    function createListener(mongoClient, event) {
      const eventSet = new Set(["all", "fullsetup", "open", "reconnect"]);
      return (v1, v2) => {
        if (eventSet.has(event)) {
          return mongoClient.emit(event, mongoClient);
        }
        mongoClient.emit(event, v1, v2);
      };
    }
    function createServer(mongoClient, options, callback) {
      options.promiseLibrary = mongoClient.s.promiseLibrary;
      const servers = translateOptions(options);
      const server = servers[0];
      const collectedEvents = collectEvents(mongoClient, server);
      server.connect(options, (err, topology) => {
        if (err) {
          server.close(true);
          return callback(err);
        }
        clearAllEvents(server);
        relayEvents(mongoClient, server);
        addListeners(mongoClient, server);
        const ismaster = topology.lastIsMaster();
        assignTopology(mongoClient, topology);
        if (ismaster && ismaster.msg === "isdbgrid") {
          topology.close();
          return createTopology(mongoClient, "mongos", options, callback);
        }
        replayEvents(mongoClient, collectedEvents);
        callback(err, topology);
      });
    }
    var DEPRECATED_UNIFIED_EVENTS = new Set([
      "reconnect",
      "reconnectFailed",
      "attemptReconnect",
      "joined",
      "left",
      "ping",
      "ha",
      "all",
      "fullsetup",
      "open"
    ]);
    function registerDeprecatedEventNotifiers(client2) {
      client2.on("newListener", (eventName) => {
        if (DEPRECATED_UNIFIED_EVENTS.has(eventName)) {
          emitDeprecationWarning(`The \`${eventName}\` event is no longer supported by the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, "DeprecationWarning");
        }
      });
    }
    function createTopology(mongoClient, topologyType, options, callback) {
      options.promiseLibrary = mongoClient.s.promiseLibrary;
      const translationOptions = {};
      if (topologyType === "unified")
        translationOptions.createServers = false;
      const servers = translateOptions(options, translationOptions);
      if (options.autoEncryption != null) {
        const Encrypter = require_encrypter().Encrypter;
        options.encrypter = new Encrypter(mongoClient, options);
        options.autoEncrypter = options.encrypter.autoEncrypter;
      }
      let topology;
      if (topologyType === "mongos") {
        topology = new Mongos(servers, options);
      } else if (topologyType === "replicaset") {
        topology = new ReplSet(servers, options);
      } else if (topologyType === "unified") {
        topology = new NativeTopology(options.servers, options);
        registerDeprecatedEventNotifiers(mongoClient);
      }
      addListeners(mongoClient, topology);
      relayEvents(mongoClient, topology);
      assignTopology(mongoClient, topology);
      if (options.autoEncrypter) {
        options.autoEncrypter.init((err) => {
          if (err) {
            callback(err);
            return;
          }
          topology.connect(options, (err2) => {
            if (err2) {
              topology.close(true);
              callback(err2);
              return;
            }
            options.encrypter.connectInternalClient((error) => {
              if (error)
                return callback(error);
              callback(void 0, topology);
            });
          });
        });
        return;
      }
      topology.connect(options, (err) => {
        if (err) {
          topology.close(true);
          return callback(err);
        }
        callback(void 0, topology);
        return;
      });
    }
    function createUnifiedOptions(finalOptions, options) {
      const childOptions = [
        "mongos",
        "server",
        "db",
        "replset",
        "db_options",
        "server_options",
        "rs_options",
        "mongos_options"
      ];
      const noMerge = ["readconcern", "compression", "autoencryption"];
      const skip = ["w", "wtimeout", "j", "journal", "fsync", "writeconcern"];
      for (const name in options) {
        if (skip.indexOf(name.toLowerCase()) !== -1) {
          continue;
        } else if (noMerge.indexOf(name.toLowerCase()) !== -1) {
          finalOptions[name] = options[name];
        } else if (childOptions.indexOf(name.toLowerCase()) !== -1) {
          finalOptions = mergeOptions(finalOptions, options[name], false);
        } else {
          if (options[name] && typeof options[name] === "object" && !Buffer.isBuffer(options[name]) && !Array.isArray(options[name])) {
            finalOptions = mergeOptions(finalOptions, options[name], true);
          } else {
            finalOptions[name] = options[name];
          }
        }
      }
      const optionsWriteConcern = WriteConcern.fromOptions(options);
      if (optionsWriteConcern) {
        finalOptions.writeConcern = Object.assign({}, finalOptions.writeConcern, optionsWriteConcern);
      }
      return finalOptions;
    }
    function generateCredentials(client2, username, password, options) {
      options = Object.assign({}, options);
      const source = options.authSource || options.authdb || options.dbName;
      const authMechanismRaw = options.authMechanism || "DEFAULT";
      const authMechanism = authMechanismRaw.toUpperCase();
      const mechanismProperties = options.authMechanismProperties;
      if (!VALID_AUTH_MECHANISMS.has(authMechanism)) {
        throw MongoError.create({
          message: `authentication mechanism ${authMechanismRaw} not supported', options.authMechanism`,
          driver: true
        });
      }
      return new MongoCredentials({
        mechanism: AUTH_MECHANISM_INTERNAL_MAP[authMechanism],
        mechanismProperties,
        source,
        username,
        password
      });
    }
    function legacyTransformUrlOptions(object) {
      return mergeOptions(createUnifiedOptions({}, object), object, false);
    }
    function mergeOptions(target, source, flatten) {
      for (const name in source) {
        if (source[name] && typeof source[name] === "object" && flatten) {
          target = mergeOptions(target, source[name], flatten);
        } else {
          target[name] = source[name];
        }
      }
      return target;
    }
    function relayEvents(mongoClient, topology) {
      const serverOrCommandEvents = [
        "commandStarted",
        "commandSucceeded",
        "commandFailed",
        "serverOpening",
        "serverClosed",
        "serverDescriptionChanged",
        "serverHeartbeatStarted",
        "serverHeartbeatSucceeded",
        "serverHeartbeatFailed",
        "topologyOpening",
        "topologyClosed",
        "topologyDescriptionChanged",
        "joined",
        "left",
        "ping",
        "ha"
      ].concat(CMAP_EVENT_NAMES);
      serverOrCommandEvents.forEach((event) => {
        topology.on(event, (object1, object2) => {
          mongoClient.emit(event, object1, object2);
        });
      });
    }
    function replayEvents(mongoClient, events) {
      for (let i = 0; i < events.length; i++) {
        mongoClient.emit(events[i].event, events[i].object1, events[i].object2);
      }
    }
    function transformUrlOptions(_object) {
      let object = Object.assign({ servers: _object.hosts }, _object.options);
      for (let name in object) {
        const camelCaseName = LEGACY_OPTIONS_MAP[name];
        if (camelCaseName) {
          object[camelCaseName] = object[name];
        }
      }
      const hasUsername = _object.auth && _object.auth.username;
      const hasAuthMechanism = _object.options && _object.options.authMechanism;
      if (hasUsername || hasAuthMechanism) {
        object.auth = Object.assign({}, _object.auth);
        if (object.auth.db) {
          object.authSource = object.authSource || object.auth.db;
        }
        if (object.auth.username) {
          object.auth.user = object.auth.username;
        }
      }
      if (_object.defaultDatabase) {
        object.dbName = _object.defaultDatabase;
      }
      if (object.maxPoolSize) {
        object.poolSize = object.maxPoolSize;
      }
      if (object.readConcernLevel) {
        object.readConcern = new ReadConcern(object.readConcernLevel);
      }
      if (object.wTimeoutMS) {
        object.wtimeout = object.wTimeoutMS;
        object.wTimeoutMS = void 0;
      }
      if (_object.srvHost) {
        object.srvHost = _object.srvHost;
      }
      const wcKeys = ["w", "wtimeout", "j", "journal", "fsync"];
      for (const key of wcKeys) {
        if (object[key] !== void 0) {
          if (object.writeConcern === void 0)
            object.writeConcern = {};
          object.writeConcern[key] = object[key];
          object[key] = void 0;
        }
      }
      return object;
    }
    function translateOptions(options, translationOptions) {
      translationOptions = Object.assign({}, { createServers: true }, translationOptions);
      if (typeof options.readPreference === "string" || typeof options.read_preference === "string") {
        options.readPreference = new ReadPreference(options.readPreference || options.read_preference);
      }
      if (options.readPreference && (options.readPreferenceTags || options.read_preference_tags)) {
        options.readPreference.tags = options.readPreferenceTags || options.read_preference_tags;
      }
      if (options.maxStalenessSeconds) {
        options.readPreference.maxStalenessSeconds = options.maxStalenessSeconds;
      }
      if (options.socketTimeoutMS == null)
        options.socketTimeoutMS = 0;
      if (options.connectTimeoutMS == null)
        options.connectTimeoutMS = 1e4;
      if (!translationOptions.createServers) {
        return;
      }
      return options.servers.map((serverObj) => {
        return serverObj.domain_socket ? new Server(serverObj.domain_socket, 27017, options) : new Server(serverObj.host, serverObj.port, options);
      });
    }
    module2.exports = { validOptions, connect };
  }
});

// node_modules/mongodb/lib/mongo_client.js
var require_mongo_client = __commonJS({
  "node_modules/mongodb/lib/mongo_client.js"(exports2, module2) {
    "use strict";
    var ChangeStream = require_change_stream();
    var Db = require_db2();
    var EventEmitter = require("events").EventEmitter;
    var inherits2 = require("util").inherits;
    var MongoError = require_core().MongoError;
    var deprecate = require("util").deprecate;
    var WriteConcern = require_write_concern();
    var MongoDBNamespace = require_utils6().MongoDBNamespace;
    var ReadPreference = require_read_preference();
    var maybePromise = require_utils6().maybePromise;
    var NativeTopology = require_native_topology();
    var connect = require_connect2().connect;
    var validOptions = require_connect2().validOptions;
    function MongoClient(url, options) {
      if (!(this instanceof MongoClient))
        return new MongoClient(url, options);
      EventEmitter.call(this);
      if (options && options.autoEncryption)
        require_encrypter();
      this.s = {
        url,
        options: options || {},
        promiseLibrary: options && options.promiseLibrary || Promise,
        dbCache: new Map(),
        sessions: new Set(),
        writeConcern: WriteConcern.fromOptions(options),
        readPreference: ReadPreference.fromOptions(options) || ReadPreference.primary,
        namespace: new MongoDBNamespace("admin")
      };
    }
    inherits2(MongoClient, EventEmitter);
    Object.defineProperty(MongoClient.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(MongoClient.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        return this.s.readPreference;
      }
    });
    MongoClient.prototype.connect = function(callback) {
      if (typeof callback === "string") {
        throw new TypeError("`connect` only accepts a callback");
      }
      const client = this;
      return maybePromise(this, callback, (cb) => {
        const err = validOptions(client.s.options);
        if (err)
          return cb(err);
        connect(client, client.s.url, client.s.options, (err2) => {
          if (err2)
            return cb(err2);
          cb(null, client);
        });
      });
    };
    MongoClient.prototype.logout = deprecate(function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      if (typeof callback === "function")
        callback(null, true);
    }, "Multiple authentication is prohibited on a connected client, please only authenticate once per MongoClient");
    MongoClient.prototype.close = function(force, callback) {
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      const client = this;
      return maybePromise(this, callback, (cb) => {
        const completeClose = (err) => {
          client.emit("close", client);
          if (!(client.topology instanceof NativeTopology)) {
            for (const item of client.s.dbCache) {
              item[1].emit("close", client);
            }
          }
          client.removeAllListeners("close");
          cb(err);
        };
        if (client.topology == null) {
          completeClose();
          return;
        }
        client.topology.close(force, (err) => {
          const encrypter = client.topology.s.options.encrypter;
          if (encrypter) {
            return encrypter.close(client, force, (err2) => {
              completeClose(err || err2);
            });
          }
          completeClose(err);
        });
      });
    };
    MongoClient.prototype.db = function(dbName, options) {
      options = options || {};
      if (!dbName) {
        dbName = this.s.options.dbName;
      }
      const finalOptions = Object.assign({}, this.s.options, options);
      if (this.s.dbCache.has(dbName) && finalOptions.returnNonCachedInstance !== true) {
        return this.s.dbCache.get(dbName);
      }
      finalOptions.promiseLibrary = this.s.promiseLibrary;
      if (!this.topology) {
        throw new MongoError("MongoClient must be connected before calling MongoClient.prototype.db");
      }
      const db = new Db(dbName, this.topology, finalOptions);
      this.s.dbCache.set(dbName, db);
      return db;
    };
    MongoClient.prototype.isConnected = function(options) {
      options = options || {};
      if (!this.topology)
        return false;
      return this.topology.isConnected(options);
    };
    MongoClient.connect = function(url, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() : null;
      options = options || {};
      const mongoClient = new MongoClient(url, options);
      return mongoClient.connect(callback);
    };
    MongoClient.prototype.startSession = function(options) {
      options = Object.assign({ explicit: true }, options);
      if (!this.topology) {
        throw new MongoError("Must connect to a server before calling this method");
      }
      return this.topology.startSession(options, this.s.options);
    };
    MongoClient.prototype.withSession = function(options, operation) {
      if (typeof options === "function")
        operation = options, options = void 0;
      const session = this.startSession(options);
      let cleanupHandler = (err, result, opts) => {
        cleanupHandler = () => {
          throw new ReferenceError("cleanupHandler was called too many times");
        };
        opts = Object.assign({ throw: true }, opts);
        session.endSession();
        if (err) {
          if (opts.throw)
            throw err;
          return Promise.reject(err);
        }
      };
      try {
        const result = operation(session);
        return Promise.resolve(result).then((result2) => cleanupHandler(null, result2)).catch((err) => cleanupHandler(err, null, { throw: true }));
      } catch (err) {
        return cleanupHandler(err, null, { throw: false });
      }
    };
    MongoClient.prototype.watch = function(pipeline, options) {
      pipeline = pipeline || [];
      options = options || {};
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }
      return new ChangeStream(this, pipeline, options);
    };
    MongoClient.prototype.getLogger = function() {
      return this.s.options.logger;
    };
    module2.exports = MongoClient;
  }
});

// node_modules/mongodb/lib/gridfs/chunk.js
var require_chunk = __commonJS({
  "node_modules/mongodb/lib/gridfs/chunk.js"(exports2, module2) {
    "use strict";
    var Binary2 = require_core().BSON.Binary;
    var ObjectID2 = require_core().BSON.ObjectID;
    var Buffer2 = require_safe_buffer().Buffer;
    var Chunk = function(file, mongoObject, writeConcern) {
      if (!(this instanceof Chunk))
        return new Chunk(file, mongoObject);
      this.file = file;
      var mongoObjectFinal = mongoObject == null ? {} : mongoObject;
      this.writeConcern = writeConcern || { w: 1 };
      this.objectId = mongoObjectFinal._id == null ? new ObjectID2() : mongoObjectFinal._id;
      this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
      this.data = new Binary2();
      if (typeof mongoObjectFinal.data === "string") {
        var buffer = Buffer2.alloc(mongoObjectFinal.data.length);
        buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, "binary");
        this.data = new Binary2(buffer);
      } else if (Array.isArray(mongoObjectFinal.data)) {
        buffer = Buffer2.alloc(mongoObjectFinal.data.length);
        var data = mongoObjectFinal.data.join("");
        buffer.write(data, 0, data.length, "binary");
        this.data = new Binary2(buffer);
      } else if (mongoObjectFinal.data && mongoObjectFinal.data._bsontype === "Binary") {
        this.data = mongoObjectFinal.data;
      } else if (!Buffer2.isBuffer(mongoObjectFinal.data) && !(mongoObjectFinal.data == null)) {
        throw Error("Illegal chunk format");
      }
      this.internalPosition = 0;
    };
    Chunk.prototype.write = function(data, callback) {
      this.data.write(data, this.internalPosition, data.length, "binary");
      this.internalPosition = this.data.length();
      if (callback != null)
        return callback(null, this);
      return this;
    };
    Chunk.prototype.read = function(length) {
      length = length == null || length === 0 ? this.length() : length;
      if (this.length() - this.internalPosition + 1 >= length) {
        var data = this.data.read(this.internalPosition, length);
        this.internalPosition = this.internalPosition + length;
        return data;
      } else {
        return "";
      }
    };
    Chunk.prototype.readSlice = function(length) {
      if (this.length() - this.internalPosition >= length) {
        var data = null;
        if (this.data.buffer != null) {
          data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);
        } else {
          data = Buffer2.alloc(length);
          length = this.data.readInto(data, this.internalPosition);
        }
        this.internalPosition = this.internalPosition + length;
        return data;
      } else {
        return null;
      }
    };
    Chunk.prototype.eof = function() {
      return this.internalPosition === this.length() ? true : false;
    };
    Chunk.prototype.getc = function() {
      return this.read(1);
    };
    Chunk.prototype.rewind = function() {
      this.internalPosition = 0;
      this.data = new Binary2();
    };
    Chunk.prototype.save = function(options, callback) {
      var self2 = this;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      self2.file.chunkCollection(function(err, collection) {
        if (err)
          return callback(err);
        var writeOptions = { upsert: true };
        for (var name in options)
          writeOptions[name] = options[name];
        for (name in self2.writeConcern)
          writeOptions[name] = self2.writeConcern[name];
        if (self2.data.length() > 0) {
          self2.buildMongoObject(function(mongoObject) {
            var options2 = { forceServerObjectId: true };
            for (var name2 in self2.writeConcern) {
              options2[name2] = self2.writeConcern[name2];
            }
            collection.replaceOne({ _id: self2.objectId }, mongoObject, writeOptions, function(err2) {
              callback(err2, self2);
            });
          });
        } else {
          callback(null, self2);
        }
      });
    };
    Chunk.prototype.buildMongoObject = function(callback) {
      var mongoObject = {
        files_id: this.file.fileId,
        n: this.chunkNumber,
        data: this.data
      };
      if (this.objectId != null)
        mongoObject._id = this.objectId;
      callback(mongoObject);
    };
    Chunk.prototype.length = function() {
      return this.data.length();
    };
    Object.defineProperty(Chunk.prototype, "position", {
      enumerable: true,
      get: function() {
        return this.internalPosition;
      },
      set: function(value) {
        this.internalPosition = value;
      }
    });
    Chunk.DEFAULT_CHUNK_SIZE = 1024 * 255;
    module2.exports = Chunk;
  }
});

// node_modules/mongodb/lib/gridfs/grid_store.js
var require_grid_store = __commonJS({
  "node_modules/mongodb/lib/gridfs/grid_store.js"(exports2, module2) {
    "use strict";
    var Chunk = require_chunk();
    var ObjectID2 = require_core().BSON.ObjectID;
    var ReadPreference = require_core().ReadPreference;
    var Buffer2 = require_safe_buffer().Buffer;
    var fs = require("fs");
    var f = require("util").format;
    var util = require("util");
    var MongoError = require_core().MongoError;
    var inherits2 = util.inherits;
    var Duplex = require("stream").Duplex;
    var shallowClone = require_utils6().shallowClone;
    var executeLegacyOperation = require_utils6().executeLegacyOperation;
    var deprecate = require("util").deprecate;
    var REFERENCE_BY_FILENAME = 0;
    var REFERENCE_BY_ID = 1;
    var deprecationFn = deprecate(() => {
    }, "GridStore is deprecated, and will be removed in a future version. Please use GridFSBucket instead");
    var GridStore = function GridStore2(db, id, filename, mode, options) {
      deprecationFn();
      if (!(this instanceof GridStore2))
        return new GridStore2(db, id, filename, mode, options);
      this.db = db;
      if (typeof options === "undefined")
        options = {};
      if (typeof mode === "undefined") {
        mode = filename;
        filename = void 0;
      } else if (typeof mode === "object") {
        options = mode;
        mode = filename;
        filename = void 0;
      }
      if (id && id._bsontype === "ObjectID") {
        this.referenceBy = REFERENCE_BY_ID;
        this.fileId = id;
        this.filename = filename;
      } else if (typeof filename === "undefined") {
        this.referenceBy = REFERENCE_BY_FILENAME;
        this.filename = id;
        if (mode.indexOf("w") != null) {
          this.fileId = new ObjectID2();
        }
      } else {
        this.referenceBy = REFERENCE_BY_ID;
        this.fileId = id;
        this.filename = filename;
      }
      this.mode = mode == null ? "r" : mode;
      this.options = options || {};
      this.isOpen = false;
      this.root = this.options["root"] == null ? GridStore2.DEFAULT_ROOT_COLLECTION : this.options["root"];
      this.position = 0;
      this.readPreference = this.options.readPreference || db.options.readPreference || ReadPreference.primary;
      this.writeConcern = _getWriteConcern(db, this.options);
      this.internalChunkSize = this.options["chunkSize"] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options["chunkSize"];
      var promiseLibrary = this.options.promiseLibrary || Promise;
      this.promiseLibrary = promiseLibrary;
      Object.defineProperty(this, "chunkSize", {
        enumerable: true,
        get: function() {
          return this.internalChunkSize;
        },
        set: function(value) {
          if (!(this.mode[0] === "w" && this.position === 0 && this.uploadDate == null)) {
            this.internalChunkSize = this.internalChunkSize;
          } else {
            this.internalChunkSize = value;
          }
        }
      });
      Object.defineProperty(this, "md5", {
        enumerable: true,
        get: function() {
          return this.internalMd5;
        }
      });
      Object.defineProperty(this, "chunkNumber", {
        enumerable: true,
        get: function() {
          return this.currentChunk && this.currentChunk.chunkNumber ? this.currentChunk.chunkNumber : null;
        }
      });
    };
    GridStore.prototype.open = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.mode !== "w" && this.mode !== "w+" && this.mode !== "r") {
        throw MongoError.create({ message: "Illegal mode " + this.mode, driver: true });
      }
      return executeLegacyOperation(this.db.s.topology, open, [this, options, callback], {
        skipSessions: true
      });
    };
    var open = function(self2, options, callback) {
      var writeConcern = _getWriteConcern(self2.db, self2.options);
      if (self2.mode === "w" || self2.mode === "w+") {
        var collection = self2.collection();
        collection.ensureIndex([["filename", 1]], writeConcern, function() {
          var chunkCollection = self2.chunkCollection();
          var chunkIndexOptions = shallowClone(writeConcern);
          chunkIndexOptions.unique = true;
          chunkCollection.ensureIndex([
            ["files_id", 1],
            ["n", 1]
          ], chunkIndexOptions, function() {
            _open(self2, writeConcern, function(err, r) {
              if (err)
                return callback(err);
              self2.isOpen = true;
              callback(err, r);
            });
          });
        });
      } else {
        _open(self2, writeConcern, function(err, r) {
          if (err)
            return callback(err);
          self2.isOpen = true;
          callback(err, r);
        });
      }
    };
    GridStore.prototype.eof = function() {
      return this.position === this.length ? true : false;
    };
    GridStore.prototype.getc = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.db.s.topology, getc, [this, options, callback], {
        skipSessions: true
      });
    };
    var getc = function(self2, options, callback) {
      if (self2.eof()) {
        callback(null, null);
      } else if (self2.currentChunk.eof()) {
        nthChunk(self2, self2.currentChunk.chunkNumber + 1, function(err, chunk) {
          self2.currentChunk = chunk;
          self2.position = self2.position + 1;
          callback(err, self2.currentChunk.getc());
        });
      } else {
        self2.position = self2.position + 1;
        callback(null, self2.currentChunk.getc());
      }
    };
    GridStore.prototype.puts = function(string, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      var finalString = string.match(/\n$/) == null ? string + "\n" : string;
      return executeLegacyOperation(this.db.s.topology, this.write.bind(this), [finalString, options, callback], { skipSessions: true });
    };
    GridStore.prototype.stream = function() {
      return new GridStoreStream(this);
    };
    GridStore.prototype.write = function write(data, close2, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.db.s.topology, _writeNormal, [this, data, close2, options, callback], { skipSessions: true });
    };
    GridStore.prototype.destroy = function destroy() {
      if (!this.writable)
        return;
      this.readable = false;
      if (this.writable) {
        this.writable = false;
        this._q.length = 0;
        this.emit("close");
      }
    };
    GridStore.prototype.writeFile = function(file, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.db.s.topology, writeFile, [this, file, options, callback], {
        skipSessions: true
      });
    };
    var writeFile = function(self2, file, options, callback) {
      if (typeof file === "string") {
        fs.open(file, "r", function(err, fd) {
          if (err)
            return callback(err);
          self2.writeFile(fd, callback);
        });
        return;
      }
      self2.open(function(err, self3) {
        if (err)
          return callback(err, self3);
        fs.fstat(file, function(err2, stats) {
          if (err2)
            return callback(err2, self3);
          var offset = 0;
          var index = 0;
          var writeChunk = function() {
            var _buffer = Buffer2.alloc(self3.chunkSize);
            fs.read(file, _buffer, 0, _buffer.length, offset, function(err3, bytesRead, data) {
              if (err3)
                return callback(err3, self3);
              offset = offset + bytesRead;
              var chunk = new Chunk(self3, { n: index++ }, self3.writeConcern);
              chunk.write(data.slice(0, bytesRead), function(err4, chunk2) {
                if (err4)
                  return callback(err4, self3);
                chunk2.save({}, function(err5) {
                  if (err5)
                    return callback(err5, self3);
                  self3.position = self3.position + bytesRead;
                  self3.currentChunk = chunk2;
                  if (offset >= stats.size) {
                    fs.close(file, function(err6) {
                      if (err6)
                        return callback(err6);
                      self3.close(function(err7) {
                        if (err7)
                          return callback(err7, self3);
                        return callback(null, self3);
                      });
                    });
                  } else {
                    return process.nextTick(writeChunk);
                  }
                });
              });
            });
          };
          process.nextTick(writeChunk);
        });
      });
    };
    GridStore.prototype.close = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.db.s.topology, close, [this, options, callback], {
        skipSessions: true
      });
    };
    var close = function(self2, options, callback) {
      if (self2.mode[0] === "w") {
        options = Object.assign({}, self2.writeConcern, options);
        if (self2.currentChunk != null && self2.currentChunk.position > 0) {
          self2.currentChunk.save({}, function(err) {
            if (err && typeof callback === "function")
              return callback(err);
            self2.collection(function(err2, files) {
              if (err2 && typeof callback === "function")
                return callback(err2);
              if (self2.uploadDate != null) {
                buildMongoObject(self2, function(err3, mongoObject) {
                  if (err3) {
                    if (typeof callback === "function")
                      return callback(err3);
                    else
                      throw err3;
                  }
                  files.save(mongoObject, options, function(err4) {
                    if (typeof callback === "function")
                      callback(err4, mongoObject);
                  });
                });
              } else {
                self2.uploadDate = new Date();
                buildMongoObject(self2, function(err3, mongoObject) {
                  if (err3) {
                    if (typeof callback === "function")
                      return callback(err3);
                    else
                      throw err3;
                  }
                  files.save(mongoObject, options, function(err4) {
                    if (typeof callback === "function")
                      callback(err4, mongoObject);
                  });
                });
              }
            });
          });
        } else {
          self2.collection(function(err, files) {
            if (err && typeof callback === "function")
              return callback(err);
            self2.uploadDate = new Date();
            buildMongoObject(self2, function(err2, mongoObject) {
              if (err2) {
                if (typeof callback === "function")
                  return callback(err2);
                else
                  throw err2;
              }
              files.save(mongoObject, options, function(err3) {
                if (typeof callback === "function")
                  callback(err3, mongoObject);
              });
            });
          });
        }
      } else if (self2.mode[0] === "r") {
        if (typeof callback === "function")
          callback(null, null);
      } else {
        if (typeof callback === "function")
          callback(MongoError.create({ message: f("Illegal mode %s", self2.mode), driver: true }));
      }
    };
    GridStore.prototype.chunkCollection = function(callback) {
      if (typeof callback === "function")
        return this.db.collection(this.root + ".chunks", callback);
      return this.db.collection(this.root + ".chunks");
    };
    GridStore.prototype.unlink = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.db.s.topology, unlink, [this, options, callback], {
        skipSessions: true
      });
    };
    var unlink = function(self2, options, callback) {
      deleteChunks(self2, function(err) {
        if (err !== null) {
          err.message = "at deleteChunks: " + err.message;
          return callback(err);
        }
        self2.collection(function(err2, collection) {
          if (err2 !== null) {
            err2.message = "at collection: " + err2.message;
            return callback(err2);
          }
          collection.remove({ _id: self2.fileId }, self2.writeConcern, function(err3) {
            callback(err3, self2);
          });
        });
      });
    };
    GridStore.prototype.collection = function(callback) {
      if (typeof callback === "function")
        this.db.collection(this.root + ".files", callback);
      return this.db.collection(this.root + ".files");
    };
    GridStore.prototype.readlines = function(separator, options, callback) {
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      separator = args.length ? args.shift() : "\n";
      separator = separator || "\n";
      options = args.length ? args.shift() : {};
      return executeLegacyOperation(this.db.s.topology, readlines, [this, separator, options, callback], { skipSessions: true });
    };
    var readlines = function(self2, separator, options, callback) {
      self2.read(function(err, data) {
        if (err)
          return callback(err);
        var items = data.toString().split(separator);
        items = items.length > 0 ? items.splice(0, items.length - 1) : [];
        for (var i = 0; i < items.length; i++) {
          items[i] = items[i] + separator;
        }
        callback(null, items);
      });
    };
    GridStore.prototype.rewind = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.db.s.topology, rewind, [this, options, callback], {
        skipSessions: true
      });
    };
    var rewind = function(self2, options, callback) {
      if (self2.currentChunk.chunkNumber !== 0) {
        if (self2.mode[0] === "w") {
          deleteChunks(self2, function(err) {
            if (err)
              return callback(err);
            self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
            self2.position = 0;
            callback(null, self2);
          });
        } else {
          self2.currentChunk(0, function(err, chunk) {
            if (err)
              return callback(err);
            self2.currentChunk = chunk;
            self2.currentChunk.rewind();
            self2.position = 0;
            callback(null, self2);
          });
        }
      } else {
        self2.currentChunk.rewind();
        self2.position = 0;
        callback(null, self2);
      }
    };
    GridStore.prototype.read = function(length, buffer, options, callback) {
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      length = args.length ? args.shift() : null;
      buffer = args.length ? args.shift() : null;
      options = args.length ? args.shift() : {};
      return executeLegacyOperation(this.db.s.topology, read, [this, length, buffer, options, callback], { skipSessions: true });
    };
    var read = function(self2, length, buffer, options, callback) {
      var finalLength = length == null ? self2.length - self2.position : length;
      var finalBuffer = buffer == null ? Buffer2.alloc(finalLength) : buffer;
      finalBuffer._index = buffer != null && buffer._index != null ? buffer._index : 0;
      if (self2.currentChunk.length() - self2.currentChunk.position + finalBuffer._index >= finalLength) {
        var slice = self2.currentChunk.readSlice(finalLength - finalBuffer._index);
        slice.copy(finalBuffer, finalBuffer._index);
        self2.position = self2.position + finalBuffer.length;
        if (finalLength === 0 && finalBuffer.length === 0)
          return callback(MongoError.create({ message: "File does not exist", driver: true }), null);
        return callback(null, finalBuffer);
      }
      slice = self2.currentChunk.readSlice(self2.currentChunk.length() - self2.currentChunk.position);
      slice.copy(finalBuffer, finalBuffer._index);
      finalBuffer._index += slice.length;
      nthChunk(self2, self2.currentChunk.chunkNumber + 1, function(err, chunk) {
        if (err)
          return callback(err);
        if (chunk.length() > 0) {
          self2.currentChunk = chunk;
          self2.read(length, finalBuffer, callback);
        } else {
          if (finalBuffer._index > 0) {
            callback(null, finalBuffer);
          } else {
            callback(MongoError.create({
              message: "no chunks found for file, possibly corrupt",
              driver: true
            }), null);
          }
        }
      });
    };
    GridStore.prototype.tell = function(callback) {
      var self2 = this;
      if (typeof callback === "function")
        return callback(null, this.position);
      return new self2.promiseLibrary(function(resolve) {
        resolve(self2.position);
      });
    };
    GridStore.prototype.seek = function(position, seekLocation, options, callback) {
      var args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      seekLocation = args.length ? args.shift() : null;
      options = args.length ? args.shift() : {};
      return executeLegacyOperation(this.db.s.topology, seek, [this, position, seekLocation, options, callback], { skipSessions: true });
    };
    var seek = function(self2, position, seekLocation, options, callback) {
      if (self2.mode !== "r") {
        return callback(MongoError.create({ message: "seek is only supported for mode r", driver: true }));
      }
      var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;
      var finalPosition = position;
      var targetPosition = 0;
      if (seekLocationFinal === GridStore.IO_SEEK_CUR) {
        targetPosition = self2.position + finalPosition;
      } else if (seekLocationFinal === GridStore.IO_SEEK_END) {
        targetPosition = self2.length + finalPosition;
      } else {
        targetPosition = finalPosition;
      }
      var newChunkNumber = Math.floor(targetPosition / self2.chunkSize);
      var seekChunk = function() {
        nthChunk(self2, newChunkNumber, function(err, chunk) {
          if (err)
            return callback(err, null);
          if (chunk == null)
            return callback(new Error("no chunk found"));
          self2.currentChunk = chunk;
          self2.position = targetPosition;
          self2.currentChunk.position = self2.position % self2.chunkSize;
          callback(err, self2);
        });
      };
      seekChunk();
    };
    var _open = function(self2, options, callback) {
      var collection = self2.collection();
      var query = self2.referenceBy === REFERENCE_BY_ID ? { _id: self2.fileId } : { filename: self2.filename };
      query = self2.fileId == null && self2.filename == null ? null : query;
      options.readPreference = self2.readPreference;
      if (query != null) {
        collection.findOne(query, options, function(err, doc) {
          if (err) {
            return error(err);
          }
          if (doc != null) {
            self2.fileId = doc._id;
            self2.filename = self2.mode === "r" || self2.filename === void 0 ? doc.filename : self2.filename;
            self2.contentType = doc.contentType;
            self2.internalChunkSize = doc.chunkSize;
            self2.uploadDate = doc.uploadDate;
            self2.aliases = doc.aliases;
            self2.length = doc.length;
            self2.metadata = doc.metadata;
            self2.internalMd5 = doc.md5;
          } else if (self2.mode !== "r") {
            self2.fileId = self2.fileId == null ? new ObjectID2() : self2.fileId;
            self2.contentType = GridStore.DEFAULT_CONTENT_TYPE;
            self2.internalChunkSize = self2.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self2.internalChunkSize;
            self2.length = 0;
          } else {
            self2.length = 0;
            var txtId = self2.fileId._bsontype === "ObjectID" ? self2.fileId.toHexString() : self2.fileId;
            return error(MongoError.create({
              message: f("file with id %s not opened for writing", self2.referenceBy === REFERENCE_BY_ID ? txtId : self2.filename),
              driver: true
            }), self2);
          }
          if (self2.mode === "r") {
            nthChunk(self2, 0, options, function(err2, chunk) {
              if (err2)
                return error(err2);
              self2.currentChunk = chunk;
              self2.position = 0;
              callback(null, self2);
            });
          } else if (self2.mode === "w" && doc) {
            deleteChunks(self2, options, function(err2) {
              if (err2)
                return error(err2);
              self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
              self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
              self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
              self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
              self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
              self2.position = 0;
              callback(null, self2);
            });
          } else if (self2.mode === "w") {
            self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
            self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
            self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = 0;
            callback(null, self2);
          } else if (self2.mode === "w+") {
            nthChunk(self2, lastChunkNumber(self2), options, function(err2, chunk) {
              if (err2)
                return error(err2);
              self2.currentChunk = chunk == null ? new Chunk(self2, { n: 0 }, self2.writeConcern) : chunk;
              self2.currentChunk.position = self2.currentChunk.data.length();
              self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
              self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
              self2.position = self2.length;
              callback(null, self2);
            });
          }
        });
      } else {
        self2.fileId = self2.fileId == null ? new ObjectID2() : self2.fileId;
        self2.contentType = GridStore.DEFAULT_CONTENT_TYPE;
        self2.internalChunkSize = self2.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self2.internalChunkSize;
        self2.length = 0;
        if (self2.mode === "w") {
          deleteChunks(self2, options, function(err) {
            if (err)
              return error(err);
            self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
            self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
            self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = 0;
            callback(null, self2);
          });
        } else if (self2.mode === "w+") {
          nthChunk(self2, lastChunkNumber(self2), options, function(err, chunk) {
            if (err)
              return error(err);
            self2.currentChunk = chunk == null ? new Chunk(self2, { n: 0 }, self2.writeConcern) : chunk;
            self2.currentChunk.position = self2.currentChunk.data.length();
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = self2.length;
            callback(null, self2);
          });
        }
      }
      function error(err) {
        if (error.err)
          return;
        callback(error.err = err);
      }
    };
    var writeBuffer = function(self2, buffer, close2, callback) {
      if (typeof close2 === "function") {
        callback = close2;
        close2 = null;
      }
      var finalClose = typeof close2 === "boolean" ? close2 : false;
      if (self2.mode !== "w") {
        callback(MongoError.create({
          message: f("file with id %s not opened for writing", self2.referenceBy === REFERENCE_BY_ID ? self2.referenceBy : self2.filename),
          driver: true
        }), null);
      } else {
        if (self2.currentChunk.position + buffer.length >= self2.chunkSize) {
          var previousChunkNumber = self2.currentChunk.chunkNumber;
          var leftOverDataSize = self2.chunkSize - self2.currentChunk.position;
          var firstChunkData = buffer.slice(0, leftOverDataSize);
          var leftOverData = buffer.slice(leftOverDataSize);
          var chunksToWrite = [self2.currentChunk.write(firstChunkData)];
          while (leftOverData.length >= self2.chunkSize) {
            var newChunk = new Chunk(self2, { n: previousChunkNumber + 1 }, self2.writeConcern);
            firstChunkData = leftOverData.slice(0, self2.chunkSize);
            leftOverData = leftOverData.slice(self2.chunkSize);
            previousChunkNumber = previousChunkNumber + 1;
            newChunk.write(firstChunkData);
            chunksToWrite.push(newChunk);
          }
          self2.currentChunk = new Chunk(self2, { n: previousChunkNumber + 1 }, self2.writeConcern);
          if (leftOverData.length > 0)
            self2.currentChunk.write(leftOverData);
          self2.position = self2.position + buffer.length;
          var numberOfChunksToWrite = chunksToWrite.length;
          for (var i = 0; i < chunksToWrite.length; i++) {
            chunksToWrite[i].save({}, function(err) {
              if (err)
                return callback(err);
              numberOfChunksToWrite = numberOfChunksToWrite - 1;
              if (numberOfChunksToWrite <= 0) {
                if (finalClose) {
                  return self2.close(function(err2) {
                    callback(err2, self2);
                  });
                }
                return callback(null, self2);
              }
            });
          }
        } else {
          self2.position = self2.position + buffer.length;
          self2.currentChunk.write(buffer);
          if (finalClose) {
            return self2.close(function(err) {
              callback(err, self2);
            });
          }
          return callback(null, self2);
        }
      }
    };
    var buildMongoObject = function(self2, callback) {
      var mongoObject = {
        _id: self2.fileId,
        filename: self2.filename,
        contentType: self2.contentType,
        length: self2.position ? self2.position : 0,
        chunkSize: self2.chunkSize,
        uploadDate: self2.uploadDate,
        aliases: self2.aliases,
        metadata: self2.metadata
      };
      var md5Command = { filemd5: self2.fileId, root: self2.root };
      self2.db.command(md5Command, function(err, results) {
        if (err)
          return callback(err);
        mongoObject.md5 = results.md5;
        callback(null, mongoObject);
      });
    };
    var nthChunk = function(self2, chunkNumber, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || self2.writeConcern;
      options.readPreference = self2.readPreference;
      self2.chunkCollection().findOne({ files_id: self2.fileId, n: chunkNumber }, options, function(err, chunk) {
        if (err)
          return callback(err);
        var finalChunk = chunk == null ? {} : chunk;
        callback(null, new Chunk(self2, finalChunk, self2.writeConcern));
      });
    };
    var lastChunkNumber = function(self2) {
      return Math.floor((self2.length ? self2.length - 1 : 0) / self2.chunkSize);
    };
    var deleteChunks = function(self2, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || self2.writeConcern;
      if (self2.fileId != null) {
        self2.chunkCollection().remove({ files_id: self2.fileId }, options, function(err) {
          if (err)
            return callback(err, false);
          callback(null, true);
        });
      } else {
        callback(null, true);
      }
    };
    GridStore.DEFAULT_ROOT_COLLECTION = "fs";
    GridStore.DEFAULT_CONTENT_TYPE = "binary/octet-stream";
    GridStore.IO_SEEK_SET = 0;
    GridStore.IO_SEEK_CUR = 1;
    GridStore.IO_SEEK_END = 2;
    GridStore.exist = function(db, fileIdObject, rootCollection, options, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      rootCollection = args.length ? args.shift() : null;
      options = args.length ? args.shift() : {};
      options = options || {};
      return executeLegacyOperation(db.s.topology, exists, [db, fileIdObject, rootCollection, options, callback], { skipSessions: true });
    };
    var exists = function(db, fileIdObject, rootCollection, options, callback) {
      var readPreference = options.readPreference || ReadPreference.PRIMARY;
      var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
      db.collection(rootCollectionFinal + ".files", function(err, collection) {
        if (err)
          return callback(err);
        var query = typeof fileIdObject === "string" || Object.prototype.toString.call(fileIdObject) === "[object RegExp]" ? { filename: fileIdObject } : { _id: fileIdObject };
        if (fileIdObject != null && typeof fileIdObject === "object" && Object.prototype.toString.call(fileIdObject) !== "[object RegExp]") {
          query = fileIdObject;
        }
        collection.findOne(query, { readPreference }, function(err2, item) {
          if (err2)
            return callback(err2);
          callback(null, item == null ? false : true);
        });
      });
    };
    GridStore.list = function(db, rootCollection, options, callback) {
      var args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      rootCollection = args.length ? args.shift() : null;
      options = args.length ? args.shift() : {};
      options = options || {};
      return executeLegacyOperation(db.s.topology, list, [db, rootCollection, options, callback], {
        skipSessions: true
      });
    };
    var list = function(db, rootCollection, options, callback) {
      if (rootCollection != null && typeof rootCollection === "object") {
        options = rootCollection;
        rootCollection = null;
      }
      var readPreference = options.readPreference || ReadPreference.primary;
      var byId = options["id"] != null ? options["id"] : false;
      var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
      var items = [];
      db.collection(rootCollectionFinal + ".files", function(err, collection) {
        if (err)
          return callback(err);
        collection.find({}, { readPreference }, function(err2, cursor) {
          if (err2)
            return callback(err2);
          cursor.each(function(err3, item) {
            if (item != null) {
              items.push(byId ? item._id : item.filename);
            } else {
              callback(err3, items);
            }
          });
        });
      });
    };
    GridStore.read = function(db, name, length, offset, options, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      length = args.length ? args.shift() : null;
      offset = args.length ? args.shift() : null;
      options = args.length ? args.shift() : null;
      options = options || {};
      return executeLegacyOperation(db.s.topology, readStatic, [db, name, length, offset, options, callback], { skipSessions: true });
    };
    var readStatic = function(db, name, length, offset, options, callback) {
      new GridStore(db, name, "r", options).open(function(err, gridStore) {
        if (err)
          return callback(err);
        if (offset && offset >= gridStore.length)
          return callback("offset larger than size of file", null);
        if (length && length > gridStore.length)
          return callback("length is larger than the size of the file", null);
        if (offset && length && offset + length > gridStore.length)
          return callback("offset and length is larger than the size of the file", null);
        if (offset != null) {
          gridStore.seek(offset, function(err2, gridStore2) {
            if (err2)
              return callback(err2);
            gridStore2.read(length, callback);
          });
        } else {
          gridStore.read(length, callback);
        }
      });
    };
    GridStore.readlines = function(db, name, separator, options, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      separator = args.length ? args.shift() : null;
      options = args.length ? args.shift() : null;
      options = options || {};
      return executeLegacyOperation(db.s.topology, readlinesStatic, [db, name, separator, options, callback], { skipSessions: true });
    };
    var readlinesStatic = function(db, name, separator, options, callback) {
      var finalSeperator = separator == null ? "\n" : separator;
      new GridStore(db, name, "r", options).open(function(err, gridStore) {
        if (err)
          return callback(err);
        gridStore.readlines(finalSeperator, callback);
      });
    };
    GridStore.unlink = function(db, names, options, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() : {};
      options = options || {};
      return executeLegacyOperation(db.s.topology, unlinkStatic, [this, db, names, options, callback], {
        skipSessions: true
      });
    };
    var unlinkStatic = function(self2, db, names, options, callback) {
      var writeConcern = _getWriteConcern(db, options);
      if (names.constructor === Array) {
        var tc = 0;
        for (var i = 0; i < names.length; i++) {
          ++tc;
          GridStore.unlink(db, names[i], options, function() {
            if (--tc === 0) {
              callback(null, self2);
            }
          });
        }
      } else {
        new GridStore(db, names, "w", options).open(function(err, gridStore) {
          if (err)
            return callback(err);
          deleteChunks(gridStore, function(err2) {
            if (err2)
              return callback(err2);
            gridStore.collection(function(err3, collection) {
              if (err3)
                return callback(err3);
              collection.remove({ _id: gridStore.fileId }, writeConcern, function(err4) {
                callback(err4, self2);
              });
            });
          });
        });
      }
    };
    var _writeNormal = function(self2, data, close2, options, callback) {
      if (Buffer2.isBuffer(data)) {
        return writeBuffer(self2, data, close2, callback);
      } else {
        return writeBuffer(self2, Buffer2.from(data, "binary"), close2, callback);
      }
    };
    var _setWriteConcernHash = function(options) {
      const baseOptions = Object.assign(options, options.writeConcern);
      var finalOptions = {};
      if (baseOptions.w != null)
        finalOptions.w = baseOptions.w;
      if (baseOptions.journal === true)
        finalOptions.j = baseOptions.journal;
      if (baseOptions.j === true)
        finalOptions.j = baseOptions.j;
      if (baseOptions.fsync === true)
        finalOptions.fsync = baseOptions.fsync;
      if (baseOptions.wtimeout != null)
        finalOptions.wtimeout = baseOptions.wtimeout;
      return finalOptions;
    };
    var _getWriteConcern = function(self2, options) {
      var finalOptions = { w: 1 };
      options = options || {};
      if (options.writeConcern != null || options.w != null || typeof options.j === "boolean" || typeof options.journal === "boolean" || typeof options.fsync === "boolean") {
        finalOptions = _setWriteConcernHash(options);
      } else if (options.safe != null && typeof options.safe === "object") {
        finalOptions = _setWriteConcernHash(options.safe);
      } else if (typeof options.safe === "boolean") {
        finalOptions = { w: options.safe ? 1 : 0 };
      } else if (self2.options.writeConcern != null || self2.options.w != null || typeof self2.options.j === "boolean" || typeof self2.options.journal === "boolean" || typeof self2.options.fsync === "boolean") {
        finalOptions = _setWriteConcernHash(self2.options);
      } else if (self2.safe && (self2.safe.w != null || typeof self2.safe.j === "boolean" || typeof self2.safe.journal === "boolean" || typeof self2.safe.fsync === "boolean")) {
        finalOptions = _setWriteConcernHash(self2.safe);
      } else if (typeof self2.safe === "boolean") {
        finalOptions = { w: self2.safe ? 1 : 0 };
      }
      if (finalOptions.w < 1 && (finalOptions.journal === true || finalOptions.j === true || finalOptions.fsync === true))
        throw MongoError.create({
          message: "No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true",
          driver: true
        });
      return finalOptions;
    };
    var GridStoreStream = function(gs) {
      Duplex.call(this);
      this.gs = gs;
      this.endCalled = false;
      this.totalBytesToRead = this.gs.length - this.gs.position;
      this.seekPosition = this.gs.position;
    };
    inherits2(GridStoreStream, Duplex);
    GridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe;
    GridStoreStream.prototype.pipe = function(destination) {
      var self2 = this;
      if (!self2.gs.isOpen) {
        self2.gs.open(function(err) {
          if (err)
            return self2.emit("error", err);
          self2.totalBytesToRead = self2.gs.length - self2.gs.position;
          self2._pipe.apply(self2, [destination]);
        });
      } else {
        self2.totalBytesToRead = self2.gs.length - self2.gs.position;
        self2._pipe.apply(self2, [destination]);
      }
      return destination;
    };
    GridStoreStream.prototype._read = function() {
      var self2 = this;
      var read2 = function() {
        self2.gs.read(length, function(err, buffer) {
          if (err && !self2.endCalled)
            return self2.emit("error", err);
          if (self2.endCalled || buffer == null)
            return self2.push(null);
          if (buffer.length <= self2.totalBytesToRead) {
            self2.totalBytesToRead = self2.totalBytesToRead - buffer.length;
            self2.push(buffer);
          } else if (buffer.length > self2.totalBytesToRead) {
            self2.totalBytesToRead = self2.totalBytesToRead - buffer._index;
            self2.push(buffer.slice(0, buffer._index));
          }
          if (self2.totalBytesToRead <= 0) {
            self2.endCalled = true;
          }
        });
      };
      var length = self2.gs.length < self2.gs.chunkSize ? self2.gs.length - self2.seekPosition : self2.gs.chunkSize;
      if (!self2.gs.isOpen) {
        self2.gs.open(function(err) {
          self2.totalBytesToRead = self2.gs.length - self2.gs.position;
          if (err)
            return self2.emit("error", err);
          read2();
        });
      } else {
        read2();
      }
    };
    GridStoreStream.prototype.destroy = function() {
      this.pause();
      this.endCalled = true;
      this.gs.close();
      this.emit("end");
    };
    GridStoreStream.prototype.write = function(chunk) {
      var self2 = this;
      if (self2.endCalled)
        return self2.emit("error", MongoError.create({ message: "attempting to write to stream after end called", driver: true }));
      if (!self2.gs.isOpen) {
        self2.gs.open(function() {
          self2.gs.isOpen = true;
          self2.gs.write(chunk, function() {
            process.nextTick(function() {
              self2.emit("drain");
            });
          });
        });
        return false;
      } else {
        self2.gs.write(chunk, function() {
          self2.emit("drain");
        });
        return true;
      }
    };
    GridStoreStream.prototype.end = function(chunk, encoding, callback) {
      var self2 = this;
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      chunk = args.length ? args.shift() : null;
      encoding = args.length ? args.shift() : null;
      self2.endCalled = true;
      if (chunk) {
        self2.gs.write(chunk, function() {
          self2.gs.close(function() {
            if (typeof callback === "function")
              callback();
            self2.emit("end");
          });
        });
      }
      self2.gs.close(function() {
        if (typeof callback === "function")
          callback();
        self2.emit("end");
      });
    };
    module2.exports = GridStore;
  }
});

// node_modules/mongodb/lib/gridfs-stream/download.js
var require_download = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/download.js"(exports2, module2) {
    "use strict";
    var stream = require("stream");
    var util = require("util");
    module2.exports = GridFSBucketReadStream;
    function GridFSBucketReadStream(chunks, files, readPreference, filter, options) {
      this.s = {
        bytesRead: 0,
        chunks,
        cursor: null,
        expected: 0,
        files,
        filter,
        init: false,
        expectedEnd: 0,
        file: null,
        options,
        readPreference
      };
      stream.Readable.call(this);
    }
    util.inherits(GridFSBucketReadStream, stream.Readable);
    GridFSBucketReadStream.prototype._read = function() {
      var _this = this;
      if (this.destroyed) {
        return;
      }
      waitForFile(_this, function() {
        doRead(_this);
      });
    };
    GridFSBucketReadStream.prototype.start = function(start) {
      throwIfInitialized(this);
      this.s.options.start = start;
      return this;
    };
    GridFSBucketReadStream.prototype.end = function(end) {
      throwIfInitialized(this);
      this.s.options.end = end;
      return this;
    };
    GridFSBucketReadStream.prototype.abort = function(callback) {
      var _this = this;
      this.push(null);
      this.destroyed = true;
      if (this.s.cursor) {
        this.s.cursor.close(function(error) {
          _this.emit("close");
          callback && callback(error);
        });
      } else {
        if (!this.s.init) {
          _this.emit("close");
        }
        callback && callback();
      }
    };
    function throwIfInitialized(self2) {
      if (self2.s.init) {
        throw new Error("You cannot change options after the stream has enteredflowing mode!");
      }
    }
    function doRead(_this) {
      if (_this.destroyed) {
        return;
      }
      _this.s.cursor.next(function(error, doc) {
        if (_this.destroyed) {
          return;
        }
        if (error) {
          return __handleError(_this, error);
        }
        if (!doc) {
          _this.push(null);
          process.nextTick(() => {
            _this.s.cursor.close(function(error2) {
              if (error2) {
                __handleError(_this, error2);
                return;
              }
              _this.emit("close");
            });
          });
          return;
        }
        var bytesRemaining = _this.s.file.length - _this.s.bytesRead;
        var expectedN = _this.s.expected++;
        var expectedLength = Math.min(_this.s.file.chunkSize, bytesRemaining);
        if (doc.n > expectedN) {
          var errmsg = "ChunkIsMissing: Got unexpected n: " + doc.n + ", expected: " + expectedN;
          return __handleError(_this, new Error(errmsg));
        }
        if (doc.n < expectedN) {
          errmsg = "ExtraChunk: Got unexpected n: " + doc.n + ", expected: " + expectedN;
          return __handleError(_this, new Error(errmsg));
        }
        var buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;
        if (buf.length !== expectedLength) {
          if (bytesRemaining <= 0) {
            errmsg = "ExtraChunk: Got unexpected n: " + doc.n;
            return __handleError(_this, new Error(errmsg));
          }
          errmsg = "ChunkIsWrongSize: Got unexpected length: " + buf.length + ", expected: " + expectedLength;
          return __handleError(_this, new Error(errmsg));
        }
        _this.s.bytesRead += buf.length;
        if (buf.length === 0) {
          return _this.push(null);
        }
        var sliceStart = null;
        var sliceEnd = null;
        if (_this.s.bytesToSkip != null) {
          sliceStart = _this.s.bytesToSkip;
          _this.s.bytesToSkip = 0;
        }
        const atEndOfStream = expectedN === _this.s.expectedEnd - 1;
        const bytesLeftToRead = _this.s.options.end - _this.s.bytesToSkip;
        if (atEndOfStream && _this.s.bytesToTrim != null) {
          sliceEnd = _this.s.file.chunkSize - _this.s.bytesToTrim;
        } else if (_this.s.options.end && bytesLeftToRead < doc.data.length()) {
          sliceEnd = bytesLeftToRead;
        }
        if (sliceStart != null || sliceEnd != null) {
          buf = buf.slice(sliceStart || 0, sliceEnd || buf.length);
        }
        _this.push(buf);
      });
    }
    function init(self2) {
      var findOneOptions = {};
      if (self2.s.readPreference) {
        findOneOptions.readPreference = self2.s.readPreference;
      }
      if (self2.s.options && self2.s.options.sort) {
        findOneOptions.sort = self2.s.options.sort;
      }
      if (self2.s.options && self2.s.options.skip) {
        findOneOptions.skip = self2.s.options.skip;
      }
      self2.s.files.findOne(self2.s.filter, findOneOptions, function(error, doc) {
        if (error) {
          return __handleError(self2, error);
        }
        if (!doc) {
          var identifier = self2.s.filter._id ? self2.s.filter._id.toString() : self2.s.filter.filename;
          var errmsg = "FileNotFound: file " + identifier + " was not found";
          var err = new Error(errmsg);
          err.code = "ENOENT";
          return __handleError(self2, err);
        }
        if (doc.length <= 0) {
          self2.push(null);
          return;
        }
        if (self2.destroyed) {
          self2.emit("close");
          return;
        }
        try {
          self2.s.bytesToSkip = handleStartOption(self2, doc, self2.s.options);
        } catch (error2) {
          return __handleError(self2, error2);
        }
        var filter = { files_id: doc._id };
        if (self2.s.options && self2.s.options.start != null) {
          var skip = Math.floor(self2.s.options.start / doc.chunkSize);
          if (skip > 0) {
            filter["n"] = { $gte: skip };
          }
        }
        self2.s.cursor = self2.s.chunks.find(filter).sort({ n: 1 });
        if (self2.s.readPreference) {
          self2.s.cursor.setReadPreference(self2.s.readPreference);
        }
        self2.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
        self2.s.file = doc;
        try {
          self2.s.bytesToTrim = handleEndOption(self2, doc, self2.s.cursor, self2.s.options);
        } catch (error2) {
          return __handleError(self2, error2);
        }
        self2.emit("file", doc);
      });
    }
    function waitForFile(_this, callback) {
      if (_this.s.file) {
        return callback();
      }
      if (!_this.s.init) {
        init(_this);
        _this.s.init = true;
      }
      _this.once("file", function() {
        callback();
      });
    }
    function handleStartOption(stream2, doc, options) {
      if (options && options.start != null) {
        if (options.start > doc.length) {
          throw new Error("Stream start (" + options.start + ") must not be more than the length of the file (" + doc.length + ")");
        }
        if (options.start < 0) {
          throw new Error("Stream start (" + options.start + ") must not be negative");
        }
        if (options.end != null && options.end < options.start) {
          throw new Error("Stream start (" + options.start + ") must not be greater than stream end (" + options.end + ")");
        }
        stream2.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;
        stream2.s.expected = Math.floor(options.start / doc.chunkSize);
        return options.start - stream2.s.bytesRead;
      }
    }
    function handleEndOption(stream2, doc, cursor, options) {
      if (options && options.end != null) {
        if (options.end > doc.length) {
          throw new Error("Stream end (" + options.end + ") must not be more than the length of the file (" + doc.length + ")");
        }
        if (options.start < 0) {
          throw new Error("Stream end (" + options.end + ") must not be negative");
        }
        var start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;
        cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);
        stream2.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);
        return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;
      }
    }
    function __handleError(_this, error) {
      _this.emit("error", error);
    }
  }
});

// node_modules/mongodb/lib/gridfs-stream/upload.js
var require_upload = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/upload.js"(exports2, module2) {
    "use strict";
    var core = require_core();
    var crypto = require("crypto");
    var stream = require("stream");
    var util = require("util");
    var Buffer2 = require_safe_buffer().Buffer;
    var ERROR_NAMESPACE_NOT_FOUND = 26;
    module2.exports = GridFSBucketWriteStream;
    function GridFSBucketWriteStream(bucket, filename, options) {
      options = options || {};
      stream.Writable.call(this, options);
      this.bucket = bucket;
      this.chunks = bucket.s._chunksCollection;
      this.filename = filename;
      this.files = bucket.s._filesCollection;
      this.options = options;
      this.done = false;
      this.id = options.id ? options.id : core.BSON.ObjectId();
      this.chunkSizeBytes = this.options.chunkSizeBytes;
      this.bufToStore = Buffer2.alloc(this.chunkSizeBytes);
      this.length = 0;
      this.md5 = !options.disableMD5 && crypto.createHash("md5");
      this.n = 0;
      this.pos = 0;
      this.state = {
        streamEnd: false,
        outstandingRequests: 0,
        errored: false,
        aborted: false,
        promiseLibrary: this.bucket.s.promiseLibrary
      };
      if (!this.bucket.s.calledOpenUploadStream) {
        this.bucket.s.calledOpenUploadStream = true;
        var _this = this;
        checkIndexes(this, function() {
          _this.bucket.s.checkedIndexes = true;
          _this.bucket.emit("index");
        });
      }
    }
    util.inherits(GridFSBucketWriteStream, stream.Writable);
    GridFSBucketWriteStream.prototype.write = function(chunk, encoding, callback) {
      var _this = this;
      return waitForIndexes(this, function() {
        return doWrite(_this, chunk, encoding, callback);
      });
    };
    GridFSBucketWriteStream.prototype.abort = function(callback) {
      if (this.state.streamEnd) {
        var error = new Error("Cannot abort a stream that has already completed");
        if (typeof callback === "function") {
          return callback(error);
        }
        return this.state.promiseLibrary.reject(error);
      }
      if (this.state.aborted) {
        error = new Error("Cannot call abort() on a stream twice");
        if (typeof callback === "function") {
          return callback(error);
        }
        return this.state.promiseLibrary.reject(error);
      }
      this.state.aborted = true;
      this.chunks.deleteMany({ files_id: this.id }, function(error2) {
        if (typeof callback === "function")
          callback(error2);
      });
    };
    GridFSBucketWriteStream.prototype.end = function(chunk, encoding, callback) {
      var _this = this;
      if (typeof chunk === "function") {
        callback = chunk, chunk = null, encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding, encoding = null;
      }
      if (checkAborted(this, callback)) {
        return;
      }
      this.state.streamEnd = true;
      if (callback) {
        this.once("finish", function(result) {
          callback(null, result);
        });
      }
      if (!chunk) {
        waitForIndexes(this, function() {
          writeRemnant(_this);
        });
        return;
      }
      this.write(chunk, encoding, function() {
        writeRemnant(_this);
      });
    };
    function __handleError(_this, error, callback) {
      if (_this.state.errored) {
        return;
      }
      _this.state.errored = true;
      if (callback) {
        return callback(error);
      }
      _this.emit("error", error);
    }
    function createChunkDoc(filesId, n, data) {
      return {
        _id: core.BSON.ObjectId(),
        files_id: filesId,
        n,
        data
      };
    }
    function checkChunksIndex(_this, callback) {
      _this.chunks.listIndexes().toArray(function(error, indexes) {
        if (error) {
          if (error.code === ERROR_NAMESPACE_NOT_FOUND) {
            var index = { files_id: 1, n: 1 };
            _this.chunks.createIndex(index, { background: false, unique: true }, function(error2) {
              if (error2) {
                return callback(error2);
              }
              callback();
            });
            return;
          }
          return callback(error);
        }
        var hasChunksIndex = false;
        indexes.forEach(function(index2) {
          if (index2.key) {
            var keys = Object.keys(index2.key);
            if (keys.length === 2 && index2.key.files_id === 1 && index2.key.n === 1) {
              hasChunksIndex = true;
            }
          }
        });
        if (hasChunksIndex) {
          callback();
        } else {
          index = { files_id: 1, n: 1 };
          var indexOptions = getWriteOptions(_this);
          indexOptions.background = false;
          indexOptions.unique = true;
          _this.chunks.createIndex(index, indexOptions, function(error2) {
            if (error2) {
              return callback(error2);
            }
            callback();
          });
        }
      });
    }
    function checkDone(_this, callback) {
      if (_this.done)
        return true;
      if (_this.state.streamEnd && _this.state.outstandingRequests === 0 && !_this.state.errored) {
        _this.done = true;
        var filesDoc = createFilesDoc(_this.id, _this.length, _this.chunkSizeBytes, _this.md5 && _this.md5.digest("hex"), _this.filename, _this.options.contentType, _this.options.aliases, _this.options.metadata);
        if (checkAborted(_this, callback)) {
          return false;
        }
        _this.files.insertOne(filesDoc, getWriteOptions(_this), function(error) {
          if (error) {
            return __handleError(_this, error, callback);
          }
          _this.emit("finish", filesDoc);
          _this.emit("close");
        });
        return true;
      }
      return false;
    }
    function checkIndexes(_this, callback) {
      _this.files.findOne({}, { _id: 1 }, function(error, doc) {
        if (error) {
          return callback(error);
        }
        if (doc) {
          return callback();
        }
        _this.files.listIndexes().toArray(function(error2, indexes) {
          if (error2) {
            if (error2.code === ERROR_NAMESPACE_NOT_FOUND) {
              var index = { filename: 1, uploadDate: 1 };
              _this.files.createIndex(index, { background: false }, function(error3) {
                if (error3) {
                  return callback(error3);
                }
                checkChunksIndex(_this, callback);
              });
              return;
            }
            return callback(error2);
          }
          var hasFileIndex = false;
          indexes.forEach(function(index2) {
            var keys = Object.keys(index2.key);
            if (keys.length === 2 && index2.key.filename === 1 && index2.key.uploadDate === 1) {
              hasFileIndex = true;
            }
          });
          if (hasFileIndex) {
            checkChunksIndex(_this, callback);
          } else {
            index = { filename: 1, uploadDate: 1 };
            var indexOptions = getWriteOptions(_this);
            indexOptions.background = false;
            _this.files.createIndex(index, indexOptions, function(error3) {
              if (error3) {
                return callback(error3);
              }
              checkChunksIndex(_this, callback);
            });
          }
        });
      });
    }
    function createFilesDoc(_id, length, chunkSize, md5, filename, contentType, aliases, metadata) {
      var ret2 = {
        _id,
        length,
        chunkSize,
        uploadDate: new Date(),
        filename
      };
      if (md5) {
        ret2.md5 = md5;
      }
      if (contentType) {
        ret2.contentType = contentType;
      }
      if (aliases) {
        ret2.aliases = aliases;
      }
      if (metadata) {
        ret2.metadata = metadata;
      }
      return ret2;
    }
    function doWrite(_this, chunk, encoding, callback) {
      if (checkAborted(_this, callback)) {
        return false;
      }
      var inputBuf = Buffer2.isBuffer(chunk) ? chunk : Buffer2.from(chunk, encoding);
      _this.length += inputBuf.length;
      if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {
        inputBuf.copy(_this.bufToStore, _this.pos);
        _this.pos += inputBuf.length;
        callback && callback();
        return true;
      }
      var inputBufRemaining = inputBuf.length;
      var spaceRemaining = _this.chunkSizeBytes - _this.pos;
      var numToCopy = Math.min(spaceRemaining, inputBuf.length);
      var outstandingRequests = 0;
      while (inputBufRemaining > 0) {
        var inputBufPos = inputBuf.length - inputBufRemaining;
        inputBuf.copy(_this.bufToStore, _this.pos, inputBufPos, inputBufPos + numToCopy);
        _this.pos += numToCopy;
        spaceRemaining -= numToCopy;
        if (spaceRemaining === 0) {
          if (_this.md5) {
            _this.md5.update(_this.bufToStore);
          }
          var doc = createChunkDoc(_this.id, _this.n, Buffer2.from(_this.bufToStore));
          ++_this.state.outstandingRequests;
          ++outstandingRequests;
          if (checkAborted(_this, callback)) {
            return false;
          }
          _this.chunks.insertOne(doc, getWriteOptions(_this), function(error) {
            if (error) {
              return __handleError(_this, error);
            }
            --_this.state.outstandingRequests;
            --outstandingRequests;
            if (!outstandingRequests) {
              _this.emit("drain", doc);
              callback && callback();
              checkDone(_this);
            }
          });
          spaceRemaining = _this.chunkSizeBytes;
          _this.pos = 0;
          ++_this.n;
        }
        inputBufRemaining -= numToCopy;
        numToCopy = Math.min(spaceRemaining, inputBufRemaining);
      }
      return false;
    }
    function getWriteOptions(_this) {
      var obj = {};
      if (_this.options.writeConcern) {
        obj.w = _this.options.writeConcern.w;
        obj.wtimeout = _this.options.writeConcern.wtimeout;
        obj.j = _this.options.writeConcern.j;
      }
      return obj;
    }
    function waitForIndexes(_this, callback) {
      if (_this.bucket.s.checkedIndexes) {
        return callback(false);
      }
      _this.bucket.once("index", function() {
        callback(true);
      });
      return true;
    }
    function writeRemnant(_this, callback) {
      if (_this.pos === 0) {
        return checkDone(_this, callback);
      }
      ++_this.state.outstandingRequests;
      var remnant = Buffer2.alloc(_this.pos);
      _this.bufToStore.copy(remnant, 0, 0, _this.pos);
      if (_this.md5) {
        _this.md5.update(remnant);
      }
      var doc = createChunkDoc(_this.id, _this.n, remnant);
      if (checkAborted(_this, callback)) {
        return false;
      }
      _this.chunks.insertOne(doc, getWriteOptions(_this), function(error) {
        if (error) {
          return __handleError(_this, error);
        }
        --_this.state.outstandingRequests;
        checkDone(_this);
      });
    }
    function checkAborted(_this, callback) {
      if (_this.state.aborted) {
        if (typeof callback === "function") {
          callback(new Error("this stream has been aborted"));
        }
        return true;
      }
      return false;
    }
  }
});

// node_modules/mongodb/lib/gridfs-stream/index.js
var require_gridfs_stream = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/index.js"(exports2, module2) {
    "use strict";
    var Emitter = require("events").EventEmitter;
    var GridFSBucketReadStream = require_download();
    var GridFSBucketWriteStream = require_upload();
    var shallowClone = require_utils6().shallowClone;
    var toError = require_utils6().toError;
    var util = require("util");
    var executeLegacyOperation = require_utils6().executeLegacyOperation;
    var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
      bucketName: "fs",
      chunkSizeBytes: 255 * 1024
    };
    module2.exports = GridFSBucket;
    function GridFSBucket(db, options) {
      Emitter.apply(this);
      this.setMaxListeners(0);
      if (options && typeof options === "object") {
        options = shallowClone(options);
        var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);
        for (var i = 0; i < keys.length; ++i) {
          if (!options[keys[i]]) {
            options[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];
          }
        }
      } else {
        options = DEFAULT_GRIDFS_BUCKET_OPTIONS;
      }
      this.s = {
        db,
        options,
        _chunksCollection: db.collection(options.bucketName + ".chunks"),
        _filesCollection: db.collection(options.bucketName + ".files"),
        checkedIndexes: false,
        calledOpenUploadStream: false,
        promiseLibrary: db.s.promiseLibrary || Promise
      };
    }
    util.inherits(GridFSBucket, Emitter);
    GridFSBucket.prototype.openUploadStream = function(filename, options) {
      if (options) {
        options = shallowClone(options);
      } else {
        options = {};
      }
      if (!options.chunkSizeBytes) {
        options.chunkSizeBytes = this.s.options.chunkSizeBytes;
      }
      return new GridFSBucketWriteStream(this, filename, options);
    };
    GridFSBucket.prototype.openUploadStreamWithId = function(id, filename, options) {
      if (options) {
        options = shallowClone(options);
      } else {
        options = {};
      }
      if (!options.chunkSizeBytes) {
        options.chunkSizeBytes = this.s.options.chunkSizeBytes;
      }
      options.id = id;
      return new GridFSBucketWriteStream(this, filename, options);
    };
    GridFSBucket.prototype.openDownloadStream = function(id, options) {
      var filter = { _id: id };
      options = {
        start: options && options.start,
        end: options && options.end
      };
      return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options);
    };
    GridFSBucket.prototype.delete = function(id, callback) {
      return executeLegacyOperation(this.s.db.s.topology, _delete, [this, id, callback], {
        skipSessions: true
      });
    };
    function _delete(_this, id, callback) {
      _this.s._filesCollection.deleteOne({ _id: id }, function(error, res) {
        if (error) {
          return callback(error);
        }
        _this.s._chunksCollection.deleteMany({ files_id: id }, function(error2) {
          if (error2) {
            return callback(error2);
          }
          if (!res.result.n) {
            var errmsg = "FileNotFound: no file with id " + id + " found";
            return callback(new Error(errmsg));
          }
          callback();
        });
      });
    }
    GridFSBucket.prototype.find = function(filter, options) {
      filter = filter || {};
      options = options || {};
      var cursor = this.s._filesCollection.find(filter);
      if (options.batchSize != null) {
        cursor.batchSize(options.batchSize);
      }
      if (options.limit != null) {
        cursor.limit(options.limit);
      }
      if (options.maxTimeMS != null) {
        cursor.maxTimeMS(options.maxTimeMS);
      }
      if (options.noCursorTimeout != null) {
        cursor.addCursorFlag("noCursorTimeout", options.noCursorTimeout);
      }
      if (options.skip != null) {
        cursor.skip(options.skip);
      }
      if (options.sort != null) {
        cursor.sort(options.sort);
      }
      return cursor;
    };
    GridFSBucket.prototype.openDownloadStreamByName = function(filename, options) {
      var sort = { uploadDate: -1 };
      var skip = null;
      if (options && options.revision != null) {
        if (options.revision >= 0) {
          sort = { uploadDate: 1 };
          skip = options.revision;
        } else {
          skip = -options.revision - 1;
        }
      }
      var filter = { filename };
      options = {
        sort,
        skip,
        start: options && options.start,
        end: options && options.end
      };
      return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options);
    };
    GridFSBucket.prototype.rename = function(id, filename, callback) {
      return executeLegacyOperation(this.s.db.s.topology, _rename, [this, id, filename, callback], {
        skipSessions: true
      });
    };
    function _rename(_this, id, filename, callback) {
      var filter = { _id: id };
      var update = { $set: { filename } };
      _this.s._filesCollection.updateOne(filter, update, function(error, res) {
        if (error) {
          return callback(error);
        }
        if (!res.result.n) {
          return callback(toError("File with id " + id + " not found"));
        }
        callback();
      });
    }
    GridFSBucket.prototype.drop = function(callback) {
      return executeLegacyOperation(this.s.db.s.topology, _drop, [this, callback], {
        skipSessions: true
      });
    };
    GridFSBucket.prototype.getLogger = function() {
      return this.s.db.s.logger;
    };
    function _drop(_this, callback) {
      _this.s._filesCollection.drop(function(error) {
        if (error) {
          return callback(error);
        }
        _this.s._chunksCollection.drop(function(error2) {
          if (error2) {
            return callback(error2);
          }
          return callback();
        });
      });
    }
  }
});

// node_modules/mongodb/index.js
var require_mongodb = __commonJS({
  "node_modules/mongodb/index.js"(exports2, module2) {
    "use strict";
    var core = require_core();
    var Instrumentation = require_apm2();
    var connect = require_mongo_client().connect;
    connect.MongoError = core.MongoError;
    connect.MongoNetworkError = core.MongoNetworkError;
    connect.MongoTimeoutError = core.MongoTimeoutError;
    connect.MongoServerSelectionError = core.MongoServerSelectionError;
    connect.MongoParseError = core.MongoParseError;
    connect.MongoWriteConcernError = core.MongoWriteConcernError;
    connect.MongoBulkWriteError = require_common2().BulkWriteError;
    connect.BulkWriteError = connect.MongoBulkWriteError;
    connect.Admin = require_admin();
    connect.MongoClient = require_mongo_client();
    connect.Db = require_db2();
    connect.Collection = require_collection();
    connect.Server = require_server3();
    connect.ReplSet = require_replset2();
    connect.Mongos = require_mongos2();
    connect.ReadPreference = core.ReadPreference;
    connect.GridStore = require_grid_store();
    connect.Chunk = require_chunk();
    connect.Logger = core.Logger;
    connect.AggregationCursor = require_aggregation_cursor();
    connect.CommandCursor = require_command_cursor();
    connect.Cursor = require_cursor2();
    connect.GridFSBucket = require_gridfs_stream();
    connect.CoreServer = core.Server;
    connect.CoreConnection = core.Connection;
    connect.Binary = core.BSON.Binary;
    connect.Code = core.BSON.Code;
    connect.Map = core.BSON.Map;
    connect.DBRef = core.BSON.DBRef;
    connect.Double = core.BSON.Double;
    connect.Int32 = core.BSON.Int32;
    connect.Long = core.BSON.Long;
    connect.MinKey = core.BSON.MinKey;
    connect.MaxKey = core.BSON.MaxKey;
    connect.ObjectID = core.BSON.ObjectID;
    connect.ObjectId = core.BSON.ObjectID;
    connect.Symbol = core.BSON.Symbol;
    connect.Timestamp = core.BSON.Timestamp;
    connect.BSONRegExp = core.BSON.BSONRegExp;
    connect.Decimal128 = core.BSON.Decimal128;
    connect.connect = connect;
    connect.instrument = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      const instrumentation = new Instrumentation();
      instrumentation.instrument(connect.MongoClient, callback);
      return instrumentation;
    };
    module2.exports = connect;
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/binary.js
var require_binary2 = __commonJS({
  "node_modules/mongoose/lib/drivers/node-mongodb-native/binary.js"(exports2, module2) {
    "use strict";
    var Binary2 = require_mongodb().Binary;
    module2.exports = exports2 = Binary2;
  }
});

// node_modules/mongoose/lib/connectionstate.js
var require_connectionstate = __commonJS({
  "node_modules/mongoose/lib/connectionstate.js"(exports2, module2) {
    "use strict";
    var STATES = module2.exports = exports2 = Object.create(null);
    var disconnected = "disconnected";
    var connected = "connected";
    var connecting = "connecting";
    var disconnecting = "disconnecting";
    var uninitialized = "uninitialized";
    STATES[0] = disconnected;
    STATES[1] = connected;
    STATES[2] = connecting;
    STATES[3] = disconnecting;
    STATES[99] = uninitialized;
    STATES[disconnected] = 0;
    STATES[connected] = 1;
    STATES[connecting] = 2;
    STATES[disconnecting] = 3;
    STATES[uninitialized] = 99;
  }
});

// node_modules/mongoose/lib/helpers/immediate.js
var require_immediate = __commonJS({
  "node_modules/mongoose/lib/helpers/immediate.js"(exports2, module2) {
    "use strict";
    var nextTick = process.nextTick.bind(process);
    module2.exports = function immediate(cb) {
      return nextTick(cb);
    };
  }
});

// node_modules/mongoose/lib/collection.js
var require_collection2 = __commonJS({
  "node_modules/mongoose/lib/collection.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var STATES = require_connectionstate();
    var immediate = require_immediate();
    function Collection(name, conn, opts) {
      if (opts === void 0) {
        opts = {};
      }
      if (opts.capped === void 0) {
        opts.capped = {};
      }
      if (typeof opts.capped === "number") {
        opts.capped = { size: opts.capped };
      }
      this.opts = opts;
      this.name = name;
      this.collectionName = name;
      this.conn = conn;
      this.queue = [];
      this.buffer = true;
      this.emitter = new EventEmitter();
      if (STATES.connected === this.conn.readyState) {
        this.onOpen();
      }
    }
    Collection.prototype.name;
    Collection.prototype.collectionName;
    Collection.prototype.conn;
    Collection.prototype.onOpen = function() {
      this.buffer = false;
      immediate(() => this.doQueue());
    };
    Collection.prototype.onClose = function(force) {
      if (this._shouldBufferCommands() && !force) {
        this.buffer = true;
      }
    };
    Collection.prototype.addQueue = function(name, args) {
      this.queue.push([name, args]);
      return this;
    };
    Collection.prototype.removeQueue = function(name, args) {
      const index = this.queue.findIndex((v) => v[0] === name && v[1] === args);
      if (index === -1) {
        return false;
      }
      this.queue.splice(index, 1);
      return true;
    };
    Collection.prototype.doQueue = function() {
      for (const method of this.queue) {
        if (typeof method[0] === "function") {
          method[0].apply(this, method[1]);
        } else {
          this[method[0]].apply(this, method[1]);
        }
      }
      this.queue = [];
      const _this = this;
      immediate(function() {
        _this.emitter.emit("queue");
      });
      return this;
    };
    Collection.prototype.ensureIndex = function() {
      throw new Error("Collection#ensureIndex unimplemented by driver");
    };
    Collection.prototype.createIndex = function() {
      throw new Error("Collection#createIndex unimplemented by driver");
    };
    Collection.prototype.findAndModify = function() {
      throw new Error("Collection#findAndModify unimplemented by driver");
    };
    Collection.prototype.findOneAndUpdate = function() {
      throw new Error("Collection#findOneAndUpdate unimplemented by driver");
    };
    Collection.prototype.findOneAndDelete = function() {
      throw new Error("Collection#findOneAndDelete unimplemented by driver");
    };
    Collection.prototype.findOneAndReplace = function() {
      throw new Error("Collection#findOneAndReplace unimplemented by driver");
    };
    Collection.prototype.findOne = function() {
      throw new Error("Collection#findOne unimplemented by driver");
    };
    Collection.prototype.find = function() {
      throw new Error("Collection#find unimplemented by driver");
    };
    Collection.prototype.insert = function() {
      throw new Error("Collection#insert unimplemented by driver");
    };
    Collection.prototype.insertOne = function() {
      throw new Error("Collection#insertOne unimplemented by driver");
    };
    Collection.prototype.insertMany = function() {
      throw new Error("Collection#insertMany unimplemented by driver");
    };
    Collection.prototype.save = function() {
      throw new Error("Collection#save unimplemented by driver");
    };
    Collection.prototype.update = function() {
      throw new Error("Collection#update unimplemented by driver");
    };
    Collection.prototype.getIndexes = function() {
      throw new Error("Collection#getIndexes unimplemented by driver");
    };
    Collection.prototype.mapReduce = function() {
      throw new Error("Collection#mapReduce unimplemented by driver");
    };
    Collection.prototype.watch = function() {
      throw new Error("Collection#watch unimplemented by driver");
    };
    Collection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
      const opts = this.opts;
      if (opts.bufferCommands != null) {
        return opts.bufferCommands;
      }
      if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferCommands != null) {
        return opts.schemaUserProvidedOptions.bufferCommands;
      }
      return this.conn._shouldBufferCommands();
    };
    Collection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {
      const conn = this.conn;
      const opts = this.opts;
      if (opts.bufferTimeoutMS != null) {
        return opts.bufferTimeoutMS;
      }
      if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferTimeoutMS != null) {
        return opts.schemaUserProvidedOptions.bufferTimeoutMS;
      }
      if (conn.config.bufferTimeoutMS != null) {
        return conn.config.bufferTimeoutMS;
      }
      if (conn.base != null && conn.base.get("bufferTimeoutMS") != null) {
        return conn.base.get("bufferTimeoutMS");
      }
      return 1e4;
    };
    module2.exports = Collection;
  }
});

// node_modules/mongoose/lib/error/mongooseError.js
var require_mongooseError = __commonJS({
  "node_modules/mongoose/lib/error/mongooseError.js"(exports2, module2) {
    "use strict";
    var MongooseError = class extends Error {
    };
    Object.defineProperty(MongooseError.prototype, "name", {
      value: "MongooseError"
    });
    module2.exports = MongooseError;
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/objectid.js
var require_objectid2 = __commonJS({
  "node_modules/mongoose/lib/drivers/node-mongodb-native/objectid.js"(exports2, module2) {
    "use strict";
    var ObjectId2 = require_mongodb().ObjectId;
    module2.exports = exports2 = ObjectId2;
  }
});

// node_modules/mongoose/lib/helpers/get.js
var require_get = __commonJS({
  "node_modules/mongoose/lib/helpers/get.js"(exports2, module2) {
    "use strict";
    module2.exports = function get(obj, path, def) {
      let parts;
      let isPathArray = false;
      if (typeof path === "string") {
        if (path.indexOf(".") === -1) {
          const _v = getProperty(obj, path);
          if (_v == null) {
            return def;
          }
          return _v;
        }
        parts = path.split(".");
      } else {
        isPathArray = true;
        parts = path;
        if (parts.length === 1) {
          const _v = getProperty(obj, parts[0]);
          if (_v == null) {
            return def;
          }
          return _v;
        }
      }
      let rest = path;
      let cur = obj;
      for (const part of parts) {
        if (cur == null) {
          return def;
        }
        if (!isPathArray && cur[rest] != null) {
          return cur[rest];
        }
        cur = getProperty(cur, part);
        if (!isPathArray) {
          rest = rest.substr(part.length + 1);
        }
      }
      return cur == null ? def : cur;
    };
    function getProperty(obj, prop) {
      if (obj == null) {
        return obj;
      }
      if (obj instanceof Map) {
        return obj.get(prop);
      }
      return obj[prop];
    }
  }
});

// node_modules/mongoose/lib/helpers/getConstructorName.js
var require_getConstructorName = __commonJS({
  "node_modules/mongoose/lib/helpers/getConstructorName.js"(exports2, module2) {
    "use strict";
    module2.exports = function getConstructorName(val) {
      if (val == null) {
        return void 0;
      }
      if (typeof val.constructor !== "function") {
        return void 0;
      }
      return val.constructor.name;
    };
  }
});

// node_modules/sliced/index.js
var require_sliced = __commonJS({
  "node_modules/sliced/index.js"(exports2, module2) {
    module2.exports = function(args, slice, sliceEnd) {
      var ret2 = [];
      var len = args.length;
      if (len === 0)
        return ret2;
      var start = slice < 0 ? Math.max(0, slice + len) : slice || 0;
      if (sliceEnd !== void 0) {
        len = sliceEnd < 0 ? sliceEnd + len : sliceEnd;
      }
      while (len-- > start) {
        ret2[len - start] = args[len];
      }
      return ret2;
    };
  }
});

// node_modules/regexp-clone/index.js
var require_regexp_clone = __commonJS({
  "node_modules/regexp-clone/index.js"(exports2, module2) {
    var toString = Object.prototype.toString;
    function isRegExp(o) {
      return typeof o == "object" && toString.call(o) == "[object RegExp]";
    }
    module2.exports = exports2 = function(regexp) {
      if (!isRegExp(regexp)) {
        throw new TypeError("Not a RegExp");
      }
      const flags = [];
      if (regexp.global)
        flags.push("g");
      if (regexp.multiline)
        flags.push("m");
      if (regexp.ignoreCase)
        flags.push("i");
      if (regexp.dotAll)
        flags.push("s");
      if (regexp.unicode)
        flags.push("u");
      if (regexp.sticky)
        flags.push("y");
      const result = new RegExp(regexp.source, flags.join(""));
      if (typeof regexp.lastIndex === "number") {
        result.lastIndex = regexp.lastIndex;
      }
      return result;
    };
  }
});

// node_modules/mongoose/lib/types/decimal128.js
var require_decimal1282 = __commonJS({
  "node_modules/mongoose/lib/types/decimal128.js"(exports2, module2) {
    "use strict";
    module2.exports = require_driver().get().Decimal128;
  }
});

// node_modules/mongoose/lib/helpers/symbols.js
var require_symbols = __commonJS({
  "node_modules/mongoose/lib/helpers/symbols.js"(exports2) {
    "use strict";
    exports2.arrayAtomicsSymbol = Symbol("mongoose#Array#_atomics");
    exports2.arrayParentSymbol = Symbol("mongoose#Array#_parent");
    exports2.arrayPathSymbol = Symbol("mongoose#Array#_path");
    exports2.arraySchemaSymbol = Symbol("mongoose#Array#_schema");
    exports2.documentArrayParent = Symbol("mongoose:documentArrayParent");
    exports2.documentIsSelected = Symbol("mongoose#Document#isSelected");
    exports2.documentIsModified = Symbol("mongoose#Document#isModified");
    exports2.documentModifiedPaths = Symbol("mongoose#Document#modifiedPaths");
    exports2.documentSchemaSymbol = Symbol("mongoose#Document#schema");
    exports2.getSymbol = Symbol("mongoose#Document#get");
    exports2.modelSymbol = Symbol("mongoose#Model");
    exports2.objectIdSymbol = Symbol("mongoose#ObjectId");
    exports2.populateModelSymbol = Symbol("mongoose.PopulateOptions#Model");
    exports2.schemaTypeSymbol = Symbol("mongoose#schemaType");
    exports2.sessionNewDocuments = Symbol("mongoose:ClientSession#newDocuments");
    exports2.scopeSymbol = Symbol("mongoose#Document#scope");
    exports2.validatorErrorSymbol = Symbol("mongoose:validatorError");
  }
});

// node_modules/mongoose/lib/types/objectid.js
var require_objectid3 = __commonJS({
  "node_modules/mongoose/lib/types/objectid.js"(exports2, module2) {
    "use strict";
    var ObjectId2 = require_driver().get().ObjectId;
    var objectIdSymbol = require_symbols().objectIdSymbol;
    Object.defineProperty(ObjectId2.prototype, "_id", {
      enumerable: false,
      configurable: true,
      get: function() {
        return this;
      }
    });
    ObjectId2.prototype[objectIdSymbol] = true;
    module2.exports = ObjectId2;
  }
});

// node_modules/mongoose/lib/helpers/specialProperties.js
var require_specialProperties = __commonJS({
  "node_modules/mongoose/lib/helpers/specialProperties.js"(exports2, module2) {
    "use strict";
    module2.exports = new Set(["__proto__", "constructor", "prototype"]);
  }
});

// node_modules/mongoose/lib/helpers/isMongooseObject.js
var require_isMongooseObject = __commonJS({
  "node_modules/mongoose/lib/helpers/isMongooseObject.js"(exports2, module2) {
    "use strict";
    module2.exports = function(v) {
      if (v == null) {
        return false;
      }
      return v.$__ != null || v.isMongooseArray || v.isMongooseBuffer || v.$isMongooseMap;
    };
  }
});

// node_modules/mongoose/lib/helpers/getFunctionName.js
var require_getFunctionName = __commonJS({
  "node_modules/mongoose/lib/helpers/getFunctionName.js"(exports2, module2) {
    "use strict";
    module2.exports = function(fn) {
      if (fn.name) {
        return fn.name;
      }
      return (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
    };
  }
});

// node_modules/mongoose/lib/helpers/isBsonType.js
var require_isBsonType = __commonJS({
  "node_modules/mongoose/lib/helpers/isBsonType.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    function isBsonType(obj, typename) {
      return get(obj, "_bsontype", void 0) === typename;
    }
    module2.exports = isBsonType;
  }
});

// node_modules/mongoose/lib/helpers/isObject.js
var require_isObject = __commonJS({
  "node_modules/mongoose/lib/helpers/isObject.js"(exports2, module2) {
    "use strict";
    module2.exports = function(arg) {
      if (Buffer.isBuffer(arg)) {
        return true;
      }
      return Object.prototype.toString.call(arg) === "[object Object]";
    };
  }
});

// node_modules/mongoose/node_modules/ms/index.js
var require_ms7 = __commonJS({
  "node_modules/mongoose/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/mpath/lib/stringToParts.js
var require_stringToParts = __commonJS({
  "node_modules/mpath/lib/stringToParts.js"(exports2, module2) {
    "use strict";
    module2.exports = function stringToParts(str) {
      const result = [];
      let curPropertyName = "";
      let state = "DEFAULT";
      for (let i = 0; i < str.length; ++i) {
        if (state === "IN_SQUARE_BRACKETS" && !/\d/.test(str[i]) && str[i] !== "]") {
          state = "DEFAULT";
          curPropertyName = result[result.length - 1] + "[" + curPropertyName;
          result.splice(result.length - 1, 1);
        }
        if (str[i] === "[") {
          if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
            result.push(curPropertyName);
            curPropertyName = "";
          }
          state = "IN_SQUARE_BRACKETS";
        } else if (str[i] === "]") {
          if (state === "IN_SQUARE_BRACKETS") {
            state = "IMMEDIATELY_AFTER_SQUARE_BRACKETS";
            result.push(curPropertyName);
            curPropertyName = "";
          } else {
            state = "DEFAULT";
            curPropertyName += str[i];
          }
        } else if (str[i] === ".") {
          if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
            result.push(curPropertyName);
            curPropertyName = "";
          }
          state = "DEFAULT";
        } else {
          curPropertyName += str[i];
        }
      }
      if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
        result.push(curPropertyName);
      }
      return result;
    };
  }
});

// node_modules/mpath/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/mpath/lib/index.js"(exports2) {
    var stringToParts = require_stringToParts();
    var ignoreProperties = ["__proto__", "constructor", "prototype"];
    exports2.get = function(path, o, special, map) {
      var lookup;
      if (typeof special == "function") {
        if (special.length < 2) {
          map = special;
          special = void 0;
        } else {
          lookup = special;
          special = void 0;
        }
      }
      map || (map = K);
      var parts = typeof path == "string" ? stringToParts(path) : path;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      var obj = o, part;
      for (var i = 0; i < parts.length; ++i) {
        part = parts[i];
        if (Array.isArray(obj) && !/^\d+$/.test(part)) {
          var paths = parts.slice(i);
          return [].concat(obj).map(function(item) {
            return item ? exports2.get(paths, item, special || lookup, map) : map(void 0);
          });
        }
        if (lookup) {
          obj = lookup(obj, part);
        } else {
          var _from = special && obj[special] ? obj[special] : obj;
          obj = _from instanceof Map ? _from.get(part) : _from[part];
        }
        if (!obj)
          return map(obj);
      }
      return map(obj);
    };
    exports2.has = function(path, o) {
      var parts = typeof path === "string" ? stringToParts(path) : path;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      var len = parts.length;
      var cur = o;
      for (var i = 0; i < len; ++i) {
        if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
          return false;
        }
        cur = cur[parts[i]];
      }
      return true;
    };
    exports2.unset = function(path, o) {
      var parts = typeof path === "string" ? stringToParts(path) : path;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      var len = parts.length;
      var cur = o;
      for (var i = 0; i < len; ++i) {
        if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
          return false;
        }
        if (ignoreProperties.indexOf(parts[i]) !== -1) {
          return false;
        }
        if (i === len - 1) {
          delete cur[parts[i]];
          return true;
        }
        cur = cur instanceof Map ? cur.get(parts[i]) : cur[parts[i]];
      }
      return true;
    };
    exports2.set = function(path, val, o, special, map, _copying) {
      var lookup;
      if (typeof special == "function") {
        if (special.length < 2) {
          map = special;
          special = void 0;
        } else {
          lookup = special;
          special = void 0;
        }
      }
      map || (map = K);
      var parts = typeof path == "string" ? stringToParts(path) : path;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      if (o == null)
        return;
      for (var i = 0; i < parts.length; ++i) {
        if (ignoreProperties.indexOf(parts[i]) !== -1) {
          return;
        }
      }
      var copy = _copying || /\$/.test(path) && _copying !== false, obj = o, part;
      for (var i = 0, len = parts.length - 1; i < len; ++i) {
        part = parts[i];
        if (part == "$") {
          if (i == len - 1) {
            break;
          } else {
            continue;
          }
        }
        if (Array.isArray(obj) && !/^\d+$/.test(part)) {
          var paths = parts.slice(i);
          if (!copy && Array.isArray(val)) {
            for (var j = 0; j < obj.length && j < val.length; ++j) {
              exports2.set(paths, val[j], obj[j], special || lookup, map, copy);
            }
          } else {
            for (var j = 0; j < obj.length; ++j) {
              exports2.set(paths, val, obj[j], special || lookup, map, copy);
            }
          }
          return;
        }
        if (lookup) {
          obj = lookup(obj, part);
        } else {
          var _to = special && obj[special] ? obj[special] : obj;
          obj = _to instanceof Map ? _to.get(part) : _to[part];
        }
        if (!obj)
          return;
      }
      part = parts[len];
      if (special && obj[special]) {
        obj = obj[special];
      }
      if (Array.isArray(obj) && !/^\d+$/.test(part)) {
        if (!copy && Array.isArray(val)) {
          _setArray(obj, val, part, lookup, special, map);
        } else {
          for (var j = 0; j < obj.length; ++j) {
            var item = obj[j];
            if (item) {
              if (lookup) {
                lookup(item, part, map(val));
              } else {
                if (item[special])
                  item = item[special];
                item[part] = map(val);
              }
            }
          }
        }
      } else {
        if (lookup) {
          lookup(obj, part, map(val));
        } else if (obj instanceof Map) {
          obj.set(part, map(val));
        } else {
          obj[part] = map(val);
        }
      }
    };
    function _setArray(obj, val, part, lookup, special, map) {
      for (var item, j = 0; j < obj.length && j < val.length; ++j) {
        item = obj[j];
        if (Array.isArray(item) && Array.isArray(val[j])) {
          _setArray(item, val[j], part, lookup, special, map);
        } else if (item) {
          if (lookup) {
            lookup(item, part, map(val[j]));
          } else {
            if (item[special])
              item = item[special];
            item[part] = map(val[j]);
          }
        }
      }
    }
    function K(v) {
      return v;
    }
  }
});

// node_modules/mpath/index.js
var require_mpath = __commonJS({
  "node_modules/mpath/index.js"(exports2, module2) {
    "use strict";
    module2.exports = exports2 = require_lib3();
  }
});

// node_modules/mongoose/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "node_modules/mongoose/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/mongoose/lib/options/PopulateOptions.js
var require_PopulateOptions = __commonJS({
  "node_modules/mongoose/lib/options/PopulateOptions.js"(exports2, module2) {
    "use strict";
    var clone = require_clone();
    var PopulateOptions = class {
      constructor(obj) {
        this._docs = {};
        this._childDocs = [];
        if (obj == null) {
          return;
        }
        obj = clone(obj);
        Object.assign(this, obj);
        if (typeof obj.subPopulate === "object") {
          this.populate = obj.subPopulate;
        }
        if (obj.perDocumentLimit != null && obj.limit != null) {
          throw new Error("Can not use `limit` and `perDocumentLimit` at the same time. Path: `" + obj.path + "`.");
        }
      }
    };
    module2.exports = PopulateOptions;
  }
});

// node_modules/mquery/lib/utils.js
var require_utils7 = __commonJS({
  "node_modules/mquery/lib/utils.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var RegExpClone = require_regexp_clone();
    var specialProperties = ["__proto__", "constructor", "prototype"];
    var clone = exports2.clone = function clone2(obj, options) {
      if (obj === void 0 || obj === null)
        return obj;
      if (Array.isArray(obj))
        return exports2.cloneArray(obj, options);
      if (obj.constructor) {
        if (/ObjectI[dD]$/.test(obj.constructor.name)) {
          return typeof obj.clone == "function" ? obj.clone() : new obj.constructor(obj.id);
        }
        if (obj.constructor.name === "ReadPreference") {
          return new obj.constructor(obj.mode, clone2(obj.tags, options));
        }
        if (obj._bsontype == "Binary" && obj.buffer && obj.value) {
          return typeof obj.clone == "function" ? obj.clone() : new obj.constructor(obj.value(true), obj.sub_type);
        }
        if (obj.constructor.name === "Date" || obj.constructor.name === "Function")
          return new obj.constructor(+obj);
        if (obj.constructor.name === "RegExp")
          return RegExpClone(obj);
        if (obj.constructor.name === "Buffer")
          return exports2.cloneBuffer(obj);
      }
      if (isObject2(obj))
        return exports2.cloneObject(obj, options);
      if (obj.valueOf)
        return obj.valueOf();
    };
    exports2.cloneObject = function cloneObject(obj, options) {
      var minimize = options && options.minimize;
      var ret2 = {};
      var hasKeys;
      var val;
      for (const k of Object.keys(obj)) {
        if (specialProperties.indexOf(k) !== -1) {
          continue;
        }
        val = clone(obj[k], options);
        if (!minimize || typeof val !== "undefined") {
          hasKeys || (hasKeys = true);
          ret2[k] = val;
        }
      }
      return minimize ? hasKeys && ret2 : ret2;
    };
    exports2.cloneArray = function cloneArray(arr, options) {
      var ret2 = [];
      for (var i = 0, l = arr.length; i < l; i++)
        ret2.push(clone(arr[i], options));
      return ret2;
    };
    exports2.tick = function tick(callback) {
      if (typeof callback !== "function")
        return;
      return function() {
        var args = arguments;
        soon(function() {
          callback.apply(this, args);
        });
      };
    };
    exports2.merge = function merge(to, from) {
      var keys = Object.keys(from), i = keys.length, key;
      while (i--) {
        key = keys[i];
        if (specialProperties.indexOf(key) !== -1) {
          continue;
        }
        if (typeof to[key] === "undefined") {
          to[key] = from[key];
        } else {
          if (exports2.isObject(from[key])) {
            merge(to[key], from[key]);
          } else {
            to[key] = from[key];
          }
        }
      }
    };
    exports2.mergeClone = function mergeClone(to, from) {
      var keys = Object.keys(from), i = keys.length, key;
      while (i--) {
        key = keys[i];
        if (specialProperties.indexOf(key) !== -1) {
          continue;
        }
        if (typeof to[key] === "undefined") {
          to[key] = clone(from[key]);
        } else {
          if (exports2.isObject(from[key])) {
            mergeClone(to[key], from[key]);
          } else {
            to[key] = clone(from[key]);
          }
        }
      }
    };
    exports2.readPref = function readPref(pref) {
      switch (pref) {
        case "p":
          pref = "primary";
          break;
        case "pp":
          pref = "primaryPreferred";
          break;
        case "s":
          pref = "secondary";
          break;
        case "sp":
          pref = "secondaryPreferred";
          break;
        case "n":
          pref = "nearest";
          break;
      }
      return pref;
    };
    exports2.readConcern = function readConcern(concern) {
      if (typeof concern === "string") {
        switch (concern) {
          case "l":
            concern = "local";
            break;
          case "a":
            concern = "available";
            break;
          case "m":
            concern = "majority";
            break;
          case "lz":
            concern = "linearizable";
            break;
          case "s":
            concern = "snapshot";
            break;
        }
        concern = { level: concern };
      }
      return concern;
    };
    var _toString = Object.prototype.toString;
    exports2.toString = function(arg) {
      return _toString.call(arg);
    };
    var isObject2 = exports2.isObject = function(arg) {
      return exports2.toString(arg) == "[object Object]";
    };
    exports2.isArray = function(arg) {
      return Array.isArray(arg) || typeof arg == "object" && exports2.toString(arg) == "[object Array]";
    };
    exports2.keys = Object.keys;
    exports2.create = typeof Object.create == "function" ? Object.create : create;
    function create(proto) {
      if (arguments.length > 1) {
        throw new Error("Adding properties is not supported");
      }
      function F() {
      }
      F.prototype = proto;
      return new F();
    }
    exports2.inherits = function(ctor, superCtor) {
      ctor.prototype = exports2.create(superCtor.prototype);
      ctor.prototype.constructor = ctor;
    };
    var soon = exports2.soon = typeof setImmediate == "function" ? setImmediate : process.nextTick;
    exports2.cloneBuffer = function(buff) {
      var dupe = Buffer2.alloc(buff.length);
      buff.copy(dupe, 0, 0, buff.length);
      return dupe;
    };
    exports2.isArgumentsObject = function(v) {
      return Object.prototype.toString.call(v) === "[object Arguments]";
    };
  }
});

// node_modules/mquery/node_modules/ms/index.js
var require_ms8 = __commonJS({
  "node_modules/mquery/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/mquery/node_modules/debug/src/debug.js
var require_debug5 = __commonJS({
  "node_modules/mquery/node_modules/debug/src/debug.js"(exports2, module2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms8();
    exports2.instances = [];
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      var prevTime;
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if (typeof formatter === "function") {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;
      if (typeof exports2.init === "function") {
        exports2.init(debug);
      }
      exports2.instances.push(debug);
      return debug;
    }
    function destroy() {
      var index = exports2.instances.indexOf(this);
      if (index !== -1) {
        exports2.instances.splice(index, 1);
        return true;
      } else {
        return false;
      }
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var i;
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
      for (i = 0; i < exports2.instances.length; i++) {
        var instance = exports2.instances[i];
        instance.enabled = exports2.enabled(instance.namespace);
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/mquery/node_modules/debug/src/browser.js
var require_browser5 = __commonJS({
  "node_modules/mquery/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2 = module2.exports = require_debug5();
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log2() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env: env2 } = process;
    var flagForceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      flagForceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      flagForceColor = 1;
    }
    function envForceColor() {
      if ("FORCE_COLOR" in env2) {
        if (env2.FORCE_COLOR === "true") {
          return 1;
        }
        if (env2.FORCE_COLOR === "false") {
          return 0;
        }
        return env2.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
      const noFlagForceColor = envForceColor();
      if (noFlagForceColor !== void 0) {
        flagForceColor = noFlagForceColor;
      }
      const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
      if (forceColor === 0) {
        return 0;
      }
      if (sniffFlags) {
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = Number.parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream, options = {}) {
      const level = supportsColor(stream, __spreadValues({
        streamIsTTY: stream && stream.isTTY
      }, options));
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
      stderr: getSupportLevel({ isTTY: tty.isatty(2) })
    };
  }
});

// node_modules/mquery/node_modules/debug/src/node.js
var require_node6 = __commonJS({
  "node_modules/mquery/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2 = module2.exports = require_debug5();
    exports2.init = init;
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      supportsColor = require_supports_color();
      if (supportsColor && supportsColor.level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (err) {
    }
    var supportsColor;
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        var prefix = "  " + colorCode + ";1m" + name + " [0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + exports2.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      } else {
        return new Date().toISOString() + " ";
      }
    }
    function log2() {
      return process.stderr.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (namespaces == null) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    exports2.enable(load());
  }
});

// node_modules/mquery/node_modules/debug/src/index.js
var require_src5 = __commonJS({
  "node_modules/mquery/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer") {
      module2.exports = require_browser5();
    } else {
      module2.exports = require_node6();
    }
  }
});

// node_modules/mquery/lib/permissions.js
var require_permissions = __commonJS({
  "node_modules/mquery/lib/permissions.js"(exports2) {
    "use strict";
    var denied = exports2;
    denied.distinct = function(self2) {
      if (self2._fields && Object.keys(self2._fields).length > 0) {
        return "field selection and slice";
      }
      var keys = Object.keys(denied.distinct);
      var err;
      keys.every(function(option) {
        if (self2.options[option]) {
          err = option;
          return false;
        }
        return true;
      });
      return err;
    };
    denied.distinct.select = denied.distinct.slice = denied.distinct.sort = denied.distinct.limit = denied.distinct.skip = denied.distinct.batchSize = denied.distinct.comment = denied.distinct.maxScan = denied.distinct.snapshot = denied.distinct.hint = denied.distinct.tailable = true;
    denied.findOneAndUpdate = denied.findOneAndRemove = function(self2) {
      var keys = Object.keys(denied.findOneAndUpdate);
      var err;
      keys.every(function(option) {
        if (self2.options[option]) {
          err = option;
          return false;
        }
        return true;
      });
      return err;
    };
    denied.findOneAndUpdate.limit = denied.findOneAndUpdate.skip = denied.findOneAndUpdate.batchSize = denied.findOneAndUpdate.maxScan = denied.findOneAndUpdate.snapshot = denied.findOneAndUpdate.hint = denied.findOneAndUpdate.tailable = denied.findOneAndUpdate.comment = true;
    denied.count = function(self2) {
      if (self2._fields && Object.keys(self2._fields).length > 0) {
        return "field selection and slice";
      }
      var keys = Object.keys(denied.count);
      var err;
      keys.every(function(option) {
        if (self2.options[option]) {
          err = option;
          return false;
        }
        return true;
      });
      return err;
    };
    denied.count.slice = denied.count.batchSize = denied.count.comment = denied.count.maxScan = denied.count.snapshot = denied.count.tailable = true;
  }
});

// node_modules/mquery/lib/env.js
var require_env = __commonJS({
  "node_modules/mquery/lib/env.js"(exports2, module2) {
    "use strict";
    exports2.isNode = typeof process != "undefined" && typeof module2 == "object" && typeof global == "object" && typeof Buffer == "function" && process.argv;
    exports2.isMongo = !exports2.isNode && typeof printjson == "function" && typeof ObjectId == "function" && typeof rs == "function" && typeof sh == "function";
    exports2.isBrowser = !exports2.isNode && !exports2.isMongo && typeof window != "undefined";
    exports2.type = exports2.isNode ? "node" : exports2.isMongo ? "mongo" : exports2.isBrowser ? "browser" : "unknown";
  }
});

// node_modules/mquery/lib/collection/collection.js
var require_collection3 = __commonJS({
  "node_modules/mquery/lib/collection/collection.js"(exports2, module2) {
    "use strict";
    var methods = [
      "find",
      "findOne",
      "update",
      "updateMany",
      "updateOne",
      "replaceOne",
      "remove",
      "count",
      "distinct",
      "findAndModify",
      "aggregate",
      "findStream",
      "deleteOne",
      "deleteMany"
    ];
    function Collection() {
    }
    for (var i = 0, len = methods.length; i < len; ++i) {
      method = methods[i];
      Collection.prototype[method] = notImplemented(method);
    }
    var method;
    module2.exports = exports2 = Collection;
    Collection.methods = methods;
    function notImplemented(method2) {
      return function() {
        throw new Error("collection." + method2 + " not implemented");
      };
    }
  }
});

// node_modules/mquery/lib/collection/node.js
var require_node7 = __commonJS({
  "node_modules/mquery/lib/collection/node.js"(exports2, module2) {
    "use strict";
    var Collection = require_collection3();
    var utils2 = require_utils7();
    function NodeCollection(col) {
      this.collection = col;
      this.collectionName = col.collectionName;
    }
    utils2.inherits(NodeCollection, Collection);
    NodeCollection.prototype.find = function(match, options, cb) {
      this.collection.find(match, options, function(err, cursor) {
        if (err)
          return cb(err);
        try {
          cursor.toArray(cb);
        } catch (error) {
          cb(error);
        }
      });
    };
    NodeCollection.prototype.findOne = function(match, options, cb) {
      this.collection.findOne(match, options, cb);
    };
    NodeCollection.prototype.count = function(match, options, cb) {
      this.collection.count(match, options, cb);
    };
    NodeCollection.prototype.distinct = function(prop, match, options, cb) {
      this.collection.distinct(prop, match, options, cb);
    };
    NodeCollection.prototype.update = function(match, update, options, cb) {
      this.collection.update(match, update, options, cb);
    };
    NodeCollection.prototype.updateMany = function(match, update, options, cb) {
      this.collection.updateMany(match, update, options, cb);
    };
    NodeCollection.prototype.updateOne = function(match, update, options, cb) {
      this.collection.updateOne(match, update, options, cb);
    };
    NodeCollection.prototype.replaceOne = function(match, update, options, cb) {
      this.collection.replaceOne(match, update, options, cb);
    };
    NodeCollection.prototype.deleteOne = function(match, options, cb) {
      this.collection.deleteOne(match, options, cb);
    };
    NodeCollection.prototype.deleteMany = function(match, options, cb) {
      this.collection.deleteMany(match, options, cb);
    };
    NodeCollection.prototype.remove = function(match, options, cb) {
      this.collection.remove(match, options, cb);
    };
    NodeCollection.prototype.findAndModify = function(match, update, options, cb) {
      var sort = Array.isArray(options.sort) ? options.sort : [];
      this.collection.findAndModify(match, sort, update, options, cb);
    };
    NodeCollection.prototype.findStream = function(match, findOptions, streamOptions) {
      return this.collection.find(match, findOptions).stream(streamOptions);
    };
    NodeCollection.prototype.findCursor = function(match, findOptions) {
      return this.collection.find(match, findOptions);
    };
    module2.exports = exports2 = NodeCollection;
  }
});

// node_modules/mquery/lib/collection/index.js
var require_collection4 = __commonJS({
  "node_modules/mquery/lib/collection/index.js"(exports2, module2) {
    "use strict";
    var env2 = require_env();
    if (env2.type == "unknown") {
      throw new Error("Unknown environment");
    }
    module2.exports = env2.isNode ? require_node7() : env2.isMongo ? require_collection3() : require_collection3();
  }
});

// node_modules/bluebird/js/release/es5.js
var require_es5 = __commonJS({
  "node_modules/bluebird/js/release/es5.js"(exports2, module2) {
    var isES5 = function() {
      "use strict";
      return this === void 0;
    }();
    if (isES5) {
      module2.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5,
        propertyIsWritable: function(obj, prop) {
          var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
          return !!(!descriptor || descriptor.writable || descriptor.set);
        }
      };
    } else {
      has = {}.hasOwnProperty;
      str = {}.toString;
      proto = {}.constructor.prototype;
      ObjectKeys = function(o) {
        var ret2 = [];
        for (var key in o) {
          if (has.call(o, key)) {
            ret2.push(key);
          }
        }
        return ret2;
      };
      ObjectGetDescriptor = function(o, key) {
        return { value: o[key] };
      };
      ObjectDefineProperty = function(o, key, desc) {
        o[key] = desc.value;
        return o;
      };
      ObjectFreeze = function(obj) {
        return obj;
      };
      ObjectGetPrototypeOf = function(obj) {
        try {
          return Object(obj).constructor.prototype;
        } catch (e) {
          return proto;
        }
      };
      ArrayIsArray = function(obj) {
        try {
          return str.call(obj) === "[object Array]";
        } catch (e) {
          return false;
        }
      };
      module2.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5,
        propertyIsWritable: function() {
          return true;
        }
      };
    }
    var has;
    var str;
    var proto;
    var ObjectKeys;
    var ObjectGetDescriptor;
    var ObjectDefineProperty;
    var ObjectFreeze;
    var ObjectGetPrototypeOf;
    var ArrayIsArray;
  }
});

// node_modules/bluebird/js/release/util.js
var require_util2 = __commonJS({
  "node_modules/bluebird/js/release/util.js"(exports, module) {
    "use strict";
    var es5 = require_es5();
    var canEvaluate = typeof navigator == "undefined";
    var errorObj = { e: {} };
    var tryCatchTarget;
    var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports !== void 0 ? exports : null;
    function tryCatcher() {
      try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      tryCatchTarget = fn;
      return tryCatcher;
    }
    var inherits = function(Child, Parent) {
      var hasProp = {}.hasOwnProperty;
      function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
          if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
            this[propertyName + "$"] = Parent.prototype[propertyName];
          }
        }
      }
      T.prototype = Parent.prototype;
      Child.prototype = new T();
      return Child.prototype;
    };
    function isPrimitive(val) {
      return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
    }
    function isObject(value) {
      return typeof value === "function" || typeof value === "object" && value !== null;
    }
    function maybeWrapAsError(maybeError) {
      if (!isPrimitive(maybeError))
        return maybeError;
      return new Error(safeToString(maybeError));
    }
    function withAppended(target, appendee) {
      var len = target.length;
      var ret2 = new Array(len + 1);
      var i;
      for (i = 0; i < len; ++i) {
        ret2[i] = target[i];
      }
      ret2[i] = appendee;
      return ret2;
    }
    function getDataPropertyOrDefault(obj, key, defaultValue) {
      if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc != null) {
          return desc.get == null && desc.set == null ? desc.value : defaultValue;
        }
      } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : void 0;
      }
    }
    function notEnumerableProp(obj, name, value) {
      if (isPrimitive(obj))
        return obj;
      var descriptor = {
        value,
        configurable: true,
        enumerable: false,
        writable: true
      };
      es5.defineProperty(obj, name, descriptor);
      return obj;
    }
    function thrower(r) {
      throw r;
    }
    var inheritedDataKeys = function() {
      var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
      ];
      var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
          if (excludedPrototypes[i] === val) {
            return true;
          }
        }
        return false;
      };
      if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj) {
          var ret2 = [];
          var visitedKeys = Object.create(null);
          while (obj != null && !isExcludedProto(obj)) {
            var keys;
            try {
              keys = getKeys(obj);
            } catch (e) {
              return ret2;
            }
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (visitedKeys[key])
                continue;
              visitedKeys[key] = true;
              var desc = Object.getOwnPropertyDescriptor(obj, key);
              if (desc != null && desc.get == null && desc.set == null) {
                ret2.push(key);
              }
            }
            obj = es5.getPrototypeOf(obj);
          }
          return ret2;
        };
      } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj) {
          if (isExcludedProto(obj))
            return [];
          var ret2 = [];
          enumeration:
            for (var key in obj) {
              if (hasProp.call(obj, key)) {
                ret2.push(key);
              } else {
                for (var i = 0; i < excludedPrototypes.length; ++i) {
                  if (hasProp.call(excludedPrototypes[i], key)) {
                    continue enumeration;
                  }
                }
                ret2.push(key);
              }
            }
          return ret2;
        };
      }
    }();
    var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
    function isClass(fn) {
      try {
        if (typeof fn === "function") {
          var keys = es5.names(fn.prototype);
          var hasMethods = es5.isES5 && keys.length > 1;
          var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
          var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
          if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
            return true;
          }
        }
        return false;
      } catch (e) {
        return false;
      }
    }
    function toFastProperties(obj) {
      function FakeConstructor() {
      }
      FakeConstructor.prototype = obj;
      var l = 8;
      while (l--)
        new FakeConstructor();
      return obj;
      eval(obj);
    }
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
      return rident.test(str);
    }
    function filledRange(count, prefix, suffix) {
      var ret2 = new Array(count);
      for (var i = 0; i < count; ++i) {
        ret2[i] = prefix + i + suffix;
      }
      return ret2;
    }
    function safeToString(obj) {
      try {
        return obj + "";
      } catch (e) {
        return "[no string representation]";
      }
    }
    function isError(obj) {
      return obj instanceof Error || obj !== null && typeof obj === "object" && typeof obj.message === "string" && typeof obj.name === "string";
    }
    function markAsOriginatingFromRejection(e) {
      try {
        notEnumerableProp(e, "isOperational", true);
      } catch (ignore) {
      }
    }
    function originatesFromRejection(e) {
      if (e == null)
        return false;
      return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
    }
    function canAttachTrace(obj) {
      return isError(obj) && es5.propertyIsWritable(obj, "stack");
    }
    var ensureErrorObject = function() {
      if (!("stack" in new Error())) {
        return function(value) {
          if (canAttachTrace(value))
            return value;
          try {
            throw new Error(safeToString(value));
          } catch (err) {
            return err;
          }
        };
      } else {
        return function(value) {
          if (canAttachTrace(value))
            return value;
          return new Error(safeToString(value));
        };
      }
    }();
    function classString(obj) {
      return {}.toString.call(obj);
    }
    function copyDescriptors(from, to, filter) {
      var keys = es5.names(from);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
          try {
            es5.defineProperty(to, key, es5.getDescriptor(from, key));
          } catch (ignore) {
          }
        }
      }
    }
    var asArray = function(v) {
      if (es5.isArray(v)) {
        return v;
      }
      return null;
    };
    if (typeof Symbol !== "undefined" && Symbol.iterator) {
      ArrayFrom = typeof Array.from === "function" ? function(v) {
        return Array.from(v);
      } : function(v) {
        var ret2 = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!(itResult = it.next()).done) {
          ret2.push(itResult.value);
        }
        return ret2;
      };
      asArray = function(v) {
        if (es5.isArray(v)) {
          return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
          return ArrayFrom(v);
        }
        return null;
      };
    }
    var ArrayFrom;
    var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
    var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
    function env(key) {
      return hasEnvVariables ? process.env[key] : void 0;
    }
    function getNativePromise() {
      if (typeof Promise === "function") {
        try {
          var promise = new Promise(function() {
          });
          if ({}.toString.call(promise) === "[object Promise]") {
            return Promise;
          }
        } catch (e) {
        }
      }
    }
    function domainBind(self2, cb) {
      return self2.bind(cb);
    }
    var ret = {
      isClass,
      isIdentifier,
      inheritedDataKeys,
      getDataPropertyOrDefault,
      thrower,
      isArray: es5.isArray,
      asArray,
      notEnumerableProp,
      isPrimitive,
      isObject,
      isError,
      canEvaluate,
      errorObj,
      tryCatch,
      inherits,
      withAppended,
      maybeWrapAsError,
      toFastProperties,
      filledRange,
      toString: safeToString,
      canAttachTrace,
      ensureErrorObject,
      originatesFromRejection,
      markAsOriginatingFromRejection,
      classString,
      copyDescriptors,
      hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
      isNode,
      hasEnvVariables,
      env,
      global: globalObject,
      getNativePromise,
      domainBind
    };
    ret.isRecentNode = ret.isNode && function() {
      var version = process.versions.node.split(".").map(Number);
      return version[0] === 0 && version[1] > 10 || version[0] > 0;
    }();
    if (ret.isNode)
      ret.toFastProperties(process);
    try {
      throw new Error();
    } catch (e) {
      ret.lastLineError = e;
    }
    module.exports = ret;
  }
});

// node_modules/bluebird/js/release/schedule.js
var require_schedule = __commonJS({
  "node_modules/bluebird/js/release/schedule.js"(exports2, module2) {
    "use strict";
    var util = require_util2();
    var schedule;
    var noAsyncScheduler = function() {
      throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    };
    var NativePromise = util.getNativePromise();
    if (util.isNode && typeof MutationObserver === "undefined") {
      GlobalSetImmediate = global.setImmediate;
      ProcessNextTick = process.nextTick;
      schedule = util.isRecentNode ? function(fn) {
        GlobalSetImmediate.call(global, fn);
      } : function(fn) {
        ProcessNextTick.call(process, fn);
      };
    } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
      nativePromise = NativePromise.resolve();
      schedule = function(fn) {
        nativePromise.then(fn);
      };
    } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
      schedule = function() {
        var div = document.createElement("div");
        var opts = { attributes: true };
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function() {
          div.classList.toggle("foo");
          toggleScheduled = false;
        });
        o2.observe(div2, opts);
        var scheduleToggle = function() {
          if (toggleScheduled)
            return;
          toggleScheduled = true;
          div2.classList.toggle("foo");
        };
        return function schedule2(fn) {
          var o = new MutationObserver(function() {
            o.disconnect();
            fn();
          });
          o.observe(div, opts);
          scheduleToggle();
        };
      }();
    } else if (typeof setImmediate !== "undefined") {
      schedule = function(fn) {
        setImmediate(fn);
      };
    } else if (typeof setTimeout !== "undefined") {
      schedule = function(fn) {
        setTimeout(fn, 0);
      };
    } else {
      schedule = noAsyncScheduler;
    }
    var GlobalSetImmediate;
    var ProcessNextTick;
    var nativePromise;
    module2.exports = schedule;
  }
});

// node_modules/bluebird/js/release/queue.js
var require_queue = __commonJS({
  "node_modules/bluebird/js/release/queue.js"(exports2, module2) {
    "use strict";
    function arrayMove(src, srcIndex, dst, dstIndex, len) {
      for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
      }
    }
    function Queue(capacity) {
      this._capacity = capacity;
      this._length = 0;
      this._front = 0;
    }
    Queue.prototype._willBeOverCapacity = function(size) {
      return this._capacity < size;
    };
    Queue.prototype._pushOne = function(arg) {
      var length = this.length();
      this._checkCapacity(length + 1);
      var i = this._front + length & this._capacity - 1;
      this[i] = arg;
      this._length = length + 1;
    };
    Queue.prototype.push = function(fn, receiver, arg) {
      var length = this.length() + 3;
      if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
      }
      var j = this._front + length - 3;
      this._checkCapacity(length);
      var wrapMask = this._capacity - 1;
      this[j + 0 & wrapMask] = fn;
      this[j + 1 & wrapMask] = receiver;
      this[j + 2 & wrapMask] = arg;
      this._length = length;
    };
    Queue.prototype.shift = function() {
      var front = this._front, ret2 = this[front];
      this[front] = void 0;
      this._front = front + 1 & this._capacity - 1;
      this._length--;
      return ret2;
    };
    Queue.prototype.length = function() {
      return this._length;
    };
    Queue.prototype._checkCapacity = function(size) {
      if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
      }
    };
    Queue.prototype._resizeTo = function(capacity) {
      var oldCapacity = this._capacity;
      this._capacity = capacity;
      var front = this._front;
      var length = this._length;
      var moveItemsCount = front + length & oldCapacity - 1;
      arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    };
    module2.exports = Queue;
  }
});

// node_modules/bluebird/js/release/async.js
var require_async = __commonJS({
  "node_modules/bluebird/js/release/async.js"(exports2, module2) {
    "use strict";
    var firstLineError;
    try {
      throw new Error();
    } catch (e) {
      firstLineError = e;
    }
    var schedule = require_schedule();
    var Queue = require_queue();
    var util = require_util2();
    function Async() {
      this._customScheduler = false;
      this._isTickUsed = false;
      this._lateQueue = new Queue(16);
      this._normalQueue = new Queue(16);
      this._haveDrainedQueues = false;
      this._trampolineEnabled = true;
      var self2 = this;
      this.drainQueues = function() {
        self2._drainQueues();
      };
      this._schedule = schedule;
    }
    Async.prototype.setScheduler = function(fn) {
      var prev = this._schedule;
      this._schedule = fn;
      this._customScheduler = true;
      return prev;
    };
    Async.prototype.hasCustomScheduler = function() {
      return this._customScheduler;
    };
    Async.prototype.enableTrampoline = function() {
      this._trampolineEnabled = true;
    };
    Async.prototype.disableTrampolineIfNecessary = function() {
      if (util.hasDevTools) {
        this._trampolineEnabled = false;
      }
    };
    Async.prototype.haveItemsQueued = function() {
      return this._isTickUsed || this._haveDrainedQueues;
    };
    Async.prototype.fatalError = function(e, isNode2) {
      if (isNode2) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
        process.exit(2);
      } else {
        this.throwLater(e);
      }
    };
    Async.prototype.throwLater = function(fn, arg) {
      if (arguments.length === 1) {
        arg = fn;
        fn = function() {
          throw arg;
        };
      }
      if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
          fn(arg);
        }, 0);
      } else
        try {
          this._schedule(function() {
            fn(arg);
          });
        } catch (e) {
          throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
        }
    };
    function AsyncInvokeLater(fn, receiver, arg) {
      this._lateQueue.push(fn, receiver, arg);
      this._queueTick();
    }
    function AsyncInvoke(fn, receiver, arg) {
      this._normalQueue.push(fn, receiver, arg);
      this._queueTick();
    }
    function AsyncSettlePromises(promise) {
      this._normalQueue._pushOne(promise);
      this._queueTick();
    }
    if (!util.hasDevTools) {
      Async.prototype.invokeLater = AsyncInvokeLater;
      Async.prototype.invoke = AsyncInvoke;
      Async.prototype.settlePromises = AsyncSettlePromises;
    } else {
      Async.prototype.invokeLater = function(fn, receiver, arg) {
        if (this._trampolineEnabled) {
          AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
          this._schedule(function() {
            setTimeout(function() {
              fn.call(receiver, arg);
            }, 100);
          });
        }
      };
      Async.prototype.invoke = function(fn, receiver, arg) {
        if (this._trampolineEnabled) {
          AsyncInvoke.call(this, fn, receiver, arg);
        } else {
          this._schedule(function() {
            fn.call(receiver, arg);
          });
        }
      };
      Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
          AsyncSettlePromises.call(this, promise);
        } else {
          this._schedule(function() {
            promise._settlePromises();
          });
        }
      };
    }
    Async.prototype._drainQueue = function(queue) {
      while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
          fn._settlePromises();
          continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
      }
    };
    Async.prototype._drainQueues = function() {
      this._drainQueue(this._normalQueue);
      this._reset();
      this._haveDrainedQueues = true;
      this._drainQueue(this._lateQueue);
    };
    Async.prototype._queueTick = function() {
      if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
      }
    };
    Async.prototype._reset = function() {
      this._isTickUsed = false;
    };
    module2.exports = Async;
    module2.exports.firstLineError = firstLineError;
  }
});

// node_modules/bluebird/js/release/errors.js
var require_errors2 = __commonJS({
  "node_modules/bluebird/js/release/errors.js"(exports2, module2) {
    "use strict";
    var es52 = require_es5();
    var Objectfreeze = es52.freeze;
    var util = require_util2();
    var inherits2 = util.inherits;
    var notEnumerableProp2 = util.notEnumerableProp;
    function subError(nameProperty, defaultMessage2) {
      function SubError(message) {
        if (!(this instanceof SubError))
          return new SubError(message);
        notEnumerableProp2(this, "message", typeof message === "string" ? message : defaultMessage2);
        notEnumerableProp2(this, "name", nameProperty);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          Error.call(this);
        }
      }
      inherits2(SubError, Error);
      return SubError;
    }
    var _TypeError;
    var _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
      _TypeError = TypeError;
      _RangeError = RangeError;
    } catch (e) {
      _TypeError = subError("TypeError", "type error");
      _RangeError = subError("RangeError", "range error");
    }
    var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
    for (var i = 0; i < methods.length; ++i) {
      if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
      }
    }
    es52.defineProperty(AggregateError.prototype, "length", {
      value: 0,
      configurable: false,
      writable: true,
      enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
      var indent = Array(level * 4 + 1).join(" ");
      var ret2 = "\n" + indent + "AggregateError of:\n";
      level++;
      indent = Array(level * 4 + 1).join(" ");
      for (var i2 = 0; i2 < this.length; ++i2) {
        var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
          lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret2 += str + "\n";
      }
      level--;
      return ret2;
    };
    function OperationalError(message) {
      if (!(this instanceof OperationalError))
        return new OperationalError(message);
      notEnumerableProp2(this, "name", "OperationalError");
      notEnumerableProp2(this, "message", message);
      this.cause = message;
      this["isOperational"] = true;
      if (message instanceof Error) {
        notEnumerableProp2(this, "message", message.message);
        notEnumerableProp2(this, "stack", message.stack);
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    }
    inherits2(OperationalError, Error);
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
      errorTypes = Objectfreeze({
        CancellationError,
        TimeoutError,
        OperationalError,
        RejectionError: OperationalError,
        AggregateError
      });
      es52.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      Error,
      TypeError: _TypeError,
      RangeError: _RangeError,
      CancellationError: errorTypes.CancellationError,
      OperationalError: errorTypes.OperationalError,
      TimeoutError: errorTypes.TimeoutError,
      AggregateError: errorTypes.AggregateError,
      Warning
    };
  }
});

// node_modules/bluebird/js/release/thenables.js
var require_thenables = __commonJS({
  "node_modules/bluebird/js/release/thenables.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var util = require_util2();
      var errorObj2 = util.errorObj;
      var isObject2 = util.isObject;
      function tryConvertToPromise(obj, context) {
        if (isObject2(obj)) {
          if (obj instanceof Promise2)
            return obj;
          var then = getThen(obj);
          if (then === errorObj2) {
            if (context)
              context._pushContext();
            var ret2 = Promise2.reject(then.e);
            if (context)
              context._popContext();
            return ret2;
          } else if (typeof then === "function") {
            if (isAnyBluebirdPromise(obj)) {
              var ret2 = new Promise2(INTERNAL);
              obj._then(ret2._fulfill, ret2._reject, void 0, ret2, null);
              return ret2;
            }
            return doThenable(obj, then, context);
          }
        }
        return obj;
      }
      function doGetThen(obj) {
        return obj.then;
      }
      function getThen(obj) {
        try {
          return doGetThen(obj);
        } catch (e) {
          errorObj2.e = e;
          return errorObj2;
        }
      }
      var hasProp = {}.hasOwnProperty;
      function isAnyBluebirdPromise(obj) {
        try {
          return hasProp.call(obj, "_promise0");
        } catch (e) {
          return false;
        }
      }
      function doThenable(x, then, context) {
        var promise = new Promise2(INTERNAL);
        var ret2 = promise;
        if (context)
          context._pushContext();
        promise._captureStackTrace();
        if (context)
          context._popContext();
        var synchronous = true;
        var result = util.tryCatch(then).call(x, resolve, reject);
        synchronous = false;
        if (promise && result === errorObj2) {
          promise._rejectCallback(result.e, true, true);
          promise = null;
        }
        function resolve(value) {
          if (!promise)
            return;
          promise._resolveCallback(value);
          promise = null;
        }
        function reject(reason) {
          if (!promise)
            return;
          promise._rejectCallback(reason, synchronous, true);
          promise = null;
        }
        return ret2;
      }
      return tryConvertToPromise;
    };
  }
});

// node_modules/bluebird/js/release/promise_array.js
var require_promise_array = __commonJS({
  "node_modules/bluebird/js/release/promise_array.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
      var util = require_util2();
      var isArray = util.isArray;
      function toResolutionValue(val) {
        switch (val) {
          case -2:
            return [];
          case -3:
            return {};
          case -6:
            return new Map();
        }
      }
      function PromiseArray(values) {
        var promise = this._promise = new Promise2(INTERNAL);
        if (values instanceof Promise2) {
          promise._propagateFrom(values, 3);
        }
        promise._setOnCancel(this);
        this._values = values;
        this._length = 0;
        this._totalResolved = 0;
        this._init(void 0, -2);
      }
      util.inherits(PromiseArray, Proxyable);
      PromiseArray.prototype.length = function() {
        return this._length;
      };
      PromiseArray.prototype.promise = function() {
        return this._promise;
      };
      PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
        var values = tryConvertToPromise(this._values, this._promise);
        if (values instanceof Promise2) {
          values = values._target();
          var bitField = values._bitField;
          ;
          this._values = values;
          if ((bitField & 50397184) === 0) {
            this._promise._setAsyncGuaranteed();
            return values._then(init, this._reject, void 0, this, resolveValueIfEmpty);
          } else if ((bitField & 33554432) !== 0) {
            values = values._value();
          } else if ((bitField & 16777216) !== 0) {
            return this._reject(values._reason());
          } else {
            return this._cancel();
          }
        }
        values = util.asArray(values);
        if (values === null) {
          var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();
          this._promise._rejectCallback(err, false);
          return;
        }
        if (values.length === 0) {
          if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
          } else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
          }
          return;
        }
        this._iterate(values);
      };
      PromiseArray.prototype._iterate = function(values) {
        var len = this.getActualLength(values.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var result = this._promise;
        var isResolved = false;
        var bitField = null;
        for (var i = 0; i < len; ++i) {
          var maybePromise = tryConvertToPromise(values[i], result);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
          } else {
            bitField = null;
          }
          if (isResolved) {
            if (bitField !== null) {
              maybePromise.suppressUnhandledRejections();
            }
          } else if (bitField !== null) {
            if ((bitField & 50397184) === 0) {
              maybePromise._proxy(this, i);
              this._values[i] = maybePromise;
            } else if ((bitField & 33554432) !== 0) {
              isResolved = this._promiseFulfilled(maybePromise._value(), i);
            } else if ((bitField & 16777216) !== 0) {
              isResolved = this._promiseRejected(maybePromise._reason(), i);
            } else {
              isResolved = this._promiseCancelled(i);
            }
          } else {
            isResolved = this._promiseFulfilled(maybePromise, i);
          }
        }
        if (!isResolved)
          result._setAsyncGuaranteed();
      };
      PromiseArray.prototype._isResolved = function() {
        return this._values === null;
      };
      PromiseArray.prototype._resolve = function(value) {
        this._values = null;
        this._promise._fulfill(value);
      };
      PromiseArray.prototype._cancel = function() {
        if (this._isResolved() || !this._promise._isCancellable())
          return;
        this._values = null;
        this._promise._cancel();
      };
      PromiseArray.prototype._reject = function(reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false);
      };
      PromiseArray.prototype._promiseFulfilled = function(value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      PromiseArray.prototype._promiseCancelled = function() {
        this._cancel();
        return true;
      };
      PromiseArray.prototype._promiseRejected = function(reason) {
        this._totalResolved++;
        this._reject(reason);
        return true;
      };
      PromiseArray.prototype._resultCancelled = function() {
        if (this._isResolved())
          return;
        var values = this._values;
        this._cancel();
        if (values instanceof Promise2) {
          values.cancel();
        } else {
          for (var i = 0; i < values.length; ++i) {
            if (values[i] instanceof Promise2) {
              values[i].cancel();
            }
          }
        }
      };
      PromiseArray.prototype.shouldCopyValues = function() {
        return true;
      };
      PromiseArray.prototype.getActualLength = function(len) {
        return len;
      };
      return PromiseArray;
    };
  }
});

// node_modules/bluebird/js/release/context.js
var require_context = __commonJS({
  "node_modules/bluebird/js/release/context.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      var longStackTraces = false;
      var contextStack = [];
      Promise2.prototype._promiseCreated = function() {
      };
      Promise2.prototype._pushContext = function() {
      };
      Promise2.prototype._popContext = function() {
        return null;
      };
      Promise2._peekContext = Promise2.prototype._peekContext = function() {
      };
      function Context() {
        this._trace = new Context.CapturedTrace(peekContext());
      }
      Context.prototype._pushContext = function() {
        if (this._trace !== void 0) {
          this._trace._promiseCreated = null;
          contextStack.push(this._trace);
        }
      };
      Context.prototype._popContext = function() {
        if (this._trace !== void 0) {
          var trace = contextStack.pop();
          var ret2 = trace._promiseCreated;
          trace._promiseCreated = null;
          return ret2;
        }
        return null;
      };
      function createContext() {
        if (longStackTraces)
          return new Context();
      }
      function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
          return contextStack[lastIndex];
        }
        return void 0;
      }
      Context.CapturedTrace = null;
      Context.create = createContext;
      Context.deactivateLongStackTraces = function() {
      };
      Context.activateLongStackTraces = function() {
        var Promise_pushContext = Promise2.prototype._pushContext;
        var Promise_popContext = Promise2.prototype._popContext;
        var Promise_PeekContext = Promise2._peekContext;
        var Promise_peekContext = Promise2.prototype._peekContext;
        var Promise_promiseCreated = Promise2.prototype._promiseCreated;
        Context.deactivateLongStackTraces = function() {
          Promise2.prototype._pushContext = Promise_pushContext;
          Promise2.prototype._popContext = Promise_popContext;
          Promise2._peekContext = Promise_PeekContext;
          Promise2.prototype._peekContext = Promise_peekContext;
          Promise2.prototype._promiseCreated = Promise_promiseCreated;
          longStackTraces = false;
        };
        longStackTraces = true;
        Promise2.prototype._pushContext = Context.prototype._pushContext;
        Promise2.prototype._popContext = Context.prototype._popContext;
        Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
        Promise2.prototype._promiseCreated = function() {
          var ctx = this._peekContext();
          if (ctx && ctx._promiseCreated == null)
            ctx._promiseCreated = this;
        };
      };
      return Context;
    };
  }
});

// node_modules/bluebird/js/release/debuggability.js
var require_debuggability = __commonJS({
  "node_modules/bluebird/js/release/debuggability.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, Context) {
      var getDomain = Promise2._getDomain;
      var async = Promise2._async;
      var Warning = require_errors2().Warning;
      var util = require_util2();
      var canAttachTrace2 = util.canAttachTrace;
      var unhandledRejectionHandled;
      var possiblyUnhandledRejection;
      var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
      var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
      var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
      var stackFramePattern = null;
      var formatStack = null;
      var indentStackFrames = false;
      var printWarning;
      var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && (util.env("BLUEBIRD_DEBUG") || util.env("NODE_ENV") === "development"));
      var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));
      var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
      var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
      Promise2.prototype.suppressUnhandledRejections = function() {
        var target = this._target();
        target._bitField = target._bitField & ~1048576 | 524288;
      };
      Promise2.prototype._ensurePossibleRejectionHandled = function() {
        if ((this._bitField & 524288) !== 0)
          return;
        this._setRejectionIsUnhandled();
        var self2 = this;
        setTimeout(function() {
          self2._notifyUnhandledRejection();
        }, 1);
      };
      Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
        fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, void 0, this);
      };
      Promise2.prototype._setReturnedNonUndefined = function() {
        this._bitField = this._bitField | 268435456;
      };
      Promise2.prototype._returnedNonUndefined = function() {
        return (this._bitField & 268435456) !== 0;
      };
      Promise2.prototype._notifyUnhandledRejection = function() {
        if (this._isRejectionUnhandled()) {
          var reason = this._settledValue();
          this._setUnhandledRejectionIsNotified();
          fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
        }
      };
      Promise2.prototype._setUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField | 262144;
      };
      Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField & ~262144;
      };
      Promise2.prototype._isUnhandledRejectionNotified = function() {
        return (this._bitField & 262144) > 0;
      };
      Promise2.prototype._setRejectionIsUnhandled = function() {
        this._bitField = this._bitField | 1048576;
      };
      Promise2.prototype._unsetRejectionIsUnhandled = function() {
        this._bitField = this._bitField & ~1048576;
        if (this._isUnhandledRejectionNotified()) {
          this._unsetUnhandledRejectionIsNotified();
          this._notifyUnhandledRejectionIsHandled();
        }
      };
      Promise2.prototype._isRejectionUnhandled = function() {
        return (this._bitField & 1048576) > 0;
      };
      Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise) {
        return warn(message, shouldUseOwnTrace, promise || this);
      };
      Promise2.onPossiblyUnhandledRejection = function(fn) {
        var domain = getDomain();
        possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : void 0;
      };
      Promise2.onUnhandledRejectionHandled = function(fn) {
        var domain = getDomain();
        unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : void 0;
      };
      var disableLongStackTraces = function() {
      };
      Promise2.longStackTraces = function() {
        if (async.haveItemsQueued() && !config.longStackTraces) {
          throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
        }
        if (!config.longStackTraces && longStackTracesIsSupported()) {
          var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
          var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
          config.longStackTraces = true;
          disableLongStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) {
              throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
            }
            Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Context.deactivateLongStackTraces();
            async.enableTrampoline();
            config.longStackTraces = false;
          };
          Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
          Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
          Context.activateLongStackTraces();
          async.disableTrampolineIfNecessary();
        }
      };
      Promise2.hasLongStackTraces = function() {
        return config.longStackTraces && longStackTracesIsSupported();
      };
      var fireDomEvent = function() {
        try {
          if (typeof CustomEvent === "function") {
            var event = new CustomEvent("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = new CustomEvent(name.toLowerCase(), {
                detail: event2,
                cancelable: true
              });
              return !util.global.dispatchEvent(domEvent);
            };
          } else if (typeof Event === "function") {
            var event = new Event("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = new Event(name.toLowerCase(), {
                cancelable: true
              });
              domEvent.detail = event2;
              return !util.global.dispatchEvent(domEvent);
            };
          } else {
            var event = document.createEvent("CustomEvent");
            event.initCustomEvent("testingtheevent", false, true, {});
            util.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = document.createEvent("CustomEvent");
              domEvent.initCustomEvent(name.toLowerCase(), false, true, event2);
              return !util.global.dispatchEvent(domEvent);
            };
          }
        } catch (e) {
        }
        return function() {
          return false;
        };
      }();
      var fireGlobalEvent = function() {
        if (util.isNode) {
          return function() {
            return process.emit.apply(process, arguments);
          };
        } else {
          if (!util.global) {
            return function() {
              return false;
            };
          }
          return function(name) {
            var methodName = "on" + name.toLowerCase();
            var method = util.global[methodName];
            if (!method)
              return false;
            method.apply(util.global, [].slice.call(arguments, 1));
            return true;
          };
        }
      }();
      function generatePromiseLifecycleEventObject(name, promise) {
        return { promise };
      }
      var eventToObjectGenerator = {
        promiseCreated: generatePromiseLifecycleEventObject,
        promiseFulfilled: generatePromiseLifecycleEventObject,
        promiseRejected: generatePromiseLifecycleEventObject,
        promiseResolved: generatePromiseLifecycleEventObject,
        promiseCancelled: generatePromiseLifecycleEventObject,
        promiseChained: function(name, promise, child) {
          return { promise, child };
        },
        warning: function(name, warning) {
          return { warning };
        },
        unhandledRejection: function(name, reason, promise) {
          return { reason, promise };
        },
        rejectionHandled: generatePromiseLifecycleEventObject
      };
      var activeFireEvent = function(name) {
        var globalEventFired = false;
        try {
          globalEventFired = fireGlobalEvent.apply(null, arguments);
        } catch (e) {
          async.throwLater(e);
          globalEventFired = true;
        }
        var domEventFired = false;
        try {
          domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
        } catch (e) {
          async.throwLater(e);
          domEventFired = true;
        }
        return domEventFired || globalEventFired;
      };
      Promise2.config = function(opts) {
        opts = Object(opts);
        if ("longStackTraces" in opts) {
          if (opts.longStackTraces) {
            Promise2.longStackTraces();
          } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
            disableLongStackTraces();
          }
        }
        if ("warnings" in opts) {
          var warningsOption = opts.warnings;
          config.warnings = !!warningsOption;
          wForgottenReturn = config.warnings;
          if (util.isObject(warningsOption)) {
            if ("wForgottenReturn" in warningsOption) {
              wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
          }
        }
        if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
          if (async.haveItemsQueued()) {
            throw new Error("cannot enable cancellation after promises are in use");
          }
          Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
          Promise2.prototype._propagateFrom = cancellationPropagateFrom;
          Promise2.prototype._onCancel = cancellationOnCancel;
          Promise2.prototype._setOnCancel = cancellationSetOnCancel;
          Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
          Promise2.prototype._execute = cancellationExecute;
          propagateFromFunction = cancellationPropagateFrom;
          config.cancellation = true;
        }
        if ("monitoring" in opts) {
          if (opts.monitoring && !config.monitoring) {
            config.monitoring = true;
            Promise2.prototype._fireEvent = activeFireEvent;
          } else if (!opts.monitoring && config.monitoring) {
            config.monitoring = false;
            Promise2.prototype._fireEvent = defaultFireEvent;
          }
        }
        return Promise2;
      };
      function defaultFireEvent() {
        return false;
      }
      Promise2.prototype._fireEvent = defaultFireEvent;
      Promise2.prototype._execute = function(executor, resolve, reject) {
        try {
          executor(resolve, reject);
        } catch (e) {
          return e;
        }
      };
      Promise2.prototype._onCancel = function() {
      };
      Promise2.prototype._setOnCancel = function(handler) {
        ;
      };
      Promise2.prototype._attachCancellationCallback = function(onCancel) {
        ;
      };
      Promise2.prototype._captureStackTrace = function() {
      };
      Promise2.prototype._attachExtraTrace = function() {
      };
      Promise2.prototype._clearCancellationData = function() {
      };
      Promise2.prototype._propagateFrom = function(parent, flags) {
        ;
        ;
      };
      function cancellationExecute(executor, resolve, reject) {
        var promise = this;
        try {
          executor(resolve, reject, function(onCancel) {
            if (typeof onCancel !== "function") {
              throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
          });
        } catch (e) {
          return e;
        }
      }
      function cancellationAttachCancellationCallback(onCancel) {
        if (!this._isCancellable())
          return this;
        var previousOnCancel = this._onCancel();
        if (previousOnCancel !== void 0) {
          if (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
          } else {
            this._setOnCancel([previousOnCancel, onCancel]);
          }
        } else {
          this._setOnCancel(onCancel);
        }
      }
      function cancellationOnCancel() {
        return this._onCancelField;
      }
      function cancellationSetOnCancel(onCancel) {
        this._onCancelField = onCancel;
      }
      function cancellationClearCancellationData() {
        this._cancellationParent = void 0;
        this._onCancelField = void 0;
      }
      function cancellationPropagateFrom(parent, flags) {
        if ((flags & 1) !== 0) {
          this._cancellationParent = parent;
          var branchesRemainingToCancel = parent._branchesRemainingToCancel;
          if (branchesRemainingToCancel === void 0) {
            branchesRemainingToCancel = 0;
          }
          parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
        }
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      function bindingPropagateFrom(parent, flags) {
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      var propagateFromFunction = bindingPropagateFrom;
      function boundValueFunction() {
        var ret2 = this._boundTo;
        if (ret2 !== void 0) {
          if (ret2 instanceof Promise2) {
            if (ret2.isFulfilled()) {
              return ret2.value();
            } else {
              return void 0;
            }
          }
        }
        return ret2;
      }
      function longStackTracesCaptureStackTrace() {
        this._trace = new CapturedTrace(this._peekContext());
      }
      function longStackTracesAttachExtraTrace(error, ignoreSelf) {
        if (canAttachTrace2(error)) {
          var trace = this._trace;
          if (trace !== void 0) {
            if (ignoreSelf)
              trace = trace._parent;
          }
          if (trace !== void 0) {
            trace.attachExtraTrace(error);
          } else if (!error.__stackCleaned__) {
            var parsed = parseStackAndMessage(error);
            util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
            util.notEnumerableProp(error, "__stackCleaned__", true);
          }
        }
      }
      function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
        if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
          if (parent !== void 0 && parent._returnedNonUndefined())
            return;
          if ((promise._bitField & 65535) === 0)
            return;
          if (name)
            name = name + " ";
          var handlerLine = "";
          var creatorLine = "";
          if (promiseCreated._trace) {
            var traceLines = promiseCreated._trace.stack.split("\n");
            var stack = cleanStack(traceLines);
            for (var i = stack.length - 1; i >= 0; --i) {
              var line = stack[i];
              if (!nodeFramePattern.test(line)) {
                var lineMatches = line.match(parseLinePattern);
                if (lineMatches) {
                  handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                }
                break;
              }
            }
            if (stack.length > 0) {
              var firstUserLine = stack[0];
              for (var i = 0; i < traceLines.length; ++i) {
                if (traceLines[i] === firstUserLine) {
                  if (i > 0) {
                    creatorLine = "\n" + traceLines[i - 1];
                  }
                  break;
                }
              }
            }
          }
          var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
          promise._warn(msg, true, promiseCreated);
        }
      }
      function deprecated(name, replacement) {
        var message = name + " is deprecated and will be removed in a future version.";
        if (replacement)
          message += " Use " + replacement + " instead.";
        return warn(message);
      }
      function warn(message, shouldUseOwnTrace, promise) {
        if (!config.warnings)
          return;
        var warning = new Warning(message);
        var ctx;
        if (shouldUseOwnTrace) {
          promise._attachExtraTrace(warning);
        } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
          ctx.attachExtraTrace(warning);
        } else {
          var parsed = parseStackAndMessage(warning);
          warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }
        if (!activeFireEvent("warning", warning)) {
          formatAndLogError(warning, "", true);
        }
      }
      function reconstructStack(message, stacks) {
        for (var i = 0; i < stacks.length - 1; ++i) {
          stacks[i].push("From previous event:");
          stacks[i] = stacks[i].join("\n");
        }
        if (i < stacks.length) {
          stacks[i] = stacks[i].join("\n");
        }
        return message + "\n" + stacks.join("\n");
      }
      function removeDuplicateOrEmptyJumps(stacks) {
        for (var i = 0; i < stacks.length; ++i) {
          if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
            stacks.splice(i, 1);
            i--;
          }
        }
      }
      function removeCommonRoots(stacks) {
        var current = stacks[0];
        for (var i = 1; i < stacks.length; ++i) {
          var prev = stacks[i];
          var currentLastIndex = current.length - 1;
          var currentLastLine = current[currentLastIndex];
          var commonRootMeetPoint = -1;
          for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
              commonRootMeetPoint = j;
              break;
            }
          }
          for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
              current.pop();
              currentLastIndex--;
            } else {
              break;
            }
          }
          current = prev;
        }
      }
      function cleanStack(stack) {
        var ret2 = [];
        for (var i = 0; i < stack.length; ++i) {
          var line = stack[i];
          var isTraceLine = line === "    (No stack trace)" || stackFramePattern.test(line);
          var isInternalFrame = isTraceLine && shouldIgnore(line);
          if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
              line = "    " + line;
            }
            ret2.push(line);
          }
        }
        return ret2;
      }
      function stackFramesAsArray(error) {
        var stack = error.stack.replace(/\s+$/g, "").split("\n");
        for (var i = 0; i < stack.length; ++i) {
          var line = stack[i];
          if (line === "    (No stack trace)" || stackFramePattern.test(line)) {
            break;
          }
        }
        if (i > 0 && error.name != "SyntaxError") {
          stack = stack.slice(i);
        }
        return stack;
      }
      function parseStackAndMessage(error) {
        var stack = error.stack;
        var message = error.toString();
        stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
        return {
          message,
          stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
        };
      }
      function formatAndLogError(error, title, isSoft) {
        if (typeof console !== "undefined") {
          var message;
          if (util.isObject(error)) {
            var stack = error.stack;
            message = title + formatStack(stack, error);
          } else {
            message = title + String(error);
          }
          if (typeof printWarning === "function") {
            printWarning(message, isSoft);
          } else if (typeof console.log === "function" || typeof console.log === "object") {
            console.log(message);
          }
        }
      }
      function fireRejectionEvent(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
          if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
              localHandler(promise);
            } else {
              localHandler(reason, promise);
            }
          }
        } catch (e) {
          async.throwLater(e);
        }
        if (name === "unhandledRejection") {
          if (!activeFireEvent(name, reason, promise) && !localEventFired) {
            formatAndLogError(reason, "Unhandled rejection ");
          }
        } else {
          activeFireEvent(name, promise);
        }
      }
      function formatNonError(obj) {
        var str;
        if (typeof obj === "function") {
          str = "[function " + (obj.name || "anonymous") + "]";
        } else {
          str = obj && typeof obj.toString === "function" ? obj.toString() : util.toString(obj);
          var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
          if (ruselessToString.test(str)) {
            try {
              var newStr = JSON.stringify(obj);
              str = newStr;
            } catch (e) {
            }
          }
          if (str.length === 0) {
            str = "(empty array)";
          }
        }
        return "(<" + snip(str) + ">, no stack trace)";
      }
      function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
          return str;
        }
        return str.substr(0, maxChars - 3) + "...";
      }
      function longStackTracesIsSupported() {
        return typeof captureStackTrace === "function";
      }
      var shouldIgnore = function() {
        return false;
      };
      var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
      function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
          return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
          };
        }
      }
      function setBounds(firstLineError, lastLineError) {
        if (!longStackTracesIsSupported())
          return;
        var firstStackLines = firstLineError.stack.split("\n");
        var lastStackLines = lastLineError.stack.split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for (var i = 0; i < firstStackLines.length; ++i) {
          var result = parseLineInfo(firstStackLines[i]);
          if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
          }
        }
        for (var i = 0; i < lastStackLines.length; ++i) {
          var result = parseLineInfo(lastStackLines[i]);
          if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
          }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
          return;
        }
        shouldIgnore = function(line) {
          if (bluebirdFramePattern.test(line))
            return true;
          var info = parseLineInfo(line);
          if (info) {
            if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
              return true;
            }
          }
          return false;
        };
      }
      function CapturedTrace(parent) {
        this._parent = parent;
        this._promisesCreated = 0;
        var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32)
          this.uncycle();
      }
      util.inherits(CapturedTrace, Error);
      Context.CapturedTrace = CapturedTrace;
      CapturedTrace.prototype.uncycle = function() {
        var length = this._length;
        if (length < 2)
          return;
        var nodes = [];
        var stackToIndex = {};
        for (var i = 0, node = this; node !== void 0; ++i) {
          nodes.push(node);
          node = node._parent;
        }
        length = this._length = i;
        for (var i = length - 1; i >= 0; --i) {
          var stack = nodes[i].stack;
          if (stackToIndex[stack] === void 0) {
            stackToIndex[stack] = i;
          }
        }
        for (var i = 0; i < length; ++i) {
          var currentStack = nodes[i].stack;
          var index = stackToIndex[currentStack];
          if (index !== void 0 && index !== i) {
            if (index > 0) {
              nodes[index - 1]._parent = void 0;
              nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = void 0;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
            if (index < length - 1) {
              cycleEdgeNode._parent = nodes[index + 1];
              cycleEdgeNode._parent.uncycle();
              cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
            } else {
              cycleEdgeNode._parent = void 0;
              cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
              nodes[j]._length = currentChildLength;
              currentChildLength++;
            }
            return;
          }
        }
      };
      CapturedTrace.prototype.attachExtraTrace = function(error) {
        if (error.__stackCleaned__)
          return;
        this.uncycle();
        var parsed = parseStackAndMessage(error);
        var message = parsed.message;
        var stacks = [parsed.stack];
        var trace = this;
        while (trace !== void 0) {
          stacks.push(cleanStack(trace.stack.split("\n")));
          trace = trace._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
        util.notEnumerableProp(error, "__stackCleaned__", true);
      };
      var captureStackTrace = function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = function(stack, error) {
          if (typeof stack === "string")
            return stack;
          if (error.name !== void 0 && error.message !== void 0) {
            return error.toString();
          }
          return formatNonError(error);
        };
        if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
          Error.stackTraceLimit += 6;
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          var captureStackTrace2 = Error.captureStackTrace;
          shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
          };
          return function(receiver, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace2(receiver, ignoreUntil);
            Error.stackTraceLimit -= 6;
          };
        }
        var err = new Error();
        if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
          stackFramePattern = /@/;
          formatStack = v8stackFormatter;
          indentStackFrames = true;
          return function captureStackTrace3(o) {
            o.stack = new Error().stack;
          };
        }
        var hasStackAfterThrow;
        try {
          throw new Error();
        } catch (e) {
          hasStackAfterThrow = "stack" in e;
        }
        if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          return function captureStackTrace3(o) {
            Error.stackTraceLimit += 6;
            try {
              throw new Error();
            } catch (e) {
              o.stack = e.stack;
            }
            Error.stackTraceLimit -= 6;
          };
        }
        formatStack = function(stack, error) {
          if (typeof stack === "string")
            return stack;
          if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
            return error.toString();
          }
          return formatNonError(error);
        };
        return null;
      }([]);
      if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        printWarning = function(message) {
          console.warn(message);
        };
        if (util.isNode && process.stderr.isTTY) {
          printWarning = function(message, isSoft) {
            var color = isSoft ? "[33m" : "[31m";
            console.warn(color + message + "[0m\n");
          };
        } else if (!util.isNode && typeof new Error().stack === "string") {
          printWarning = function(message, isSoft) {
            console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
          };
        }
      }
      var config = {
        warnings,
        longStackTraces: false,
        cancellation: false,
        monitoring: false
      };
      if (longStackTraces)
        Promise2.longStackTraces();
      return {
        longStackTraces: function() {
          return config.longStackTraces;
        },
        warnings: function() {
          return config.warnings;
        },
        cancellation: function() {
          return config.cancellation;
        },
        monitoring: function() {
          return config.monitoring;
        },
        propagateFromFunction: function() {
          return propagateFromFunction;
        },
        boundValueFunction: function() {
          return boundValueFunction;
        },
        checkForgottenReturns,
        setBounds,
        warn,
        deprecated,
        CapturedTrace,
        fireDomEvent,
        fireGlobalEvent
      };
    };
  }
});

// node_modules/bluebird/js/release/catch_filter.js
var require_catch_filter = __commonJS({
  "node_modules/bluebird/js/release/catch_filter.js"(exports2, module2) {
    "use strict";
    module2.exports = function(NEXT_FILTER) {
      var util = require_util2();
      var getKeys = require_es5().keys;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      function catchFilter(instances, cb, promise) {
        return function(e) {
          var boundTo = promise._boundValue();
          predicateLoop:
            for (var i = 0; i < instances.length; ++i) {
              var item = instances[i];
              if (item === Error || item != null && item.prototype instanceof Error) {
                if (e instanceof item) {
                  return tryCatch2(cb).call(boundTo, e);
                }
              } else if (typeof item === "function") {
                var matchesPredicate = tryCatch2(item).call(boundTo, e);
                if (matchesPredicate === errorObj2) {
                  return matchesPredicate;
                } else if (matchesPredicate) {
                  return tryCatch2(cb).call(boundTo, e);
                }
              } else if (util.isObject(e)) {
                var keys = getKeys(item);
                for (var j = 0; j < keys.length; ++j) {
                  var key = keys[j];
                  if (item[key] != e[key]) {
                    continue predicateLoop;
                  }
                }
                return tryCatch2(cb).call(boundTo, e);
              }
            }
          return NEXT_FILTER;
        };
      }
      return catchFilter;
    };
  }
});

// node_modules/bluebird/js/release/finally.js
var require_finally = __commonJS({
  "node_modules/bluebird/js/release/finally.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, tryConvertToPromise, NEXT_FILTER) {
      var util = require_util2();
      var CancellationError = Promise2.CancellationError;
      var errorObj2 = util.errorObj;
      var catchFilter = require_catch_filter()(NEXT_FILTER);
      function PassThroughHandlerContext(promise, type, handler) {
        this.promise = promise;
        this.type = type;
        this.handler = handler;
        this.called = false;
        this.cancelPromise = null;
      }
      PassThroughHandlerContext.prototype.isFinallyHandler = function() {
        return this.type === 0;
      };
      function FinallyHandlerCancelReaction(finallyHandler2) {
        this.finallyHandler = finallyHandler2;
      }
      FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
        checkCancel(this.finallyHandler);
      };
      function checkCancel(ctx, reason) {
        if (ctx.cancelPromise != null) {
          if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
          } else {
            ctx.cancelPromise._cancel();
          }
          ctx.cancelPromise = null;
          return true;
        }
        return false;
      }
      function succeed() {
        return finallyHandler.call(this, this.promise._target()._settledValue());
      }
      function fail(reason) {
        if (checkCancel(this, reason))
          return;
        errorObj2.e = reason;
        return errorObj2;
      }
      function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler = this.handler;
        if (!this.called) {
          this.called = true;
          var ret2 = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
          if (ret2 === NEXT_FILTER) {
            return ret2;
          } else if (ret2 !== void 0) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret2, promise);
            if (maybePromise instanceof Promise2) {
              if (this.cancelPromise != null) {
                if (maybePromise._isCancelled()) {
                  var reason = new CancellationError("late cancellation observer");
                  promise._attachExtraTrace(reason);
                  errorObj2.e = reason;
                  return errorObj2;
                } else if (maybePromise.isPending()) {
                  maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
                }
              }
              return maybePromise._then(succeed, fail, void 0, this, void 0);
            }
          }
        }
        if (promise.isRejected()) {
          checkCancel(this);
          errorObj2.e = reasonOrValue;
          return errorObj2;
        } else {
          checkCancel(this);
          return reasonOrValue;
        }
      }
      Promise2.prototype._passThrough = function(handler, type, success, fail2) {
        if (typeof handler !== "function")
          return this.then();
        return this._then(success, fail2, void 0, new PassThroughHandlerContext(this, type, handler), void 0);
      };
      Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
        return this._passThrough(handler, 0, finallyHandler, finallyHandler);
      };
      Promise2.prototype.tap = function(handler) {
        return this._passThrough(handler, 1, finallyHandler);
      };
      Promise2.prototype.tapCatch = function(handlerOrPredicate) {
        var len = arguments.length;
        if (len === 1) {
          return this._passThrough(handlerOrPredicate, 1, void 0, finallyHandler);
        } else {
          var catchInstances = new Array(len - 1), j = 0, i;
          for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
              catchInstances[j++] = item;
            } else {
              return Promise2.reject(new TypeError("tapCatch statement predicate: expecting an object but got " + util.classString(item)));
            }
          }
          catchInstances.length = j;
          var handler = arguments[i];
          return this._passThrough(catchFilter(catchInstances, handler, this), 1, void 0, finallyHandler);
        }
      };
      return PassThroughHandlerContext;
    };
  }
});

// node_modules/bluebird/js/release/nodeback.js
var require_nodeback = __commonJS({
  "node_modules/bluebird/js/release/nodeback.js"(exports2, module2) {
    "use strict";
    var util = require_util2();
    var maybeWrapAsError2 = util.maybeWrapAsError;
    var errors = require_errors2();
    var OperationalError = errors.OperationalError;
    var es52 = require_es5();
    function isUntypedError(obj) {
      return obj instanceof Error && es52.getPrototypeOf(obj) === Error.prototype;
    }
    var rErrorKey = /^(?:name|message|stack|cause)$/;
    function wrapAsOperationalError(obj) {
      var ret2;
      if (isUntypedError(obj)) {
        ret2 = new OperationalError(obj);
        ret2.name = obj.name;
        ret2.message = obj.message;
        ret2.stack = obj.stack;
        var keys = es52.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!rErrorKey.test(key)) {
            ret2[key] = obj[key];
          }
        }
        return ret2;
      }
      util.markAsOriginatingFromRejection(obj);
      return obj;
    }
    function nodebackForPromise(promise, multiArgs) {
      return function(err, value) {
        if (promise === null)
          return;
        if (err) {
          var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
          promise._attachExtraTrace(wrapped);
          promise._reject(wrapped);
        } else if (!multiArgs) {
          promise._fulfill(value);
        } else {
          var $_len = arguments.length;
          var args = new Array(Math.max($_len - 1, 0));
          for (var $_i = 1; $_i < $_len; ++$_i) {
            args[$_i - 1] = arguments[$_i];
          }
          ;
          promise._fulfill(args);
        }
        promise = null;
      };
    }
    module2.exports = nodebackForPromise;
  }
});

// node_modules/bluebird/js/release/method.js
var require_method = __commonJS({
  "node_modules/bluebird/js/release/method.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug) {
      var util = require_util2();
      var tryCatch2 = util.tryCatch;
      Promise2.method = function(fn) {
        if (typeof fn !== "function") {
          throw new Promise2.TypeError("expecting a function but got " + util.classString(fn));
        }
        return function() {
          var ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._pushContext();
          var value = tryCatch2(fn).apply(this, arguments);
          var promiseCreated = ret2._popContext();
          debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret2);
          ret2._resolveFromSyncValue(value);
          return ret2;
        };
      };
      Promise2.attempt = Promise2["try"] = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._pushContext();
        var value;
        if (arguments.length > 1) {
          debug.deprecated("calling Promise.try with more than 1 argument");
          var arg = arguments[1];
          var ctx = arguments[2];
          value = util.isArray(arg) ? tryCatch2(fn).apply(ctx, arg) : tryCatch2(fn).call(ctx, arg);
        } else {
          value = tryCatch2(fn)();
        }
        var promiseCreated = ret2._popContext();
        debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret2);
        ret2._resolveFromSyncValue(value);
        return ret2;
      };
      Promise2.prototype._resolveFromSyncValue = function(value) {
        if (value === util.errorObj) {
          this._rejectCallback(value.e, false);
        } else {
          this._resolveCallback(value, true);
        }
      };
    };
  }
});

// node_modules/bluebird/js/release/bind.js
var require_bind = __commonJS({
  "node_modules/bluebird/js/release/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, debug) {
      var calledBind = false;
      var rejectThis = function(_, e) {
        this._reject(e);
      };
      var targetRejected = function(e, context) {
        context.promiseRejectionQueued = true;
        context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
      };
      var bindingResolved = function(thisArg, context) {
        if ((this._bitField & 50397184) === 0) {
          this._resolveCallback(context.target);
        }
      };
      var bindingRejected = function(e, context) {
        if (!context.promiseRejectionQueued)
          this._reject(e);
      };
      Promise2.prototype.bind = function(thisArg) {
        if (!calledBind) {
          calledBind = true;
          Promise2.prototype._propagateFrom = debug.propagateFromFunction();
          Promise2.prototype._boundValue = debug.boundValueFunction();
        }
        var maybePromise = tryConvertToPromise(thisArg);
        var ret2 = new Promise2(INTERNAL);
        ret2._propagateFrom(this, 1);
        var target = this._target();
        ret2._setBoundTo(maybePromise);
        if (maybePromise instanceof Promise2) {
          var context = {
            promiseRejectionQueued: false,
            promise: ret2,
            target,
            bindingPromise: maybePromise
          };
          target._then(INTERNAL, targetRejected, void 0, ret2, context);
          maybePromise._then(bindingResolved, bindingRejected, void 0, ret2, context);
          ret2._setOnCancel(maybePromise);
        } else {
          ret2._resolveCallback(target);
        }
        return ret2;
      };
      Promise2.prototype._setBoundTo = function(obj) {
        if (obj !== void 0) {
          this._bitField = this._bitField | 2097152;
          this._boundTo = obj;
        } else {
          this._bitField = this._bitField & ~2097152;
        }
      };
      Promise2.prototype._isBound = function() {
        return (this._bitField & 2097152) === 2097152;
      };
      Promise2.bind = function(thisArg, value) {
        return Promise2.resolve(value).bind(thisArg);
      };
    };
  }
});

// node_modules/bluebird/js/release/cancel.js
var require_cancel = __commonJS({
  "node_modules/bluebird/js/release/cancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, debug) {
      var util = require_util2();
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var async = Promise2._async;
      Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
        if (!debug.cancellation())
          return this._warn("cancellation is disabled");
        var promise = this;
        var child = promise;
        while (promise._isCancellable()) {
          if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
              child._followee().cancel();
            } else {
              child._cancelBranched();
            }
            break;
          }
          var parent = promise._cancellationParent;
          if (parent == null || !parent._isCancellable()) {
            if (promise._isFollowing()) {
              promise._followee().cancel();
            } else {
              promise._cancelBranched();
            }
            break;
          } else {
            if (promise._isFollowing())
              promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
          }
        }
      };
      Promise2.prototype._branchHasCancelled = function() {
        this._branchesRemainingToCancel--;
      };
      Promise2.prototype._enoughBranchesHaveCancelled = function() {
        return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
      };
      Promise2.prototype._cancelBy = function(canceller) {
        if (canceller === this) {
          this._branchesRemainingToCancel = 0;
          this._invokeOnCancel();
          return true;
        } else {
          this._branchHasCancelled();
          if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
          }
        }
        return false;
      };
      Promise2.prototype._cancelBranched = function() {
        if (this._enoughBranchesHaveCancelled()) {
          this._cancel();
        }
      };
      Promise2.prototype._cancel = function() {
        if (!this._isCancellable())
          return;
        this._setCancelled();
        async.invoke(this._cancelPromises, this, void 0);
      };
      Promise2.prototype._cancelPromises = function() {
        if (this._length() > 0)
          this._settlePromises();
      };
      Promise2.prototype._unsetOnCancel = function() {
        this._onCancelField = void 0;
      };
      Promise2.prototype._isCancellable = function() {
        return this.isPending() && !this._isCancelled();
      };
      Promise2.prototype.isCancellable = function() {
        return this.isPending() && !this.isCancelled();
      };
      Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
        if (util.isArray(onCancelCallback)) {
          for (var i = 0; i < onCancelCallback.length; ++i) {
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
          }
        } else if (onCancelCallback !== void 0) {
          if (typeof onCancelCallback === "function") {
            if (!internalOnly) {
              var e = tryCatch2(onCancelCallback).call(this._boundValue());
              if (e === errorObj2) {
                this._attachExtraTrace(e.e);
                async.throwLater(e.e);
              }
            }
          } else {
            onCancelCallback._resultCancelled(this);
          }
        }
      };
      Promise2.prototype._invokeOnCancel = function() {
        var onCancelCallback = this._onCancel();
        this._unsetOnCancel();
        async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
      };
      Promise2.prototype._invokeInternalOnCancel = function() {
        if (this._isCancellable()) {
          this._doInvokeOnCancel(this._onCancel(), true);
          this._unsetOnCancel();
        }
      };
      Promise2.prototype._resultCancelled = function() {
        this.cancel();
      };
    };
  }
});

// node_modules/bluebird/js/release/direct_resolve.js
var require_direct_resolve = __commonJS({
  "node_modules/bluebird/js/release/direct_resolve.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      function returner() {
        return this.value;
      }
      function thrower2() {
        throw this.reason;
      }
      Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
        if (value instanceof Promise2)
          value.suppressUnhandledRejections();
        return this._then(returner, void 0, void 0, { value }, void 0);
      };
      Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
        return this._then(thrower2, void 0, void 0, { reason }, void 0);
      };
      Promise2.prototype.catchThrow = function(reason) {
        if (arguments.length <= 1) {
          return this._then(void 0, thrower2, void 0, { reason }, void 0);
        } else {
          var _reason = arguments[1];
          var handler = function() {
            throw _reason;
          };
          return this.caught(reason, handler);
        }
      };
      Promise2.prototype.catchReturn = function(value) {
        if (arguments.length <= 1) {
          if (value instanceof Promise2)
            value.suppressUnhandledRejections();
          return this._then(void 0, returner, void 0, { value }, void 0);
        } else {
          var _value = arguments[1];
          if (_value instanceof Promise2)
            _value.suppressUnhandledRejections();
          var handler = function() {
            return _value;
          };
          return this.caught(value, handler);
        }
      };
    };
  }
});

// node_modules/bluebird/js/release/synchronous_inspection.js
var require_synchronous_inspection = __commonJS({
  "node_modules/bluebird/js/release/synchronous_inspection.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      function PromiseInspection(promise) {
        if (promise !== void 0) {
          promise = promise._target();
          this._bitField = promise._bitField;
          this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0;
        } else {
          this._bitField = 0;
          this._settledValueField = void 0;
        }
      }
      PromiseInspection.prototype._settledValue = function() {
        return this._settledValueField;
      };
      var value = PromiseInspection.prototype.value = function() {
        if (!this.isFulfilled()) {
          throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
        if (!this.isRejected()) {
          throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
        return (this._bitField & 33554432) !== 0;
      };
      var isRejected = PromiseInspection.prototype.isRejected = function() {
        return (this._bitField & 16777216) !== 0;
      };
      var isPending = PromiseInspection.prototype.isPending = function() {
        return (this._bitField & 50397184) === 0;
      };
      var isResolved = PromiseInspection.prototype.isResolved = function() {
        return (this._bitField & 50331648) !== 0;
      };
      PromiseInspection.prototype.isCancelled = function() {
        return (this._bitField & 8454144) !== 0;
      };
      Promise2.prototype.__isCancelled = function() {
        return (this._bitField & 65536) === 65536;
      };
      Promise2.prototype._isCancelled = function() {
        return this._target().__isCancelled();
      };
      Promise2.prototype.isCancelled = function() {
        return (this._target()._bitField & 8454144) !== 0;
      };
      Promise2.prototype.isPending = function() {
        return isPending.call(this._target());
      };
      Promise2.prototype.isRejected = function() {
        return isRejected.call(this._target());
      };
      Promise2.prototype.isFulfilled = function() {
        return isFulfilled.call(this._target());
      };
      Promise2.prototype.isResolved = function() {
        return isResolved.call(this._target());
      };
      Promise2.prototype.value = function() {
        return value.call(this._target());
      };
      Promise2.prototype.reason = function() {
        var target = this._target();
        target._unsetRejectionIsUnhandled();
        return reason.call(target);
      };
      Promise2.prototype._value = function() {
        return this._settledValue();
      };
      Promise2.prototype._reason = function() {
        this._unsetRejectionIsUnhandled();
        return this._settledValue();
      };
      Promise2.PromiseInspection = PromiseInspection;
    };
  }
});

// node_modules/bluebird/js/release/join.js
var require_join = __commonJS({
  "node_modules/bluebird/js/release/join.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
      var util = require_util2();
      var canEvaluate2 = util.canEvaluate;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var reject;
      if (true) {
        if (canEvaluate2) {
          var thenCallback = function(i2) {
            return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i2));
          };
          var promiseSetter = function(i2) {
            return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i2));
          };
          var generateHolderClass = function(total) {
            var props = new Array(total);
            for (var i2 = 0; i2 < props.length; ++i2) {
              props[i2] = "this.p" + (i2 + 1);
            }
            var assignment = props.join(" = ") + " = null;";
            var cancellationCode = "var promise;\n" + props.map(function(prop) {
              return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
            }).join("\n");
            var passedArguments = props.join(", ");
            var name = "Holder$" + total;
            var code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
            code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
            return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch2, errorObj2, Promise2, async);
          };
          var holderClasses = [];
          var thenCallbacks = [];
          var promiseSetters = [];
          for (var i = 0; i < 8; ++i) {
            holderClasses.push(generateHolderClass(i + 1));
            thenCallbacks.push(thenCallback(i + 1));
            promiseSetters.push(promiseSetter(i + 1));
          }
          reject = function(reason) {
            this._reject(reason);
          };
        }
      }
      Promise2.join = function() {
        var last = arguments.length - 1;
        var fn;
        if (last > 0 && typeof arguments[last] === "function") {
          fn = arguments[last];
          if (true) {
            if (last <= 8 && canEvaluate2) {
              var ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              var HolderClass = holderClasses[last - 1];
              var holder = new HolderClass(fn);
              var callbacks = thenCallbacks;
              for (var i2 = 0; i2 < last; ++i2) {
                var maybePromise = tryConvertToPromise(arguments[i2], ret2);
                if (maybePromise instanceof Promise2) {
                  maybePromise = maybePromise._target();
                  var bitField = maybePromise._bitField;
                  ;
                  if ((bitField & 50397184) === 0) {
                    maybePromise._then(callbacks[i2], reject, void 0, ret2, holder);
                    promiseSetters[i2](maybePromise, holder);
                    holder.asyncNeeded = false;
                  } else if ((bitField & 33554432) !== 0) {
                    callbacks[i2].call(ret2, maybePromise._value(), holder);
                  } else if ((bitField & 16777216) !== 0) {
                    ret2._reject(maybePromise._reason());
                  } else {
                    ret2._cancel();
                  }
                } else {
                  callbacks[i2].call(ret2, maybePromise, holder);
                }
              }
              if (!ret2._isFateSealed()) {
                if (holder.asyncNeeded) {
                  var domain = getDomain();
                  if (domain !== null) {
                    holder.fn = util.domainBind(domain, holder.fn);
                  }
                }
                ret2._setAsyncGuaranteed();
                ret2._setOnCancel(holder);
              }
              return ret2;
            }
          }
        }
        var $_len = arguments.length;
        var args = new Array($_len);
        for (var $_i = 0; $_i < $_len; ++$_i) {
          args[$_i] = arguments[$_i];
        }
        ;
        if (fn)
          args.pop();
        var ret2 = new PromiseArray(args).promise();
        return fn !== void 0 ? ret2.spread(fn) : ret2;
      };
    };
  }
});

// node_modules/bluebird/js/release/map.js
var require_map2 = __commonJS({
  "node_modules/bluebird/js/release/map.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
      var getDomain = Promise2._getDomain;
      var util = require_util2();
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var async = Promise2._async;
      function MappingPromiseArray(promises, fn, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        var domain = getDomain();
        this._callback = domain === null ? fn : util.domainBind(domain, fn);
        this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = [];
        async.invoke(this._asyncInit, this, void 0);
      }
      util.inherits(MappingPromiseArray, PromiseArray);
      MappingPromiseArray.prototype._asyncInit = function() {
        this._init$(void 0, -2);
      };
      MappingPromiseArray.prototype._init = function() {
      };
      MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
        var values = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;
        if (index < 0) {
          index = index * -1 - 1;
          values[index] = value;
          if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved())
              return true;
          }
        } else {
          if (limit >= 1 && this._inFlight >= limit) {
            values[index] = value;
            this._queue.push(index);
            return false;
          }
          if (preservedValues !== null)
            preservedValues[index] = value;
          var promise = this._promise;
          var callback = this._callback;
          var receiver = promise._boundValue();
          promise._pushContext();
          var ret2 = tryCatch2(callback).call(receiver, value, index, length);
          var promiseCreated = promise._popContext();
          debug.checkForgottenReturns(ret2, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);
          if (ret2 === errorObj2) {
            this._reject(ret2.e);
            return true;
          }
          var maybePromise = tryConvertToPromise(ret2, this._promise);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if ((bitField & 50397184) === 0) {
              if (limit >= 1)
                this._inFlight++;
              values[index] = maybePromise;
              maybePromise._proxy(this, (index + 1) * -1);
              return false;
            } else if ((bitField & 33554432) !== 0) {
              ret2 = maybePromise._value();
            } else if ((bitField & 16777216) !== 0) {
              this._reject(maybePromise._reason());
              return true;
            } else {
              this._cancel();
              return true;
            }
          }
          values[index] = ret2;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
          if (preservedValues !== null) {
            this._filter(values, preservedValues);
          } else {
            this._resolve(values);
          }
          return true;
        }
        return false;
      };
      MappingPromiseArray.prototype._drainQueue = function() {
        var queue = this._queue;
        var limit = this._limit;
        var values = this._values;
        while (queue.length > 0 && this._inFlight < limit) {
          if (this._isResolved())
            return;
          var index = queue.pop();
          this._promiseFulfilled(values[index], index);
        }
      };
      MappingPromiseArray.prototype._filter = function(booleans, values) {
        var len = values.length;
        var ret2 = new Array(len);
        var j = 0;
        for (var i = 0; i < len; ++i) {
          if (booleans[i])
            ret2[j++] = values[i];
        }
        ret2.length = j;
        this._resolve(ret2);
      };
      MappingPromiseArray.prototype.preservedValues = function() {
        return this._preservedValues;
      };
      function map(promises, fn, options, _filter) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var limit = 0;
        if (options !== void 0) {
          if (typeof options === "object" && options !== null) {
            if (typeof options.concurrency !== "number") {
              return Promise2.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency)));
            }
            limit = options.concurrency;
          } else {
            return Promise2.reject(new TypeError("options argument must be an object but it is " + util.classString(options)));
          }
        }
        limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn, limit, _filter).promise();
      }
      Promise2.prototype.map = function(fn, options) {
        return map(this, fn, options, null);
      };
      Promise2.map = function(promises, fn, options, _filter) {
        return map(promises, fn, options, _filter);
      };
    };
  }
});

// node_modules/bluebird/js/release/call_get.js
var require_call_get = __commonJS({
  "node_modules/bluebird/js/release/call_get.js"(exports2, module2) {
    "use strict";
    var cr = Object.create;
    if (cr) {
      callerCache = cr(null);
      getterCache = cr(null);
      callerCache[" size"] = getterCache[" size"] = 0;
    }
    var callerCache;
    var getterCache;
    module2.exports = function(Promise2) {
      var util = require_util2();
      var canEvaluate2 = util.canEvaluate;
      var isIdentifier2 = util.isIdentifier;
      var getMethodCaller;
      var getGetter;
      if (true) {
        var makeMethodCaller = function(methodName) {
          return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
        };
        var makeGetter = function(propertyName) {
          return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
        };
        var getCompiled = function(name, compiler, cache) {
          var ret2 = cache[name];
          if (typeof ret2 !== "function") {
            if (!isIdentifier2(name)) {
              return null;
            }
            ret2 = compiler(name);
            cache[name] = ret2;
            cache[" size"]++;
            if (cache[" size"] > 512) {
              var keys = Object.keys(cache);
              for (var i = 0; i < 256; ++i)
                delete cache[keys[i]];
              cache[" size"] = keys.length - 256;
            }
          }
          return ret2;
        };
        getMethodCaller = function(name) {
          return getCompiled(name, makeMethodCaller, callerCache);
        };
        getGetter = function(name) {
          return getCompiled(name, makeGetter, getterCache);
        };
      }
      function ensureMethod(obj, methodName) {
        var fn;
        if (obj != null)
          fn = obj[methodName];
        if (typeof fn !== "function") {
          var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
          throw new Promise2.TypeError(message);
        }
        return fn;
      }
      function caller(obj) {
        var methodName = this.pop();
        var fn = ensureMethod(obj, methodName);
        return fn.apply(obj, this);
      }
      Promise2.prototype.call = function(methodName) {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1; $_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        ;
        if (true) {
          if (canEvaluate2) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
              return this._then(maybeCaller, void 0, void 0, args, void 0);
            }
          }
        }
        args.push(methodName);
        return this._then(caller, void 0, void 0, args, void 0);
      };
      function namedGetter(obj) {
        return obj[this];
      }
      function indexedGetter(obj) {
        var index = +this;
        if (index < 0)
          index = Math.max(0, index + obj.length);
        return obj[index];
      }
      Promise2.prototype.get = function(propertyName) {
        var isIndex = typeof propertyName === "number";
        var getter;
        if (!isIndex) {
          if (canEvaluate2) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
          } else {
            getter = namedGetter;
          }
        } else {
          getter = indexedGetter;
        }
        return this._then(getter, void 0, void 0, propertyName, void 0);
      };
    };
  }
});

// node_modules/bluebird/js/release/using.js
var require_using = __commonJS({
  "node_modules/bluebird/js/release/using.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
      var util = require_util2();
      var TypeError2 = require_errors2().TypeError;
      var inherits2 = require_util2().inherits;
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      var NULL = {};
      function thrower2(e) {
        setTimeout(function() {
          throw e;
        }, 0);
      }
      function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
          maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
      }
      function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret2 = new Promise2(INTERNAL);
        function iterator() {
          if (i >= len)
            return ret2._fulfill();
          var maybePromise = castPreservingDisposable(resources[i++]);
          if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
            try {
              maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
            } catch (e) {
              return thrower2(e);
            }
            if (maybePromise instanceof Promise2) {
              return maybePromise._then(iterator, thrower2, null, null, null);
            }
          }
          iterator();
        }
        iterator();
        return ret2;
      }
      function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
      }
      Disposer.prototype.data = function() {
        return this._data;
      };
      Disposer.prototype.promise = function() {
        return this._promise;
      };
      Disposer.prototype.resource = function() {
        if (this.promise().isFulfilled()) {
          return this.promise().value();
        }
        return NULL;
      };
      Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== void 0)
          context._pushContext();
        var ret2 = resource !== NULL ? this.doDispose(resource, inspection) : null;
        if (context !== void 0)
          context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret2;
      };
      Disposer.isDisposer = function(d) {
        return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
      };
      function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
      }
      inherits2(FunctionDisposer, Disposer);
      FunctionDisposer.prototype.doDispose = function(resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
      };
      function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
          this.resources[this.index]._setDisposable(value);
          return value.promise();
        }
        return value;
      }
      function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length - 1] = null;
      }
      ResourceList.prototype._resultCancelled = function() {
        var len = this.length;
        for (var i = 0; i < len; ++i) {
          var item = this[i];
          if (item instanceof Promise2) {
            item.cancel();
          }
        }
      };
      Promise2.using = function() {
        var len = arguments.length;
        if (len < 2)
          return apiRejection("you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
          input = arguments[0];
          len = input.length;
          spreadArgs = false;
        } else {
          input = arguments;
          len--;
        }
        var resources = new ResourceList(len);
        for (var i = 0; i < len; ++i) {
          var resource = input[i];
          if (Disposer.isDisposer(resource)) {
            var disposer = resource;
            resource = resource.promise();
            resource._setDisposable(disposer);
          } else {
            var maybePromise = tryConvertToPromise(resource);
            if (maybePromise instanceof Promise2) {
              resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                resources,
                index: i
              }, void 0);
            }
          }
          resources[i] = resource;
        }
        var reflectedResources = new Array(resources.length);
        for (var i = 0; i < reflectedResources.length; ++i) {
          reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
        }
        var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
          for (var i2 = 0; i2 < inspections.length; ++i2) {
            var inspection = inspections[i2];
            if (inspection.isRejected()) {
              errorObj2.e = inspection.error();
              return errorObj2;
            } else if (!inspection.isFulfilled()) {
              resultPromise.cancel();
              return;
            }
            inspections[i2] = inspection.value();
          }
          promise._pushContext();
          fn = tryCatch2(fn);
          var ret2 = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
          var promiseCreated = promise._popContext();
          debug.checkForgottenReturns(ret2, promiseCreated, "Promise.using", promise);
          return ret2;
        });
        var promise = resultPromise.lastly(function() {
          var inspection = new Promise2.PromiseInspection(resultPromise);
          return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
      };
      Promise2.prototype._setDisposable = function(disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
      };
      Promise2.prototype._isDisposable = function() {
        return (this._bitField & 131072) > 0;
      };
      Promise2.prototype._getDisposer = function() {
        return this._disposer;
      };
      Promise2.prototype._unsetDisposable = function() {
        this._bitField = this._bitField & ~131072;
        this._disposer = void 0;
      };
      Promise2.prototype.disposer = function(fn) {
        if (typeof fn === "function") {
          return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError2();
      };
    };
  }
});

// node_modules/bluebird/js/release/timers.js
var require_timers = __commonJS({
  "node_modules/bluebird/js/release/timers.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, debug) {
      var util = require_util2();
      var TimeoutError = Promise2.TimeoutError;
      function HandleWrapper(handle) {
        this.handle = handle;
      }
      HandleWrapper.prototype._resultCancelled = function() {
        clearTimeout(this.handle);
      };
      var afterValue = function(value) {
        return delay(+this).thenReturn(value);
      };
      var delay = Promise2.delay = function(ms, value) {
        var ret2;
        var handle;
        if (value !== void 0) {
          ret2 = Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
          if (debug.cancellation() && value instanceof Promise2) {
            ret2._setOnCancel(value);
          }
        } else {
          ret2 = new Promise2(INTERNAL);
          handle = setTimeout(function() {
            ret2._fulfill();
          }, +ms);
          if (debug.cancellation()) {
            ret2._setOnCancel(new HandleWrapper(handle));
          }
          ret2._captureStackTrace();
        }
        ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.prototype.delay = function(ms) {
        return delay(ms, this);
      };
      var afterTimeout = function(promise, message, parent) {
        var err;
        if (typeof message !== "string") {
          if (message instanceof Error) {
            err = message;
          } else {
            err = new TimeoutError("operation timed out");
          }
        } else {
          err = new TimeoutError(message);
        }
        util.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._reject(err);
        if (parent != null) {
          parent.cancel();
        }
      };
      function successClear(value) {
        clearTimeout(this.handle);
        return value;
      }
      function failureClear(reason) {
        clearTimeout(this.handle);
        throw reason;
      }
      Promise2.prototype.timeout = function(ms, message) {
        ms = +ms;
        var ret2, parent;
        var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
          if (ret2.isPending()) {
            afterTimeout(ret2, message, parent);
          }
        }, ms));
        if (debug.cancellation()) {
          parent = this.then();
          ret2 = parent._then(successClear, failureClear, void 0, handleWrapper, void 0);
          ret2._setOnCancel(handleWrapper);
        } else {
          ret2 = this._then(successClear, failureClear, void 0, handleWrapper, void 0);
        }
        return ret2;
      };
    };
  }
});

// node_modules/bluebird/js/release/generators.js
var require_generators = __commonJS({
  "node_modules/bluebird/js/release/generators.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
      var errors = require_errors2();
      var TypeError2 = errors.TypeError;
      var util = require_util2();
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      var yieldHandlers = [];
      function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
        for (var i = 0; i < yieldHandlers2.length; ++i) {
          traceParent._pushContext();
          var result = tryCatch2(yieldHandlers2[i])(value);
          traceParent._popContext();
          if (result === errorObj2) {
            traceParent._pushContext();
            var ret2 = Promise2.reject(errorObj2.e);
            traceParent._popContext();
            return ret2;
          }
          var maybePromise = tryConvertToPromise(result, traceParent);
          if (maybePromise instanceof Promise2)
            return maybePromise;
        }
        return null;
      }
      function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
        if (debug.cancellation()) {
          var internal = new Promise2(INTERNAL);
          var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
          this._promise = internal.lastly(function() {
            return _finallyPromise;
          });
          internal._captureStackTrace();
          internal._setOnCancel(this);
        } else {
          var promise = this._promise = new Promise2(INTERNAL);
          promise._captureStackTrace();
        }
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver;
        this._generator = void 0;
        this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
        this._yieldedPromise = null;
        this._cancellationPhase = false;
      }
      util.inherits(PromiseSpawn, Proxyable);
      PromiseSpawn.prototype._isResolved = function() {
        return this._promise === null;
      };
      PromiseSpawn.prototype._cleanup = function() {
        this._promise = this._generator = null;
        if (debug.cancellation() && this._finallyPromise !== null) {
          this._finallyPromise._fulfill();
          this._finallyPromise = null;
        }
      };
      PromiseSpawn.prototype._promiseCancelled = function() {
        if (this._isResolved())
          return;
        var implementsReturn = typeof this._generator["return"] !== "undefined";
        var result;
        if (!implementsReturn) {
          var reason = new Promise2.CancellationError("generator .return() sentinel");
          Promise2.coroutine.returnSentinel = reason;
          this._promise._attachExtraTrace(reason);
          this._promise._pushContext();
          result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
          this._promise._popContext();
        } else {
          this._promise._pushContext();
          result = tryCatch2(this._generator["return"]).call(this._generator, void 0);
          this._promise._popContext();
        }
        this._cancellationPhase = true;
        this._yieldedPromise = null;
        this._continue(result);
      };
      PromiseSpawn.prototype._promiseFulfilled = function(value) {
        this._yieldedPromise = null;
        this._promise._pushContext();
        var result = tryCatch2(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result);
      };
      PromiseSpawn.prototype._promiseRejected = function(reason) {
        this._yieldedPromise = null;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
        this._continue(result);
      };
      PromiseSpawn.prototype._resultCancelled = function() {
        if (this._yieldedPromise instanceof Promise2) {
          var promise = this._yieldedPromise;
          this._yieldedPromise = null;
          promise.cancel();
        }
      };
      PromiseSpawn.prototype.promise = function() {
        return this._promise;
      };
      PromiseSpawn.prototype._run = function() {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver = this._generatorFunction = void 0;
        this._promiseFulfilled(void 0);
      };
      PromiseSpawn.prototype._continue = function(result) {
        var promise = this._promise;
        if (result === errorObj2) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._rejectCallback(result.e, false);
          }
        }
        var value = result.value;
        if (result.done === true) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._resolveCallback(value);
          }
        } else {
          var maybePromise = tryConvertToPromise(value, this._promise);
          if (!(maybePromise instanceof Promise2)) {
            maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
            if (maybePromise === null) {
              this._promiseRejected(new TypeError2("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")));
              return;
            }
          }
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          ;
          if ((bitField & 50397184) === 0) {
            this._yieldedPromise = maybePromise;
            maybePromise._proxy(this, null);
          } else if ((bitField & 33554432) !== 0) {
            Promise2._async.invoke(this._promiseFulfilled, this, maybePromise._value());
          } else if ((bitField & 16777216) !== 0) {
            Promise2._async.invoke(this._promiseRejected, this, maybePromise._reason());
          } else {
            this._promiseCancelled();
          }
        }
      };
      Promise2.coroutine = function(generatorFunction, options) {
        if (typeof generatorFunction !== "function") {
          throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var yieldHandler = Object(options).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function() {
          var generator = generatorFunction.apply(this, arguments);
          var spawn = new PromiseSpawn$(void 0, void 0, yieldHandler, stack);
          var ret2 = spawn.promise();
          spawn._generator = generator;
          spawn._promiseFulfilled(void 0);
          return ret2;
        };
      };
      Promise2.coroutine.addYieldHandler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        yieldHandlers.push(fn);
      };
      Promise2.spawn = function(generatorFunction) {
        debug.deprecated("Promise.spawn()", "Promise.coroutine()");
        if (typeof generatorFunction !== "function") {
          return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret2 = spawn.promise();
        spawn._run(Promise2.spawn);
        return ret2;
      };
    };
  }
});

// node_modules/bluebird/js/release/nodeify.js
var require_nodeify = __commonJS({
  "node_modules/bluebird/js/release/nodeify.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      var util = require_util2();
      var async = Promise2._async;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util.isArray(val))
          return successAdapter.call(promise, val, nodeback);
        var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      function successAdapter(val, nodeback) {
        var promise = this;
        var receiver = promise._boundValue();
        var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver, null) : tryCatch2(nodeback).call(receiver, null, val);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
          var newReason = new Error(reason + "");
          newReason.cause = reason;
          reason = newReason;
        }
        var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
        if (typeof nodeback == "function") {
          var adapter = successAdapter;
          if (options !== void 0 && Object(options).spread) {
            adapter = spreadAdapter;
          }
          this._then(adapter, errorAdapter, void 0, this, nodeback);
        }
        return this;
      };
    };
  }
});

// node_modules/bluebird/js/release/promisify.js
var require_promisify = __commonJS({
  "node_modules/bluebird/js/release/promisify.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var THIS = {};
      var util = require_util2();
      var nodebackForPromise = require_nodeback();
      var withAppended2 = util.withAppended;
      var maybeWrapAsError2 = util.maybeWrapAsError;
      var canEvaluate2 = util.canEvaluate;
      var TypeError2 = require_errors2().TypeError;
      var defaultSuffix = "Async";
      var defaultPromisified = { __isPromisified__: true };
      var noCopyProps = [
        "arity",
        "length",
        "name",
        "arguments",
        "caller",
        "callee",
        "prototype",
        "__isPromisified__"
      ];
      var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
      var defaultFilter = function(name) {
        return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
      };
      function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
      }
      function isPromisified(fn) {
        try {
          return fn.__isPromisified__ === true;
        } catch (e) {
          return false;
        }
      }
      function hasPromisified(obj, key, suffix) {
        var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
        return val ? isPromisified(val) : false;
      }
      function checkValid(ret2, suffix, suffixRegexp) {
        for (var i = 0; i < ret2.length; i += 2) {
          var key = ret2[i];
          if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j = 0; j < ret2.length; j += 2) {
              if (ret2[j] === keyWithoutAsyncSuffix) {
                throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
              }
            }
          }
        }
      }
      function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
        var keys = util.inheritedDataKeys(obj);
        var ret2 = [];
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          var value = obj[key];
          var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);
          if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
            ret2.push(key, value);
          }
        }
        checkValid(ret2, suffix, suffixRegexp);
        return ret2;
      }
      var escapeIdentRegex = function(str) {
        return str.replace(/([$])/, "\\$");
      };
      var makeNodePromisifiedEval;
      if (true) {
        var switchCaseArgumentOrder = function(likelyArgumentCount) {
          var ret2 = [likelyArgumentCount];
          var min = Math.max(0, likelyArgumentCount - 1 - 3);
          for (var i = likelyArgumentCount - 1; i >= min; --i) {
            ret2.push(i);
          }
          for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
            ret2.push(i);
          }
          return ret2;
        };
        var argumentSequence = function(argumentCount) {
          return util.filledRange(argumentCount, "_arg", "");
        };
        var parameterDeclaration = function(parameterCount2) {
          return util.filledRange(Math.max(parameterCount2, 3), "_arg", "");
        };
        var parameterCount = function(fn) {
          if (typeof fn.length === "number") {
            return Math.max(Math.min(fn.length, 1023 + 1), 0);
          }
          return 0;
        };
        makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _, multiArgs) {
          var newParameterCount = Math.max(0, parameterCount(fn) - 1);
          var argumentOrder = switchCaseArgumentOrder(newParameterCount);
          var shouldProxyThis = typeof callback === "string" || receiver === THIS;
          function generateCallForArgumentCount(count) {
            var args = argumentSequence(count).join(", ");
            var comma = count > 0 ? ", " : "";
            var ret2;
            if (shouldProxyThis) {
              ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
            } else {
              ret2 = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
            }
            return ret2.replace("{{args}}", args).replace(", ", comma);
          }
          function generateArgumentSwitchCase() {
            var ret2 = "";
            for (var i = 0; i < argumentOrder.length; ++i) {
              ret2 += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
            }
            ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
            return ret2;
          }
          var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
          var body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
          body = body.replace("Parameters", parameterDeclaration(newParameterCount));
          return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise2, fn, receiver, withAppended2, maybeWrapAsError2, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
        };
      }
      function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
        var defaultThis = function() {
          return this;
        }();
        var method = callback;
        if (typeof method === "string") {
          callback = fn;
        }
        function promisified() {
          var _receiver = receiver;
          if (receiver === THIS)
            _receiver = this;
          var promise = new Promise2(INTERNAL);
          promise._captureStackTrace();
          var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
          var fn2 = nodebackForPromise(promise, multiArgs);
          try {
            cb.apply(_receiver, withAppended2(arguments, fn2));
          } catch (e) {
            promise._rejectCallback(maybeWrapAsError2(e), true, true);
          }
          if (!promise._isFateSealed())
            promise._setAsyncGuaranteed();
          return promise;
        }
        util.notEnumerableProp(promisified, "__isPromisified__", true);
        return promisified;
      }
      var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
      function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);
        for (var i = 0, len = methods.length; i < len; i += 2) {
          var key = methods[i];
          var fn = methods[i + 1];
          var promisifiedKey = key + suffix;
          if (promisifier === makeNodePromisified) {
            obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
          } else {
            var promisified = promisifier(fn, function() {
              return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
            });
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            obj[promisifiedKey] = promisified;
          }
        }
        util.toFastProperties(obj);
        return obj;
      }
      function promisify(callback, receiver, multiArgs) {
        return makeNodePromisified(callback, receiver, void 0, callback, null, multiArgs);
      }
      Promise2.promisify = function(fn, options) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        if (isPromisified(fn)) {
          return fn;
        }
        options = Object(options);
        var receiver = options.context === void 0 ? THIS : options.context;
        var multiArgs = !!options.multiArgs;
        var ret2 = promisify(fn, receiver, multiArgs);
        util.copyDescriptors(fn, ret2, propsFilter);
        return ret2;
      };
      Promise2.promisifyAll = function(target, options) {
        if (typeof target !== "function" && typeof target !== "object") {
          throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        options = Object(options);
        var multiArgs = !!options.multiArgs;
        var suffix = options.suffix;
        if (typeof suffix !== "string")
          suffix = defaultSuffix;
        var filter = options.filter;
        if (typeof filter !== "function")
          filter = defaultFilter;
        var promisifier = options.promisifier;
        if (typeof promisifier !== "function")
          promisifier = makeNodePromisified;
        if (!util.isIdentifier(suffix)) {
          throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
        }
        var keys = util.inheritedDataKeys(target);
        for (var i = 0; i < keys.length; ++i) {
          var value = target[keys[i]];
          if (keys[i] !== "constructor" && util.isClass(value)) {
            promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);
            promisifyAll(value, suffix, filter, promisifier, multiArgs);
          }
        }
        return promisifyAll(target, suffix, filter, promisifier, multiArgs);
      };
    };
  }
});

// node_modules/bluebird/js/release/props.js
var require_props = __commonJS({
  "node_modules/bluebird/js/release/props.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
      var util = require_util2();
      var isObject2 = util.isObject;
      var es52 = require_es5();
      var Es6Map;
      if (typeof Map === "function")
        Es6Map = Map;
      var mapToEntries = function() {
        var index = 0;
        var size = 0;
        function extractEntry(value, key) {
          this[index] = value;
          this[index + size] = key;
          index++;
        }
        return function mapToEntries2(map) {
          size = map.size;
          index = 0;
          var ret2 = new Array(map.size * 2);
          map.forEach(extractEntry, ret2);
          return ret2;
        };
      }();
      var entriesToMap = function(entries) {
        var ret2 = new Es6Map();
        var length = entries.length / 2 | 0;
        for (var i = 0; i < length; ++i) {
          var key = entries[length + i];
          var value = entries[i];
          ret2.set(key, value);
        }
        return ret2;
      };
      function PropertiesPromiseArray(obj) {
        var isMap = false;
        var entries;
        if (Es6Map !== void 0 && obj instanceof Es6Map) {
          entries = mapToEntries(obj);
          isMap = true;
        } else {
          var keys = es52.keys(obj);
          var len = keys.length;
          entries = new Array(len * 2);
          for (var i = 0; i < len; ++i) {
            var key = keys[i];
            entries[i] = obj[key];
            entries[i + len] = key;
          }
        }
        this.constructor$(entries);
        this._isMap = isMap;
        this._init$(void 0, isMap ? -6 : -3);
      }
      util.inherits(PropertiesPromiseArray, PromiseArray);
      PropertiesPromiseArray.prototype._init = function() {
      };
      PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          var val;
          if (this._isMap) {
            val = entriesToMap(this._values);
          } else {
            val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i < len; ++i) {
              val[this._values[i + keyOffset]] = this._values[i];
            }
          }
          this._resolve(val);
          return true;
        }
        return false;
      };
      PropertiesPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      PropertiesPromiseArray.prototype.getActualLength = function(len) {
        return len >> 1;
      };
      function props(promises) {
        var ret2;
        var castValue = tryConvertToPromise(promises);
        if (!isObject2(castValue)) {
          return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
        } else if (castValue instanceof Promise2) {
          ret2 = castValue._then(Promise2.props, void 0, void 0, void 0, void 0);
        } else {
          ret2 = new PropertiesPromiseArray(castValue).promise();
        }
        if (castValue instanceof Promise2) {
          ret2._propagateFrom(castValue, 2);
        }
        return ret2;
      }
      Promise2.prototype.props = function() {
        return props(this);
      };
      Promise2.props = function(promises) {
        return props(promises);
      };
    };
  }
});

// node_modules/bluebird/js/release/race.js
var require_race = __commonJS({
  "node_modules/bluebird/js/release/race.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
      var util = require_util2();
      var raceLater = function(promise) {
        return promise.then(function(array) {
          return race(array, promise);
        });
      };
      function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);
        if (maybePromise instanceof Promise2) {
          return raceLater(maybePromise);
        } else {
          promises = util.asArray(promises);
          if (promises === null)
            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
        }
        var ret2 = new Promise2(INTERNAL);
        if (parent !== void 0) {
          ret2._propagateFrom(parent, 3);
        }
        var fulfill = ret2._fulfill;
        var reject = ret2._reject;
        for (var i = 0, len = promises.length; i < len; ++i) {
          var val = promises[i];
          if (val === void 0 && !(i in promises)) {
            continue;
          }
          Promise2.cast(val)._then(fulfill, reject, void 0, ret2, null);
        }
        return ret2;
      }
      Promise2.race = function(promises) {
        return race(promises, void 0);
      };
      Promise2.prototype.race = function() {
        return race(this, void 0);
      };
    };
  }
});

// node_modules/bluebird/js/release/reduce.js
var require_reduce = __commonJS({
  "node_modules/bluebird/js/release/reduce.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
      var getDomain = Promise2._getDomain;
      var util = require_util2();
      var tryCatch2 = util.tryCatch;
      function ReductionPromiseArray(promises, fn, initialValue, _each) {
        this.constructor$(promises);
        var domain = getDomain();
        this._fn = domain === null ? fn : util.domainBind(domain, fn);
        if (initialValue !== void 0) {
          initialValue = Promise2.resolve(initialValue);
          initialValue._attachCancellationCallback(this);
        }
        this._initialValue = initialValue;
        this._currentCancellable = null;
        if (_each === INTERNAL) {
          this._eachValues = Array(this._length);
        } else if (_each === 0) {
          this._eachValues = null;
        } else {
          this._eachValues = void 0;
        }
        this._promise._captureStackTrace();
        this._init$(void 0, -5);
      }
      util.inherits(ReductionPromiseArray, PromiseArray);
      ReductionPromiseArray.prototype._gotAccum = function(accum) {
        if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
          this._eachValues.push(accum);
        }
      };
      ReductionPromiseArray.prototype._eachComplete = function(value) {
        if (this._eachValues !== null) {
          this._eachValues.push(value);
        }
        return this._eachValues;
      };
      ReductionPromiseArray.prototype._init = function() {
      };
      ReductionPromiseArray.prototype._resolveEmptyArray = function() {
        this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
      };
      ReductionPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      ReductionPromiseArray.prototype._resolve = function(value) {
        this._promise._resolveCallback(value);
        this._values = null;
      };
      ReductionPromiseArray.prototype._resultCancelled = function(sender) {
        if (sender === this._initialValue)
          return this._cancel();
        if (this._isResolved())
          return;
        this._resultCancelled$();
        if (this._currentCancellable instanceof Promise2) {
          this._currentCancellable.cancel();
        }
        if (this._initialValue instanceof Promise2) {
          this._initialValue.cancel();
        }
      };
      ReductionPromiseArray.prototype._iterate = function(values) {
        this._values = values;
        var value;
        var i;
        var length = values.length;
        if (this._initialValue !== void 0) {
          value = this._initialValue;
          i = 0;
        } else {
          value = Promise2.resolve(values[0]);
          i = 1;
        }
        this._currentCancellable = value;
        if (!value.isRejected()) {
          for (; i < length; ++i) {
            var ctx = {
              accum: null,
              value: values[i],
              index: i,
              length,
              array: this
            };
            value = value._then(gotAccum, void 0, void 0, ctx, void 0);
          }
        }
        if (this._eachValues !== void 0) {
          value = value._then(this._eachComplete, void 0, void 0, this, void 0);
        }
        value._then(completed, completed, void 0, value, this);
      };
      Promise2.prototype.reduce = function(fn, initialValue) {
        return reduce(this, fn, initialValue, null);
      };
      Promise2.reduce = function(promises, fn, initialValue, _each) {
        return reduce(promises, fn, initialValue, _each);
      };
      function completed(valueOrReason, array) {
        if (this.isFulfilled()) {
          array._resolve(valueOrReason);
        } else {
          array._reject(valueOrReason);
        }
      }
      function reduce(promises, fn, initialValue, _each) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
        return array.promise();
      }
      function gotAccum(accum) {
        this.accum = accum;
        this.array._gotAccum(accum);
        var value = tryConvertToPromise(this.value, this.array._promise);
        if (value instanceof Promise2) {
          this.array._currentCancellable = value;
          return value._then(gotValue, void 0, void 0, this, void 0);
        } else {
          return gotValue.call(this, value);
        }
      }
      function gotValue(value) {
        var array = this.array;
        var promise = array._promise;
        var fn = tryCatch2(array._fn);
        promise._pushContext();
        var ret2;
        if (array._eachValues !== void 0) {
          ret2 = fn.call(promise._boundValue(), value, this.index, this.length);
        } else {
          ret2 = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
        }
        if (ret2 instanceof Promise2) {
          array._currentCancellable = ret2;
        }
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(ret2, promiseCreated, array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce", promise);
        return ret2;
      }
    };
  }
});

// node_modules/bluebird/js/release/settle.js
var require_settle = __commonJS({
  "node_modules/bluebird/js/release/settle.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, debug) {
      var PromiseInspection = Promise2.PromiseInspection;
      var util = require_util2();
      function SettledPromiseArray(values) {
        this.constructor$(values);
      }
      util.inherits(SettledPromiseArray, PromiseArray);
      SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
        this._values[index] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 33554432;
        ret2._settledValueField = value;
        return this._promiseResolved(index, ret2);
      };
      SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 16777216;
        ret2._settledValueField = reason;
        return this._promiseResolved(index, ret2);
      };
      Promise2.settle = function(promises) {
        debug.deprecated(".settle()", ".reflect()");
        return new SettledPromiseArray(promises).promise();
      };
      Promise2.prototype.settle = function() {
        return Promise2.settle(this);
      };
    };
  }
});

// node_modules/bluebird/js/release/some.js
var require_some = __commonJS({
  "node_modules/bluebird/js/release/some.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection) {
      var util = require_util2();
      var RangeError2 = require_errors2().RangeError;
      var AggregateError = require_errors2().AggregateError;
      var isArray = util.isArray;
      var CANCELLATION = {};
      function SomePromiseArray(values) {
        this.constructor$(values);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
      }
      util.inherits(SomePromiseArray, PromiseArray);
      SomePromiseArray.prototype._init = function() {
        if (!this._initialized) {
          return;
        }
        if (this._howMany === 0) {
          this._resolve([]);
          return;
        }
        this._init$(void 0, -5);
        var isArrayResolved = isArray(this._values);
        if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
          this._reject(this._getRangeError(this.length()));
        }
      };
      SomePromiseArray.prototype.init = function() {
        this._initialized = true;
        this._init();
      };
      SomePromiseArray.prototype.setUnwrap = function() {
        this._unwrap = true;
      };
      SomePromiseArray.prototype.howMany = function() {
        return this._howMany;
      };
      SomePromiseArray.prototype.setHowMany = function(count) {
        this._howMany = count;
      };
      SomePromiseArray.prototype._promiseFulfilled = function(value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
          this._values.length = this.howMany();
          if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
          } else {
            this._resolve(this._values);
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._promiseRejected = function(reason) {
        this._addRejected(reason);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._promiseCancelled = function() {
        if (this._values instanceof Promise2 || this._values == null) {
          return this._cancel();
        }
        this._addRejected(CANCELLATION);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._checkOutcome = function() {
        if (this.howMany() > this._canPossiblyFulfill()) {
          var e = new AggregateError();
          for (var i = this.length(); i < this._values.length; ++i) {
            if (this._values[i] !== CANCELLATION) {
              e.push(this._values[i]);
            }
          }
          if (e.length > 0) {
            this._reject(e);
          } else {
            this._cancel();
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._fulfilled = function() {
        return this._totalResolved;
      };
      SomePromiseArray.prototype._rejected = function() {
        return this._values.length - this.length();
      };
      SomePromiseArray.prototype._addRejected = function(reason) {
        this._values.push(reason);
      };
      SomePromiseArray.prototype._addFulfilled = function(value) {
        this._values[this._totalResolved++] = value;
      };
      SomePromiseArray.prototype._canPossiblyFulfill = function() {
        return this.length() - this._rejected();
      };
      SomePromiseArray.prototype._getRangeError = function(count) {
        var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
        return new RangeError2(message);
      };
      SomePromiseArray.prototype._resolveEmptyArray = function() {
        this._reject(this._getRangeError(0));
      };
      function some(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
          return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
        }
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(howMany);
        ret2.init();
        return promise;
      }
      Promise2.some = function(promises, howMany) {
        return some(promises, howMany);
      };
      Promise2.prototype.some = function(howMany) {
        return some(this, howMany);
      };
      Promise2._SomePromiseArray = SomePromiseArray;
    };
  }
});

// node_modules/bluebird/js/release/filter.js
var require_filter = __commonJS({
  "node_modules/bluebird/js/release/filter.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var PromiseMap = Promise2.map;
      Promise2.prototype.filter = function(fn, options) {
        return PromiseMap(this, fn, options, INTERNAL);
      };
      Promise2.filter = function(promises, fn, options) {
        return PromiseMap(promises, fn, options, INTERNAL);
      };
    };
  }
});

// node_modules/bluebird/js/release/each.js
var require_each = __commonJS({
  "node_modules/bluebird/js/release/each.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var PromiseReduce = Promise2.reduce;
      var PromiseAll = Promise2.all;
      function promiseAllThis() {
        return PromiseAll(this);
      }
      function PromiseMapSeries(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
      }
      Promise2.prototype.each = function(fn) {
        return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
      };
      Promise2.prototype.mapSeries = function(fn) {
        return PromiseReduce(this, fn, INTERNAL, INTERNAL);
      };
      Promise2.each = function(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
      };
      Promise2.mapSeries = PromiseMapSeries;
    };
  }
});

// node_modules/bluebird/js/release/any.js
var require_any = __commonJS({
  "node_modules/bluebird/js/release/any.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      var SomePromiseArray = Promise2._SomePromiseArray;
      function any(promises) {
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(1);
        ret2.setUnwrap();
        ret2.init();
        return promise;
      }
      Promise2.any = function(promises) {
        return any(promises);
      };
      Promise2.prototype.any = function() {
        return any(this);
      };
    };
  }
});

// node_modules/bluebird/js/release/promise.js
var require_promise = __commonJS({
  "node_modules/bluebird/js/release/promise.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      var makeSelfResolutionError = function() {
        return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
      };
      var reflectHandler = function() {
        return new Promise2.PromiseInspection(this._target());
      };
      var apiRejection = function(msg) {
        return Promise2.reject(new TypeError2(msg));
      };
      function Proxyable() {
      }
      var UNDEFINED_BINDING = {};
      var util = require_util2();
      var getDomain;
      if (util.isNode) {
        getDomain = function() {
          var ret2 = process.domain;
          if (ret2 === void 0)
            ret2 = null;
          return ret2;
        };
      } else {
        getDomain = function() {
          return null;
        };
      }
      util.notEnumerableProp(Promise2, "_getDomain", getDomain);
      var es52 = require_es5();
      var Async = require_async();
      var async = new Async();
      es52.defineProperty(Promise2, "_async", { value: async });
      var errors = require_errors2();
      var TypeError2 = Promise2.TypeError = errors.TypeError;
      Promise2.RangeError = errors.RangeError;
      var CancellationError = Promise2.CancellationError = errors.CancellationError;
      Promise2.TimeoutError = errors.TimeoutError;
      Promise2.OperationalError = errors.OperationalError;
      Promise2.RejectionError = errors.OperationalError;
      Promise2.AggregateError = errors.AggregateError;
      var INTERNAL = function() {
      };
      var APPLY = {};
      var NEXT_FILTER = {};
      var tryConvertToPromise = require_thenables()(Promise2, INTERNAL);
      var PromiseArray = require_promise_array()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);
      var Context = require_context()(Promise2);
      var createContext = Context.create;
      var debug = require_debuggability()(Promise2, Context);
      var CapturedTrace = debug.CapturedTrace;
      var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise, NEXT_FILTER);
      var catchFilter = require_catch_filter()(NEXT_FILTER);
      var nodebackForPromise = require_nodeback();
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      function check(self2, executor) {
        if (self2 == null || self2.constructor !== Promise2) {
          throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
        }
        if (typeof executor !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(executor));
        }
      }
      function Promise2(executor) {
        if (executor !== INTERNAL) {
          check(this, executor);
        }
        this._bitField = 0;
        this._fulfillmentHandler0 = void 0;
        this._rejectionHandler0 = void 0;
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._resolveFromExecutor(executor);
        this._promiseCreated();
        this._fireEvent("promiseCreated", this);
      }
      Promise2.prototype.toString = function() {
        return "[object Promise]";
      };
      Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
        var len = arguments.length;
        if (len > 1) {
          var catchInstances = new Array(len - 1), j = 0, i;
          for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
              catchInstances[j++] = item;
            } else {
              return apiRejection("Catch statement predicate: expecting an object but got " + util.classString(item));
            }
          }
          catchInstances.length = j;
          fn = arguments[i];
          return this.then(void 0, catchFilter(catchInstances, fn, this));
        }
        return this.then(void 0, fn);
      };
      Promise2.prototype.reflect = function() {
        return this._then(reflectHandler, reflectHandler, void 0, this, void 0);
      };
      Promise2.prototype.then = function(didFulfill, didReject) {
        if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
          var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
          if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
          }
          this._warn(msg);
        }
        return this._then(didFulfill, didReject, void 0, void 0, void 0);
      };
      Promise2.prototype.done = function(didFulfill, didReject) {
        var promise = this._then(didFulfill, didReject, void 0, void 0, void 0);
        promise._setIsFinal();
      };
      Promise2.prototype.spread = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        return this.all()._then(fn, void 0, void 0, APPLY, void 0);
      };
      Promise2.prototype.toJSON = function() {
        var ret2 = {
          isFulfilled: false,
          isRejected: false,
          fulfillmentValue: void 0,
          rejectionReason: void 0
        };
        if (this.isFulfilled()) {
          ret2.fulfillmentValue = this.value();
          ret2.isFulfilled = true;
        } else if (this.isRejected()) {
          ret2.rejectionReason = this.reason();
          ret2.isRejected = true;
        }
        return ret2;
      };
      Promise2.prototype.all = function() {
        if (arguments.length > 0) {
          this._warn(".all() was passed arguments but it does not take any");
        }
        return new PromiseArray(this).promise();
      };
      Promise2.prototype.error = function(fn) {
        return this.caught(util.originatesFromRejection, fn);
      };
      Promise2.getNewLibraryCopy = module2.exports;
      Promise2.is = function(val) {
        return val instanceof Promise2;
      };
      Promise2.fromNode = Promise2.fromCallback = function(fn) {
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
        var result = tryCatch2(fn)(nodebackForPromise(ret2, multiArgs));
        if (result === errorObj2) {
          ret2._rejectCallback(result.e, true);
        }
        if (!ret2._isFateSealed())
          ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.all = function(promises) {
        return new PromiseArray(promises).promise();
      };
      Promise2.cast = function(obj) {
        var ret2 = tryConvertToPromise(obj);
        if (!(ret2 instanceof Promise2)) {
          ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._setFulfilled();
          ret2._rejectionHandler0 = obj;
        }
        return ret2;
      };
      Promise2.resolve = Promise2.fulfilled = Promise2.cast;
      Promise2.reject = Promise2.rejected = function(reason) {
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._rejectCallback(reason, true);
        return ret2;
      };
      Promise2.setScheduler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        return async.setScheduler(fn);
      };
      Promise2.prototype._then = function(didFulfill, didReject, _, receiver, internalData) {
        var haveInternalData = internalData !== void 0;
        var promise = haveInternalData ? internalData : new Promise2(INTERNAL);
        var target = this._target();
        var bitField = target._bitField;
        if (!haveInternalData) {
          promise._propagateFrom(this, 3);
          promise._captureStackTrace();
          if (receiver === void 0 && (this._bitField & 2097152) !== 0) {
            if (!((bitField & 50397184) === 0)) {
              receiver = this._boundValue();
            } else {
              receiver = target === this ? void 0 : this._boundTo;
            }
          }
          this._fireEvent("promiseChained", this, promise);
        }
        var domain = getDomain();
        if (!((bitField & 50397184) === 0)) {
          var handler, value, settler = target._settlePromiseCtx;
          if ((bitField & 33554432) !== 0) {
            value = target._rejectionHandler0;
            handler = didFulfill;
          } else if ((bitField & 16777216) !== 0) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
          } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler = didReject;
          }
          async.invoke(settler, target, {
            handler: domain === null ? handler : typeof handler === "function" && util.domainBind(domain, handler),
            promise,
            receiver,
            value
          });
        } else {
          target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
        }
        return promise;
      };
      Promise2.prototype._length = function() {
        return this._bitField & 65535;
      };
      Promise2.prototype._isFateSealed = function() {
        return (this._bitField & 117506048) !== 0;
      };
      Promise2.prototype._isFollowing = function() {
        return (this._bitField & 67108864) === 67108864;
      };
      Promise2.prototype._setLength = function(len) {
        this._bitField = this._bitField & -65536 | len & 65535;
      };
      Promise2.prototype._setFulfilled = function() {
        this._bitField = this._bitField | 33554432;
        this._fireEvent("promiseFulfilled", this);
      };
      Promise2.prototype._setRejected = function() {
        this._bitField = this._bitField | 16777216;
        this._fireEvent("promiseRejected", this);
      };
      Promise2.prototype._setFollowing = function() {
        this._bitField = this._bitField | 67108864;
        this._fireEvent("promiseResolved", this);
      };
      Promise2.prototype._setIsFinal = function() {
        this._bitField = this._bitField | 4194304;
      };
      Promise2.prototype._isFinal = function() {
        return (this._bitField & 4194304) > 0;
      };
      Promise2.prototype._unsetCancelled = function() {
        this._bitField = this._bitField & ~65536;
      };
      Promise2.prototype._setCancelled = function() {
        this._bitField = this._bitField | 65536;
        this._fireEvent("promiseCancelled", this);
      };
      Promise2.prototype._setWillBeCancelled = function() {
        this._bitField = this._bitField | 8388608;
      };
      Promise2.prototype._setAsyncGuaranteed = function() {
        if (async.hasCustomScheduler())
          return;
        this._bitField = this._bitField | 134217728;
      };
      Promise2.prototype._receiverAt = function(index) {
        var ret2 = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
        if (ret2 === UNDEFINED_BINDING) {
          return void 0;
        } else if (ret2 === void 0 && this._isBound()) {
          return this._boundValue();
        }
        return ret2;
      };
      Promise2.prototype._promiseAt = function(index) {
        return this[index * 4 - 4 + 2];
      };
      Promise2.prototype._fulfillmentHandlerAt = function(index) {
        return this[index * 4 - 4 + 0];
      };
      Promise2.prototype._rejectionHandlerAt = function(index) {
        return this[index * 4 - 4 + 1];
      };
      Promise2.prototype._boundValue = function() {
      };
      Promise2.prototype._migrateCallback0 = function(follower) {
        var bitField = follower._bitField;
        var fulfill = follower._fulfillmentHandler0;
        var reject = follower._rejectionHandler0;
        var promise = follower._promise0;
        var receiver = follower._receiverAt(0);
        if (receiver === void 0)
          receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
      };
      Promise2.prototype._migrateCallbackAt = function(follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject = follower._rejectionHandlerAt(index);
        var promise = follower._promiseAt(index);
        var receiver = follower._receiverAt(index);
        if (receiver === void 0)
          receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
      };
      Promise2.prototype._addCallbacks = function(fulfill, reject, promise, receiver, domain) {
        var index = this._length();
        if (index >= 65535 - 4) {
          index = 0;
          this._setLength(0);
        }
        if (index === 0) {
          this._promise0 = promise;
          this._receiver0 = receiver;
          if (typeof fulfill === "function") {
            this._fulfillmentHandler0 = domain === null ? fulfill : util.domainBind(domain, fulfill);
          }
          if (typeof reject === "function") {
            this._rejectionHandler0 = domain === null ? reject : util.domainBind(domain, reject);
          }
        } else {
          var base = index * 4 - 4;
          this[base + 2] = promise;
          this[base + 3] = receiver;
          if (typeof fulfill === "function") {
            this[base + 0] = domain === null ? fulfill : util.domainBind(domain, fulfill);
          }
          if (typeof reject === "function") {
            this[base + 1] = domain === null ? reject : util.domainBind(domain, reject);
          }
        }
        this._setLength(index + 1);
        return index;
      };
      Promise2.prototype._proxy = function(proxyable, arg) {
        this._addCallbacks(void 0, void 0, arg, proxyable, null);
      };
      Promise2.prototype._resolveCallback = function(value, shouldBind) {
        if ((this._bitField & 117506048) !== 0)
          return;
        if (value === this)
          return this._rejectCallback(makeSelfResolutionError(), false);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise2))
          return this._fulfill(value);
        if (shouldBind)
          this._propagateFrom(maybePromise, 2);
        var promise = maybePromise._target();
        if (promise === this) {
          this._reject(makeSelfResolutionError());
          return;
        }
        var bitField = promise._bitField;
        if ((bitField & 50397184) === 0) {
          var len = this._length();
          if (len > 0)
            promise._migrateCallback0(this);
          for (var i = 1; i < len; ++i) {
            promise._migrateCallbackAt(this, i);
          }
          this._setFollowing();
          this._setLength(0);
          this._setFollowee(promise);
        } else if ((bitField & 33554432) !== 0) {
          this._fulfill(promise._value());
        } else if ((bitField & 16777216) !== 0) {
          this._reject(promise._reason());
        } else {
          var reason = new CancellationError("late cancellation observer");
          promise._attachExtraTrace(reason);
          this._reject(reason);
        }
      };
      Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
        var trace = util.ensureErrorObject(reason);
        var hasStack = trace === reason;
        if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
          var message = "a promise was rejected with a non-error: " + util.classString(reason);
          this._warn(message, true);
        }
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason);
      };
      Promise2.prototype._resolveFromExecutor = function(executor) {
        if (executor === INTERNAL)
          return;
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = this._execute(executor, function(value) {
          promise._resolveCallback(value);
        }, function(reason) {
          promise._rejectCallback(reason, synchronous);
        });
        synchronous = false;
        this._popContext();
        if (r !== void 0) {
          promise._rejectCallback(r, true);
        }
      };
      Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
        var bitField = promise._bitField;
        if ((bitField & 65536) !== 0)
          return;
        promise._pushContext();
        var x;
        if (receiver === APPLY) {
          if (!value || typeof value.length !== "number") {
            x = errorObj2;
            x.e = new TypeError2("cannot .spread() a non-array: " + util.classString(value));
          } else {
            x = tryCatch2(handler).apply(this._boundValue(), value);
          }
        } else {
          x = tryCatch2(handler).call(receiver, value);
        }
        var promiseCreated = promise._popContext();
        bitField = promise._bitField;
        if ((bitField & 65536) !== 0)
          return;
        if (x === NEXT_FILTER) {
          promise._reject(value);
        } else if (x === errorObj2) {
          promise._rejectCallback(x.e, false);
        } else {
          debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
          promise._resolveCallback(x);
        }
      };
      Promise2.prototype._target = function() {
        var ret2 = this;
        while (ret2._isFollowing())
          ret2 = ret2._followee();
        return ret2;
      };
      Promise2.prototype._followee = function() {
        return this._rejectionHandler0;
      };
      Promise2.prototype._setFollowee = function(promise) {
        this._rejectionHandler0 = promise;
      };
      Promise2.prototype._settlePromise = function(promise, handler, receiver, value) {
        var isPromise = promise instanceof Promise2;
        var bitField = this._bitField;
        var asyncGuaranteed = (bitField & 134217728) !== 0;
        if ((bitField & 65536) !== 0) {
          if (isPromise)
            promise._invokeInternalOnCancel();
          if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise;
            if (tryCatch2(handler).call(receiver, value) === errorObj2) {
              promise._reject(errorObj2.e);
            }
          } else if (handler === reflectHandler) {
            promise._fulfill(reflectHandler.call(receiver));
          } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise);
          } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
          } else {
            receiver.cancel();
          }
        } else if (typeof handler === "function") {
          if (!isPromise) {
            handler.call(receiver, value, promise);
          } else {
            if (asyncGuaranteed)
              promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise);
          }
        } else if (receiver instanceof Proxyable) {
          if (!receiver._isResolved()) {
            if ((bitField & 33554432) !== 0) {
              receiver._promiseFulfilled(value, promise);
            } else {
              receiver._promiseRejected(value, promise);
            }
          }
        } else if (isPromise) {
          if (asyncGuaranteed)
            promise._setAsyncGuaranteed();
          if ((bitField & 33554432) !== 0) {
            promise._fulfill(value);
          } else {
            promise._reject(value);
          }
        }
      };
      Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
        var handler = ctx.handler;
        var promise = ctx.promise;
        var receiver = ctx.receiver;
        var value = ctx.value;
        if (typeof handler === "function") {
          if (!(promise instanceof Promise2)) {
            handler.call(receiver, value, promise);
          } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
          }
        } else if (promise instanceof Promise2) {
          promise._reject(value);
        }
      };
      Promise2.prototype._settlePromiseCtx = function(ctx) {
        this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
      };
      Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
        var promise = this._promise0;
        var receiver = this._receiverAt(0);
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._settlePromise(promise, handler, receiver, value);
      };
      Promise2.prototype._clearCallbackDataAtIndex = function(index) {
        var base = index * 4 - 4;
        this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
      };
      Promise2.prototype._fulfill = function(value) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16)
          return;
        if (value === this) {
          var err = makeSelfResolutionError();
          this._attachExtraTrace(err);
          return this._reject(err);
        }
        this._setFulfilled();
        this._rejectionHandler0 = value;
        if ((bitField & 65535) > 0) {
          if ((bitField & 134217728) !== 0) {
            this._settlePromises();
          } else {
            async.settlePromises(this);
          }
        }
      };
      Promise2.prototype._reject = function(reason) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16)
          return;
        this._setRejected();
        this._fulfillmentHandler0 = reason;
        if (this._isFinal()) {
          return async.fatalError(reason, util.isNode);
        }
        if ((bitField & 65535) > 0) {
          async.settlePromises(this);
        } else {
          this._ensurePossibleRejectionHandled();
        }
      };
      Promise2.prototype._fulfillPromises = function(len, value) {
        for (var i = 1; i < len; i++) {
          var handler = this._fulfillmentHandlerAt(i);
          var promise = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise, handler, receiver, value);
        }
      };
      Promise2.prototype._rejectPromises = function(len, reason) {
        for (var i = 1; i < len; i++) {
          var handler = this._rejectionHandlerAt(i);
          var promise = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise, handler, receiver, reason);
        }
      };
      Promise2.prototype._settlePromises = function() {
        var bitField = this._bitField;
        var len = bitField & 65535;
        if (len > 0) {
          if ((bitField & 16842752) !== 0) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
          } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
          }
          this._setLength(0);
        }
        this._clearCancellationData();
      };
      Promise2.prototype._settledValue = function() {
        var bitField = this._bitField;
        if ((bitField & 33554432) !== 0) {
          return this._rejectionHandler0;
        } else if ((bitField & 16777216) !== 0) {
          return this._fulfillmentHandler0;
        }
      };
      function deferResolve(v) {
        this.promise._resolveCallback(v);
      }
      function deferReject(v) {
        this.promise._rejectCallback(v, false);
      }
      Promise2.defer = Promise2.pending = function() {
        debug.deprecated("Promise.defer", "new Promise");
        var promise = new Promise2(INTERNAL);
        return {
          promise,
          resolve: deferResolve,
          reject: deferReject
        };
      };
      util.notEnumerableProp(Promise2, "_makeSelfResolutionError", makeSelfResolutionError);
      require_method()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug);
      require_bind()(Promise2, INTERNAL, tryConvertToPromise, debug);
      require_cancel()(Promise2, PromiseArray, apiRejection, debug);
      require_direct_resolve()(Promise2);
      require_synchronous_inspection()(Promise2);
      require_join()(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
      Promise2.Promise = Promise2;
      Promise2.version = "3.5.1";
      require_map2()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
      require_call_get()(Promise2);
      require_using()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
      require_timers()(Promise2, INTERNAL, debug);
      require_generators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
      require_nodeify()(Promise2);
      require_promisify()(Promise2, INTERNAL);
      require_props()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
      require_race()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
      require_reduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
      require_settle()(Promise2, PromiseArray, debug);
      require_some()(Promise2, PromiseArray, apiRejection);
      require_filter()(Promise2, INTERNAL);
      require_each()(Promise2, INTERNAL);
      require_any()(Promise2);
      util.toFastProperties(Promise2);
      util.toFastProperties(Promise2.prototype);
      function fillTypes(value) {
        var p = new Promise2(INTERNAL);
        p._fulfillmentHandler0 = value;
        p._rejectionHandler0 = value;
        p._promise0 = value;
        p._receiver0 = value;
      }
      fillTypes({ a: 1 });
      fillTypes({ b: 2 });
      fillTypes({ c: 3 });
      fillTypes(1);
      fillTypes(function() {
      });
      fillTypes(void 0);
      fillTypes(false);
      fillTypes(new Promise2(INTERNAL));
      debug.setBounds(Async.firstLineError, util.lastLineError);
      return Promise2;
    };
  }
});

// node_modules/bluebird/js/release/bluebird.js
var require_bluebird = __commonJS({
  "node_modules/bluebird/js/release/bluebird.js"(exports2, module2) {
    "use strict";
    var old;
    if (typeof Promise !== "undefined")
      old = Promise;
    function noConflict() {
      try {
        if (Promise === bluebird)
          Promise = old;
      } catch (e) {
      }
      return bluebird;
    }
    var bluebird = require_promise()();
    bluebird.noConflict = noConflict;
    module2.exports = bluebird;
  }
});

// node_modules/mquery/lib/mquery.js
var require_mquery = __commonJS({
  "node_modules/mquery/lib/mquery.js"(exports2, module2) {
    "use strict";
    var slice = require_sliced();
    var assert = require("assert");
    var util = require("util");
    var utils2 = require_utils7();
    var debug = require_src5()("mquery");
    function Query(criteria, options) {
      if (!(this instanceof Query))
        return new Query(criteria, options);
      var proto = this.constructor.prototype;
      this.op = proto.op || void 0;
      this.options = Object.assign({}, proto.options);
      this._conditions = proto._conditions ? utils2.clone(proto._conditions) : {};
      this._fields = proto._fields ? utils2.clone(proto._fields) : void 0;
      this._update = proto._update ? utils2.clone(proto._update) : void 0;
      this._path = proto._path || void 0;
      this._distinct = proto._distinct || void 0;
      this._collection = proto._collection || void 0;
      this._traceFunction = proto._traceFunction || void 0;
      if (options) {
        this.setOptions(options);
      }
      if (criteria) {
        if (criteria.find && criteria.remove && criteria.update) {
          this.collection(criteria);
        } else {
          this.find(criteria);
        }
      }
    }
    var $withinCmd = "$geoWithin";
    Object.defineProperty(Query, "use$geoWithin", {
      get: function() {
        return $withinCmd == "$geoWithin";
      },
      set: function(v) {
        if (v === true) {
          $withinCmd = "$geoWithin";
        } else {
          $withinCmd = "$within";
        }
      }
    });
    Query.prototype.toConstructor = function toConstructor() {
      function CustomQuery(criteria, options) {
        if (!(this instanceof CustomQuery))
          return new CustomQuery(criteria, options);
        Query.call(this, criteria, options);
      }
      utils2.inherits(CustomQuery, Query);
      var p = CustomQuery.prototype;
      p.options = {};
      p.setOptions(this.options);
      p.op = this.op;
      p._conditions = utils2.clone(this._conditions);
      p._fields = utils2.clone(this._fields);
      p._update = utils2.clone(this._update);
      p._path = this._path;
      p._distinct = this._distinct;
      p._collection = this._collection;
      p._traceFunction = this._traceFunction;
      return CustomQuery;
    };
    Query.prototype.setOptions = function(options) {
      if (!(options && utils2.isObject(options)))
        return this;
      var methods = utils2.keys(options), method;
      for (var i = 0; i < methods.length; ++i) {
        method = methods[i];
        if (typeof this[method] == "function") {
          var args = utils2.isArray(options[method]) ? options[method] : [options[method]];
          this[method].apply(this, args);
        } else {
          this.options[method] = options[method];
        }
      }
      return this;
    };
    Query.prototype.collection = function collection(coll) {
      this._collection = new Query.Collection(coll);
      return this;
    };
    Query.prototype.collation = function(value) {
      this.options.collation = value;
      return this;
    };
    Query.prototype.$where = function(js) {
      this._conditions.$where = js;
      return this;
    };
    Query.prototype.where = function() {
      if (!arguments.length)
        return this;
      if (!this.op)
        this.op = "find";
      var type = typeof arguments[0];
      if (type == "string") {
        this._path = arguments[0];
        if (arguments.length === 2) {
          this._conditions[this._path] = arguments[1];
        }
        return this;
      }
      if (type == "object" && !Array.isArray(arguments[0])) {
        return this.merge(arguments[0]);
      }
      throw new TypeError("path must be a string or object");
    };
    Query.prototype.equals = function equals(val) {
      this._ensurePath("equals");
      var path = this._path;
      this._conditions[path] = val;
      return this;
    };
    Query.prototype.eq = function eq(val) {
      this._ensurePath("eq");
      var path = this._path;
      this._conditions[path] = val;
      return this;
    };
    Query.prototype.or = function or(array) {
      var or2 = this._conditions.$or || (this._conditions.$or = []);
      if (!utils2.isArray(array))
        array = [array];
      or2.push.apply(or2, array);
      return this;
    };
    Query.prototype.nor = function nor(array) {
      var nor2 = this._conditions.$nor || (this._conditions.$nor = []);
      if (!utils2.isArray(array))
        array = [array];
      nor2.push.apply(nor2, array);
      return this;
    };
    Query.prototype.and = function and(array) {
      var and2 = this._conditions.$and || (this._conditions.$and = []);
      if (!Array.isArray(array))
        array = [array];
      and2.push.apply(and2, array);
      return this;
    };
    "gt gte lt lte ne in nin all regex size maxDistance minDistance".split(" ").forEach(function($conditional) {
      Query.prototype[$conditional] = function() {
        var path, val;
        if (arguments.length === 1) {
          this._ensurePath($conditional);
          val = arguments[0];
          path = this._path;
        } else {
          val = arguments[1];
          path = arguments[0];
        }
        var conds = this._conditions[path] === null || typeof this._conditions[path] === "object" ? this._conditions[path] : this._conditions[path] = {};
        conds["$" + $conditional] = val;
        return this;
      };
    });
    Query.prototype.mod = function() {
      var val, path;
      if (arguments.length === 1) {
        this._ensurePath("mod");
        val = arguments[0];
        path = this._path;
      } else if (arguments.length === 2 && !utils2.isArray(arguments[1])) {
        this._ensurePath("mod");
        val = slice(arguments);
        path = this._path;
      } else if (arguments.length === 3) {
        val = slice(arguments, 1);
        path = arguments[0];
      } else {
        val = arguments[1];
        path = arguments[0];
      }
      var conds = this._conditions[path] || (this._conditions[path] = {});
      conds.$mod = val;
      return this;
    };
    Query.prototype.exists = function() {
      var path, val;
      if (arguments.length === 0) {
        this._ensurePath("exists");
        path = this._path;
        val = true;
      } else if (arguments.length === 1) {
        if (typeof arguments[0] === "boolean") {
          this._ensurePath("exists");
          path = this._path;
          val = arguments[0];
        } else {
          path = arguments[0];
          val = true;
        }
      } else if (arguments.length === 2) {
        path = arguments[0];
        val = arguments[1];
      }
      var conds = this._conditions[path] || (this._conditions[path] = {});
      conds.$exists = val;
      return this;
    };
    Query.prototype.elemMatch = function() {
      if (arguments[0] == null)
        throw new TypeError("Invalid argument");
      var fn, path, criteria;
      if (typeof arguments[0] === "function") {
        this._ensurePath("elemMatch");
        path = this._path;
        fn = arguments[0];
      } else if (utils2.isObject(arguments[0])) {
        this._ensurePath("elemMatch");
        path = this._path;
        criteria = arguments[0];
      } else if (typeof arguments[1] === "function") {
        path = arguments[0];
        fn = arguments[1];
      } else if (arguments[1] && utils2.isObject(arguments[1])) {
        path = arguments[0];
        criteria = arguments[1];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (fn) {
        criteria = new Query();
        fn(criteria);
        criteria = criteria._conditions;
      }
      var conds = this._conditions[path] || (this._conditions[path] = {});
      conds.$elemMatch = criteria;
      return this;
    };
    Query.prototype.within = function within() {
      this._ensurePath("within");
      this._geoComparison = $withinCmd;
      if (arguments.length === 0) {
        return this;
      }
      if (arguments.length === 2) {
        return this.box.apply(this, arguments);
      } else if (2 < arguments.length) {
        return this.polygon.apply(this, arguments);
      }
      var area = arguments[0];
      if (!area)
        throw new TypeError("Invalid argument");
      if (area.center)
        return this.circle(area);
      if (area.box)
        return this.box.apply(this, area.box);
      if (area.polygon)
        return this.polygon.apply(this, area.polygon);
      if (area.type && area.coordinates)
        return this.geometry(area);
      throw new TypeError("Invalid argument");
    };
    Query.prototype.box = function() {
      var path, box;
      if (arguments.length === 3) {
        path = arguments[0];
        box = [arguments[1], arguments[2]];
      } else if (arguments.length === 2) {
        this._ensurePath("box");
        path = this._path;
        box = [arguments[0], arguments[1]];
      } else {
        throw new TypeError("Invalid argument");
      }
      var conds = this._conditions[path] || (this._conditions[path] = {});
      conds[this._geoComparison || $withinCmd] = { "$box": box };
      return this;
    };
    Query.prototype.polygon = function() {
      var val, path;
      if (typeof arguments[0] == "string") {
        path = arguments[0];
        val = slice(arguments, 1);
      } else {
        this._ensurePath("polygon");
        path = this._path;
        val = slice(arguments);
      }
      var conds = this._conditions[path] || (this._conditions[path] = {});
      conds[this._geoComparison || $withinCmd] = { "$polygon": val };
      return this;
    };
    Query.prototype.circle = function() {
      var path, val;
      if (arguments.length === 1) {
        this._ensurePath("circle");
        path = this._path;
        val = arguments[0];
      } else if (arguments.length === 2) {
        path = arguments[0];
        val = arguments[1];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (!("radius" in val && val.center))
        throw new Error("center and radius are required");
      var conds = this._conditions[path] || (this._conditions[path] = {});
      var type = val.spherical ? "$centerSphere" : "$center";
      var wKey = this._geoComparison || $withinCmd;
      conds[wKey] = {};
      conds[wKey][type] = [val.center, val.radius];
      if ("unique" in val)
        conds[wKey].$uniqueDocs = !!val.unique;
      return this;
    };
    Query.prototype.near = function near() {
      var path, val;
      this._geoComparison = "$near";
      if (arguments.length === 0) {
        return this;
      } else if (arguments.length === 1) {
        this._ensurePath("near");
        path = this._path;
        val = arguments[0];
      } else if (arguments.length === 2) {
        path = arguments[0];
        val = arguments[1];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (!val.center) {
        throw new Error("center is required");
      }
      var conds = this._conditions[path] || (this._conditions[path] = {});
      var type = val.spherical ? "$nearSphere" : "$near";
      if (Array.isArray(val.center)) {
        conds[type] = val.center;
        var radius = "maxDistance" in val ? val.maxDistance : null;
        if (radius != null) {
          conds.$maxDistance = radius;
        }
        if (val.minDistance != null) {
          conds.$minDistance = val.minDistance;
        }
      } else {
        if (val.center.type != "Point" || !Array.isArray(val.center.coordinates)) {
          throw new Error(util.format("Invalid GeoJSON specified for %s", type));
        }
        conds[type] = { $geometry: val.center };
        if ("maxDistance" in val) {
          conds[type]["$maxDistance"] = val.maxDistance;
        }
        if ("minDistance" in val) {
          conds[type]["$minDistance"] = val.minDistance;
        }
      }
      return this;
    };
    Query.prototype.intersects = function intersects() {
      this._ensurePath("intersects");
      this._geoComparison = "$geoIntersects";
      if (arguments.length === 0) {
        return this;
      }
      var area = arguments[0];
      if (area != null && area.type && area.coordinates)
        return this.geometry(area);
      throw new TypeError("Invalid argument");
    };
    Query.prototype.geometry = function geometry() {
      if (!(this._geoComparison == "$within" || this._geoComparison == "$geoWithin" || this._geoComparison == "$near" || this._geoComparison == "$geoIntersects")) {
        throw new Error("geometry() must come after `within()`, `intersects()`, or `near()");
      }
      var val, path;
      if (arguments.length === 1) {
        this._ensurePath("geometry");
        path = this._path;
        val = arguments[0];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (!(val.type && Array.isArray(val.coordinates))) {
        throw new TypeError("Invalid argument");
      }
      var conds = this._conditions[path] || (this._conditions[path] = {});
      conds[this._geoComparison] = { $geometry: val };
      return this;
    };
    Query.prototype.select = function select() {
      var arg = arguments[0];
      if (!arg)
        return this;
      if (arguments.length !== 1) {
        throw new Error("Invalid select: select only takes 1 argument");
      }
      this._validate("select");
      var fields = this._fields || (this._fields = {});
      var type = typeof arg;
      var i, len;
      if ((type == "string" || utils2.isArgumentsObject(arg)) && typeof arg.length == "number" || Array.isArray(arg)) {
        if (type == "string")
          arg = arg.split(/\s+/);
        for (i = 0, len = arg.length; i < len; ++i) {
          var field = arg[i];
          if (!field)
            continue;
          var include = field[0] == "-" ? 0 : 1;
          if (include === 0)
            field = field.substring(1);
          fields[field] = include;
        }
        return this;
      }
      if (utils2.isObject(arg)) {
        var keys = utils2.keys(arg);
        for (i = 0; i < keys.length; ++i) {
          fields[keys[i]] = arg[keys[i]];
        }
        return this;
      }
      throw new TypeError("Invalid select() argument. Must be string or object.");
    };
    Query.prototype.slice = function() {
      if (arguments.length === 0)
        return this;
      this._validate("slice");
      var path, val;
      if (arguments.length === 1) {
        var arg = arguments[0];
        if (typeof arg === "object" && !Array.isArray(arg)) {
          var keys = Object.keys(arg);
          var numKeys = keys.length;
          for (var i = 0; i < numKeys; ++i) {
            this.slice(keys[i], arg[keys[i]]);
          }
          return this;
        }
        this._ensurePath("slice");
        path = this._path;
        val = arguments[0];
      } else if (arguments.length === 2) {
        if (typeof arguments[0] === "number") {
          this._ensurePath("slice");
          path = this._path;
          val = slice(arguments);
        } else {
          path = arguments[0];
          val = arguments[1];
        }
      } else if (arguments.length === 3) {
        path = arguments[0];
        val = slice(arguments, 1);
      }
      var myFields = this._fields || (this._fields = {});
      myFields[path] = { "$slice": val };
      return this;
    };
    Query.prototype.sort = function(arg) {
      if (!arg)
        return this;
      var i, len, field;
      this._validate("sort");
      var type = typeof arg;
      if (Array.isArray(arg)) {
        len = arg.length;
        for (i = 0; i < arg.length; ++i) {
          if (!Array.isArray(arg[i])) {
            throw new Error("Invalid sort() argument, must be array of arrays");
          }
          _pushArr(this.options, arg[i][0], arg[i][1]);
        }
        return this;
      }
      if (arguments.length === 1 && type == "string") {
        arg = arg.split(/\s+/);
        len = arg.length;
        for (i = 0; i < len; ++i) {
          field = arg[i];
          if (!field)
            continue;
          var ascend = field[0] == "-" ? -1 : 1;
          if (ascend === -1)
            field = field.substring(1);
          push(this.options, field, ascend);
        }
        return this;
      }
      if (utils2.isObject(arg)) {
        var keys = utils2.keys(arg);
        for (i = 0; i < keys.length; ++i) {
          field = keys[i];
          push(this.options, field, arg[field]);
        }
        return this;
      }
      if (typeof Map !== "undefined" && arg instanceof Map) {
        _pushMap(this.options, arg);
        return this;
      }
      throw new TypeError("Invalid sort() argument. Must be a string, object, or array.");
    };
    var _validSortValue = {
      "1": 1,
      "-1": -1,
      "asc": 1,
      "ascending": 1,
      "desc": -1,
      "descending": -1
    };
    function push(opts, field, value) {
      if (Array.isArray(opts.sort)) {
        throw new TypeError("Can't mix sort syntaxes. Use either array or object:\n- `.sort([['field', 1], ['test', -1]])`\n- `.sort({ field: 1, test: -1 })`");
      }
      var s;
      if (value && value.$meta) {
        s = opts.sort || (opts.sort = {});
        s[field] = { $meta: value.$meta };
        return;
      }
      s = opts.sort || (opts.sort = {});
      var val = String(value || 1).toLowerCase();
      val = _validSortValue[val];
      if (!val)
        throw new TypeError("Invalid sort value: { " + field + ": " + value + " }");
      s[field] = val;
    }
    function _pushArr(opts, field, value) {
      opts.sort = opts.sort || [];
      if (!Array.isArray(opts.sort)) {
        throw new TypeError("Can't mix sort syntaxes. Use either array or object:\n- `.sort([['field', 1], ['test', -1]])`\n- `.sort({ field: 1, test: -1 })`");
      }
      var val = String(value || 1).toLowerCase();
      val = _validSortValue[val];
      if (!val)
        throw new TypeError("Invalid sort value: [ " + field + ", " + value + " ]");
      opts.sort.push([field, val]);
    }
    function _pushMap(opts, map) {
      opts.sort = opts.sort || new Map();
      if (!(opts.sort instanceof Map)) {
        throw new TypeError("Can't mix sort syntaxes. Use either array or object or map consistently");
      }
      map.forEach(function(value, key) {
        var val = String(value || 1).toLowerCase();
        val = _validSortValue[val];
        if (!val)
          throw new TypeError("Invalid sort value: < " + key + ": " + value + " >");
        opts.sort.set(key, val);
      });
    }
    ["limit", "skip", "maxScan", "batchSize", "comment"].forEach(function(method) {
      Query.prototype[method] = function(v) {
        this._validate(method);
        this.options[method] = v;
        return this;
      };
    });
    Query.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {
      this._validate("maxTime");
      this.options.maxTimeMS = ms;
      return this;
    };
    Query.prototype.snapshot = function() {
      this._validate("snapshot");
      this.options.snapshot = arguments.length ? !!arguments[0] : true;
      return this;
    };
    Query.prototype.hint = function() {
      if (arguments.length === 0)
        return this;
      this._validate("hint");
      var arg = arguments[0];
      if (utils2.isObject(arg)) {
        var hint = this.options.hint || (this.options.hint = {});
        for (var k in arg) {
          hint[k] = arg[k];
        }
        return this;
      }
      if (typeof arg === "string") {
        this.options.hint = arg;
        return this;
      }
      throw new TypeError("Invalid hint. " + arg);
    };
    Query.prototype.j = function j(val) {
      this.options.j = val;
      return this;
    };
    Query.prototype.slaveOk = function(v) {
      this.options.slaveOk = arguments.length ? !!v : true;
      return this;
    };
    Query.prototype.read = Query.prototype.setReadPreference = function(pref) {
      if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {
        console.error("Deprecation warning: 'tags' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.");
        Query.prototype.read.deprecationWarningIssued = true;
      }
      this.options.readPreference = utils2.readPref(pref);
      return this;
    };
    Query.prototype.readConcern = Query.prototype.r = function(level) {
      this.options.readConcern = utils2.readConcern(level);
      return this;
    };
    Query.prototype.tailable = function() {
      this._validate("tailable");
      this.options.tailable = arguments.length ? !!arguments[0] : true;
      return this;
    };
    Query.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {
      if (typeof concern === "object") {
        if (typeof concern.j !== "undefined")
          this.options.j = concern.j;
        if (typeof concern.w !== "undefined")
          this.options.w = concern.w;
        if (typeof concern.wtimeout !== "undefined")
          this.options.wtimeout = concern.wtimeout;
      } else {
        this.options.w = concern === "m" ? "majority" : concern;
      }
      return this;
    };
    Query.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {
      this.options.wtimeout = ms;
      return this;
    };
    Query.prototype.merge = function(source) {
      if (!source)
        return this;
      if (!Query.canMerge(source))
        throw new TypeError("Invalid argument. Expected instanceof mquery or plain object");
      if (source instanceof Query) {
        if (source._conditions) {
          utils2.merge(this._conditions, source._conditions);
        }
        if (source._fields) {
          this._fields || (this._fields = {});
          utils2.merge(this._fields, source._fields);
        }
        if (source.options) {
          this.options || (this.options = {});
          utils2.merge(this.options, source.options);
        }
        if (source._update) {
          this._update || (this._update = {});
          utils2.mergeClone(this._update, source._update);
        }
        if (source._distinct) {
          this._distinct = source._distinct;
        }
        return this;
      }
      utils2.merge(this._conditions, source);
      return this;
    };
    Query.prototype.find = function(criteria, callback) {
      this.op = "find";
      if (typeof criteria === "function") {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback)
        return this;
      var conds = this._conditions;
      var options = this._optionsForExec();
      if (this.$useProjection) {
        options.projection = this._fieldsForExec();
      } else {
        options.fields = this._fieldsForExec();
      }
      debug("find", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("find", callback, {
        conditions: conds,
        options
      });
      this._collection.find(conds, options, utils2.tick(callback));
      return this;
    };
    Query.prototype.cursor = function cursor(criteria) {
      if (this.op) {
        if (this.op !== "find") {
          throw new TypeError(".cursor only support .find method");
        }
      } else {
        this.find(criteria);
      }
      var conds = this._conditions;
      var options = this._optionsForExec();
      if (this.$useProjection) {
        options.projection = this._fieldsForExec();
      } else {
        options.fields = this._fieldsForExec();
      }
      debug("findCursor", this._collection.collectionName, conds, options);
      return this._collection.findCursor(conds, options);
    };
    Query.prototype.findOne = function(criteria, callback) {
      this.op = "findOne";
      if (typeof criteria === "function") {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback)
        return this;
      var conds = this._conditions;
      var options = this._optionsForExec();
      if (this.$useProjection) {
        options.projection = this._fieldsForExec();
      } else {
        options.fields = this._fieldsForExec();
      }
      debug("findOne", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("findOne", callback, {
        conditions: conds,
        options
      });
      this._collection.findOne(conds, options, utils2.tick(callback));
      return this;
    };
    Query.prototype.count = function(criteria, callback) {
      this.op = "count";
      this._validate();
      if (typeof criteria === "function") {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback)
        return this;
      var conds = this._conditions, options = this._optionsForExec();
      debug("count", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("count", callback, {
        conditions: conds,
        options
      });
      this._collection.count(conds, options, utils2.tick(callback));
      return this;
    };
    Query.prototype.distinct = function(criteria, field, callback) {
      this.op = "distinct";
      this._validate();
      if (!callback) {
        switch (typeof field) {
          case "function":
            callback = field;
            if (typeof criteria == "string") {
              field = criteria;
              criteria = void 0;
            }
            break;
          case "undefined":
          case "string":
            break;
          default:
            throw new TypeError("Invalid `field` argument. Must be string or function");
        }
        switch (typeof criteria) {
          case "function":
            callback = criteria;
            criteria = field = void 0;
            break;
          case "string":
            field = criteria;
            criteria = void 0;
            break;
        }
      }
      if (typeof field == "string") {
        this._distinct = field;
      }
      if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback) {
        return this;
      }
      if (!this._distinct) {
        throw new Error("No value for `distinct` has been declared");
      }
      var conds = this._conditions, options = this._optionsForExec();
      debug("distinct", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("distinct", callback, {
        conditions: conds,
        options
      });
      this._collection.distinct(this._distinct, conds, options, utils2.tick(callback));
      return this;
    };
    Query.prototype.update = function update(criteria, doc, options, callback) {
      var force;
      switch (arguments.length) {
        case 3:
          if (typeof options == "function") {
            callback = options;
            options = void 0;
          }
          break;
        case 2:
          if (typeof doc == "function") {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options = void 0;
              break;
          }
      }
      return _update(this, "update", criteria, doc, options, force, callback);
    };
    Query.prototype.updateMany = function updateMany(criteria, doc, options, callback) {
      var force;
      switch (arguments.length) {
        case 3:
          if (typeof options == "function") {
            callback = options;
            options = void 0;
          }
          break;
        case 2:
          if (typeof doc == "function") {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options = void 0;
              break;
          }
      }
      return _update(this, "updateMany", criteria, doc, options, force, callback);
    };
    Query.prototype.updateOne = function updateOne(criteria, doc, options, callback) {
      var force;
      switch (arguments.length) {
        case 3:
          if (typeof options == "function") {
            callback = options;
            options = void 0;
          }
          break;
        case 2:
          if (typeof doc == "function") {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options = void 0;
              break;
          }
      }
      return _update(this, "updateOne", criteria, doc, options, force, callback);
    };
    Query.prototype.replaceOne = function replaceOne(criteria, doc, options, callback) {
      var force;
      switch (arguments.length) {
        case 3:
          if (typeof options == "function") {
            callback = options;
            options = void 0;
          }
          break;
        case 2:
          if (typeof doc == "function") {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options = void 0;
              break;
          }
      }
      this.setOptions({ overwrite: true });
      return _update(this, "replaceOne", criteria, doc, options, force, callback);
    };
    function _update(query, op, criteria, doc, options, force, callback) {
      query.op = op;
      if (Query.canMerge(criteria)) {
        query.merge(criteria);
      }
      if (doc) {
        query._mergeUpdate(doc);
      }
      if (utils2.isObject(options)) {
        query.setOptions(options);
      }
      if (!(force || callback)) {
        return query;
      }
      if (!query._update || !query.options.overwrite && utils2.keys(query._update).length === 0) {
        callback && utils2.soon(callback.bind(null, null, 0));
        return query;
      }
      options = query._optionsForExec();
      if (!callback)
        options.safe = false;
      criteria = query._conditions;
      doc = query._updateForExec();
      debug("update", query._collection.collectionName, criteria, doc, options);
      callback = query._wrapCallback(op, callback, {
        conditions: criteria,
        doc,
        options
      });
      query._collection[op](criteria, doc, options, utils2.tick(callback));
      return query;
    }
    Query.prototype.remove = function(criteria, callback) {
      this.op = "remove";
      var force;
      if (typeof criteria === "function") {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      } else if (criteria === true) {
        force = criteria;
        criteria = void 0;
      }
      if (!(force || callback))
        return this;
      var options = this._optionsForExec();
      if (!callback)
        options.safe = false;
      var conds = this._conditions;
      debug("remove", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("remove", callback, {
        conditions: conds,
        options
      });
      this._collection.remove(conds, options, utils2.tick(callback));
      return this;
    };
    Query.prototype.deleteOne = function(criteria, callback) {
      this.op = "deleteOne";
      var force;
      if (typeof criteria === "function") {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      } else if (criteria === true) {
        force = criteria;
        criteria = void 0;
      }
      if (!(force || callback))
        return this;
      var options = this._optionsForExec();
      if (!callback)
        options.safe = false;
      delete options.justOne;
      var conds = this._conditions;
      debug("deleteOne", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("deleteOne", callback, {
        conditions: conds,
        options
      });
      this._collection.deleteOne(conds, options, utils2.tick(callback));
      return this;
    };
    Query.prototype.deleteMany = function(criteria, callback) {
      this.op = "deleteMany";
      var force;
      if (typeof criteria === "function") {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      } else if (criteria === true) {
        force = criteria;
        criteria = void 0;
      }
      if (!(force || callback))
        return this;
      var options = this._optionsForExec();
      if (!callback)
        options.safe = false;
      delete options.justOne;
      var conds = this._conditions;
      debug("deleteOne", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("deleteOne", callback, {
        conditions: conds,
        options
      });
      this._collection.deleteMany(conds, options, utils2.tick(callback));
      return this;
    };
    Query.prototype.findOneAndUpdate = function(criteria, doc, options, callback) {
      this.op = "findOneAndUpdate";
      this._validate();
      switch (arguments.length) {
        case 3:
          if (typeof options == "function") {
            callback = options;
            options = {};
          }
          break;
        case 2:
          if (typeof doc == "function") {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          options = void 0;
          break;
        case 1:
          if (typeof criteria == "function") {
            callback = criteria;
            criteria = options = doc = void 0;
          } else {
            doc = criteria;
            criteria = options = void 0;
          }
      }
      if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (doc) {
        this._mergeUpdate(doc);
      }
      options && this.setOptions(options);
      if (!callback)
        return this;
      return this._findAndModify("update", callback);
    };
    Query.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options, callback) {
      this.op = "findOneAndRemove";
      this._validate();
      if (typeof options == "function") {
        callback = options;
        options = void 0;
      } else if (typeof conditions == "function") {
        callback = conditions;
        conditions = void 0;
      }
      if (Query.canMerge(conditions)) {
        this.merge(conditions);
      }
      options && this.setOptions(options);
      if (!callback)
        return this;
      return this._findAndModify("remove", callback);
    };
    Query.prototype._findAndModify = function(type, callback) {
      assert.equal("function", typeof callback);
      var options = this._optionsForExec();
      var fields;
      var doc;
      if (type == "remove") {
        options.remove = true;
      } else {
        if (!("new" in options))
          options.new = true;
        if (!("upsert" in options))
          options.upsert = false;
        doc = this._updateForExec();
        if (!doc) {
          if (options.upsert) {
            doc = { $set: {} };
          } else {
            return this.findOne(callback);
          }
        }
      }
      fields = this._fieldsForExec();
      if (fields != null) {
        if (this.$useProjection) {
          options.projection = this._fieldsForExec();
        } else {
          options.fields = this._fieldsForExec();
        }
      }
      var conds = this._conditions;
      debug("findAndModify", this._collection.collectionName, conds, doc, options);
      callback = this._wrapCallback("findAndModify", callback, {
        conditions: conds,
        doc,
        options
      });
      this._collection.findAndModify(conds, doc, options, utils2.tick(callback));
      return this;
    };
    Query.prototype._wrapCallback = function(method, callback, queryInfo) {
      var traceFunction = this._traceFunction || Query.traceFunction;
      if (traceFunction) {
        queryInfo.collectionName = this._collection.collectionName;
        var traceCallback = traceFunction && traceFunction.call(null, method, queryInfo, this);
        var startTime = new Date().getTime();
        return function wrapperCallback(err, result) {
          if (traceCallback) {
            var millis = new Date().getTime() - startTime;
            traceCallback.call(null, err, result, millis);
          }
          if (callback) {
            callback.apply(null, arguments);
          }
        };
      }
      return callback;
    };
    Query.prototype.setTraceFunction = function(traceFunction) {
      this._traceFunction = traceFunction;
      return this;
    };
    Query.prototype.exec = function exec(op, callback) {
      switch (typeof op) {
        case "function":
          callback = op;
          op = null;
          break;
        case "string":
          this.op = op;
          break;
      }
      assert.ok(this.op, "Missing query type: (find, update, etc)");
      if (this.op == "update" || this.op == "remove") {
        callback || (callback = true);
      }
      var _this = this;
      if (typeof callback == "function") {
        this[this.op](callback);
      } else {
        return new Query.Promise(function(success, error) {
          _this[_this.op](function(err, val) {
            if (err)
              error(err);
            else
              success(val);
            success = error = null;
          });
        });
      }
    };
    Query.prototype.thunk = function() {
      var _this = this;
      return function(cb) {
        _this.exec(cb);
      };
    };
    Query.prototype.then = function(resolve, reject) {
      var _this = this;
      var promise = new Query.Promise(function(success, error) {
        _this.exec(function(err, val) {
          if (err)
            error(err);
          else
            success(val);
          success = error = null;
        });
      });
      return promise.then(resolve, reject);
    };
    Query.prototype.stream = function(streamOptions) {
      if (this.op != "find")
        throw new Error("stream() is only available for find");
      var conds = this._conditions;
      var options = this._optionsForExec();
      if (this.$useProjection) {
        options.projection = this._fieldsForExec();
      } else {
        options.fields = this._fieldsForExec();
      }
      debug("stream", this._collection.collectionName, conds, options, streamOptions);
      return this._collection.findStream(conds, options, streamOptions);
    };
    Query.prototype.selected = function selected() {
      return !!(this._fields && Object.keys(this._fields).length > 0);
    };
    Query.prototype.selectedInclusively = function selectedInclusively() {
      if (!this._fields)
        return false;
      var keys = Object.keys(this._fields);
      if (keys.length === 0)
        return false;
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (this._fields[key] === 0)
          return false;
        if (this._fields[key] && typeof this._fields[key] === "object" && this._fields[key].$meta) {
          return false;
        }
      }
      return true;
    };
    Query.prototype.selectedExclusively = function selectedExclusively() {
      if (!this._fields)
        return false;
      var keys = Object.keys(this._fields);
      if (keys.length === 0)
        return false;
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (this._fields[key] === 0)
          return true;
      }
      return false;
    };
    Query.prototype._mergeUpdate = function(doc) {
      if (!this._update)
        this._update = {};
      if (doc instanceof Query) {
        if (doc._update) {
          utils2.mergeClone(this._update, doc._update);
        }
      } else {
        utils2.mergeClone(this._update, doc);
      }
    };
    Query.prototype._optionsForExec = function() {
      var options = utils2.clone(this.options);
      return options;
    };
    Query.prototype._fieldsForExec = function() {
      return utils2.clone(this._fields);
    };
    Query.prototype._updateForExec = function() {
      var update = utils2.clone(this._update), ops = utils2.keys(update), i = ops.length, ret2 = {};
      while (i--) {
        var op = ops[i];
        if (this.options.overwrite) {
          ret2[op] = update[op];
          continue;
        }
        if (op[0] !== "$") {
          if (!ret2.$set) {
            if (update.$set) {
              ret2.$set = update.$set;
            } else {
              ret2.$set = {};
            }
          }
          ret2.$set[op] = update[op];
          ops.splice(i, 1);
          if (!~ops.indexOf("$set"))
            ops.push("$set");
        } else if (op === "$set") {
          if (!ret2.$set) {
            ret2[op] = update[op];
          }
        } else {
          ret2[op] = update[op];
        }
      }
      this._compiledUpdate = ret2;
      return ret2;
    };
    Query.prototype._ensurePath = function(method) {
      if (!this._path) {
        var msg = method + "() must be used after where() when called with these arguments";
        throw new Error(msg);
      }
    };
    Query.permissions = require_permissions();
    Query._isPermitted = function(a, b) {
      var denied = Query.permissions[b];
      if (!denied)
        return true;
      return denied[a] !== true;
    };
    Query.prototype._validate = function(action) {
      var fail;
      var validator;
      if (action === void 0) {
        validator = Query.permissions[this.op];
        if (typeof validator != "function")
          return true;
        fail = validator(this);
      } else if (!Query._isPermitted(action, this.op)) {
        fail = action;
      }
      if (fail) {
        throw new Error(fail + " cannot be used with " + this.op);
      }
    };
    Query.canMerge = function(conds) {
      return conds instanceof Query || utils2.isObject(conds);
    };
    Query.setGlobalTraceFunction = function(traceFunction) {
      Query.traceFunction = traceFunction;
    };
    Query.utils = utils2;
    Query.env = require_env();
    Query.Collection = require_collection4();
    Query.BaseCollection = require_collection3();
    Query.Promise = require_bluebird();
    module2.exports = exports2 = Query;
  }
});

// node_modules/mongoose/lib/promise_provider.js
var require_promise_provider = __commonJS({
  "node_modules/mongoose/lib/promise_provider.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var mquery = require_mquery();
    var store = {
      _promise: null
    };
    store.get = function() {
      return store._promise;
    };
    store.set = function(lib) {
      assert.ok(typeof lib === "function", `mongoose.Promise must be a function, got ${lib}`);
      store._promise = lib;
      mquery.Promise = lib;
    };
    store.set(global.Promise);
    module2.exports = store;
  }
});

// node_modules/mongoose/lib/helpers/promiseOrCallback.js
var require_promiseOrCallback = __commonJS({
  "node_modules/mongoose/lib/helpers/promiseOrCallback.js"(exports2, module2) {
    "use strict";
    var PromiseProvider = require_promise_provider();
    var immediate = require_immediate();
    var emittedSymbol = Symbol("mongoose:emitted");
    module2.exports = function promiseOrCallback(callback, fn, ee, Promise2) {
      if (typeof callback === "function") {
        return fn(function(error) {
          if (error != null) {
            if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
              error[emittedSymbol] = true;
              ee.emit("error", error);
            }
            try {
              callback(error);
            } catch (error2) {
              return immediate(() => {
                throw error2;
              });
            }
            return;
          }
          callback.apply(this, arguments);
        });
      }
      Promise2 = Promise2 || PromiseProvider.get();
      return new Promise2((resolve, reject) => {
        fn(function(error, res) {
          if (error != null) {
            if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
              error[emittedSymbol] = true;
              ee.emit("error", error);
            }
            return reject(error);
          }
          if (arguments.length > 2) {
            return resolve(Array.prototype.slice.call(arguments, 1));
          }
          resolve(res);
        });
      });
    };
  }
});

// node_modules/mongoose/lib/helpers/schema/merge.js
var require_merge = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/merge.js"(exports2, module2) {
    "use strict";
    module2.exports = function merge(s1, s2, skipConflictingPaths) {
      const paths = Object.keys(s2.tree);
      const pathsToAdd = {};
      for (const key of paths) {
        if (skipConflictingPaths && (s1.paths[key] || s1.nested[key] || s1.singleNestedPaths[key])) {
          continue;
        }
        pathsToAdd[key] = s2.tree[key];
      }
      s1.add(pathsToAdd);
      s1.callQueue = s1.callQueue.concat(s2.callQueue);
      s1.method(s2.methods);
      s1.static(s2.statics);
      for (const query in s2.query) {
        s1.query[query] = s2.query[query];
      }
      for (const virtual in s2.virtuals) {
        s1.virtuals[virtual] = s2.virtuals[virtual].clone();
      }
      s1.s.hooks.merge(s2.s.hooks, false);
    };
  }
});

// node_modules/mongoose/lib/statemachine.js
var require_statemachine = __commonJS({
  "node_modules/mongoose/lib/statemachine.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    var StateMachine = module2.exports = exports2 = function StateMachine2() {
    };
    StateMachine.ctor = function() {
      const states = utils2.args(arguments);
      const ctor = function() {
        StateMachine.apply(this, arguments);
        this.paths = {};
        this.states = {};
        this.stateNames = states;
        let i = states.length, state;
        while (i--) {
          state = states[i];
          this.states[state] = {};
        }
      };
      ctor.prototype = new StateMachine();
      states.forEach(function(state) {
        ctor.prototype[state] = function(path) {
          this._changeState(path, state);
        };
      });
      return ctor;
    };
    StateMachine.prototype._changeState = function _changeState(path, nextState) {
      const prevBucket = this.states[this.paths[path]];
      if (prevBucket)
        delete prevBucket[path];
      this.paths[path] = nextState;
      this.states[nextState][path] = true;
    };
    StateMachine.prototype.clear = function clear(state) {
      const keys = Object.keys(this.states[state]);
      let i = keys.length;
      let path;
      while (i--) {
        path = keys[i];
        delete this.states[state][path];
        delete this.paths[path];
      }
    };
    StateMachine.prototype.some = function some() {
      const _this = this;
      const what = arguments.length ? arguments : this.stateNames;
      return Array.prototype.some.call(what, function(state) {
        return Object.keys(_this.states[state]).length;
      });
    };
    StateMachine.prototype._iter = function _iter(iterMethod) {
      return function() {
        const numArgs = arguments.length;
        let states = utils2.args(arguments, 0, numArgs - 1);
        const callback = arguments[numArgs - 1];
        if (!states.length)
          states = this.stateNames;
        const _this = this;
        const paths = states.reduce(function(paths2, state) {
          return paths2.concat(Object.keys(_this.states[state]));
        }, []);
        return paths[iterMethod](function(path, i, paths2) {
          return callback(path, i, paths2);
        });
      };
    };
    StateMachine.prototype.forEach = function forEach() {
      this.forEach = this._iter("forEach");
      return this.forEach.apply(this, arguments);
    };
    StateMachine.prototype.map = function map() {
      this.map = this._iter("map");
      return this.map.apply(this, arguments);
    };
  }
});

// node_modules/mongoose/lib/internal.js
var require_internal2 = __commonJS({
  "node_modules/mongoose/lib/internal.js"(exports2, module2) {
    "use strict";
    var StateMachine = require_statemachine();
    var ActiveRoster = StateMachine.ctor("require", "modify", "init", "default", "ignore");
    module2.exports = exports2 = InternalCache;
    function InternalCache() {
      this.strictMode = void 0;
      this.selected = void 0;
      this.shardval = void 0;
      this.saveError = void 0;
      this.validationError = void 0;
      this.adhocPaths = void 0;
      this.removing = void 0;
      this.inserting = void 0;
      this.saving = void 0;
      this.version = void 0;
      this.getters = {};
      this._id = void 0;
      this.populate = void 0;
      this.populated = void 0;
      this.wasPopulated = false;
      this.scope = void 0;
      this.activePaths = new ActiveRoster();
      this.pathsToScopes = {};
      this.cachedRequired = {};
      this.session = null;
      this.$setCalled = new Set();
      this.ownerDocument = void 0;
      this.fullPath = void 0;
    }
  }
});

// node_modules/mongoose/lib/error/messages.js
var require_messages = __commonJS({
  "node_modules/mongoose/lib/error/messages.js"(exports2, module2) {
    "use strict";
    var msg = module2.exports = exports2 = {};
    msg.DocumentNotFoundError = null;
    msg.general = {};
    msg.general.default = "Validator failed for path `{PATH}` with value `{VALUE}`";
    msg.general.required = "Path `{PATH}` is required.";
    msg.Number = {};
    msg.Number.min = "Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).";
    msg.Number.max = "Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).";
    msg.Number.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
    msg.Date = {};
    msg.Date.min = "Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).";
    msg.Date.max = "Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).";
    msg.String = {};
    msg.String.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
    msg.String.match = "Path `{PATH}` is invalid ({VALUE}).";
    msg.String.minlength = "Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).";
    msg.String.maxlength = "Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).";
  }
});

// node_modules/mongoose/lib/error/notFound.js
var require_notFound = __commonJS({
  "node_modules/mongoose/lib/error/notFound.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var util = require("util");
    var DocumentNotFoundError = class extends MongooseError {
      constructor(filter, model2, numAffected, result) {
        let msg;
        const messages = MongooseError.messages;
        if (messages.DocumentNotFoundError != null) {
          msg = typeof messages.DocumentNotFoundError === "function" ? messages.DocumentNotFoundError(filter, model2) : messages.DocumentNotFoundError;
        } else {
          msg = 'No document found for query "' + util.inspect(filter) + '" on model "' + model2 + '"';
        }
        super(msg);
        this.result = result;
        this.numAffected = numAffected;
        this.filter = filter;
        this.query = filter;
      }
    };
    Object.defineProperty(DocumentNotFoundError.prototype, "name", {
      value: "DocumentNotFoundError"
    });
    module2.exports = DocumentNotFoundError;
  }
});

// node_modules/mongoose/lib/error/cast.js
var require_cast = __commonJS({
  "node_modules/mongoose/lib/error/cast.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var get = require_get();
    var util = require("util");
    var CastError = class extends MongooseError {
      constructor(type, value, path, reason, schemaType) {
        if (arguments.length > 0) {
          const stringValue = getStringValue(value);
          const valueType = getValueType(value);
          const messageFormat = getMessageFormat(schemaType);
          const msg = formatMessage(null, type, stringValue, path, messageFormat, valueType);
          super(msg);
          this.init(type, value, path, reason, schemaType);
        } else {
          super(formatMessage());
        }
      }
      toJSON() {
        return {
          stringValue: this.stringValue,
          valueType: this.valueType,
          kind: this.kind,
          value: this.value,
          path: this.path,
          reason: this.reason,
          name: this.name,
          message: this.message
        };
      }
      init(type, value, path, reason, schemaType) {
        this.stringValue = getStringValue(value);
        this.messageFormat = getMessageFormat(schemaType);
        this.kind = type;
        this.value = value;
        this.path = path;
        this.reason = reason;
        this.valueType = getValueType(value);
      }
      copy(other) {
        this.messageFormat = other.messageFormat;
        this.stringValue = other.stringValue;
        this.kind = other.kind;
        this.value = other.value;
        this.path = other.path;
        this.reason = other.reason;
        this.message = other.message;
        this.valueType = other.valueType;
      }
      setModel(model2) {
        this.model = model2;
        this.message = formatMessage(model2, this.kind, this.stringValue, this.path, this.messageFormat, this.valueType);
      }
    };
    Object.defineProperty(CastError.prototype, "name", {
      value: "CastError"
    });
    function getStringValue(value) {
      let stringValue = util.inspect(value);
      stringValue = stringValue.replace(/^'|'$/g, '"');
      if (!stringValue.startsWith('"')) {
        stringValue = '"' + stringValue + '"';
      }
      return stringValue;
    }
    function getValueType(value) {
      if (value == null) {
        return "" + value;
      }
      const t = typeof value;
      if (t !== "object") {
        return t;
      }
      if (typeof value.constructor !== "function") {
        return t;
      }
      return value.constructor.name;
    }
    function getMessageFormat(schemaType) {
      const messageFormat = get(schemaType, "options.cast", null);
      if (typeof messageFormat === "string") {
        return messageFormat;
      }
    }
    function formatMessage(model2, kind, stringValue, path, messageFormat, valueType) {
      if (messageFormat != null) {
        let ret2 = messageFormat.replace("{KIND}", kind).replace("{VALUE}", stringValue).replace("{PATH}", path);
        if (model2 != null) {
          ret2 = ret2.replace("{MODEL}", model2.modelName);
        }
        return ret2;
      } else {
        const valueTypeMsg = valueType ? " (type " + valueType + ")" : "";
        let ret2 = "Cast to " + kind + " failed for value " + stringValue + valueTypeMsg + ' at path "' + path + '"';
        if (model2 != null) {
          ret2 += ' for model "' + model2.modelName + '"';
        }
        return ret2;
      }
    }
    module2.exports = CastError;
  }
});

// node_modules/mongoose/lib/error/validation.js
var require_validation = __commonJS({
  "node_modules/mongoose/lib/error/validation.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var getConstructorName = require_getConstructorName();
    var util = require("util");
    var ValidationError = class extends MongooseError {
      constructor(instance) {
        let _message;
        if (getConstructorName(instance) === "model") {
          _message = instance.constructor.modelName + " validation failed";
        } else {
          _message = "Validation failed";
        }
        super(_message);
        this.errors = {};
        this._message = _message;
        if (instance) {
          instance.errors = this.errors;
        }
      }
      toString() {
        return this.name + ": " + _generateMessage(this);
      }
      inspect() {
        return Object.assign(new Error(this.message), this);
      }
      addError(path, error) {
        this.errors[path] = error;
        this.message = this._message + ": " + _generateMessage(this);
      }
    };
    if (util.inspect.custom) {
      ValidationError.prototype[util.inspect.custom] = ValidationError.prototype.inspect;
    }
    Object.defineProperty(ValidationError.prototype, "toJSON", {
      enumerable: false,
      writable: false,
      configurable: true,
      value: function() {
        return Object.assign({}, this, { name: this.name, message: this.message });
      }
    });
    Object.defineProperty(ValidationError.prototype, "name", {
      value: "ValidationError"
    });
    function _generateMessage(err) {
      const keys = Object.keys(err.errors || {});
      const len = keys.length;
      const msgs = [];
      let key;
      for (let i = 0; i < len; ++i) {
        key = keys[i];
        if (err === err.errors[key]) {
          continue;
        }
        msgs.push(key + ": " + err.errors[key].message);
      }
      return msgs.join(", ");
    }
    module2.exports = ValidationError;
  }
});

// node_modules/mongoose/lib/error/validator.js
var require_validator = __commonJS({
  "node_modules/mongoose/lib/error/validator.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var ValidatorError = class extends MongooseError {
      constructor(properties) {
        let msg = properties.message;
        if (!msg) {
          msg = MongooseError.messages.general.default;
        }
        const message = formatMessage(msg, properties);
        super(message);
        properties = Object.assign({}, properties, { message });
        this.properties = properties;
        this.kind = properties.type;
        this.path = properties.path;
        this.value = properties.value;
        this.reason = properties.reason;
      }
      toString() {
        return this.message;
      }
      toJSON() {
        return Object.assign({ name: this.name, message: this.message }, this);
      }
    };
    Object.defineProperty(ValidatorError.prototype, "name", {
      value: "ValidatorError"
    });
    Object.defineProperty(ValidatorError.prototype, "properties", {
      enumerable: false,
      writable: true,
      value: null
    });
    ValidatorError.prototype.formatMessage = formatMessage;
    function formatMessage(msg, properties) {
      if (typeof msg === "function") {
        return msg(properties);
      }
      const propertyNames = Object.keys(properties);
      for (const propertyName of propertyNames) {
        if (propertyName === "message") {
          continue;
        }
        msg = msg.replace("{" + propertyName.toUpperCase() + "}", properties[propertyName]);
      }
      return msg;
    }
    module2.exports = ValidatorError;
  }
});

// node_modules/mongoose/lib/error/version.js
var require_version = __commonJS({
  "node_modules/mongoose/lib/error/version.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var VersionError = class extends MongooseError {
      constructor(doc, currentVersion, modifiedPaths) {
        const modifiedPathsStr = modifiedPaths.join(", ");
        super('No matching document found for id "' + doc._id + '" version ' + currentVersion + ' modifiedPaths "' + modifiedPathsStr + '"');
        this.version = currentVersion;
        this.modifiedPaths = modifiedPaths;
      }
    };
    Object.defineProperty(VersionError.prototype, "name", {
      value: "VersionError"
    });
    module2.exports = VersionError;
  }
});

// node_modules/mongoose/lib/error/parallelSave.js
var require_parallelSave = __commonJS({
  "node_modules/mongoose/lib/error/parallelSave.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var ParallelSaveError = class extends MongooseError {
      constructor(doc) {
        const msg = "Can't save() the same doc multiple times in parallel. Document: ";
        super(msg + doc._id);
      }
    };
    Object.defineProperty(ParallelSaveError.prototype, "name", {
      value: "ParallelSaveError"
    });
    module2.exports = ParallelSaveError;
  }
});

// node_modules/mongoose/lib/error/overwriteModel.js
var require_overwriteModel = __commonJS({
  "node_modules/mongoose/lib/error/overwriteModel.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var OverwriteModelError = class extends MongooseError {
      constructor(name) {
        super("Cannot overwrite `" + name + "` model once compiled.");
      }
    };
    Object.defineProperty(OverwriteModelError.prototype, "name", {
      value: "OverwriteModelError"
    });
    module2.exports = OverwriteModelError;
  }
});

// node_modules/mongoose/lib/error/missingSchema.js
var require_missingSchema = __commonJS({
  "node_modules/mongoose/lib/error/missingSchema.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var MissingSchemaError = class extends MongooseError {
      constructor(name) {
        const msg = `Schema hasn't been registered for model "` + name + '".\nUse mongoose.model(name, schema)';
        super(msg);
      }
    };
    Object.defineProperty(MissingSchemaError.prototype, "name", {
      value: "MissingSchemaError"
    });
    module2.exports = MissingSchemaError;
  }
});

// node_modules/mongoose/lib/error/divergentArray.js
var require_divergentArray = __commonJS({
  "node_modules/mongoose/lib/error/divergentArray.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var DivergentArrayError = class extends MongooseError {
      constructor(paths) {
        const msg = "For your own good, using `document.save()` to update an array which was selected using an $elemMatch projection OR populated using skip, limit, query conditions, or exclusion of the _id field when the operation results in a $pop or $set of the entire array is not supported. The following path(s) would have been modified unsafely:\n  " + paths.join("\n  ") + "\nUse Model.update() to update these arrays instead.";
        super(msg);
      }
    };
    Object.defineProperty(DivergentArrayError.prototype, "name", {
      value: "DivergentArrayError"
    });
    module2.exports = DivergentArrayError;
  }
});

// node_modules/mongoose/lib/error/strict.js
var require_strict = __commonJS({
  "node_modules/mongoose/lib/error/strict.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var StrictModeError = class extends MongooseError {
      constructor(path, msg, immutable) {
        msg = msg || "Field `" + path + "` is not in schema and strict mode is set to throw.";
        super(msg);
        this.isImmutableError = !!immutable;
        this.path = path;
      }
    };
    Object.defineProperty(StrictModeError.prototype, "name", {
      value: "StrictModeError"
    });
    module2.exports = StrictModeError;
  }
});

// node_modules/mongoose/lib/error/index.js
var require_error3 = __commonJS({
  "node_modules/mongoose/lib/error/index.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    module2.exports = exports2 = MongooseError;
    MongooseError.messages = require_messages();
    MongooseError.Messages = MongooseError.messages;
    MongooseError.DocumentNotFoundError = require_notFound();
    MongooseError.CastError = require_cast();
    MongooseError.ValidationError = require_validation();
    MongooseError.ValidatorError = require_validator();
    MongooseError.VersionError = require_version();
    MongooseError.ParallelSaveError = require_parallelSave();
    MongooseError.OverwriteModelError = require_overwriteModel();
    MongooseError.MissingSchemaError = require_missingSchema();
    MongooseError.DivergentArrayError = require_divergentArray();
    MongooseError.StrictModeError = require_strict();
  }
});

// node_modules/mongoose/lib/options/propertyOptions.js
var require_propertyOptions = __commonJS({
  "node_modules/mongoose/lib/options/propertyOptions.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.freeze({
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
});

// node_modules/mongoose/lib/options/SchemaTypeOptions.js
var require_SchemaTypeOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaTypeOptions.js"(exports2, module2) {
    "use strict";
    var clone = require_clone();
    var SchemaTypeOptions = class {
      constructor(obj) {
        if (obj == null) {
          return this;
        }
        Object.assign(this, clone(obj));
      }
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaTypeOptions.prototype, "type", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "validate", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "cast", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "required", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "default", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "ref", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "select", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "index", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "unique", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "immutable", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "sparse", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "text", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "transform", opts);
    module2.exports = SchemaTypeOptions;
  }
});

// node_modules/mongoose/lib/cast/boolean.js
var require_boolean = __commonJS({
  "node_modules/mongoose/lib/cast/boolean.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    module2.exports = function castBoolean(value, path) {
      if (module2.exports.convertToTrue.has(value)) {
        return true;
      }
      if (module2.exports.convertToFalse.has(value)) {
        return false;
      }
      if (value == null) {
        return value;
      }
      throw new CastError("boolean", value, path);
    };
    module2.exports.convertToTrue = new Set([true, "true", 1, "1", "yes"]);
    module2.exports.convertToFalse = new Set([false, "false", 0, "0", "no"]);
  }
});

// node_modules/mongoose/lib/schema/operators/exists.js
var require_exists = __commonJS({
  "node_modules/mongoose/lib/schema/operators/exists.js"(exports2, module2) {
    "use strict";
    var castBoolean = require_boolean();
    module2.exports = function(val) {
      const path = this != null ? this.path : null;
      return castBoolean(val, path);
    };
  }
});

// node_modules/mongoose/lib/schema/operators/type.js
var require_type = __commonJS({
  "node_modules/mongoose/lib/schema/operators/type.js"(exports2, module2) {
    "use strict";
    module2.exports = function(val) {
      if (Array.isArray(val)) {
        if (!val.every((v) => typeof v === "number" || typeof v === "string")) {
          throw new Error("$type array values must be strings or numbers");
        }
        return val;
      }
      if (typeof val !== "number" && typeof val !== "string") {
        throw new Error("$type parameter must be number, string, or array of numbers and strings");
      }
      return val;
    };
  }
});

// node_modules/mongoose/lib/helpers/schematype/handleImmutable.js
var require_handleImmutable = __commonJS({
  "node_modules/mongoose/lib/helpers/schematype/handleImmutable.js"(exports2, module2) {
    "use strict";
    var StrictModeError = require_strict();
    module2.exports = function(schematype) {
      if (schematype.$immutable) {
        schematype.$immutableSetter = createImmutableSetter(schematype.path, schematype.options.immutable);
        schematype.set(schematype.$immutableSetter);
      } else if (schematype.$immutableSetter) {
        schematype.setters = schematype.setters.filter((fn) => fn !== schematype.$immutableSetter);
        delete schematype.$immutableSetter;
      }
    };
    function createImmutableSetter(path, immutable) {
      return function immutableSetter(v) {
        if (this == null || this.$__ == null) {
          return v;
        }
        if (this.isNew) {
          return v;
        }
        const _immutable = typeof immutable === "function" ? immutable.call(this, this) : immutable;
        if (!_immutable) {
          return v;
        }
        const _value = this.$__getValue(path);
        if (this.$__.strictMode === "throw" && v !== _value) {
          throw new StrictModeError(path, "Path `" + path + "` is immutable and strict mode is set to throw.", true);
        }
        return _value;
      };
    }
  }
});

// node_modules/mongoose/lib/schematype.js
var require_schematype = __commonJS({
  "node_modules/mongoose/lib/schematype.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var $exists = require_exists();
    var $type = require_type();
    var get = require_get();
    var handleImmutable = require_handleImmutable();
    var immediate = require_immediate();
    var schemaTypeSymbol = require_symbols().schemaTypeSymbol;
    var util = require("util");
    var utils2 = require_utils8();
    var validatorErrorSymbol = require_symbols().validatorErrorSymbol;
    var documentIsModified = require_symbols().documentIsModified;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var CastError = MongooseError.CastError;
    var ValidatorError = MongooseError.ValidatorError;
    function SchemaType(path, options, instance) {
      this[schemaTypeSymbol] = true;
      this.path = path;
      this.instance = instance;
      this.validators = [];
      this.getters = this.constructor.hasOwnProperty("getters") ? this.constructor.getters.slice() : [];
      this.setters = [];
      this.splitPath();
      options = options || {};
      const defaultOptions = this.constructor.defaultOptions || {};
      const defaultOptionsKeys = Object.keys(defaultOptions);
      for (const option of defaultOptionsKeys) {
        if (defaultOptions.hasOwnProperty(option) && !options.hasOwnProperty(option)) {
          options[option] = defaultOptions[option];
        }
      }
      if (options.select == null) {
        delete options.select;
      }
      const Options = this.OptionsConstructor || SchemaTypeOptions;
      this.options = new Options(options);
      this._index = null;
      if (utils2.hasUserDefinedProperty(this.options, "immutable")) {
        this.$immutable = this.options.immutable;
        handleImmutable(this);
      }
      const keys = Object.keys(this.options);
      for (const prop of keys) {
        if (prop === "cast") {
          this.castFunction(this.options[prop]);
          continue;
        }
        if (utils2.hasUserDefinedProperty(this.options, prop) && typeof this[prop] === "function") {
          if (prop === "index" && this._index) {
            if (options.index === false) {
              const index = this._index;
              if (typeof index === "object" && index != null) {
                if (index.unique) {
                  throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
                }
                if (index.sparse) {
                  throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
                }
              }
              this._index = false;
            }
            continue;
          }
          const val = options[prop];
          if (prop === "default") {
            this.default(val);
            continue;
          }
          const opts = Array.isArray(val) ? val : [val];
          this[prop].apply(this, opts);
        }
      }
      Object.defineProperty(this, "$$context", {
        enumerable: false,
        configurable: false,
        writable: true,
        value: null
      });
    }
    SchemaType.prototype.OptionsConstructor = SchemaTypeOptions;
    SchemaType.prototype.splitPath = function() {
      if (this._presplitPath != null) {
        return this._presplitPath;
      }
      if (this.path == null) {
        return void 0;
      }
      this._presplitPath = this.path.indexOf(".") === -1 ? [this.path] : this.path.split(".");
      return this._presplitPath;
    };
    SchemaType.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = (v) => v;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaType.prototype.castFunction = function castFunction(caster) {
      if (arguments.length === 0) {
        return this._castFunction;
      }
      if (caster === false) {
        caster = this.constructor._defaultCaster || ((v) => v);
      }
      this._castFunction = caster;
      return this._castFunction;
    };
    SchemaType.prototype.cast = function cast() {
      throw new Error("Base SchemaType class does not implement a `cast()` function");
    };
    SchemaType.set = function set(option, value) {
      if (!this.hasOwnProperty("defaultOptions")) {
        this.defaultOptions = Object.assign({}, this.defaultOptions);
      }
      this.defaultOptions[option] = value;
    };
    SchemaType.get = function(getter) {
      this.getters = this.hasOwnProperty("getters") ? this.getters : [];
      this.getters.push(getter);
    };
    SchemaType.prototype.default = function(val) {
      if (arguments.length === 1) {
        if (val === void 0) {
          this.defaultValue = void 0;
          return void 0;
        }
        if (val != null && val.instanceOfSchema) {
          throw new MongooseError("Cannot set default value of path `" + this.path + "` to a mongoose Schema instance.");
        }
        this.defaultValue = val;
        return this.defaultValue;
      } else if (arguments.length > 1) {
        this.defaultValue = utils2.args(arguments);
      }
      return this.defaultValue;
    };
    SchemaType.prototype.index = function(options) {
      this._index = options;
      utils2.expires(this._index);
      return this;
    };
    SchemaType.prototype.unique = function(bool) {
      if (this._index === false) {
        if (!bool) {
          return;
        }
        throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
      }
      if (this._index == null || this._index === true) {
        this._index = {};
      } else if (typeof this._index === "string") {
        this._index = { type: this._index };
      }
      this._index.unique = bool;
      return this;
    };
    SchemaType.prototype.text = function(bool) {
      if (this._index === false) {
        if (!bool) {
          return;
        }
        throw new Error('Path "' + this.path + '" may not have `index` set to false and `text` set to true');
      }
      if (this._index === null || this._index === void 0 || typeof this._index === "boolean") {
        this._index = {};
      } else if (typeof this._index === "string") {
        this._index = { type: this._index };
      }
      this._index.text = bool;
      return this;
    };
    SchemaType.prototype.sparse = function(bool) {
      if (this._index === false) {
        if (!bool) {
          return;
        }
        throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
      }
      if (this._index == null || typeof this._index === "boolean") {
        this._index = {};
      } else if (typeof this._index === "string") {
        this._index = { type: this._index };
      }
      this._index.sparse = bool;
      return this;
    };
    SchemaType.prototype.immutable = function(bool) {
      this.$immutable = bool;
      handleImmutable(this);
      return this;
    };
    SchemaType.prototype.transform = function(fn) {
      this.options.transform = fn;
      return this;
    };
    SchemaType.prototype.set = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError("A setter must be a function.");
      }
      this.setters.push(fn);
      return this;
    };
    SchemaType.prototype.get = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError("A getter must be a function.");
      }
      this.getters.push(fn);
      return this;
    };
    SchemaType.prototype.validate = function(obj, message, type) {
      if (typeof obj === "function" || obj && utils2.getFunctionName(obj.constructor) === "RegExp") {
        let properties;
        if (typeof message === "function") {
          properties = { validator: obj, message };
          properties.type = type || "user defined";
        } else if (message instanceof Object && !type) {
          properties = utils2.clone(message);
          if (!properties.message) {
            properties.message = properties.msg;
          }
          properties.validator = obj;
          properties.type = properties.type || "user defined";
        } else {
          if (message == null) {
            message = MongooseError.messages.general.default;
          }
          if (!type) {
            type = "user defined";
          }
          properties = { message, type, validator: obj };
        }
        if (properties.isAsync) {
          handleIsAsync();
        }
        this.validators.push(properties);
        return this;
      }
      let i;
      let length;
      let arg;
      for (i = 0, length = arguments.length; i < length; i++) {
        arg = arguments[i];
        if (!utils2.isPOJO(arg)) {
          const msg = "Invalid validator. Received (" + typeof arg + ") " + arg + ". See http://mongoosejs.com/docs/api.html#schematype_SchemaType-validate";
          throw new Error(msg);
        }
        this.validate(arg.validator, arg);
      }
      return this;
    };
    var handleIsAsync = util.deprecate(function handleIsAsync2() {
    }, "Mongoose: the `isAsync` option for custom validators is deprecated. Make your async validators return a promise instead: https://mongoosejs.com/docs/validation.html#async-custom-validators");
    SchemaType.prototype.required = function(required, message) {
      let customOptions = {};
      if (arguments.length > 0 && required == null) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.requiredValidator;
        }, this);
        this.isRequired = false;
        delete this.originalRequiredValue;
        return this;
      }
      if (typeof required === "object") {
        customOptions = required;
        message = customOptions.message || message;
        required = required.isRequired;
      }
      if (required === false) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.requiredValidator;
        }, this);
        this.isRequired = false;
        delete this.originalRequiredValue;
        return this;
      }
      const _this = this;
      this.isRequired = true;
      this.requiredValidator = function(v) {
        const cachedRequired = get(this, "$__.cachedRequired");
        if (cachedRequired != null && !this.$__isSelected(_this.path) && !this[documentIsModified](_this.path)) {
          return true;
        }
        if (cachedRequired != null && _this.path in cachedRequired) {
          const res = cachedRequired[_this.path] ? _this.checkRequired(v, this) : true;
          delete cachedRequired[_this.path];
          return res;
        } else if (typeof required === "function") {
          return required.apply(this) ? _this.checkRequired(v, this) : true;
        }
        return _this.checkRequired(v, this);
      };
      this.originalRequiredValue = required;
      if (typeof required === "string") {
        message = required;
        required = void 0;
      }
      const msg = message || MongooseError.messages.general.required;
      this.validators.unshift(Object.assign({}, customOptions, {
        validator: this.requiredValidator,
        message: msg,
        type: "required"
      }));
      return this;
    };
    SchemaType.prototype.ref = function(ref) {
      this.options.ref = ref;
      return this;
    };
    SchemaType.prototype.getDefault = function(scope, init) {
      let ret2 = typeof this.defaultValue === "function" ? this.defaultValue.call(scope) : this.defaultValue;
      if (ret2 !== null && ret2 !== void 0) {
        if (typeof ret2 === "object" && (!this.options || !this.options.shared)) {
          ret2 = utils2.clone(ret2);
        }
        const casted = this.applySetters(ret2, scope, init);
        if (casted && casted.$isSingleNested) {
          casted.$__parent = scope;
        }
        return casted;
      }
      return ret2;
    };
    SchemaType.prototype._applySetters = function(value, scope, init) {
      let v = value;
      if (init) {
        return v;
      }
      const setters = this.setters;
      for (let i = setters.length - 1; i >= 0; i--) {
        v = setters[i].call(scope, v, this);
      }
      return v;
    };
    SchemaType.prototype._castNullish = function _castNullish(v) {
      return v;
    };
    SchemaType.prototype.applySetters = function(value, scope, init, priorVal, options) {
      let v = this._applySetters(value, scope, init, priorVal, options);
      if (v == null) {
        return this._castNullish(v);
      }
      v = this.cast(v, scope, init, priorVal, options);
      return v;
    };
    SchemaType.prototype.applyGetters = function(value, scope) {
      let v = value;
      const getters = this.getters;
      const len = getters.length;
      if (len === 0) {
        return v;
      }
      for (let i = 0; i < len; ++i) {
        v = getters[i].call(scope, v, this);
      }
      return v;
    };
    SchemaType.prototype.select = function select(val) {
      this.selected = !!val;
      return this;
    };
    SchemaType.prototype.doValidate = function(value, fn, scope, options) {
      let err = false;
      const path = this.path;
      const validators = this.validators.filter((v) => v != null && typeof v === "object");
      let count = validators.length;
      if (!count) {
        return fn(null);
      }
      const _this = this;
      validators.forEach(function(v) {
        if (err) {
          return;
        }
        const validator = v.validator;
        let ok;
        const validatorProperties = utils2.clone(v);
        validatorProperties.path = options && options.path ? options.path : path;
        validatorProperties.value = value;
        if (validator instanceof RegExp) {
          validate(validator.test(value), validatorProperties);
          return;
        }
        if (typeof validator !== "function") {
          return;
        }
        if (value === void 0 && validator !== _this.requiredValidator) {
          validate(true, validatorProperties);
          return;
        }
        if (validatorProperties.isAsync) {
          asyncValidate(validator, scope, value, validatorProperties, validate);
          return;
        }
        try {
          if (validatorProperties.propsParameter) {
            ok = validator.call(scope, value, validatorProperties);
          } else {
            ok = validator.call(scope, value);
          }
        } catch (error) {
          ok = false;
          validatorProperties.reason = error;
          if (error.message) {
            validatorProperties.message = error.message;
          }
        }
        if (ok != null && typeof ok.then === "function") {
          ok.then(function(ok2) {
            validate(ok2, validatorProperties);
          }, function(error) {
            validatorProperties.reason = error;
            validatorProperties.message = error.message;
            ok = false;
            validate(ok, validatorProperties);
          });
        } else {
          validate(ok, validatorProperties);
        }
      });
      function validate(ok, validatorProperties) {
        if (err) {
          return;
        }
        if (ok === void 0 || ok) {
          if (--count <= 0) {
            immediate(function() {
              fn(null);
            });
          }
        } else {
          const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
          err = new ErrorConstructor(validatorProperties);
          err[validatorErrorSymbol] = true;
          immediate(function() {
            fn(err);
          });
        }
      }
    };
    function asyncValidate(validator, scope, value, props, cb) {
      let called = false;
      const returnVal = validator.call(scope, value, function(ok, customMsg) {
        if (called) {
          return;
        }
        called = true;
        if (customMsg) {
          props.message = customMsg;
        }
        cb(ok, props);
      });
      if (typeof returnVal === "boolean") {
        called = true;
        cb(returnVal, props);
      } else if (returnVal && typeof returnVal.then === "function") {
        returnVal.then(function(ok) {
          if (called) {
            return;
          }
          called = true;
          cb(ok, props);
        }, function(error) {
          if (called) {
            return;
          }
          called = true;
          props.reason = error;
          props.message = error.message;
          cb(false, props);
        });
      }
    }
    SchemaType.prototype.doValidateSync = function(value, scope, options) {
      const path = this.path;
      const count = this.validators.length;
      if (!count) {
        return null;
      }
      let validators = this.validators;
      if (value === void 0) {
        if (this.validators.length > 0 && this.validators[0].type === "required") {
          validators = [this.validators[0]];
        } else {
          return null;
        }
      }
      let err = null;
      validators.forEach(function(v) {
        if (err) {
          return;
        }
        if (v == null || typeof v !== "object") {
          return;
        }
        const validator = v.validator;
        const validatorProperties = utils2.clone(v);
        validatorProperties.path = options && options.path ? options.path : path;
        validatorProperties.value = value;
        let ok;
        if (validator.isAsync) {
          return;
        }
        if (validator instanceof RegExp) {
          validate(validator.test(value), validatorProperties);
          return;
        }
        if (typeof validator !== "function") {
          return;
        }
        try {
          if (validatorProperties.propsParameter) {
            ok = validator.call(scope, value, validatorProperties);
          } else {
            ok = validator.call(scope, value);
          }
        } catch (error) {
          ok = false;
          validatorProperties.reason = error;
        }
        if (ok != null && typeof ok.then === "function") {
          return;
        }
        validate(ok, validatorProperties);
      });
      return err;
      function validate(ok, validatorProperties) {
        if (err) {
          return;
        }
        if (ok !== void 0 && !ok) {
          const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
          err = new ErrorConstructor(validatorProperties);
          err[validatorErrorSymbol] = true;
        }
      }
    };
    SchemaType._isRef = function(self2, value, doc, init) {
      let ref = init && self2.options && (self2.options.ref || self2.options.refPath);
      if (!ref && doc && doc.$__ != null) {
        const path = doc.$__fullPath(self2.path);
        const owner = doc.ownerDocument ? doc.ownerDocument() : doc;
        ref = owner.populated(path) || doc.populated(self2.path);
      }
      if (ref) {
        if (value == null) {
          return true;
        }
        if (!Buffer.isBuffer(value) && value._bsontype !== "Binary" && utils2.isObject(value)) {
          return true;
        }
        return init;
      }
      return false;
    };
    SchemaType.prototype._castRef = function _castRef(value, doc, init) {
      if (value == null) {
        return value;
      }
      if (value.$__ != null) {
        value.$__.wasPopulated = true;
        return value;
      }
      if (Buffer.isBuffer(value) || !utils2.isObject(value)) {
        if (init) {
          return value;
        }
        throw new CastError(this.instance, value, this.path, null, this);
      }
      const path = doc.$__fullPath(this.path);
      const owner = doc.ownerDocument ? doc.ownerDocument() : doc;
      const pop = owner.populated(path, true);
      let ret2 = value;
      if (!doc.$__.populated || !doc.$__.populated[path] || !doc.$__.populated[path].options || !doc.$__.populated[path].options.options || !doc.$__.populated[path].options.options.lean) {
        ret2 = new pop.options[populateModelSymbol](value);
        ret2.$__.wasPopulated = true;
      }
      return ret2;
    };
    function handleSingle(val) {
      return this.castForQuery(val);
    }
    function handleArray(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.castForQuery(val)];
      }
      return val.map(function(m) {
        return _this.castForQuery(m);
      });
    }
    function handle$in(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.castForQuery(val)];
      }
      return val.map(function(m) {
        if (Array.isArray(m) && m.length === 0) {
          return m;
        }
        return _this.castForQuery(m);
      });
    }
    SchemaType.prototype.$conditionalHandlers = {
      $all: handleArray,
      $eq: handleSingle,
      $in: handle$in,
      $ne: handleSingle,
      $nin: handle$in,
      $exists,
      $type
    };
    SchemaType.prototype.castForQueryWrapper = function(params) {
      this.$$context = params.context;
      if ("$conditional" in params) {
        const ret3 = this.castForQuery(params.$conditional, params.val);
        this.$$context = null;
        return ret3;
      }
      if (params.$skipQueryCastForUpdate || params.$applySetters) {
        const ret3 = this._castForQuery(params.val);
        this.$$context = null;
        return ret3;
      }
      const ret2 = this.castForQuery(params.val);
      this.$$context = null;
      return ret2;
    };
    SchemaType.prototype.castForQuery = function($conditional, val) {
      let handler;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new Error("Can't use " + $conditional);
        }
        return handler.call(this, val);
      }
      val = $conditional;
      return this._castForQuery(val);
    };
    SchemaType.prototype._castForQuery = function(val) {
      return this.applySetters(val, this.$$context);
    };
    SchemaType.checkRequired = function(fn) {
      if (arguments.length > 0) {
        this._checkRequired = fn;
      }
      return this._checkRequired;
    };
    SchemaType.prototype.checkRequired = function(val) {
      return val != null;
    };
    SchemaType.prototype.clone = function() {
      const options = Object.assign({}, this.options);
      const schematype = new this.constructor(this.path, options, this.instance);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0)
        schematype.requiredValidator = this.requiredValidator;
      if (this.defaultValue !== void 0)
        schematype.defaultValue = this.defaultValue;
      if (this.$immutable !== void 0 && this.options.immutable === void 0) {
        schematype.$immutable = this.$immutable;
        handleImmutable(schematype);
      }
      if (this._index !== void 0)
        schematype._index = this._index;
      if (this.selected !== void 0)
        schematype.selected = this.selected;
      if (this.isRequired !== void 0)
        schematype.isRequired = this.isRequired;
      if (this.originalRequiredValue !== void 0)
        schematype.originalRequiredValue = this.originalRequiredValue;
      schematype.getters = this.getters.slice();
      schematype.setters = this.setters.slice();
      return schematype;
    };
    module2.exports = exports2 = SchemaType;
    exports2.CastError = CastError;
    exports2.ValidatorError = ValidatorError;
  }
});

// node_modules/mongoose/lib/schema/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/mongoose/lib/schema/symbols.js"(exports2) {
    "use strict";
    exports2.schemaMixedSymbol = Symbol.for("mongoose:schema_mixed");
    exports2.builtInMiddleware = Symbol.for("mongoose:built-in-middleware");
  }
});

// node_modules/mongoose/lib/schema/mixed.js
var require_mixed = __commonJS({
  "node_modules/mongoose/lib/schema/mixed.js"(exports2, module2) {
    "use strict";
    var SchemaType = require_schematype();
    var symbols = require_symbols2();
    var isObject2 = require_isObject();
    var utils2 = require_utils8();
    function Mixed(path, options) {
      if (options && options.default) {
        const def = options.default;
        if (Array.isArray(def) && def.length === 0) {
          options.default = Array;
        } else if (!options.shared && isObject2(def) && Object.keys(def).length === 0) {
          options.default = function() {
            return {};
          };
        }
      }
      SchemaType.call(this, path, options, "Mixed");
      this[symbols.schemaMixedSymbol] = true;
    }
    Mixed.schemaName = "Mixed";
    Mixed.defaultOptions = {};
    Mixed.prototype = Object.create(SchemaType.prototype);
    Mixed.prototype.constructor = Mixed;
    Mixed.get = SchemaType.get;
    Mixed.set = SchemaType.set;
    Mixed.prototype.cast = function(val) {
      if (val instanceof Error) {
        return utils2.errorToPOJO(val);
      }
      return val;
    };
    Mixed.prototype.castForQuery = function($cond, val) {
      if (arguments.length === 2) {
        return val;
      }
      return $cond;
    };
    module2.exports = Mixed;
  }
});

// node_modules/mongoose/lib/error/objectExpected.js
var require_objectExpected = __commonJS({
  "node_modules/mongoose/lib/error/objectExpected.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var ObjectExpectedError = class extends MongooseError {
      constructor(path, val) {
        const typeDescription = Array.isArray(val) ? "array" : "primitive value";
        super("Tried to set nested object field `" + path + `\` to ${typeDescription} \`` + val + "` and strict mode is set to throw.");
        this.path = path;
      }
    };
    Object.defineProperty(ObjectExpectedError.prototype, "name", {
      value: "ObjectExpectedError"
    });
    module2.exports = ObjectExpectedError;
  }
});

// node_modules/mongoose/lib/error/objectParameter.js
var require_objectParameter = __commonJS({
  "node_modules/mongoose/lib/error/objectParameter.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var ObjectParameterError = class extends MongooseError {
      constructor(value, paramName, fnName) {
        super('Parameter "' + paramName + '" to ' + fnName + "() must be an object, got " + value.toString());
      }
    };
    Object.defineProperty(ObjectParameterError.prototype, "name", {
      value: "ObjectParameterError"
    });
    module2.exports = ObjectParameterError;
  }
});

// node_modules/mongoose/lib/error/parallelValidate.js
var require_parallelValidate = __commonJS({
  "node_modules/mongoose/lib/error/parallelValidate.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var ParallelValidateError = class extends MongooseError {
      constructor(doc) {
        const msg = "Can't validate() the same doc multiple times in parallel. Document: ";
        super(msg + doc._id);
      }
    };
    Object.defineProperty(ParallelValidateError.prototype, "name", {
      value: "ParallelValidateError"
    });
    module2.exports = ParallelValidateError;
  }
});

// node_modules/kareem/index.js
var require_kareem = __commonJS({
  "node_modules/kareem/index.js"(exports2, module2) {
    "use strict";
    function Kareem() {
      this._pres = new Map();
      this._posts = new Map();
    }
    Kareem.prototype.execPre = function(name, context, args, callback) {
      if (arguments.length === 3) {
        callback = args;
        args = [];
      }
      var pres = get(this._pres, name, []);
      var numPres = pres.length;
      var numAsyncPres = pres.numAsync || 0;
      var currentPre = 0;
      var asyncPresLeft = numAsyncPres;
      var done = false;
      var $args = args;
      if (!numPres) {
        return process.nextTick(function() {
          callback(null);
        });
      }
      var next = function() {
        if (currentPre >= numPres) {
          return;
        }
        var pre = pres[currentPre];
        if (pre.isAsync) {
          var args2 = [
            decorateNextFn(_next),
            decorateNextFn(function(error) {
              if (error) {
                if (done) {
                  return;
                }
                done = true;
                return callback(error);
              }
              if (--asyncPresLeft === 0 && currentPre >= numPres) {
                return callback(null);
              }
            })
          ];
          callMiddlewareFunction(pre.fn, context, args2, args2[0]);
        } else if (pre.fn.length > 0) {
          var args2 = [decorateNextFn(_next)];
          var _args = arguments.length >= 2 ? arguments : [null].concat($args);
          for (var i = 1; i < _args.length; ++i) {
            args2.push(_args[i]);
          }
          callMiddlewareFunction(pre.fn, context, args2, args2[0]);
        } else {
          let maybePromise = null;
          try {
            maybePromise = pre.fn.call(context);
          } catch (err) {
            if (err != null) {
              return callback(err);
            }
          }
          if (isPromise(maybePromise)) {
            maybePromise.then(() => _next(), (err) => _next(err));
          } else {
            if (++currentPre >= numPres) {
              if (asyncPresLeft > 0) {
                return;
              } else {
                return process.nextTick(function() {
                  callback(null);
                });
              }
            }
            next();
          }
        }
      };
      next.apply(null, [null].concat(args));
      function _next(error) {
        if (error) {
          if (done) {
            return;
          }
          done = true;
          return callback(error);
        }
        if (++currentPre >= numPres) {
          if (asyncPresLeft > 0) {
            return;
          } else {
            return callback(null);
          }
        }
        next.apply(context, arguments);
      }
    };
    Kareem.prototype.execPreSync = function(name, context, args) {
      var pres = get(this._pres, name, []);
      var numPres = pres.length;
      for (var i = 0; i < numPres; ++i) {
        pres[i].fn.apply(context, args || []);
      }
    };
    Kareem.prototype.execPost = function(name, context, args, options, callback) {
      if (arguments.length < 5) {
        callback = options;
        options = null;
      }
      var posts = get(this._posts, name, []);
      var numPosts = posts.length;
      var currentPost = 0;
      var firstError = null;
      if (options && options.error) {
        firstError = options.error;
      }
      if (!numPosts) {
        return process.nextTick(function() {
          callback.apply(null, [firstError].concat(args));
        });
      }
      var next = function() {
        var post = posts[currentPost].fn;
        var numArgs = 0;
        var argLength = args.length;
        var newArgs = [];
        for (var i = 0; i < argLength; ++i) {
          numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;
          if (!args[i] || !args[i]._kareemIgnore) {
            newArgs.push(args[i]);
          }
        }
        if (firstError) {
          if (post.length === numArgs + 2) {
            var _cb = decorateNextFn(function(error) {
              if (error) {
                firstError = error;
              }
              if (++currentPost >= numPosts) {
                return callback.call(null, firstError);
              }
              next();
            });
            callMiddlewareFunction(post, context, [firstError].concat(newArgs).concat([_cb]), _cb);
          } else {
            if (++currentPost >= numPosts) {
              return callback.call(null, firstError);
            }
            next();
          }
        } else {
          const _cb2 = decorateNextFn(function(error) {
            if (error) {
              firstError = error;
              return next();
            }
            if (++currentPost >= numPosts) {
              return callback.apply(null, [null].concat(args));
            }
            next();
          });
          if (post.length === numArgs + 2) {
            if (++currentPost >= numPosts) {
              return callback.apply(null, [null].concat(args));
            }
            return next();
          }
          if (post.length === numArgs + 1) {
            callMiddlewareFunction(post, context, newArgs.concat([_cb2]), _cb2);
          } else {
            let error;
            let maybePromise;
            try {
              maybePromise = post.apply(context, newArgs);
            } catch (err) {
              error = err;
              firstError = err;
            }
            if (isPromise(maybePromise)) {
              return maybePromise.then(() => _cb2(), (err) => _cb2(err));
            }
            if (++currentPost >= numPosts) {
              return callback.apply(null, [error].concat(args));
            }
            next(error);
          }
        }
      };
      next();
    };
    Kareem.prototype.execPostSync = function(name, context, args) {
      const posts = get(this._posts, name, []);
      const numPosts = posts.length;
      for (let i = 0; i < numPosts; ++i) {
        posts[i].fn.apply(context, args || []);
      }
    };
    Kareem.prototype.createWrapperSync = function(name, fn) {
      var kareem = this;
      return function syncWrapper() {
        kareem.execPreSync(name, this, arguments);
        var toReturn = fn.apply(this, arguments);
        kareem.execPostSync(name, this, [toReturn]);
        return toReturn;
      };
    };
    function _handleWrapError(instance, error, name, context, args, options, callback) {
      if (options.useErrorHandlers) {
        var _options = { error };
        return instance.execPost(name, context, args, _options, function(error2) {
          return typeof callback === "function" && callback(error2);
        });
      } else {
        return typeof callback === "function" ? callback(error) : void 0;
      }
    }
    Kareem.prototype.wrap = function(name, fn, context, args, options) {
      const lastArg = args.length > 0 ? args[args.length - 1] : null;
      const argsWithoutCb = typeof lastArg === "function" ? args.slice(0, args.length - 1) : args;
      const _this = this;
      options = options || {};
      const checkForPromise = options.checkForPromise;
      this.execPre(name, context, args, function(error) {
        if (error) {
          const numCallbackParams = options.numCallbackParams || 0;
          const errorArgs = options.contextParameter ? [context] : [];
          for (var i = errorArgs.length; i < numCallbackParams; ++i) {
            errorArgs.push(null);
          }
          return _handleWrapError(_this, error, name, context, errorArgs, options, lastArg);
        }
        const end = typeof lastArg === "function" ? args.length - 1 : args.length;
        const numParameters = fn.length;
        const ret2 = fn.apply(context, args.slice(0, end).concat(_cb));
        if (checkForPromise) {
          if (ret2 != null && typeof ret2.then === "function") {
            return ret2.then((res) => _cb(null, res), (err) => _cb(err));
          }
          if (numParameters < end + 1) {
            return _cb(null, ret2);
          }
        }
        function _cb() {
          const args2 = arguments;
          const argsWithoutError = Array.prototype.slice.call(arguments, 1);
          if (options.nullResultByDefault && argsWithoutError.length === 0) {
            argsWithoutError.push(null);
          }
          if (arguments[0]) {
            return _handleWrapError(_this, arguments[0], name, context, argsWithoutError, options, lastArg);
          } else {
            _this.execPost(name, context, argsWithoutError, function() {
              if (arguments[0]) {
                return typeof lastArg === "function" ? lastArg(arguments[0]) : void 0;
              }
              return typeof lastArg === "function" ? lastArg.apply(context, arguments) : void 0;
            });
          }
        }
      });
    };
    Kareem.prototype.filter = function(fn) {
      const clone = this.clone();
      const pres = Array.from(clone._pres.keys());
      for (const name of pres) {
        const hooks = this._pres.get(name).map((h) => Object.assign({}, h, { name })).filter(fn);
        if (hooks.length === 0) {
          clone._pres.delete(name);
          continue;
        }
        hooks.numAsync = hooks.filter((h) => h.isAsync).length;
        clone._pres.set(name, hooks);
      }
      const posts = Array.from(clone._posts.keys());
      for (const name of posts) {
        const hooks = this._posts.get(name).map((h) => Object.assign({}, h, { name })).filter(fn);
        if (hooks.length === 0) {
          clone._posts.delete(name);
          continue;
        }
        clone._posts.set(name, hooks);
      }
      return clone;
    };
    Kareem.prototype.hasHooks = function(name) {
      return this._pres.has(name) || this._posts.has(name);
    };
    Kareem.prototype.createWrapper = function(name, fn, context, options) {
      var _this = this;
      if (!this.hasHooks(name)) {
        return function() {
          process.nextTick(() => fn.apply(this, arguments));
        };
      }
      return function() {
        var _context = context || this;
        var args = Array.prototype.slice.call(arguments);
        _this.wrap(name, fn, _context, args, options);
      };
    };
    Kareem.prototype.pre = function(name, isAsync, fn, error, unshift) {
      let options = {};
      if (typeof isAsync === "object" && isAsync != null) {
        options = isAsync;
        isAsync = options.isAsync;
      } else if (typeof arguments[1] !== "boolean") {
        error = fn;
        fn = isAsync;
        isAsync = false;
      }
      const pres = get(this._pres, name, []);
      this._pres.set(name, pres);
      if (isAsync) {
        pres.numAsync = pres.numAsync || 0;
        ++pres.numAsync;
      }
      if (typeof fn !== "function") {
        throw new Error('pre() requires a function, got "' + typeof fn + '"');
      }
      if (unshift) {
        pres.unshift(Object.assign({}, options, { fn, isAsync }));
      } else {
        pres.push(Object.assign({}, options, { fn, isAsync }));
      }
      return this;
    };
    Kareem.prototype.post = function(name, options, fn, unshift) {
      const hooks = get(this._posts, name, []);
      if (typeof options === "function") {
        unshift = !!fn;
        fn = options;
        options = {};
      }
      if (typeof fn !== "function") {
        throw new Error('post() requires a function, got "' + typeof fn + '"');
      }
      if (unshift) {
        hooks.unshift(Object.assign({}, options, { fn }));
      } else {
        hooks.push(Object.assign({}, options, { fn }));
      }
      this._posts.set(name, hooks);
      return this;
    };
    Kareem.prototype.clone = function() {
      const n = new Kareem();
      for (let key of this._pres.keys()) {
        const clone = this._pres.get(key).slice();
        clone.numAsync = this._pres.get(key).numAsync;
        n._pres.set(key, clone);
      }
      for (let key of this._posts.keys()) {
        n._posts.set(key, this._posts.get(key).slice());
      }
      return n;
    };
    Kareem.prototype.merge = function(other, clone) {
      clone = arguments.length === 1 ? true : clone;
      var ret2 = clone ? this.clone() : this;
      for (let key of other._pres.keys()) {
        const sourcePres = get(ret2._pres, key, []);
        const deduplicated = other._pres.get(key).filter((p) => sourcePres.map((_p) => _p.fn).indexOf(p.fn) === -1);
        const combined = sourcePres.concat(deduplicated);
        combined.numAsync = sourcePres.numAsync || 0;
        combined.numAsync += deduplicated.filter((p) => p.isAsync).length;
        ret2._pres.set(key, combined);
      }
      for (let key of other._posts.keys()) {
        const sourcePosts = get(ret2._posts, key, []);
        const deduplicated = other._posts.get(key).filter((p) => sourcePosts.indexOf(p) === -1);
        ret2._posts.set(key, sourcePosts.concat(deduplicated));
      }
      return ret2;
    };
    function get(map, key, def) {
      if (map.has(key)) {
        return map.get(key);
      }
      return def;
    }
    function callMiddlewareFunction(fn, context, args, next) {
      let maybePromise;
      try {
        maybePromise = fn.apply(context, args);
      } catch (error) {
        return next(error);
      }
      if (isPromise(maybePromise)) {
        maybePromise.then(() => next(), (err) => next(err));
      }
    }
    function isPromise(v) {
      return v != null && typeof v.then === "function";
    }
    function decorateNextFn(fn) {
      var called = false;
      var _this = this;
      return function() {
        if (called) {
          return;
        }
        called = true;
        return process.nextTick(() => fn.apply(_this, arguments));
      };
    }
    module2.exports = Kareem;
  }
});

// node_modules/mongoose/lib/options/VirtualOptions.js
var require_VirtualOptions = __commonJS({
  "node_modules/mongoose/lib/options/VirtualOptions.js"(exports2, module2) {
    "use strict";
    var opts = require_propertyOptions();
    var VirtualOptions = class {
      constructor(obj) {
        Object.assign(this, obj);
        if (obj != null && obj.options != null) {
          this.options = Object.assign({}, obj.options);
        }
      }
    };
    Object.defineProperty(VirtualOptions.prototype, "ref", opts);
    Object.defineProperty(VirtualOptions.prototype, "refPath", opts);
    Object.defineProperty(VirtualOptions.prototype, "localField", opts);
    Object.defineProperty(VirtualOptions.prototype, "foreignField", opts);
    Object.defineProperty(VirtualOptions.prototype, "justOne", opts);
    Object.defineProperty(VirtualOptions.prototype, "count", opts);
    Object.defineProperty(VirtualOptions.prototype, "match", opts);
    Object.defineProperty(VirtualOptions.prototype, "options", opts);
    Object.defineProperty(VirtualOptions.prototype, "skip", opts);
    Object.defineProperty(VirtualOptions.prototype, "limit", opts);
    Object.defineProperty(VirtualOptions.prototype, "perDocumentLimit", opts);
    module2.exports = VirtualOptions;
  }
});

// node_modules/mongoose/lib/virtualtype.js
var require_virtualtype = __commonJS({
  "node_modules/mongoose/lib/virtualtype.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    function VirtualType(options, name) {
      this.path = name;
      this.getters = [];
      this.setters = [];
      this.options = Object.assign({}, options);
    }
    VirtualType.prototype._applyDefaultGetters = function() {
      if (this.getters.length > 0 || this.setters.length > 0) {
        return;
      }
      const path = this.path;
      const internalProperty = "$" + path;
      this.getters.push(function() {
        return this[internalProperty];
      });
      this.setters.push(function(v) {
        this[internalProperty] = v;
      });
    };
    VirtualType.prototype.clone = function() {
      const clone = new VirtualType(this.options, this.path);
      clone.getters = [].concat(this.getters);
      clone.setters = [].concat(this.setters);
      return clone;
    };
    VirtualType.prototype.get = function(fn) {
      this.getters.push(fn);
      return this;
    };
    VirtualType.prototype.set = function(fn) {
      this.setters.push(fn);
      return this;
    };
    VirtualType.prototype.applyGetters = function(value, doc) {
      if (utils2.hasUserDefinedProperty(this.options, ["ref", "refPath"]) && doc.$$populatedVirtuals && doc.$$populatedVirtuals.hasOwnProperty(this.path)) {
        value = doc.$$populatedVirtuals[this.path];
      }
      let v = value;
      for (let l = this.getters.length - 1; l >= 0; l--) {
        v = this.getters[l].call(doc, v, this, doc);
      }
      return v;
    };
    VirtualType.prototype.applySetters = function(value, doc) {
      let v = value;
      for (let l = this.setters.length - 1; l >= 0; l--) {
        v = this.setters[l].call(doc, v, this, doc);
      }
      return v;
    };
    module2.exports = VirtualType;
  }
});

// node_modules/mongoose/lib/helpers/schema/addAutoId.js
var require_addAutoId = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/addAutoId.js"(exports2, module2) {
    "use strict";
    module2.exports = function addAutoId(schema) {
      const _obj = { _id: { auto: true } };
      _obj._id[schema.options.typeKey] = "ObjectId";
      schema.add(_obj);
    };
  }
});

// node_modules/mongoose/lib/helpers/schema/getIndexes.js
var require_getIndexes = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/getIndexes.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    var helperIsObject = require_isObject();
    module2.exports = function getIndexes(schema) {
      let indexes = [];
      const schemaStack = new WeakMap();
      const indexTypes = schema.constructor.indexTypes;
      const indexByName = new Map();
      collectIndexes(schema);
      return indexes;
      function collectIndexes(schema2, prefix, baseSchema) {
        if (schemaStack.has(schema2)) {
          return;
        }
        schemaStack.set(schema2, true);
        prefix = prefix || "";
        const keys = Object.keys(schema2.paths);
        for (const key of keys) {
          const path = schema2.paths[key];
          if (baseSchema != null && baseSchema.paths[key]) {
            continue;
          }
          if (path.$isMongooseDocumentArray || path.$isSingleNested) {
            if (get(path, "options.excludeIndexes") !== true && get(path, "schemaOptions.excludeIndexes") !== true && get(path, "schema.options.excludeIndexes") !== true) {
              collectIndexes(path.schema, prefix + key + ".");
            }
            if (path.schema.discriminators != null) {
              const discriminators = path.schema.discriminators;
              const discriminatorKeys = Object.keys(discriminators);
              for (const discriminatorKey of discriminatorKeys) {
                collectIndexes(discriminators[discriminatorKey], prefix + key + ".", path.schema);
              }
            }
            if (path.$isMongooseDocumentArray) {
              continue;
            }
          }
          const index = path._index || path.caster && path.caster._index;
          if (index !== false && index !== null && index !== void 0) {
            const field = {};
            const isObject2 = helperIsObject(index);
            const options = isObject2 ? index : {};
            const type = typeof index === "string" ? index : isObject2 ? index.type : false;
            if (type && indexTypes.indexOf(type) !== -1) {
              field[prefix + key] = type;
            } else if (options.text) {
              field[prefix + key] = "text";
              delete options.text;
            } else {
              const isDescendingIndex = Number(index) === -1;
              field[prefix + key] = isDescendingIndex ? -1 : 1;
            }
            delete options.type;
            if (!("background" in options)) {
              options.background = true;
            }
            if (schema2.options.autoIndex != null) {
              options._autoIndex = schema2.options.autoIndex;
            }
            const indexName = options && options.name;
            if (typeof indexName === "string") {
              if (indexByName.has(indexName)) {
                Object.assign(indexByName.get(indexName), field);
              } else {
                indexes.push([field, options]);
                indexByName.set(indexName, field);
              }
            } else {
              indexes.push([field, options]);
              indexByName.set(indexName, field);
            }
          }
        }
        schemaStack.delete(schema2);
        if (prefix) {
          fixSubIndexPaths(schema2, prefix);
        } else {
          schema2._indexes.forEach(function(index) {
            if (!("background" in index[1])) {
              index[1].background = true;
            }
          });
          indexes = indexes.concat(schema2._indexes);
        }
      }
      function fixSubIndexPaths(schema2, prefix) {
        const subindexes = schema2._indexes;
        const len = subindexes.length;
        for (let i = 0; i < len; ++i) {
          const indexObj = subindexes[i][0];
          const indexOptions = subindexes[i][1];
          const keys = Object.keys(indexObj);
          const klen = keys.length;
          const newindex = {};
          for (let j = 0; j < klen; ++j) {
            const key = keys[j];
            newindex[prefix + key] = indexObj[key];
          }
          const newIndexOptions = Object.assign({}, indexOptions);
          if (indexOptions != null && indexOptions.partialFilterExpression != null) {
            newIndexOptions.partialFilterExpression = {};
            const partialFilterExpression = indexOptions.partialFilterExpression;
            for (const key of Object.keys(partialFilterExpression)) {
              newIndexOptions.partialFilterExpression[prefix + key] = partialFilterExpression[key];
            }
          }
          indexes.push([newindex, newIndexOptions]);
        }
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js
var require_cleanPositionalOperators = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js"(exports2, module2) {
    "use strict";
    module2.exports = function cleanPositionalOperators(path) {
      return path.replace(/\.\$(\[[^\]]*\])?(?=\.)/g, ".0").replace(/\.\$(\[[^\]]*\])?$/g, ".0");
    };
  }
});

// node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js
var require_handleTimestampOption = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js"(exports2, module2) {
    "use strict";
    module2.exports = handleTimestampOption;
    function handleTimestampOption(arg, prop) {
      if (arg == null) {
        return null;
      }
      if (typeof arg === "boolean") {
        return prop;
      }
      if (typeof arg[prop] === "boolean") {
        return arg[prop] ? prop : null;
      }
      if (!(prop in arg)) {
        return prop;
      }
      return arg[prop];
    }
  }
});

// node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js
var require_applyTimestampsToChildren = __commonJS({
  "node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js"(exports2, module2) {
    "use strict";
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var handleTimestampOption = require_handleTimestampOption();
    module2.exports = applyTimestampsToChildren;
    function applyTimestampsToChildren(now, update, schema) {
      if (update == null) {
        return;
      }
      const keys = Object.keys(update);
      const hasDollarKey = keys.some((key) => key.startsWith("$"));
      if (hasDollarKey) {
        if (update.$push) {
          _applyTimestampToUpdateOperator(update.$push);
        }
        if (update.$addToSet) {
          _applyTimestampToUpdateOperator(update.$addToSet);
        }
        if (update.$set != null) {
          const keys2 = Object.keys(update.$set);
          for (const key of keys2) {
            applyTimestampsToUpdateKey(schema, key, update.$set, now);
          }
        }
        if (update.$setOnInsert != null) {
          const keys2 = Object.keys(update.$setOnInsert);
          for (const key of keys2) {
            applyTimestampsToUpdateKey(schema, key, update.$setOnInsert, now);
          }
        }
      }
      const updateKeys = Object.keys(update).filter((key) => !key.startsWith("$"));
      for (const key of updateKeys) {
        applyTimestampsToUpdateKey(schema, key, update, now);
      }
      function _applyTimestampToUpdateOperator(op) {
        for (const key of Object.keys(op)) {
          const $path = schema.path(key.replace(/\.\$\./i, ".").replace(/.\$$/, ""));
          if (op[key] && $path && $path.$isMongooseDocumentArray && $path.schema.options.timestamps) {
            const timestamps = $path.schema.options.timestamps;
            const createdAt = handleTimestampOption(timestamps, "createdAt");
            const updatedAt = handleTimestampOption(timestamps, "updatedAt");
            if (op[key].$each) {
              op[key].$each.forEach(function(subdoc) {
                if (updatedAt != null) {
                  subdoc[updatedAt] = now;
                }
                if (createdAt != null) {
                  subdoc[createdAt] = now;
                }
              });
            } else {
              if (updatedAt != null) {
                op[key][updatedAt] = now;
              }
              if (createdAt != null) {
                op[key][createdAt] = now;
              }
            }
          }
        }
      }
    }
    function applyTimestampsToDocumentArray(arr, schematype, now) {
      const timestamps = schematype.schema.options.timestamps;
      if (!timestamps) {
        return;
      }
      const len = arr.length;
      const createdAt = handleTimestampOption(timestamps, "createdAt");
      const updatedAt = handleTimestampOption(timestamps, "updatedAt");
      for (let i = 0; i < len; ++i) {
        if (updatedAt != null) {
          arr[i][updatedAt] = now;
        }
        if (createdAt != null) {
          arr[i][createdAt] = now;
        }
        applyTimestampsToChildren(now, arr[i], schematype.schema);
      }
    }
    function applyTimestampsToSingleNested(subdoc, schematype, now) {
      const timestamps = schematype.schema.options.timestamps;
      if (!timestamps) {
        return;
      }
      const createdAt = handleTimestampOption(timestamps, "createdAt");
      const updatedAt = handleTimestampOption(timestamps, "updatedAt");
      if (updatedAt != null) {
        subdoc[updatedAt] = now;
      }
      if (createdAt != null) {
        subdoc[createdAt] = now;
      }
      applyTimestampsToChildren(now, subdoc, schematype.schema);
    }
    function applyTimestampsToUpdateKey(schema, key, update, now) {
      const keyToSearch = cleanPositionalOperators(key);
      const path = schema.path(keyToSearch);
      if (!path) {
        return;
      }
      const parentSchemaTypes = [];
      const pieces = keyToSearch.split(".");
      for (let i = pieces.length - 1; i > 0; --i) {
        const s = schema.path(pieces.slice(0, i).join("."));
        if (s != null && (s.$isMongooseDocumentArray || s.$isSingleNested)) {
          parentSchemaTypes.push({ parentPath: key.split(".").slice(0, i).join("."), parentSchemaType: s });
        }
      }
      if (Array.isArray(update[key]) && path.$isMongooseDocumentArray) {
        applyTimestampsToDocumentArray(update[key], path, now);
      } else if (update[key] && path.$isSingleNested) {
        applyTimestampsToSingleNested(update[key], path, now);
      } else if (parentSchemaTypes.length > 0) {
        for (const item of parentSchemaTypes) {
          const parentPath = item.parentPath;
          const parentSchemaType = item.parentSchemaType;
          const timestamps = parentSchemaType.schema.options.timestamps;
          const updatedAt = handleTimestampOption(timestamps, "updatedAt");
          if (!timestamps || updatedAt == null) {
            continue;
          }
          if (parentSchemaType.$isSingleNested) {
            update[parentPath + "." + updatedAt] = now;
          } else if (parentSchemaType.$isMongooseDocumentArray) {
            let childPath = key.substr(parentPath.length + 1);
            if (/^\d+$/.test(childPath)) {
              update[parentPath + "." + childPath][updatedAt] = now;
              continue;
            }
            const firstDot = childPath.indexOf(".");
            childPath = firstDot !== -1 ? childPath.substr(0, firstDot) : childPath;
            update[parentPath + "." + childPath + "." + updatedAt] = now;
          }
        }
      } else if (path.schema != null && path.schema != schema && update[key]) {
        const timestamps = path.schema.options.timestamps;
        const createdAt = handleTimestampOption(timestamps, "createdAt");
        const updatedAt = handleTimestampOption(timestamps, "updatedAt");
        if (!timestamps) {
          return;
        }
        if (updatedAt != null) {
          update[key][updatedAt] = now;
        }
        if (createdAt != null) {
          update[key][createdAt] = now;
        }
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js
var require_applyTimestampsToUpdate = __commonJS({
  "node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    module2.exports = applyTimestampsToUpdate;
    function applyTimestampsToUpdate(now, createdAt, updatedAt, currentUpdate, options) {
      const updates = currentUpdate;
      let _updates = updates;
      const overwrite = get(options, "overwrite", false);
      const timestamps = get(options, "timestamps", true);
      if (!timestamps || updates == null) {
        return currentUpdate;
      }
      const skipCreatedAt = timestamps != null && timestamps.createdAt === false;
      const skipUpdatedAt = timestamps != null && timestamps.updatedAt === false;
      if (overwrite) {
        if (currentUpdate && currentUpdate.$set) {
          currentUpdate = currentUpdate.$set;
          updates.$set = {};
          _updates = updates.$set;
        }
        if (!skipUpdatedAt && updatedAt && !currentUpdate[updatedAt]) {
          _updates[updatedAt] = now;
        }
        if (!skipCreatedAt && createdAt && !currentUpdate[createdAt]) {
          _updates[createdAt] = now;
        }
        return updates;
      }
      currentUpdate = currentUpdate || {};
      if (Array.isArray(updates)) {
        updates.push({ $set: { updatedAt: now } });
        return updates;
      }
      updates.$set = updates.$set || {};
      if (!skipUpdatedAt && updatedAt && (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {
        let timestampSet = false;
        if (updatedAt.indexOf(".") !== -1) {
          const pieces = updatedAt.split(".");
          for (let i = 1; i < pieces.length; ++i) {
            const remnant = pieces.slice(-i).join(".");
            const start = pieces.slice(0, -i).join(".");
            if (currentUpdate[start] != null) {
              currentUpdate[start][remnant] = now;
              timestampSet = true;
              break;
            } else if (currentUpdate.$set && currentUpdate.$set[start]) {
              currentUpdate.$set[start][remnant] = now;
              timestampSet = true;
              break;
            }
          }
        }
        if (!timestampSet) {
          updates.$set[updatedAt] = now;
        }
        if (updates.hasOwnProperty(updatedAt)) {
          delete updates[updatedAt];
        }
      }
      if (!skipCreatedAt && createdAt) {
        if (currentUpdate[createdAt]) {
          delete currentUpdate[createdAt];
        }
        if (currentUpdate.$set && currentUpdate.$set[createdAt]) {
          delete currentUpdate.$set[createdAt];
        }
        let timestampSet = false;
        if (createdAt.indexOf(".") !== -1) {
          const pieces = createdAt.split(".");
          for (let i = 1; i < pieces.length; ++i) {
            const remnant = pieces.slice(-i).join(".");
            const start = pieces.slice(0, -i).join(".");
            if (currentUpdate[start] != null) {
              currentUpdate[start][remnant] = now;
              timestampSet = true;
              break;
            } else if (currentUpdate.$set && currentUpdate.$set[start]) {
              currentUpdate.$set[start][remnant] = now;
              timestampSet = true;
              break;
            }
          }
        }
        if (!timestampSet) {
          updates.$setOnInsert = updates.$setOnInsert || {};
          updates.$setOnInsert[createdAt] = now;
        }
      }
      if (Object.keys(updates.$set).length === 0) {
        delete updates.$set;
      }
      return updates;
    }
  }
});

// node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js
var require_setupTimestamps = __commonJS({
  "node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js"(exports2, module2) {
    "use strict";
    var applyTimestampsToChildren = require_applyTimestampsToChildren();
    var applyTimestampsToUpdate = require_applyTimestampsToUpdate();
    var get = require_get();
    var handleTimestampOption = require_handleTimestampOption();
    var symbols = require_symbols2();
    module2.exports = function setupTimestamps(schema, timestamps) {
      const childHasTimestamp = schema.childSchemas.find(withTimestamp);
      function withTimestamp(s) {
        const ts = s.schema.options.timestamps;
        return !!ts;
      }
      if (!timestamps && !childHasTimestamp) {
        return;
      }
      const createdAt = handleTimestampOption(timestamps, "createdAt");
      const updatedAt = handleTimestampOption(timestamps, "updatedAt");
      const currentTime = timestamps != null && timestamps.hasOwnProperty("currentTime") ? timestamps.currentTime : null;
      const schemaAdditions = {};
      schema.$timestamps = { createdAt, updatedAt };
      if (updatedAt && !schema.paths[updatedAt]) {
        schemaAdditions[updatedAt] = Date;
      }
      if (createdAt && !schema.paths[createdAt]) {
        schemaAdditions[createdAt] = Date;
      }
      schema.add(schemaAdditions);
      schema.pre("save", function(next) {
        const timestampOption = get(this, "$__.saveOptions.timestamps");
        if (timestampOption === false) {
          return next();
        }
        const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;
        const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;
        const defaultTimestamp = currentTime != null ? currentTime() : (this.ownerDocument ? this.ownerDocument() : this).constructor.base.now();
        const auto_id = this._id && this._id.auto;
        if (!skipCreatedAt && createdAt && !this.get(createdAt) && this.$__isSelected(createdAt)) {
          this.$set(createdAt, auto_id ? this._id.getTimestamp() : defaultTimestamp);
        }
        if (!skipUpdatedAt && updatedAt && (this.isNew || this.isModified())) {
          let ts = defaultTimestamp;
          if (this.isNew) {
            if (createdAt != null) {
              ts = this.$__getValue(createdAt);
            } else if (auto_id) {
              ts = this._id.getTimestamp();
            }
          }
          this.$set(updatedAt, ts);
        }
        next();
      });
      schema.methods.initializeTimestamps = function() {
        const ts = currentTime != null ? currentTime() : this.constructor.base.now();
        if (createdAt && !this.get(createdAt)) {
          this.$set(createdAt, ts);
        }
        if (updatedAt && !this.get(updatedAt)) {
          this.$set(updatedAt, ts);
        }
        return this;
      };
      _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;
      const opts = { query: true, model: false };
      schema.pre("findOneAndReplace", opts, _setTimestampsOnUpdate);
      schema.pre("findOneAndUpdate", opts, _setTimestampsOnUpdate);
      schema.pre("replaceOne", opts, _setTimestampsOnUpdate);
      schema.pre("update", opts, _setTimestampsOnUpdate);
      schema.pre("updateOne", opts, _setTimestampsOnUpdate);
      schema.pre("updateMany", opts, _setTimestampsOnUpdate);
      function _setTimestampsOnUpdate(next) {
        const now = currentTime != null ? currentTime() : this.model.base.now();
        if (this.op === "findOneAndReplace" && this.getUpdate() == null) {
          this.setUpdate({});
        }
        applyTimestampsToUpdate(now, createdAt, updatedAt, this.getUpdate(), this.options, this.schema);
        applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);
        next();
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/populate/validateRef.js
var require_validateRef = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/validateRef.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var util = require("util");
    module2.exports = validateRef;
    function validateRef(ref, path) {
      if (typeof ref === "string") {
        return;
      }
      if (typeof ref === "function") {
        return;
      }
      throw new MongooseError('Invalid ref at path "' + path + '". Got ' + util.inspect(ref, { depth: 0 }));
    }
  }
});

// node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js
var require_applyQueryMiddleware = __commonJS({
  "node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js"(exports2, module2) {
    "use strict";
    module2.exports = applyQueryMiddleware;
    applyQueryMiddleware.middlewareFunctions = [
      "count",
      "countDocuments",
      "deleteMany",
      "deleteOne",
      "distinct",
      "estimatedDocumentCount",
      "find",
      "findOne",
      "findOneAndDelete",
      "findOneAndRemove",
      "findOneAndReplace",
      "findOneAndUpdate",
      "remove",
      "replaceOne",
      "update",
      "updateMany",
      "updateOne",
      "validate"
    ];
    function applyQueryMiddleware(Query, model2) {
      const kareemOptions = {
        useErrorHandlers: true,
        numCallbackParams: 1,
        nullResultByDefault: true
      };
      const middleware = model2.hooks.filter((hook) => {
        const contexts = _getContexts(hook);
        if (hook.name === "updateOne") {
          return contexts.query == null || !!contexts.query;
        }
        if (hook.name === "deleteOne") {
          return !!contexts.query || Object.keys(contexts).length === 0;
        }
        if (hook.name === "validate" || hook.name === "remove") {
          return !!contexts.query;
        }
        if (hook.query != null || hook.document != null) {
          return !!hook.query;
        }
        return true;
      });
      Query.prototype._execUpdate = middleware.createWrapper("update", Query.prototype._execUpdate, null, kareemOptions);
      Query.prototype.__distinct = middleware.createWrapper("distinct", Query.prototype.__distinct, null, kareemOptions);
      Query.prototype.validate = middleware.createWrapper("validate", Query.prototype.validate, null, kareemOptions);
      applyQueryMiddleware.middlewareFunctions.filter((v) => v !== "update" && v !== "distinct" && v !== "validate").forEach((fn) => {
        Query.prototype[`_${fn}`] = middleware.createWrapper(fn, Query.prototype[`_${fn}`], null, kareemOptions);
      });
    }
    function _getContexts(hook) {
      const ret2 = {};
      if (hook.hasOwnProperty("query")) {
        ret2.query = hook.query;
      }
      if (hook.hasOwnProperty("document")) {
        ret2.document = hook.document;
      }
      return ret2;
    }
  }
});

// node_modules/mongoose/lib/helpers/model/applyHooks.js
var require_applyHooks = __commonJS({
  "node_modules/mongoose/lib/helpers/model/applyHooks.js"(exports2, module2) {
    "use strict";
    var symbols = require_symbols2();
    var promiseOrCallback = require_promiseOrCallback();
    module2.exports = applyHooks;
    applyHooks.middlewareFunctions = [
      "deleteOne",
      "save",
      "validate",
      "remove",
      "updateOne",
      "init"
    ];
    function applyHooks(model2, schema, options) {
      options = options || {};
      const kareemOptions = {
        useErrorHandlers: true,
        numCallbackParams: 1,
        nullResultByDefault: true,
        contextParameter: true
      };
      const objToDecorate = options.decorateDoc ? model2 : model2.prototype;
      model2.$appliedHooks = true;
      for (const key of Object.keys(schema.paths)) {
        const type = schema.paths[key];
        let childModel = null;
        if (type.$isSingleNested) {
          childModel = type.caster;
        } else if (type.$isMongooseDocumentArray) {
          childModel = type.Constructor;
        } else {
          continue;
        }
        if (childModel.$appliedHooks) {
          continue;
        }
        applyHooks(childModel, type.schema, options);
        if (childModel.discriminators != null) {
          const keys = Object.keys(childModel.discriminators);
          for (const key2 of keys) {
            applyHooks(childModel.discriminators[key2], childModel.discriminators[key2].schema, options);
          }
        }
      }
      const middleware = schema.s.hooks.filter((hook) => {
        if (hook.name === "updateOne" || hook.name === "deleteOne") {
          return !!hook["document"];
        }
        if (hook.name === "remove" || hook.name === "init") {
          return hook["document"] == null || !!hook["document"];
        }
        if (hook.query != null || hook.document != null) {
          return hook.document !== false;
        }
        return true;
      }).filter((hook) => {
        if (schema.methods[hook.name]) {
          return !hook.fn[symbols.builtInMiddleware];
        }
        return true;
      });
      model2._middleware = middleware;
      objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;
      for (const method of ["save", "validate", "remove", "deleteOne"]) {
        const toWrap = method === "validate" ? "$__originalValidate" : `$__${method}`;
        const wrapped = middleware.createWrapper(method, objToDecorate[toWrap], null, kareemOptions);
        objToDecorate[`$__${method}`] = wrapped;
      }
      objToDecorate.$__init = middleware.createWrapperSync("init", objToDecorate.$__init, null, kareemOptions);
      const customMethods = Object.keys(schema.methods);
      const customMethodOptions = Object.assign({}, kareemOptions, {
        checkForPromise: true
      });
      for (const method of customMethods) {
        if (!middleware.hasHooks(method)) {
          continue;
        }
        const originalMethod = objToDecorate[method];
        objToDecorate[method] = function() {
          const args = Array.prototype.slice.call(arguments);
          const cb = args.slice(-1).pop();
          const argsWithoutCallback = typeof cb === "function" ? args.slice(0, args.length - 1) : args;
          return promiseOrCallback(cb, (callback) => {
            return this[`$__${method}`].apply(this, argsWithoutCallback.concat([callback]));
          }, model2.events);
        };
        objToDecorate[`$__${method}`] = middleware.createWrapper(method, originalMethod, null, customMethodOptions);
      }
    }
  }
});

// node_modules/mongoose/lib/options/SchemaStringOptions.js
var require_SchemaStringOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaStringOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaStringOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaStringOptions.prototype, "enum", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "match", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "lowercase", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "trim", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "uppercase", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "minLength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "minlength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "maxLength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "maxlength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "populate", opts);
    module2.exports = SchemaStringOptions;
  }
});

// node_modules/mongoose/lib/cast/string.js
var require_string = __commonJS({
  "node_modules/mongoose/lib/cast/string.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    module2.exports = function castString(value, path) {
      if (value == null) {
        return value;
      }
      if (value._id && typeof value._id === "string") {
        return value._id;
      }
      if (value.toString && value.toString !== Object.prototype.toString && !Array.isArray(value)) {
        return value.toString();
      }
      throw new CastError("string", value, path);
    };
  }
});

// node_modules/mongoose/lib/schema/string.js
var require_string2 = __commonJS({
  "node_modules/mongoose/lib/schema/string.js"(exports2, module2) {
    "use strict";
    var SchemaType = require_schematype();
    var MongooseError = require_error3();
    var SchemaStringOptions = require_SchemaStringOptions();
    var castString = require_string();
    var utils2 = require_utils8();
    var CastError = SchemaType.CastError;
    function SchemaString(key, options) {
      this.enumValues = [];
      this.regExp = null;
      SchemaType.call(this, key, options, "String");
    }
    SchemaString.schemaName = "String";
    SchemaString.defaultOptions = {};
    SchemaString.prototype = Object.create(SchemaType.prototype);
    SchemaString.prototype.constructor = SchemaString;
    Object.defineProperty(SchemaString.prototype, "OptionsConstructor", {
      configurable: false,
      enumerable: false,
      writable: false,
      value: SchemaStringOptions
    });
    SchemaString._cast = castString;
    SchemaString.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaString._defaultCaster = (v) => {
      if (v != null && typeof v !== "string") {
        throw new Error();
      }
      return v;
    };
    SchemaString.get = SchemaType.get;
    SchemaString.set = SchemaType.set;
    SchemaString._checkRequired = (v) => (v instanceof String || typeof v === "string") && v.length;
    SchemaString.checkRequired = SchemaType.checkRequired;
    SchemaString.prototype.enum = function() {
      if (this.enumValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.enumValidator;
        }, this);
        this.enumValidator = false;
      }
      if (arguments[0] === void 0 || arguments[0] === false) {
        return this;
      }
      let values;
      let errorMessage;
      if (utils2.isObject(arguments[0])) {
        if (Array.isArray(arguments[0].values)) {
          values = arguments[0].values;
          errorMessage = arguments[0].message;
        } else {
          values = utils2.object.vals(arguments[0]);
          errorMessage = MongooseError.messages.String.enum;
        }
      } else {
        values = arguments;
        errorMessage = MongooseError.messages.String.enum;
      }
      for (const value of values) {
        if (value !== void 0) {
          this.enumValues.push(this.cast(value));
        }
      }
      const vals = this.enumValues;
      this.enumValidator = function(v) {
        return v === void 0 || ~vals.indexOf(v);
      };
      this.validators.push({
        validator: this.enumValidator,
        message: errorMessage,
        type: "enum",
        enumValues: vals
      });
      return this;
    };
    SchemaString.prototype.lowercase = function(shouldApply) {
      if (arguments.length > 0 && !shouldApply) {
        return this;
      }
      return this.set(function(v, self2) {
        if (typeof v !== "string") {
          v = self2.cast(v);
        }
        if (v) {
          return v.toLowerCase();
        }
        return v;
      });
    };
    SchemaString.prototype.uppercase = function(shouldApply) {
      if (arguments.length > 0 && !shouldApply) {
        return this;
      }
      return this.set(function(v, self2) {
        if (typeof v !== "string") {
          v = self2.cast(v);
        }
        if (v) {
          return v.toUpperCase();
        }
        return v;
      });
    };
    SchemaString.prototype.trim = function(shouldTrim) {
      if (arguments.length > 0 && !shouldTrim) {
        return this;
      }
      return this.set(function(v, self2) {
        if (typeof v !== "string") {
          v = self2.cast(v);
        }
        if (v) {
          return v.trim();
        }
        return v;
      });
    };
    SchemaString.prototype.minlength = function(value, message) {
      if (this.minlengthValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.minlengthValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.String.minlength;
        msg = msg.replace(/{MINLENGTH}/, value);
        this.validators.push({
          validator: this.minlengthValidator = function(v) {
            return v === null || v.length >= value;
          },
          message: msg,
          type: "minlength",
          minlength: value
        });
      }
      return this;
    };
    SchemaString.prototype.minLength = SchemaString.prototype.minlength;
    SchemaString.prototype.maxlength = function(value, message) {
      if (this.maxlengthValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.maxlengthValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.String.maxlength;
        msg = msg.replace(/{MAXLENGTH}/, value);
        this.validators.push({
          validator: this.maxlengthValidator = function(v) {
            return v === null || v.length <= value;
          },
          message: msg,
          type: "maxlength",
          maxlength: value
        });
      }
      return this;
    };
    SchemaString.prototype.maxLength = SchemaString.prototype.maxlength;
    SchemaString.prototype.match = function match(regExp, message) {
      const msg = message || MongooseError.messages.String.match;
      const matchValidator = function(v) {
        if (!regExp) {
          return false;
        }
        regExp.lastIndex = 0;
        const ret2 = v != null && v !== "" ? regExp.test(v) : true;
        return ret2;
      };
      this.validators.push({
        validator: matchValidator,
        message: msg,
        type: "regexp",
        regexp: regExp
      });
      return this;
    };
    SchemaString.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : SchemaString.checkRequired();
      return _checkRequired(value);
    };
    SchemaString.prototype.cast = function(value, doc, init) {
      if (SchemaType._isRef(this, value, doc, init)) {
        if (typeof value === "string") {
          return value;
        }
        return this._castRef(value, doc, init);
      }
      let castString2;
      if (typeof this._castFunction === "function") {
        castString2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castString2 = this.constructor.cast();
      } else {
        castString2 = SchemaString.cast();
      }
      try {
        return castString2(value);
      } catch (error) {
        throw new CastError("string", value, this.path, null, this);
      }
    };
    function handleSingle(val) {
      return this.castForQuery(val);
    }
    function handleArray(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.castForQuery(val)];
      }
      return val.map(function(m) {
        return _this.castForQuery(m);
      });
    }
    var $conditionalHandlers = utils2.options(SchemaType.prototype.$conditionalHandlers, {
      $all: handleArray,
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle,
      $options: String,
      $regex: handleSingle,
      $not: handleSingle
    });
    Object.defineProperty(SchemaString.prototype, "$conditionalHandlers", {
      configurable: false,
      enumerable: false,
      writable: false,
      value: Object.freeze($conditionalHandlers)
    });
    SchemaString.prototype.castForQuery = function($conditional, val) {
      let handler;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new Error("Can't use " + $conditional + " with String.");
        }
        return handler.call(this, val);
      }
      val = $conditional;
      if (Object.prototype.toString.call(val) === "[object RegExp]") {
        return val;
      }
      return this._castForQuery(val);
    };
    module2.exports = SchemaString;
  }
});

// node_modules/mongoose/lib/options/SchemaNumberOptions.js
var require_SchemaNumberOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaNumberOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaNumberOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaNumberOptions.prototype, "min", opts);
    Object.defineProperty(SchemaNumberOptions.prototype, "max", opts);
    Object.defineProperty(SchemaNumberOptions.prototype, "enum", opts);
    Object.defineProperty(SchemaNumberOptions.prototype, "populate", opts);
    module2.exports = SchemaNumberOptions;
  }
});

// node_modules/mongoose/lib/cast/number.js
var require_number = __commonJS({
  "node_modules/mongoose/lib/cast/number.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    module2.exports = function castNumber(val) {
      if (val == null) {
        return val;
      }
      if (val === "") {
        return null;
      }
      if (typeof val === "string" || typeof val === "boolean") {
        val = Number(val);
      }
      assert.ok(!isNaN(val));
      if (val instanceof Number) {
        return val.valueOf();
      }
      if (typeof val === "number") {
        return val;
      }
      if (!Array.isArray(val) && typeof val.valueOf === "function") {
        return Number(val.valueOf());
      }
      if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {
        return Number(val);
      }
      assert.ok(false);
    };
  }
});

// node_modules/mongoose/lib/schema/operators/bitwise.js
var require_bitwise = __commonJS({
  "node_modules/mongoose/lib/schema/operators/bitwise.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    function handleBitwiseOperator(val) {
      const _this = this;
      if (Array.isArray(val)) {
        return val.map(function(v) {
          return _castNumber(_this.path, v);
        });
      } else if (Buffer.isBuffer(val)) {
        return val;
      }
      return _castNumber(_this.path, val);
    }
    function _castNumber(path, num) {
      const v = Number(num);
      if (isNaN(v)) {
        throw new CastError("number", num, path);
      }
      return v;
    }
    module2.exports = handleBitwiseOperator;
  }
});

// node_modules/mongoose/lib/schema/number.js
var require_number2 = __commonJS({
  "node_modules/mongoose/lib/schema/number.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var SchemaNumberOptions = require_SchemaNumberOptions();
    var SchemaType = require_schematype();
    var castNumber = require_number();
    var handleBitwiseOperator = require_bitwise();
    var utils2 = require_utils8();
    var CastError = SchemaType.CastError;
    function SchemaNumber(key, options) {
      SchemaType.call(this, key, options, "Number");
    }
    SchemaNumber.get = SchemaType.get;
    SchemaNumber.set = SchemaType.set;
    SchemaNumber._cast = castNumber;
    SchemaNumber.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaNumber._defaultCaster = (v) => {
      if (typeof v !== "number") {
        throw new Error();
      }
      return v;
    };
    SchemaNumber.schemaName = "Number";
    SchemaNumber.defaultOptions = {};
    SchemaNumber.prototype = Object.create(SchemaType.prototype);
    SchemaNumber.prototype.constructor = SchemaNumber;
    SchemaNumber.prototype.OptionsConstructor = SchemaNumberOptions;
    SchemaNumber._checkRequired = (v) => typeof v === "number" || v instanceof Number;
    SchemaNumber.checkRequired = SchemaType.checkRequired;
    SchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : SchemaNumber.checkRequired();
      return _checkRequired(value);
    };
    SchemaNumber.prototype.min = function(value, message) {
      if (this.minValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.minValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.Number.min;
        msg = msg.replace(/{MIN}/, value);
        this.validators.push({
          validator: this.minValidator = function(v) {
            return v == null || v >= value;
          },
          message: msg,
          type: "min",
          min: value
        });
      }
      return this;
    };
    SchemaNumber.prototype.max = function(value, message) {
      if (this.maxValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.maxValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.Number.max;
        msg = msg.replace(/{MAX}/, value);
        this.validators.push({
          validator: this.maxValidator = function(v) {
            return v == null || v <= value;
          },
          message: msg,
          type: "max",
          max: value
        });
      }
      return this;
    };
    SchemaNumber.prototype.enum = function(values, message) {
      if (this.enumValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.enumValidator;
        }, this);
      }
      if (!Array.isArray(values)) {
        if (utils2.isObject(values)) {
          values = utils2.object.vals(values);
        } else {
          values = Array.prototype.slice.call(arguments);
        }
        message = MongooseError.messages.Number.enum;
      }
      message = message == null ? MongooseError.messages.Number.enum : message;
      this.enumValidator = (v) => v == null || values.indexOf(v) !== -1;
      this.validators.push({
        validator: this.enumValidator,
        message,
        type: "enum",
        enumValues: values
      });
      return this;
    };
    SchemaNumber.prototype.cast = function(value, doc, init) {
      if (SchemaType._isRef(this, value, doc, init)) {
        if (typeof value === "number") {
          return value;
        }
        return this._castRef(value, doc, init);
      }
      const val = value && typeof value._id !== "undefined" ? value._id : value;
      let castNumber2;
      if (typeof this._castFunction === "function") {
        castNumber2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castNumber2 = this.constructor.cast();
      } else {
        castNumber2 = SchemaNumber.cast();
      }
      try {
        return castNumber2(val);
      } catch (err) {
        throw new CastError("Number", val, this.path, err, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    function handleArray(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.cast(val)];
      }
      return val.map(function(m) {
        return _this.cast(m);
      });
    }
    SchemaNumber.prototype.$conditionalHandlers = utils2.options(SchemaType.prototype.$conditionalHandlers, {
      $bitsAllClear: handleBitwiseOperator,
      $bitsAnyClear: handleBitwiseOperator,
      $bitsAllSet: handleBitwiseOperator,
      $bitsAnySet: handleBitwiseOperator,
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle,
      $mod: handleArray
    });
    SchemaNumber.prototype.castForQuery = function($conditional, val) {
      let handler;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new CastError("number", val, this.path, null, this);
        }
        return handler.call(this, val);
      }
      val = this._castForQuery($conditional);
      return val;
    };
    module2.exports = SchemaNumber;
  }
});

// node_modules/mongoose/lib/schema/boolean.js
var require_boolean2 = __commonJS({
  "node_modules/mongoose/lib/schema/boolean.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    var SchemaType = require_schematype();
    var castBoolean = require_boolean();
    var utils2 = require_utils8();
    function SchemaBoolean(path, options) {
      SchemaType.call(this, path, options, "Boolean");
    }
    SchemaBoolean.schemaName = "Boolean";
    SchemaBoolean.defaultOptions = {};
    SchemaBoolean.prototype = Object.create(SchemaType.prototype);
    SchemaBoolean.prototype.constructor = SchemaBoolean;
    SchemaBoolean._cast = castBoolean;
    SchemaBoolean.set = SchemaType.set;
    SchemaBoolean.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaBoolean._defaultCaster = (v) => {
      if (v != null && typeof v !== "boolean") {
        throw new Error();
      }
      return v;
    };
    SchemaBoolean._checkRequired = (v) => v === true || v === false;
    SchemaBoolean.checkRequired = SchemaType.checkRequired;
    SchemaBoolean.prototype.checkRequired = function(value) {
      return this.constructor._checkRequired(value);
    };
    Object.defineProperty(SchemaBoolean, "convertToTrue", {
      get: () => castBoolean.convertToTrue,
      set: (v) => {
        castBoolean.convertToTrue = v;
      }
    });
    Object.defineProperty(SchemaBoolean, "convertToFalse", {
      get: () => castBoolean.convertToFalse,
      set: (v) => {
        castBoolean.convertToFalse = v;
      }
    });
    SchemaBoolean.prototype.cast = function(value) {
      let castBoolean2;
      if (typeof this._castFunction === "function") {
        castBoolean2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castBoolean2 = this.constructor.cast();
      } else {
        castBoolean2 = SchemaBoolean.cast();
      }
      try {
        return castBoolean2(value);
      } catch (error) {
        throw new CastError("Boolean", value, this.path, error, this);
      }
    };
    SchemaBoolean.$conditionalHandlers = utils2.options(SchemaType.prototype.$conditionalHandlers, {});
    SchemaBoolean.prototype.castForQuery = function($conditional, val) {
      let handler;
      if (arguments.length === 2) {
        handler = SchemaBoolean.$conditionalHandlers[$conditional];
        if (handler) {
          return handler.call(this, val);
        }
        return this._castForQuery(val);
      }
      return this._castForQuery($conditional);
    };
    SchemaBoolean.prototype._castNullish = function _castNullish(v) {
      if (typeof v === "undefined" && this.$$context != null && this.$$context._mongooseOptions != null && this.$$context._mongooseOptions.omitUndefined) {
        return v;
      }
      const castBoolean2 = typeof this.constructor.cast === "function" ? this.constructor.cast() : SchemaBoolean.cast();
      if (castBoolean2 == null) {
        return v;
      }
      if (castBoolean2.convertToFalse instanceof Set && castBoolean2.convertToFalse.has(v)) {
        return false;
      }
      if (castBoolean2.convertToTrue instanceof Set && castBoolean2.convertToTrue.has(v)) {
        return true;
      }
      return v;
    };
    module2.exports = SchemaBoolean;
  }
});

// node_modules/mongoose/lib/options/SchemaArrayOptions.js
var require_SchemaArrayOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaArrayOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaArrayOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaArrayOptions.prototype, "enum", opts);
    Object.defineProperty(SchemaArrayOptions.prototype, "of", opts);
    module2.exports = SchemaArrayOptions;
  }
});

// node_modules/mongoose/lib/helpers/arrayDepth.js
var require_arrayDepth = __commonJS({
  "node_modules/mongoose/lib/helpers/arrayDepth.js"(exports2, module2) {
    "use strict";
    module2.exports = arrayDepth;
    function arrayDepth(arr) {
      if (!Array.isArray(arr)) {
        return { min: 0, max: 0, containsNonArrayItem: true };
      }
      if (arr.length === 0) {
        return { min: 1, max: 1, containsNonArrayItem: false };
      }
      if (arr.length === 1 && !Array.isArray(arr[0])) {
        return { min: 1, max: 1, containsNonArrayItem: false };
      }
      const res = arrayDepth(arr[0]);
      for (let i = 1; i < arr.length; ++i) {
        const _res = arrayDepth(arr[i]);
        if (_res.min < res.min) {
          res.min = _res.min;
        }
        if (_res.max > res.max) {
          res.max = _res.max;
        }
        res.containsNonArrayItem = res.containsNonArrayItem || _res.containsNonArrayItem;
      }
      res.min = res.min + 1;
      res.max = res.max + 1;
      return res;
    }
  }
});

// node_modules/mongoose/lib/schema/operators/text.js
var require_text2 = __commonJS({
  "node_modules/mongoose/lib/schema/operators/text.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    var castBoolean = require_boolean();
    var castString = require_string();
    module2.exports = function(val, path) {
      if (val == null || typeof val !== "object") {
        throw new CastError("$text", val, path);
      }
      if (val.$search != null) {
        val.$search = castString(val.$search, path + ".$search");
      }
      if (val.$language != null) {
        val.$language = castString(val.$language, path + ".$language");
      }
      if (val.$caseSensitive != null) {
        val.$caseSensitive = castBoolean(val.$caseSensitive, path + ".$castSensitive");
      }
      if (val.$diacriticSensitive != null) {
        val.$diacriticSensitive = castBoolean(val.$diacriticSensitive, path + ".$diacriticSensitive");
      }
      return val;
    };
  }
});

// node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js
var require_areDiscriminatorValuesEqual = __commonJS({
  "node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js"(exports2, module2) {
    "use strict";
    var ObjectId2 = require_objectid3();
    module2.exports = function areDiscriminatorValuesEqual(a, b) {
      if (typeof a === "string" && typeof b === "string") {
        return a === b;
      }
      if (typeof a === "number" && typeof b === "number") {
        return a === b;
      }
      if (a instanceof ObjectId2 && b instanceof ObjectId2) {
        return a.toString() === b.toString();
      }
      return false;
    };
  }
});

// node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js
var require_getSchemaDiscriminatorByValue = __commonJS({
  "node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js"(exports2, module2) {
    "use strict";
    var areDiscriminatorValuesEqual = require_areDiscriminatorValuesEqual();
    module2.exports = function getSchemaDiscriminatorByValue(schema, value) {
      if (schema == null || schema.discriminators == null) {
        return null;
      }
      for (const key of Object.keys(schema.discriminators)) {
        const discriminatorSchema = schema.discriminators[key];
        if (discriminatorSchema.discriminatorMapping == null) {
          continue;
        }
        if (areDiscriminatorValuesEqual(discriminatorSchema.discriminatorMapping.value, value)) {
          return discriminatorSchema;
        }
      }
      return null;
    };
  }
});

// node_modules/mongoose/lib/helpers/query/isOperator.js
var require_isOperator = __commonJS({
  "node_modules/mongoose/lib/helpers/query/isOperator.js"(exports2, module2) {
    "use strict";
    var specialKeys = new Set([
      "$ref",
      "$id",
      "$db"
    ]);
    module2.exports = function isOperator(path) {
      return path.startsWith("$") && !specialKeys.has(path);
    };
  }
});

// node_modules/mongoose/lib/cast.js
var require_cast2 = __commonJS({
  "node_modules/mongoose/lib/cast.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    var StrictModeError = require_strict();
    var Types = require_schema();
    var castTextSearch = require_text2();
    var get = require_get();
    var getConstructorName = require_getConstructorName();
    var getSchemaDiscriminatorByValue = require_getSchemaDiscriminatorByValue();
    var isOperator = require_isOperator();
    var util = require("util");
    var isObject2 = require_isObject();
    var isMongooseObject = require_isMongooseObject();
    var ALLOWED_GEOWITHIN_GEOJSON_TYPES = ["Polygon", "MultiPolygon"];
    module2.exports = function cast(schema, obj, options, context) {
      if (Array.isArray(obj)) {
        throw new Error("Query filter must be an object, got an array ", util.inspect(obj));
      }
      if (obj == null) {
        return obj;
      }
      if (obj.hasOwnProperty("_bsontype") && obj._bsontype !== "ObjectID") {
        delete obj._bsontype;
      }
      if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {
        schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;
      }
      const paths = Object.keys(obj);
      let i = paths.length;
      let _keys;
      let any$conditionals;
      let schematype;
      let nested;
      let path;
      let type;
      let val;
      options = options || {};
      while (i--) {
        path = paths[i];
        val = obj[path];
        if (path === "$or" || path === "$nor" || path === "$and") {
          if (!Array.isArray(val)) {
            throw new CastError("Array", val, path);
          }
          for (let k = 0; k < val.length; ++k) {
            if (val[k] == null || typeof val[k] !== "object") {
              throw new CastError("Object", val[k], path + "." + k);
            }
            val[k] = cast(schema, val[k], options, context);
          }
        } else if (path === "$where") {
          type = typeof val;
          if (type !== "string" && type !== "function") {
            throw new Error("Must have a string or function for $where");
          }
          if (type === "function") {
            obj[path] = val.toString();
          }
          continue;
        } else if (path === "$elemMatch") {
          val = cast(schema, val, options, context);
        } else if (path === "$text") {
          val = castTextSearch(val, path);
        } else {
          if (!schema) {
            continue;
          }
          schematype = schema.path(path);
          if (!schematype) {
            const split = path.split(".");
            let j = split.length;
            while (j--) {
              const pathFirstHalf = split.slice(0, j).join(".");
              const pathLastHalf = split.slice(j).join(".");
              const _schematype = schema.path(pathFirstHalf);
              const discriminatorKey = get(_schematype, "schema.options.discriminatorKey");
              if (_schematype != null && get(_schematype, "schema.discriminators") != null && discriminatorKey != null && pathLastHalf !== discriminatorKey) {
                const discriminatorVal = get(obj, pathFirstHalf + "." + discriminatorKey);
                if (discriminatorVal != null) {
                  schematype = _schematype.schema.discriminators[discriminatorVal].path(pathLastHalf);
                }
              }
            }
          }
          if (!schematype) {
            const split = path.split(".");
            let j = split.length;
            let pathFirstHalf;
            let pathLastHalf;
            let remainingConds;
            while (j--) {
              pathFirstHalf = split.slice(0, j).join(".");
              schematype = schema.path(pathFirstHalf);
              if (schematype) {
                break;
              }
            }
            if (schematype) {
              if (schematype.caster && schematype.caster.schema) {
                remainingConds = {};
                pathLastHalf = split.slice(j).join(".");
                remainingConds[pathLastHalf] = val;
                obj[path] = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];
              } else {
                obj[path] = val;
              }
              continue;
            }
            if (isObject2(val)) {
              let geo = "";
              if (val.$near) {
                geo = "$near";
              } else if (val.$nearSphere) {
                geo = "$nearSphere";
              } else if (val.$within) {
                geo = "$within";
              } else if (val.$geoIntersects) {
                geo = "$geoIntersects";
              } else if (val.$geoWithin) {
                geo = "$geoWithin";
              }
              if (geo) {
                const numbertype = new Types.Number("__QueryCasting__");
                let value = val[geo];
                if (val.$maxDistance != null) {
                  val.$maxDistance = numbertype.castForQueryWrapper({
                    val: val.$maxDistance,
                    context
                  });
                }
                if (val.$minDistance != null) {
                  val.$minDistance = numbertype.castForQueryWrapper({
                    val: val.$minDistance,
                    context
                  });
                }
                if (geo === "$within") {
                  const withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;
                  if (!withinType) {
                    throw new Error("Bad $within parameter: " + JSON.stringify(val));
                  }
                  value = withinType;
                } else if (geo === "$near" && typeof value.type === "string" && Array.isArray(value.coordinates)) {
                  value = value.coordinates;
                } else if ((geo === "$near" || geo === "$nearSphere" || geo === "$geoIntersects") && value.$geometry && typeof value.$geometry.type === "string" && Array.isArray(value.$geometry.coordinates)) {
                  if (value.$maxDistance != null) {
                    value.$maxDistance = numbertype.castForQueryWrapper({
                      val: value.$maxDistance,
                      context
                    });
                  }
                  if (value.$minDistance != null) {
                    value.$minDistance = numbertype.castForQueryWrapper({
                      val: value.$minDistance,
                      context
                    });
                  }
                  if (isMongooseObject(value.$geometry)) {
                    value.$geometry = value.$geometry.toObject({
                      transform: false,
                      virtuals: false
                    });
                  }
                  value = value.$geometry.coordinates;
                } else if (geo === "$geoWithin") {
                  if (value.$geometry) {
                    if (isMongooseObject(value.$geometry)) {
                      value.$geometry = value.$geometry.toObject({ virtuals: false });
                    }
                    const geoWithinType = value.$geometry.type;
                    if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {
                      throw new Error('Invalid geoJSON type for $geoWithin "' + geoWithinType + '", must be "Polygon" or "MultiPolygon"');
                    }
                    value = value.$geometry.coordinates;
                  } else {
                    value = value.$box || value.$polygon || value.$center || value.$centerSphere;
                    if (isMongooseObject(value)) {
                      value = value.toObject({ virtuals: false });
                    }
                  }
                }
                _cast(value, numbertype, context);
                continue;
              }
            }
            if (schema.nested[path]) {
              continue;
            }
            if (options.upsert && options.strict) {
              if (options.strict === "throw") {
                throw new StrictModeError(path);
              }
              throw new StrictModeError(path, 'Path "' + path + '" is not in schema, strict mode is `true`, and upsert is `true`.');
            } else if (options.strictQuery === "throw") {
              throw new StrictModeError(path, 'Path "' + path + `" is not in schema and strictQuery is 'throw'.`);
            } else if (options.strictQuery) {
              delete obj[path];
            }
          } else if (val == null) {
            continue;
          } else if (getConstructorName(val) === "Object") {
            any$conditionals = Object.keys(val).some(isOperator);
            if (!any$conditionals) {
              obj[path] = schematype.castForQueryWrapper({
                val,
                context
              });
            } else {
              const ks = Object.keys(val);
              let $cond;
              let k = ks.length;
              while (k--) {
                $cond = ks[k];
                nested = val[$cond];
                if ($cond === "$not") {
                  if (nested && schematype && !schematype.caster) {
                    _keys = Object.keys(nested);
                    if (_keys.length && isOperator(_keys[0])) {
                      for (const key in nested) {
                        nested[key] = schematype.castForQueryWrapper({
                          $conditional: key,
                          val: nested[key],
                          context
                        });
                      }
                    } else {
                      val[$cond] = schematype.castForQueryWrapper({
                        $conditional: $cond,
                        val: nested,
                        context
                      });
                    }
                    continue;
                  }
                  cast(schematype.caster ? schematype.caster.schema : schema, nested, options, context);
                } else {
                  val[$cond] = schematype.castForQueryWrapper({
                    $conditional: $cond,
                    val: nested,
                    context
                  });
                }
              }
            }
          } else if (Array.isArray(val) && ["Buffer", "Array"].indexOf(schematype.instance) === -1) {
            const casted = [];
            const valuesArray = val;
            for (const _val of valuesArray) {
              casted.push(schematype.castForQueryWrapper({
                val: _val,
                context
              }));
            }
            obj[path] = { $in: casted };
          } else {
            obj[path] = schematype.castForQueryWrapper({
              val,
              context
            });
          }
        }
      }
      return obj;
    };
    function _cast(val, numbertype, context) {
      if (Array.isArray(val)) {
        val.forEach(function(item, i) {
          if (Array.isArray(item) || isObject2(item)) {
            return _cast(item, numbertype, context);
          }
          val[i] = numbertype.castForQueryWrapper({ val: item, context });
        });
      } else {
        const nearKeys = Object.keys(val);
        let nearLen = nearKeys.length;
        while (nearLen--) {
          const nkey = nearKeys[nearLen];
          const item = val[nkey];
          if (Array.isArray(item) || isObject2(item)) {
            _cast(item, numbertype, context);
            val[nkey] = item;
          } else {
            val[nkey] = numbertype.castForQuery({ val: item, context });
          }
        }
      }
    }
  }
});

// node_modules/mongoose/lib/schema/operators/helpers.js
var require_helpers = __commonJS({
  "node_modules/mongoose/lib/schema/operators/helpers.js"(exports2) {
    "use strict";
    var SchemaNumber = require_number2();
    exports2.castToNumber = castToNumber;
    exports2.castArraysOfNumbers = castArraysOfNumbers;
    function castToNumber(val) {
      return SchemaNumber.cast()(val);
    }
    function castArraysOfNumbers(arr, self2) {
      arr.forEach(function(v, i) {
        if (Array.isArray(v)) {
          castArraysOfNumbers(v, self2);
        } else {
          arr[i] = castToNumber.call(self2, v);
        }
      });
    }
  }
});

// node_modules/mongoose/lib/schema/operators/geospatial.js
var require_geospatial = __commonJS({
  "node_modules/mongoose/lib/schema/operators/geospatial.js"(exports2) {
    "use strict";
    var castArraysOfNumbers = require_helpers().castArraysOfNumbers;
    var castToNumber = require_helpers().castToNumber;
    exports2.cast$geoIntersects = cast$geoIntersects;
    exports2.cast$near = cast$near;
    exports2.cast$within = cast$within;
    function cast$near(val) {
      const SchemaArray = require_array2();
      if (Array.isArray(val)) {
        castArraysOfNumbers(val, this);
        return val;
      }
      _castMinMaxDistance(this, val);
      if (val && val.$geometry) {
        return cast$geometry(val, this);
      }
      if (!Array.isArray(val)) {
        throw new TypeError("$near must be either an array or an object with a $geometry property");
      }
      return SchemaArray.prototype.castForQuery.call(this, val);
    }
    function cast$geometry(val, self2) {
      switch (val.$geometry.type) {
        case "Polygon":
        case "LineString":
        case "Point":
          castArraysOfNumbers(val.$geometry.coordinates, self2);
          break;
        default:
          break;
      }
      _castMinMaxDistance(self2, val);
      return val;
    }
    function cast$within(val) {
      _castMinMaxDistance(this, val);
      if (val.$box || val.$polygon) {
        const type = val.$box ? "$box" : "$polygon";
        val[type].forEach((arr) => {
          if (!Array.isArray(arr)) {
            const msg = "Invalid $within $box argument. Expected an array, received " + arr;
            throw new TypeError(msg);
          }
          arr.forEach((v, i) => {
            arr[i] = castToNumber.call(this, v);
          });
        });
      } else if (val.$center || val.$centerSphere) {
        const type = val.$center ? "$center" : "$centerSphere";
        val[type].forEach((item, i) => {
          if (Array.isArray(item)) {
            item.forEach((v, j) => {
              item[j] = castToNumber.call(this, v);
            });
          } else {
            val[type][i] = castToNumber.call(this, item);
          }
        });
      } else if (val.$geometry) {
        cast$geometry(val, this);
      }
      return val;
    }
    function cast$geoIntersects(val) {
      const geo = val.$geometry;
      if (!geo) {
        return;
      }
      cast$geometry(val, this);
      return val;
    }
    function _castMinMaxDistance(self2, val) {
      if (val.$maxDistance) {
        val.$maxDistance = castToNumber.call(self2, val.$maxDistance);
      }
      if (val.$minDistance) {
        val.$minDistance = castToNumber.call(self2, val.$minDistance);
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js
var require_getDiscriminatorByValue = __commonJS({
  "node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js"(exports2, module2) {
    "use strict";
    var areDiscriminatorValuesEqual = require_areDiscriminatorValuesEqual();
    module2.exports = function getDiscriminatorByValue(discriminators, value) {
      if (discriminators == null) {
        return null;
      }
      for (const name of Object.keys(discriminators)) {
        const it = discriminators[name];
        if (it.schema && it.schema.discriminatorMapping && areDiscriminatorValuesEqual(it.schema.discriminatorMapping.value, value)) {
          return it;
        }
      }
      return null;
    };
  }
});

// node_modules/mongoose/lib/browserDocument.js
var require_browserDocument = __commonJS({
  "node_modules/mongoose/lib/browserDocument.js"(exports2, module2) {
    "use strict";
    var NodeJSDocument = require_document();
    var EventEmitter = require("events").EventEmitter;
    var MongooseError = require_error3();
    var Schema2 = require_schema2();
    var ObjectId2 = require_objectid3();
    var ValidationError = MongooseError.ValidationError;
    var applyHooks = require_applyHooks();
    var isObject2 = require_isObject();
    function Document2(obj, schema, fields, skipId, skipInit) {
      if (!(this instanceof Document2)) {
        return new Document2(obj, schema, fields, skipId, skipInit);
      }
      if (isObject2(schema) && !schema.instanceOfSchema) {
        schema = new Schema2(schema);
      }
      schema = this.schema || schema;
      if (!this.schema && schema.options._id) {
        obj = obj || {};
        if (obj._id === void 0) {
          obj._id = new ObjectId2();
        }
      }
      if (!schema) {
        throw new MongooseError.MissingSchemaError();
      }
      this.$__setSchema(schema);
      NodeJSDocument.call(this, obj, fields, skipId, skipInit);
      applyHooks(this, schema, { decorateDoc: true });
      for (const m in schema.methods) {
        this[m] = schema.methods[m];
      }
      for (const s in schema.statics) {
        this[s] = schema.statics[s];
      }
    }
    Document2.prototype = Object.create(NodeJSDocument.prototype);
    Document2.prototype.constructor = Document2;
    Document2.events = new EventEmitter();
    Document2.$emitter = new EventEmitter();
    [
      "on",
      "once",
      "emit",
      "listeners",
      "removeListener",
      "setMaxListeners",
      "removeAllListeners",
      "addListener"
    ].forEach(function(emitterFn) {
      Document2[emitterFn] = function() {
        return Document2.$emitter[emitterFn].apply(Document2.$emitter, arguments);
      };
    });
    Document2.ValidationError = ValidationError;
    module2.exports = exports2 = Document2;
  }
});

// node_modules/mongoose/lib/document_provider.js
var require_document_provider = __commonJS({
  "node_modules/mongoose/lib/document_provider.js"(exports2, module2) {
    "use strict";
    var Document2 = require_document();
    var BrowserDocument = require_browserDocument();
    var isBrowser = false;
    module2.exports = function() {
      if (isBrowser) {
        return BrowserDocument;
      }
      return Document2;
    };
    module2.exports.setBrowser = function(flag) {
      isBrowser = flag;
    };
  }
});

// node_modules/mongoose/lib/options.js
var require_options = __commonJS({
  "node_modules/mongoose/lib/options.js"(exports2) {
    "use strict";
    exports2.internalToObjectOptions = {
      transform: false,
      virtuals: false,
      getters: false,
      _skipDepopulateTopLevel: true,
      depopulate: true,
      flattenDecimals: false,
      useProjection: false
    };
  }
});

// node_modules/mongoose/lib/types/embedded.js
var require_embedded = __commonJS({
  "node_modules/mongoose/lib/types/embedded.js"(exports2, module2) {
    "use strict";
    var Document2 = require_document_provider()();
    var EventEmitter = require("events").EventEmitter;
    var ValidationError = require_validation();
    var immediate = require_immediate();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var get = require_get();
    var promiseOrCallback = require_promiseOrCallback();
    var util = require("util");
    var documentArrayParent = require_symbols().documentArrayParent;
    var validatorErrorSymbol = require_symbols().validatorErrorSymbol;
    function EmbeddedDocument(obj, parentArr, skipId, fields, index) {
      const options = {};
      if (parentArr != null && parentArr.isMongooseDocumentArray) {
        this.__parentArray = parentArr;
        this[documentArrayParent] = parentArr.$parent();
      } else {
        this.__parentArray = void 0;
        this[documentArrayParent] = void 0;
      }
      this.$setIndex(index);
      this.$isDocumentArrayElement = true;
      if (this[documentArrayParent] != null) {
        options.defaults = this[documentArrayParent].$__.$options.defaults;
      }
      Document2.call(this, obj, fields, skipId, options);
      const _this = this;
      this.on("isNew", function(val) {
        _this.isNew = val;
      });
      _this.on("save", function() {
        _this.constructor.emit("save", _this);
      });
    }
    EmbeddedDocument.prototype = Object.create(Document2.prototype);
    EmbeddedDocument.prototype.constructor = EmbeddedDocument;
    for (const i in EventEmitter.prototype) {
      EmbeddedDocument[i] = EventEmitter.prototype[i];
    }
    EmbeddedDocument.prototype.toBSON = function() {
      return this.toObject(internalToObjectOptions);
    };
    EmbeddedDocument.prototype.$setIndex = function(index) {
      this.__index = index;
      if (get(this, "$__.validationError", null) != null) {
        const keys = Object.keys(this.$__.validationError.errors);
        for (const key of keys) {
          this.invalidate(key, this.$__.validationError.errors[key]);
        }
      }
    };
    EmbeddedDocument.prototype.markModified = function(path) {
      this.$__.activePaths.modify(path);
      if (!this.__parentArray) {
        return;
      }
      const pathToCheck = this.__parentArray.$path() + ".0." + path;
      if (this.isNew && this.ownerDocument().$__isSelected(pathToCheck)) {
        this.__parentArray._markModified();
      } else {
        this.__parentArray._markModified(this, path);
      }
    };
    EmbeddedDocument.prototype.populate = function() {
      throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.arr[0].populate("path")`, use `doc.populate("arr.0.path")`');
    };
    EmbeddedDocument.prototype.save = function(options, fn) {
      if (typeof options === "function") {
        fn = options;
        options = {};
      }
      options = options || {};
      if (!options.suppressWarning) {
        console.warn("mongoose: calling `save()` on a subdoc does **not** save the document to MongoDB, it only runs save middleware. Use `subdoc.save({ suppressWarning: true })` to hide this warning if you're sure this behavior is right for your app.");
      }
      return promiseOrCallback(fn, (cb) => {
        this.$__save(cb);
      });
    };
    EmbeddedDocument.prototype.$__save = function(fn) {
      return immediate(() => fn(null, this));
    };
    function registerRemoveListener(sub) {
      let owner = sub.ownerDocument();
      function emitRemove() {
        owner.removeListener("save", emitRemove);
        owner.removeListener("remove", emitRemove);
        sub.emit("remove", sub);
        sub.constructor.emit("remove", sub);
        owner = sub = null;
      }
      owner.on("save", emitRemove);
      owner.on("remove", emitRemove);
    }
    EmbeddedDocument.prototype.$__remove = function(cb) {
      if (cb == null) {
        return;
      }
      return cb(null, this);
    };
    EmbeddedDocument.prototype.remove = function(options, fn) {
      if (typeof options === "function" && !fn) {
        fn = options;
        options = void 0;
      }
      if (!this.__parentArray || options && options.noop) {
        this.$__remove(fn);
        return this;
      }
      let _id;
      if (!this.willRemove) {
        _id = this._doc._id;
        if (!_id) {
          throw new Error("For your own good, Mongoose does not know how to remove an EmbeddedDocument that has no _id");
        }
        this.__parentArray.pull({ _id });
        this.willRemove = true;
        registerRemoveListener(this);
      }
      this.$__remove(fn);
      return this;
    };
    EmbeddedDocument.prototype.update = function() {
      throw new Error("The #update method is not available on EmbeddedDocuments");
    };
    EmbeddedDocument.prototype.inspect = function() {
      return this.toObject({
        transform: false,
        virtuals: false,
        flattenDecimals: false
      });
    };
    if (util.inspect.custom) {
      EmbeddedDocument.prototype[util.inspect.custom] = EmbeddedDocument.prototype.inspect;
    }
    EmbeddedDocument.prototype.invalidate = function(path, err, val) {
      Document2.prototype.invalidate.call(this, path, err, val);
      if (!this[documentArrayParent] || this.__index == null) {
        if (err[validatorErrorSymbol] || err instanceof ValidationError) {
          return this.ownerDocument().$__.validationError;
        }
        throw err;
      }
      const index = this.__index;
      const parentPath = this.__parentArray.$path();
      const fullPath = [parentPath, index, path].join(".");
      this[documentArrayParent].invalidate(fullPath, err, val);
      return this.ownerDocument().$__.validationError;
    };
    EmbeddedDocument.prototype.$markValid = function(path) {
      if (!this[documentArrayParent]) {
        return;
      }
      const index = this.__index;
      if (typeof index !== "undefined") {
        const parentPath = this.__parentArray.$path();
        const fullPath = [parentPath, index, path].join(".");
        this[documentArrayParent].$markValid(fullPath);
      }
    };
    EmbeddedDocument.prototype.$ignore = function(path) {
      Document2.prototype.$ignore.call(this, path);
      if (!this[documentArrayParent]) {
        return;
      }
      const index = this.__index;
      if (typeof index !== "undefined") {
        const parentPath = this.__parentArray.$path();
        const fullPath = [parentPath, index, path].join(".");
        this[documentArrayParent].$ignore(fullPath);
      }
    };
    EmbeddedDocument.prototype.$isValid = function(path) {
      const index = this.__index;
      if (typeof index !== "undefined" && this[documentArrayParent]) {
        return !this[documentArrayParent].$__.validationError || !this[documentArrayParent].$__.validationError.errors[this.$__fullPath(path)];
      }
      return true;
    };
    EmbeddedDocument.prototype.ownerDocument = function() {
      if (this.$__.ownerDocument) {
        return this.$__.ownerDocument;
      }
      let parent = this[documentArrayParent];
      if (!parent) {
        return this;
      }
      while (parent[documentArrayParent] || parent.$__parent) {
        parent = parent[documentArrayParent] || parent.$__parent;
      }
      this.$__.ownerDocument = parent;
      return this.$__.ownerDocument;
    };
    EmbeddedDocument.prototype.$__fullPath = function(path) {
      if (!this.$__.fullPath) {
        let parent = this;
        if (!parent[documentArrayParent]) {
          return path;
        }
        const paths = [];
        while (parent[documentArrayParent] || parent.$__parent) {
          if (parent[documentArrayParent]) {
            paths.unshift(parent.__parentArray.$path());
          } else {
            paths.unshift(parent.$basePath);
          }
          parent = parent[documentArrayParent] || parent.$__parent;
        }
        this.$__.fullPath = paths.join(".");
        if (!this.$__.ownerDocument) {
          this.$__.ownerDocument = parent;
        }
      }
      return path ? this.$__.fullPath + "." + path : this.$__.fullPath;
    };
    EmbeddedDocument.prototype.parent = function() {
      return this[documentArrayParent];
    };
    EmbeddedDocument.prototype.$parent = EmbeddedDocument.prototype.parent;
    EmbeddedDocument.prototype.parentArray = function() {
      return this.__parentArray;
    };
    module2.exports = EmbeddedDocument;
  }
});

// node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js
var require_cleanModifiedSubpaths = __commonJS({
  "node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js"(exports2, module2) {
    "use strict";
    module2.exports = function cleanModifiedSubpaths(doc, path, options) {
      options = options || {};
      const skipDocArrays = options.skipDocArrays;
      let deleted = 0;
      if (!doc) {
        return deleted;
      }
      for (const modifiedPath of Object.keys(doc.$__.activePaths.states.modify)) {
        if (skipDocArrays) {
          const schemaType = doc.$__schema.path(modifiedPath);
          if (schemaType && schemaType.$isMongooseDocumentArray) {
            continue;
          }
        }
        if (modifiedPath.startsWith(path + ".")) {
          delete doc.$__.activePaths.states.modify[modifiedPath];
          ++deleted;
        }
      }
      return deleted;
    };
  }
});

// node_modules/mongoose/lib/types/core_array.js
var require_core_array = __commonJS({
  "node_modules/mongoose/lib/types/core_array.js"(exports2, module2) {
    "use strict";
    var Document2 = require_document();
    var EmbeddedDocument = require_embedded();
    var MongooseError = require_mongooseError();
    var ObjectId2 = require_objectid3();
    var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
    var get = require_get();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var utils2 = require_utils8();
    var util = require("util");
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var slicedSymbol = Symbol("mongoose#Array#sliced");
    var _basePush = Array.prototype.push;
    var validatorsSymbol = Symbol("mongoose#MongooseCoreArray#validators");
    var CoreMongooseArray = class extends Array {
      get isMongooseArray() {
        return true;
      }
      get validators() {
        return this[validatorsSymbol];
      }
      set validators(v) {
        this[validatorsSymbol] = v;
      }
      $__getAtomics() {
        const ret2 = [];
        const keys = Object.keys(this[arrayAtomicsSymbol] || {});
        let i = keys.length;
        const opts = Object.assign({}, internalToObjectOptions, { _isNested: true });
        if (i === 0) {
          ret2[0] = ["$set", this.toObject(opts)];
          return ret2;
        }
        while (i--) {
          const op = keys[i];
          let val = this[arrayAtomicsSymbol][op];
          if (utils2.isMongooseObject(val)) {
            val = val.toObject(opts);
          } else if (Array.isArray(val)) {
            val = this.toObject.call(val, opts);
          } else if (val != null && Array.isArray(val.$each)) {
            val.$each = this.toObject.call(val.$each, opts);
          } else if (val != null && typeof val.valueOf === "function") {
            val = val.valueOf();
          }
          if (op === "$addToSet") {
            val = { $each: val };
          }
          ret2.push([op, val]);
        }
        return ret2;
      }
      $atomics() {
        return this[arrayAtomicsSymbol] || {};
      }
      $parent() {
        return this[arrayParentSymbol];
      }
      $path() {
        return this[arrayPathSymbol];
      }
      $shift() {
        this._registerAtomic("$pop", -1);
        this._markModified();
        if (this._shifted) {
          return;
        }
        this._shifted = true;
        return [].shift.call(this);
      }
      $pop() {
        this._registerAtomic("$pop", 1);
        this._markModified();
        if (this._popped) {
          return;
        }
        this._popped = true;
        return [].pop.call(this);
      }
      $schema() {
        return this[arraySchemaSymbol];
      }
      _cast(value) {
        let populated = false;
        let Model;
        if (this[arrayParentSymbol]) {
          populated = this[arrayParentSymbol].populated(this[arrayPathSymbol], true);
        }
        if (populated && value !== null && value !== void 0) {
          Model = populated.options[populateModelSymbol];
          if (Buffer.isBuffer(value) || value instanceof ObjectId2 || !utils2.isObject(value)) {
            value = { _id: value };
          }
          const isDisc = value.$__schema && value.$__schema.discriminatorMapping && value.$__schema.discriminatorMapping.key !== void 0;
          if (!isDisc) {
            value = new Model(value);
          }
          return this[arraySchemaSymbol].caster.applySetters(value, this[arrayParentSymbol], true);
        }
        return this[arraySchemaSymbol].caster.applySetters(value, this[arrayParentSymbol], false);
      }
      _mapCast(val, index) {
        return this._cast(val, this.length + index);
      }
      _markModified(elem) {
        const parent = this[arrayParentSymbol];
        let dirtyPath;
        if (parent) {
          dirtyPath = this[arrayPathSymbol];
          if (arguments.length) {
            dirtyPath = dirtyPath + "." + elem;
          }
          if (dirtyPath != null && dirtyPath.endsWith(".$")) {
            return this;
          }
          parent.markModified(dirtyPath, arguments.length > 0 ? elem : parent);
        }
        return this;
      }
      _registerAtomic(op, val) {
        if (this[slicedSymbol]) {
          return;
        }
        if (op === "$set") {
          this[arrayAtomicsSymbol] = { $set: val };
          cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]);
          this._markModified();
          return this;
        }
        this[arrayAtomicsSymbol] || (this[arrayAtomicsSymbol] = {});
        const atomics = this[arrayAtomicsSymbol];
        if (op === "$pop" && !("$pop" in atomics)) {
          const _this = this;
          this[arrayParentSymbol].once("save", function() {
            _this._popped = _this._shifted = null;
          });
        }
        if (this[arrayAtomicsSymbol].$set || Object.keys(atomics).length && !(op in atomics)) {
          this[arrayAtomicsSymbol] = { $set: this };
          return this;
        }
        let selector;
        if (op === "$pullAll" || op === "$addToSet") {
          atomics[op] || (atomics[op] = []);
          atomics[op] = atomics[op].concat(val);
        } else if (op === "$pullDocs") {
          const pullOp = atomics["$pull"] || (atomics["$pull"] = {});
          if (val[0] instanceof EmbeddedDocument) {
            selector = pullOp["$or"] || (pullOp["$or"] = []);
            Array.prototype.push.apply(selector, val.map(function(v) {
              return v.toObject({ transform: false, virtuals: false });
            }));
          } else {
            selector = pullOp["_id"] || (pullOp["_id"] = { $in: [] });
            selector["$in"] = selector["$in"].concat(val);
          }
        } else if (op === "$push") {
          atomics.$push = atomics.$push || { $each: [] };
          if (val != null && utils2.hasUserDefinedProperty(val, "$each")) {
            atomics.$push = val;
          } else {
            atomics.$push.$each = atomics.$push.$each.concat(val);
          }
        } else {
          atomics[op] = val;
        }
        return this;
      }
      addToSet() {
        _checkManualPopulation(this, arguments);
        let values = [].map.call(arguments, this._mapCast, this);
        values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);
        const added = [];
        let type = "";
        if (values[0] instanceof EmbeddedDocument) {
          type = "doc";
        } else if (values[0] instanceof Date) {
          type = "date";
        }
        values.forEach(function(v) {
          let found;
          const val = +v;
          switch (type) {
            case "doc":
              found = this.some(function(doc) {
                return doc.equals(v);
              });
              break;
            case "date":
              found = this.some(function(d) {
                return +d === val;
              });
              break;
            default:
              found = ~this.indexOf(v);
          }
          if (!found) {
            [].push.call(this, v);
            this._registerAtomic("$addToSet", v);
            this._markModified();
            [].push.call(added, v);
          }
        }, this);
        return added;
      }
      hasAtomics() {
        if (!utils2.isPOJO(this[arrayAtomicsSymbol])) {
          return 0;
        }
        return Object.keys(this[arrayAtomicsSymbol]).length;
      }
      includes(obj, fromIndex) {
        const ret2 = this.indexOf(obj, fromIndex);
        return ret2 !== -1;
      }
      indexOf(obj, fromIndex) {
        if (obj instanceof ObjectId2) {
          obj = obj.toString();
        }
        fromIndex = fromIndex == null ? 0 : fromIndex;
        const len = this.length;
        for (let i = fromIndex; i < len; ++i) {
          if (obj == this[i]) {
            return i;
          }
        }
        return -1;
      }
      inspect() {
        return JSON.stringify(this);
      }
      nonAtomicPush() {
        const values = [].map.call(arguments, this._mapCast, this);
        const ret2 = [].push.apply(this, values);
        this._registerAtomic("$set", this);
        this._markModified();
        return ret2;
      }
      pop() {
        const ret2 = [].pop.call(this);
        this._registerAtomic("$set", this);
        this._markModified();
        return ret2;
      }
      pull() {
        const values = [].map.call(arguments, this._cast, this);
        const cur = this[arrayParentSymbol].get(this[arrayPathSymbol]);
        let i = cur.length;
        let mem;
        while (i--) {
          mem = cur[i];
          if (mem instanceof Document2) {
            const some = values.some(function(v) {
              return mem.equals(v);
            });
            if (some) {
              [].splice.call(cur, i, 1);
            }
          } else if (~cur.indexOf.call(values, mem)) {
            [].splice.call(cur, i, 1);
          }
        }
        if (values[0] instanceof EmbeddedDocument) {
          this._registerAtomic("$pullDocs", values.map(function(v) {
            return v.$__getValue("_id") || v;
          }));
        } else {
          this._registerAtomic("$pullAll", values);
        }
        this._markModified();
        if (cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]) > 0) {
          this._registerAtomic("$set", this);
        }
        return this;
      }
      push() {
        let values = arguments;
        let atomic = values;
        const isOverwrite = values[0] != null && utils2.hasUserDefinedProperty(values[0], "$each");
        if (isOverwrite) {
          atomic = values[0];
          values = values[0].$each;
        }
        if (this[arraySchemaSymbol] == null) {
          return _basePush.apply(this, values);
        }
        _checkManualPopulation(this, values);
        const parent = this[arrayParentSymbol];
        values = [].map.call(values, this._mapCast, this);
        values = this[arraySchemaSymbol].applySetters(values, parent, void 0, void 0, { skipDocumentArrayCast: true });
        let ret2;
        const atomics = this[arrayAtomicsSymbol];
        if (isOverwrite) {
          atomic.$each = values;
          if (get(atomics, "$push.$each.length", 0) > 0 && atomics.$push.$position != atomics.$position) {
            throw new MongooseError("Cannot call `Array#push()` multiple times with different `$position`");
          }
          if (atomic.$position != null) {
            [].splice.apply(this, [atomic.$position, 0].concat(values));
            ret2 = this.length;
          } else {
            ret2 = [].push.apply(this, values);
          }
        } else {
          if (get(atomics, "$push.$each.length", 0) > 0 && atomics.$push.$position != null) {
            throw new MongooseError("Cannot call `Array#push()` multiple times with different `$position`");
          }
          atomic = values;
          ret2 = [].push.apply(this, values);
        }
        this._registerAtomic("$push", atomic);
        this._markModified();
        return ret2;
      }
      remove() {
        return this.pull.apply(this, arguments);
      }
      set(i, val) {
        const value = this._cast(val, i);
        this[i] = value;
        this._markModified(i);
        return this;
      }
      shift() {
        const ret2 = [].shift.call(this);
        this._registerAtomic("$set", this);
        this._markModified();
        return ret2;
      }
      sort() {
        const ret2 = [].sort.apply(this, arguments);
        this._registerAtomic("$set", this);
        return ret2;
      }
      splice() {
        let ret2;
        _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));
        if (arguments.length) {
          let vals;
          if (this[arraySchemaSymbol] == null) {
            vals = arguments;
          } else {
            vals = [];
            for (let i = 0; i < arguments.length; ++i) {
              vals[i] = i < 2 ? arguments[i] : this._cast(arguments[i], arguments[0] + (i - 2));
            }
          }
          ret2 = [].splice.apply(this, vals);
          this._registerAtomic("$set", this);
        }
        return ret2;
      }
      slice() {
        const ret2 = super.slice.apply(this, arguments);
        ret2[arrayParentSymbol] = this[arrayParentSymbol];
        ret2[arraySchemaSymbol] = this[arraySchemaSymbol];
        ret2[arrayAtomicsSymbol] = this[arrayAtomicsSymbol];
        ret2[arrayPathSymbol] = this[arrayPathSymbol];
        ret2[slicedSymbol] = true;
        return ret2;
      }
      filter() {
        const ret2 = super.filter.apply(this, arguments);
        ret2[arrayParentSymbol] = this[arrayParentSymbol];
        ret2[arraySchemaSymbol] = this[arraySchemaSymbol];
        ret2[arrayAtomicsSymbol] = this[arrayAtomicsSymbol];
        ret2[arrayPathSymbol] = this[arrayPathSymbol];
        return ret2;
      }
      toBSON() {
        return this.toObject(internalToObjectOptions);
      }
      toObject(options) {
        if (options && options.depopulate) {
          options = utils2.clone(options);
          options._isNested = true;
          return [].concat(this).map(function(doc) {
            return doc instanceof Document2 ? doc.toObject(options) : doc;
          });
        }
        return [].concat(this);
      }
      unshift() {
        _checkManualPopulation(this, arguments);
        let values;
        if (this[arraySchemaSymbol] == null) {
          values = arguments;
        } else {
          values = [].map.call(arguments, this._cast, this);
          values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);
        }
        [].unshift.apply(this, values);
        this._registerAtomic("$set", this);
        this._markModified();
        return this.length;
      }
    };
    if (util.inspect.custom) {
      CoreMongooseArray.prototype[util.inspect.custom] = CoreMongooseArray.prototype.inspect;
    }
    function _isAllSubdocs(docs, ref) {
      if (!ref) {
        return false;
      }
      for (const arg of docs) {
        if (arg == null) {
          return false;
        }
        const model2 = arg.constructor;
        if (!(arg instanceof Document2) || model2.modelName !== ref && model2.baseModelName !== ref) {
          return false;
        }
      }
      return true;
    }
    function _checkManualPopulation(arr, docs) {
      const ref = arr == null ? null : get(arr[arraySchemaSymbol], "caster.options.ref", null);
      if (arr.length === 0 && docs.length > 0) {
        if (_isAllSubdocs(docs, ref)) {
          arr[arrayParentSymbol].populated(arr[arrayPathSymbol], [], {
            [populateModelSymbol]: docs[0].constructor
          });
        }
      }
    }
    module2.exports = CoreMongooseArray;
  }
});

// node_modules/mongoose/lib/types/array.js
var require_array = __commonJS({
  "node_modules/mongoose/lib/types/array.js"(exports2, module2) {
    "use strict";
    var CoreMongooseArray = require_core_array();
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
    var _basePush = Array.prototype.push;
    function MongooseArray(values, path, doc, schematype) {
      let arr;
      if (Array.isArray(values)) {
        const len = values.length;
        if (len === 0) {
          arr = new CoreMongooseArray();
        } else if (len === 1) {
          arr = new CoreMongooseArray(1);
          arr[0] = values[0];
        } else if (len < 1e4) {
          arr = new CoreMongooseArray();
          _basePush.apply(arr, values);
        } else {
          arr = new CoreMongooseArray();
          for (let i = 0; i < len; ++i) {
            _basePush.call(arr, values[i]);
          }
        }
        if (values[arrayAtomicsSymbol] != null) {
          arr[arrayAtomicsSymbol] = values[arrayAtomicsSymbol];
        }
      } else {
        arr = new CoreMongooseArray();
      }
      arr[arrayPathSymbol] = path;
      if (doc != null && doc.$__ != null) {
        arr[arrayParentSymbol] = doc;
        arr[arraySchemaSymbol] = schematype || doc.schema.path(path);
      }
      return arr;
    }
    module2.exports = exports2 = MongooseArray;
  }
});

// node_modules/mongoose/lib/types/buffer.js
var require_buffer = __commonJS({
  "node_modules/mongoose/lib/types/buffer.js"(exports2, module2) {
    "use strict";
    var Binary2 = require_driver().get().Binary;
    var utils2 = require_utils8();
    var Buffer2 = require_safe_buffer2().Buffer;
    function MongooseBuffer(value, encode, offset) {
      const length = arguments.length;
      let val;
      if (length === 0 || arguments[0] === null || arguments[0] === void 0) {
        val = 0;
      } else {
        val = value;
      }
      let encoding;
      let path;
      let doc;
      if (Array.isArray(encode)) {
        path = encode[0];
        doc = encode[1];
      } else {
        encoding = encode;
      }
      let buf;
      if (typeof val === "number" || val instanceof Number) {
        buf = Buffer2.alloc(val);
      } else {
        buf = Buffer2.from(val, encoding, offset);
      }
      utils2.decorate(buf, MongooseBuffer.mixin);
      buf.isMongooseBuffer = true;
      buf[MongooseBuffer.pathSymbol] = path;
      buf[parentSymbol] = doc;
      buf._subtype = 0;
      return buf;
    }
    var pathSymbol = Symbol.for("mongoose#Buffer#_path");
    var parentSymbol = Symbol.for("mongoose#Buffer#_parent");
    MongooseBuffer.pathSymbol = pathSymbol;
    MongooseBuffer.mixin = {
      _subtype: void 0,
      _markModified: function() {
        const parent = this[parentSymbol];
        if (parent) {
          parent.markModified(this[MongooseBuffer.pathSymbol]);
        }
        return this;
      },
      write: function() {
        const written = Buffer2.prototype.write.apply(this, arguments);
        if (written > 0) {
          this._markModified();
        }
        return written;
      },
      copy: function(target) {
        const ret2 = Buffer2.prototype.copy.apply(this, arguments);
        if (target && target.isMongooseBuffer) {
          target._markModified();
        }
        return ret2;
      }
    };
    "writeUInt8 writeUInt16 writeUInt32 writeInt8 writeInt16 writeInt32 writeFloat writeDouble fill utf8Write binaryWrite asciiWrite set writeUInt16LE writeUInt16BE writeUInt32LE writeUInt32BE writeInt16LE writeInt16BE writeInt32LE writeInt32BE writeFloatLE writeFloatBE writeDoubleLE writeDoubleBE".split(" ").forEach(function(method) {
      if (!Buffer2.prototype[method]) {
        return;
      }
      MongooseBuffer.mixin[method] = function() {
        const ret2 = Buffer2.prototype[method].apply(this, arguments);
        this._markModified();
        return ret2;
      };
    });
    MongooseBuffer.mixin.toObject = function(options) {
      const subtype = typeof options === "number" ? options : this._subtype || 0;
      return new Binary2(Buffer2.from(this), subtype);
    };
    MongooseBuffer.mixin.toBSON = function() {
      return new Binary2(this, this._subtype || 0);
    };
    MongooseBuffer.mixin.equals = function(other) {
      if (!Buffer2.isBuffer(other)) {
        return false;
      }
      if (this.length !== other.length) {
        return false;
      }
      for (let i = 0; i < this.length; ++i) {
        if (this[i] !== other[i]) {
          return false;
        }
      }
      return true;
    };
    MongooseBuffer.mixin.subtype = function(subtype) {
      if (typeof subtype !== "number") {
        throw new TypeError("Invalid subtype. Expected a number");
      }
      if (this._subtype !== subtype) {
        this._markModified();
      }
      this._subtype = subtype;
    };
    MongooseBuffer.Binary = Binary2;
    module2.exports = MongooseBuffer;
  }
});

// node_modules/mongoose/lib/cast/objectid.js
var require_objectid4 = __commonJS({
  "node_modules/mongoose/lib/cast/objectid.js"(exports2, module2) {
    "use strict";
    var ObjectId2 = require_driver().get().ObjectId;
    var assert = require("assert");
    module2.exports = function castObjectId(value) {
      if (value == null) {
        return value;
      }
      if (value instanceof ObjectId2) {
        return value;
      }
      if (value._id) {
        if (value._id instanceof ObjectId2) {
          return value._id;
        }
        if (value._id.toString instanceof Function) {
          return new ObjectId2(value._id.toString());
        }
      }
      if (value.toString instanceof Function) {
        return new ObjectId2(value.toString());
      }
      assert.ok(false);
    };
  }
});

// node_modules/mongoose/lib/types/documentarray.js
var require_documentarray = __commonJS({
  "node_modules/mongoose/lib/types/documentarray.js"(exports2, module2) {
    "use strict";
    var CoreMongooseArray = require_core_array();
    var Document2 = require_document();
    var ObjectId2 = require_objectid3();
    var castObjectId = require_objectid4();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var util = require("util");
    var utils2 = require_utils8();
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
    var documentArrayParent = require_symbols().documentArrayParent;
    var _basePush = Array.prototype.push;
    var CoreDocumentArray = class extends CoreMongooseArray {
      get isMongooseDocumentArray() {
        return true;
      }
      toBSON() {
        return this.toObject(internalToObjectOptions);
      }
      map() {
        const ret2 = super.map.apply(this, arguments);
        ret2[arraySchemaSymbol] = null;
        ret2[arrayPathSymbol] = null;
        ret2[arrayParentSymbol] = null;
        return ret2;
      }
      _cast(value, index) {
        if (this[arraySchemaSymbol] == null) {
          return value;
        }
        let Constructor = this[arraySchemaSymbol].casterConstructor;
        const isInstance = Constructor.$isMongooseDocumentArray ? value && value.isMongooseDocumentArray : value instanceof Constructor;
        if (isInstance || value && value.constructor && value.constructor.baseCasterConstructor === Constructor) {
          if (!(value[documentArrayParent] && value.__parentArray)) {
            value[documentArrayParent] = this[arrayParentSymbol];
            value.__parentArray = this;
          }
          value.$setIndex(index);
          return value;
        }
        if (value === void 0 || value === null) {
          return null;
        }
        if (Buffer.isBuffer(value) || value instanceof ObjectId2 || !utils2.isObject(value)) {
          value = { _id: value };
        }
        if (value && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
          if (typeof value[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) {
            Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]];
          } else {
            const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[Constructor.schema.options.discriminatorKey]);
            if (constructorByValue) {
              Constructor = constructorByValue;
            }
          }
        }
        if (Constructor.$isMongooseDocumentArray) {
          return Constructor.cast(value, this, void 0, void 0, index);
        }
        return new Constructor(value, this, void 0, void 0, index);
      }
      id(id) {
        let casted;
        let sid;
        let _id;
        try {
          casted = castObjectId(id).toString();
        } catch (e) {
          casted = null;
        }
        for (const val of this) {
          if (!val) {
            continue;
          }
          _id = val.get("_id");
          if (_id === null || typeof _id === "undefined") {
            continue;
          } else if (_id instanceof Document2) {
            sid || (sid = String(id));
            if (sid == _id._id) {
              return val;
            }
          } else if (!(id instanceof ObjectId2) && !(_id instanceof ObjectId2)) {
            if (id == _id || utils2.deepEqual(id, _id)) {
              return val;
            }
          } else if (casted == _id) {
            return val;
          }
        }
        return null;
      }
      toObject(options) {
        return [].concat(this.map(function(doc) {
          if (doc == null) {
            return null;
          }
          if (typeof doc.toObject !== "function") {
            return doc;
          }
          return doc.toObject(options);
        }));
      }
      slice() {
        const arr = super.slice.apply(this, arguments);
        arr[arrayParentSymbol] = this[arrayParentSymbol];
        arr[arrayPathSymbol] = this[arrayPathSymbol];
        return arr;
      }
      push() {
        const ret2 = super.push.apply(this, arguments);
        _updateParentPopulated(this);
        return ret2;
      }
      pull() {
        const ret2 = super.pull.apply(this, arguments);
        _updateParentPopulated(this);
        return ret2;
      }
      shift() {
        const ret2 = super.shift.apply(this, arguments);
        _updateParentPopulated(this);
        return ret2;
      }
      splice() {
        const ret2 = super.splice.apply(this, arguments);
        _updateParentPopulated(this);
        return ret2;
      }
      inspect() {
        return this.toObject();
      }
      create(obj) {
        let Constructor = this[arraySchemaSymbol].casterConstructor;
        if (obj && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
          if (typeof obj[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) {
            Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]];
          } else {
            const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, obj[Constructor.schema.options.discriminatorKey]);
            if (constructorByValue) {
              Constructor = constructorByValue;
            }
          }
        }
        return new Constructor(obj, this);
      }
      notify(event) {
        const _this = this;
        return function notify(val, _arr) {
          _arr = _arr || _this;
          let i = _arr.length;
          while (i--) {
            if (_arr[i] == null) {
              continue;
            }
            switch (event) {
              case "save":
                val = _this[i];
                break;
              default:
                break;
            }
            if (_arr[i].isMongooseArray) {
              notify(val, _arr[i]);
            } else if (_arr[i]) {
              _arr[i].emit(event, val);
            }
          }
        };
      }
      _markModified(elem, embeddedPath) {
        const parent = this[arrayParentSymbol];
        let dirtyPath;
        if (parent) {
          dirtyPath = this[arrayPathSymbol];
          if (arguments.length) {
            if (embeddedPath != null) {
              const index = elem.__index;
              dirtyPath = dirtyPath + "." + index + "." + embeddedPath;
            } else {
              dirtyPath = dirtyPath + "." + elem;
            }
          }
          if (dirtyPath != null && dirtyPath.endsWith(".$")) {
            return this;
          }
          parent.markModified(dirtyPath, arguments.length > 0 ? elem : parent);
        }
        return this;
      }
    };
    if (util.inspect.custom) {
      CoreDocumentArray.prototype[util.inspect.custom] = CoreDocumentArray.prototype.inspect;
    }
    function _updateParentPopulated(arr) {
      const parent = arr[arrayParentSymbol];
      if (!parent || parent.$__.populated == null)
        return;
      const populatedPaths = Object.keys(parent.$__.populated).filter((p) => p.startsWith(arr[arrayPathSymbol] + "."));
      for (const path of populatedPaths) {
        const remnant = path.slice((arr[arrayPathSymbol] + ".").length);
        if (!Array.isArray(parent.$__.populated[path].value)) {
          continue;
        }
        parent.$__.populated[path].value = arr.map((val) => val.populated(remnant));
      }
    }
    function MongooseDocumentArray(values, path, doc) {
      const arr = new CoreDocumentArray();
      arr[arrayAtomicsSymbol] = {};
      arr[arraySchemaSymbol] = void 0;
      if (Array.isArray(values)) {
        if (values[arrayPathSymbol] === path && values[arrayParentSymbol] === doc) {
          arr[arrayAtomicsSymbol] = Object.assign({}, values[arrayAtomicsSymbol]);
        }
        values.forEach((v) => {
          _basePush.call(arr, v);
        });
      }
      arr[arrayPathSymbol] = path;
      if (doc && doc instanceof Document2) {
        arr[arrayParentSymbol] = doc;
        arr[arraySchemaSymbol] = doc.schema.path(path);
        while (arr != null && arr[arraySchemaSymbol] != null && arr[arraySchemaSymbol].$isMongooseArray && !arr[arraySchemaSymbol].$isMongooseDocumentArray) {
          arr[arraySchemaSymbol] = arr[arraySchemaSymbol].casterConstructor;
        }
      }
      return arr;
    }
    module2.exports = MongooseDocumentArray;
  }
});

// node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js
var require_handleSpreadDoc = __commonJS({
  "node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    module2.exports = function handleSpreadDoc(v) {
      if (utils2.isPOJO(v) && v.$__ != null && v._doc != null) {
        return v._doc;
      }
      return v;
    };
  }
});

// node_modules/mongoose/lib/types/map.js
var require_map3 = __commonJS({
  "node_modules/mongoose/lib/types/map.js"(exports2, module2) {
    "use strict";
    var Mixed = require_mixed();
    var ObjectId2 = require_objectid3();
    var clone = require_clone();
    var deepEqual = require_utils8().deepEqual;
    var get = require_get();
    var getConstructorName = require_getConstructorName();
    var handleSpreadDoc = require_handleSpreadDoc();
    var util = require("util");
    var specialProperties = require_specialProperties();
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var MongooseMap = class extends Map {
      constructor(v, path, doc, schemaType) {
        if (getConstructorName(v) === "Object") {
          v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);
        }
        super(v);
        this.$__parent = doc != null && doc.$__ != null ? doc : null;
        this.$__path = path;
        this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;
        this.$__runDeferred();
      }
      $init(key, value) {
        checkValidKey(key);
        super.set(key, value);
        if (value != null && value.$isSingleNested) {
          value.$basePath = this.$__path + "." + key;
        }
      }
      $__set(key, value) {
        super.set(key, value);
      }
      get(key, options) {
        if (key instanceof ObjectId2) {
          key = key.toString();
        }
        options = options || {};
        if (options.getters === false) {
          return super.get(key);
        }
        return this.$__schemaType.applyGetters(super.get(key), this.$__parent);
      }
      set(key, value) {
        if (key instanceof ObjectId2) {
          key = key.toString();
        }
        checkValidKey(key);
        value = handleSpreadDoc(value);
        if (this.$__schemaType == null) {
          this.$__deferred = this.$__deferred || [];
          this.$__deferred.push({ key, value });
          return;
        }
        const fullPath = this.$__path + "." + key;
        const populated = this.$__parent != null && this.$__parent.$__ ? this.$__parent.populated(fullPath) || this.$__parent.populated(this.$__path) : null;
        const priorVal = this.get(key);
        if (populated != null) {
          if (value.$__ == null) {
            value = new populated.options[populateModelSymbol](value);
          }
          value.$__.wasPopulated = true;
        } else {
          try {
            value = this.$__schemaType.applySetters(value, this.$__parent, false, this.get(key), { path: fullPath });
          } catch (error) {
            if (this.$__parent != null && this.$__parent.$__ != null) {
              this.$__parent.invalidate(fullPath, error);
              return;
            }
            throw error;
          }
        }
        super.set(key, value);
        if (value != null && value.$isSingleNested) {
          value.$basePath = this.$__path + "." + key;
        }
        const parent = this.$__parent;
        if (parent != null && parent.$__ != null && !deepEqual(value, priorVal)) {
          parent.markModified(this.$__path + "." + key);
        }
      }
      clear() {
        super.clear();
        const parent = this.$__parent;
        if (parent != null) {
          parent.markModified(this.$__path);
        }
      }
      delete(key) {
        if (key instanceof ObjectId2) {
          key = key.toString();
        }
        this.set(key, void 0);
        super.delete(key);
      }
      toBSON() {
        return new Map(this);
      }
      toObject(options) {
        if (get(options, "flattenMaps")) {
          const ret2 = {};
          const keys = this.keys();
          for (const key of keys) {
            ret2[key] = clone(this.get(key));
          }
          return ret2;
        }
        return new Map(this);
      }
      toJSON() {
        const ret2 = {};
        const keys = this.keys();
        for (const key of keys) {
          ret2[key] = this.get(key);
        }
        return ret2;
      }
      inspect() {
        return new Map(this);
      }
      $__runDeferred() {
        if (!this.$__deferred) {
          return;
        }
        for (const keyValueObject of this.$__deferred) {
          this.set(keyValueObject.key, keyValueObject.value);
        }
        this.$__deferred = null;
      }
    };
    if (util.inspect.custom) {
      Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {
        enumerable: false,
        writable: false,
        configurable: false,
        value: MongooseMap.prototype.inspect
      });
    }
    Object.defineProperty(MongooseMap.prototype, "$__set", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$__parent", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$__path", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$__schemaType", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$isMongooseMap", {
      enumerable: false,
      writable: false,
      configurable: false,
      value: true
    });
    Object.defineProperty(MongooseMap.prototype, "$__deferredCalls", {
      enumerable: false,
      writable: false,
      configurable: false,
      value: true
    });
    function checkValidKey(key) {
      const keyType = typeof key;
      if (keyType !== "string") {
        throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);
      }
      if (key.startsWith("$")) {
        throw new Error(`Mongoose maps do not support keys that start with "$", got "${key}"`);
      }
      if (key.includes(".")) {
        throw new Error(`Mongoose maps do not support keys that contain ".", got "${key}"`);
      }
      if (specialProperties.has(key)) {
        throw new Error(`Mongoose maps do not support reserved key name "${key}"`);
      }
    }
    module2.exports = MongooseMap;
  }
});

// node_modules/mongoose/lib/types/subdocument.js
var require_subdocument = __commonJS({
  "node_modules/mongoose/lib/types/subdocument.js"(exports2, module2) {
    "use strict";
    var Document2 = require_document();
    var immediate = require_immediate();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var promiseOrCallback = require_promiseOrCallback();
    var documentArrayParent = require_symbols().documentArrayParent;
    module2.exports = Subdocument;
    function Subdocument(value, fields, parent, skipId, options) {
      this.$isSingleNested = true;
      if (options != null && options.path != null) {
        this.$basePath = options.path;
      }
      const hasPriorDoc = options != null && options.priorDoc;
      let initedPaths = null;
      if (hasPriorDoc) {
        this._doc = Object.assign({}, options.priorDoc._doc);
        delete this._doc[this.$__schema.options.discriminatorKey];
        initedPaths = Object.keys(options.priorDoc._doc || {}).filter((key) => key !== this.$__schema.options.discriminatorKey);
      }
      if (parent != null) {
        options = Object.assign({}, options, {
          isNew: parent.isNew,
          defaults: parent.$__.$options.defaults
        });
      }
      Document2.call(this, value, fields, skipId, options);
      if (hasPriorDoc) {
        for (const key of initedPaths) {
          if (!this.$__.activePaths.states.modify[key] && !this.$__.activePaths.states.default[key] && !this.$__.$setCalled.has(key)) {
            const schematype = this.$__schema.path(key);
            const def = schematype == null ? void 0 : schematype.getDefault(this);
            if (def === void 0) {
              delete this._doc[key];
            } else {
              this._doc[key] = def;
              this.$__.activePaths.default(key);
            }
          }
        }
        delete options.priorDoc;
        delete this.$__.$options.priorDoc;
      }
    }
    Subdocument.prototype = Object.create(Document2.prototype);
    Subdocument.prototype.toBSON = function() {
      return this.toObject(internalToObjectOptions);
    };
    Subdocument.prototype.save = function(options, fn) {
      if (typeof options === "function") {
        fn = options;
        options = {};
      }
      options = options || {};
      if (!options.suppressWarning) {
        console.warn("mongoose: calling `save()` on a subdoc does **not** save the document to MongoDB, it only runs save middleware. Use `subdoc.save({ suppressWarning: true })` to hide this warning if you're sure this behavior is right for your app.");
      }
      return promiseOrCallback(fn, (cb) => {
        this.$__save(cb);
      });
    };
    Subdocument.prototype.$__save = function(fn) {
      return immediate(() => fn(null, this));
    };
    Subdocument.prototype.$isValid = function(path) {
      if (this.$__parent && this.$basePath) {
        return this.$__parent.$isValid([this.$basePath, path].join("."));
      }
      return Document2.prototype.$isValid.call(this, path);
    };
    Subdocument.prototype.markModified = function(path) {
      Document2.prototype.markModified.call(this, path);
      if (this.$__parent && this.$basePath) {
        if (this.$__parent.isDirectModified(this.$basePath)) {
          return;
        }
        this.$__parent.markModified([this.$basePath, path].join("."), this);
      }
    };
    Subdocument.prototype.isModified = function(paths, modifiedPaths) {
      if (this.$__parent && this.$basePath) {
        if (Array.isArray(paths) || typeof paths === "string") {
          paths = Array.isArray(paths) ? paths : paths.split(" ");
          paths = paths.map((p) => [this.$basePath, p].join("."));
          return this.$__parent.isModified(paths, modifiedPaths);
        }
        return this.$__parent.isModified(this.$basePath);
      }
      return Document2.prototype.isModified.call(this, paths, modifiedPaths);
    };
    Subdocument.prototype.$markValid = function(path) {
      Document2.prototype.$markValid.call(this, path);
      if (this.$__parent && this.$basePath) {
        this.$__parent.$markValid([this.$basePath, path].join("."));
      }
    };
    Subdocument.prototype.invalidate = function(path, err, val) {
      if (err !== this.ownerDocument().$__.validationError) {
        Document2.prototype.invalidate.call(this, path, err, val);
      }
      if (this.$__parent && this.$basePath) {
        this.$__parent.invalidate([this.$basePath, path].join("."), err, val);
      } else if (err.kind === "cast" || err.name === "CastError") {
        throw err;
      }
      return this.ownerDocument().$__.validationError;
    };
    Subdocument.prototype.$ignore = function(path) {
      Document2.prototype.$ignore.call(this, path);
      if (this.$__parent && this.$basePath) {
        this.$__parent.$ignore([this.$basePath, path].join("."));
      }
    };
    Subdocument.prototype.ownerDocument = function() {
      if (this.$__.ownerDocument) {
        return this.$__.ownerDocument;
      }
      let parent = this.$__parent;
      if (!parent) {
        return this;
      }
      while (parent.$__parent || parent[documentArrayParent]) {
        parent = parent.$__parent || parent[documentArrayParent];
      }
      this.$__.ownerDocument = parent;
      return this.$__.ownerDocument;
    };
    Subdocument.prototype.parent = function() {
      return this.$__parent;
    };
    Subdocument.prototype.$parent = Subdocument.prototype.parent;
    Subdocument.prototype.$__remove = function(cb) {
      return cb(null, this);
    };
    Subdocument.prototype.remove = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      registerRemoveListener(this);
      if (!options || !options.noop) {
        this.$__parent.set(this.$basePath, null);
      }
      if (typeof callback === "function") {
        callback(null);
      }
    };
    Subdocument.prototype.populate = function() {
      throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.nested.populate("path")`, use `doc.populate("nested.path")`');
    };
    function registerRemoveListener(sub) {
      let owner = sub.ownerDocument();
      function emitRemove() {
        owner.removeListener("save", emitRemove);
        owner.removeListener("remove", emitRemove);
        sub.emit("remove", sub);
        sub.constructor.emit("remove", sub);
        owner = sub = null;
      }
      owner.on("save", emitRemove);
      owner.on("remove", emitRemove);
    }
  }
});

// node_modules/mongoose/lib/types/index.js
var require_types2 = __commonJS({
  "node_modules/mongoose/lib/types/index.js"(exports2) {
    "use strict";
    exports2.Array = require_array();
    exports2.Buffer = require_buffer();
    exports2.Document = exports2.Embedded = require_embedded();
    exports2.DocumentArray = require_documentarray();
    exports2.Decimal128 = require_decimal1282();
    exports2.ObjectId = require_objectid3();
    exports2.Map = require_map3();
    exports2.Subdocument = require_subdocument();
  }
});

// node_modules/mongoose/lib/schema/array.js
var require_array2 = __commonJS({
  "node_modules/mongoose/lib/schema/array.js"(exports2, module2) {
    "use strict";
    var $exists = require_exists();
    var $type = require_type();
    var MongooseError = require_mongooseError();
    var SchemaArrayOptions = require_SchemaArrayOptions();
    var SchemaType = require_schematype();
    var CastError = SchemaType.CastError;
    var Mixed = require_mixed();
    var arrayDepth = require_arrayDepth();
    var cast = require_cast2();
    var get = require_get();
    var isOperator = require_isOperator();
    var util = require("util");
    var utils2 = require_utils8();
    var castToNumber = require_helpers().castToNumber;
    var geospatial = require_geospatial();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var MongooseArray;
    var EmbeddedDoc;
    var isNestedArraySymbol = Symbol("mongoose#isNestedArray");
    var emptyOpts = Object.freeze({});
    function SchemaArray(key, cast2, options, schemaOptions) {
      EmbeddedDoc || (EmbeddedDoc = require_types2().Embedded);
      let typeKey = "type";
      if (schemaOptions && schemaOptions.typeKey) {
        typeKey = schemaOptions.typeKey;
      }
      this.schemaOptions = schemaOptions;
      if (cast2) {
        let castOptions = {};
        if (utils2.isPOJO(cast2)) {
          if (cast2[typeKey]) {
            castOptions = utils2.clone(cast2);
            delete castOptions[typeKey];
            cast2 = cast2[typeKey];
          } else {
            cast2 = Mixed;
          }
        }
        if (options != null && options.ref != null && castOptions.ref == null) {
          castOptions.ref = options.ref;
        }
        if (cast2 === Object) {
          cast2 = Mixed;
        }
        const name = typeof cast2 === "string" ? cast2 : utils2.getFunctionName(cast2);
        const Types = require_schema();
        const caster = Types.hasOwnProperty(name) ? Types[name] : cast2;
        this.casterConstructor = caster;
        if (this.casterConstructor instanceof SchemaArray) {
          this.casterConstructor[isNestedArraySymbol] = true;
        }
        if (typeof caster === "function" && !caster.$isArraySubdocument && !caster.$isSchemaMap) {
          const path = this.caster instanceof EmbeddedDoc ? null : key;
          this.caster = new caster(path, castOptions);
        } else {
          this.caster = caster;
          if (!(this.caster instanceof EmbeddedDoc)) {
            this.caster.path = key;
          }
        }
        this.$embeddedSchemaType = this.caster;
      }
      this.$isMongooseArray = true;
      SchemaType.call(this, key, options, "Array");
      let defaultArr;
      let fn;
      if (this.defaultValue != null) {
        defaultArr = this.defaultValue;
        fn = typeof defaultArr === "function";
      }
      if (!("defaultValue" in this) || this.defaultValue !== void 0) {
        const defaultFn = function() {
          let arr = [];
          if (fn) {
            arr = defaultArr.call(this);
          } else if (defaultArr != null) {
            arr = arr.concat(defaultArr);
          }
          return arr;
        };
        defaultFn.$runBeforeSetters = !fn;
        this.default(defaultFn);
      }
    }
    SchemaArray.schemaName = "Array";
    SchemaArray.options = { castNonArrays: true };
    SchemaArray.defaultOptions = {};
    SchemaArray.set = SchemaType.set;
    SchemaArray.prototype = Object.create(SchemaType.prototype);
    SchemaArray.prototype.constructor = SchemaArray;
    SchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;
    SchemaArray._checkRequired = SchemaType.prototype.checkRequired;
    SchemaArray.checkRequired = SchemaType.checkRequired;
    SchemaArray.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : SchemaArray.checkRequired();
      return _checkRequired(value);
    };
    SchemaArray.prototype.enum = function() {
      let arr = this;
      while (true) {
        const instance = get(arr, "caster.instance");
        if (instance === "Array") {
          arr = arr.caster;
          continue;
        }
        if (instance !== "String" && instance !== "Number") {
          throw new Error("`enum` can only be set on an array of strings or numbers , not " + instance);
        }
        break;
      }
      let enumArray = arguments;
      if (!Array.isArray(arguments) && utils2.isObject(arguments)) {
        enumArray = utils2.object.vals(enumArray);
      }
      arr.caster.enum.apply(arr.caster, enumArray);
      return this;
    };
    SchemaArray.prototype.applyGetters = function(value, scope) {
      if (scope != null && scope.$__ != null && scope.populated(this.path)) {
        return value;
      }
      const ret2 = SchemaType.prototype.applyGetters.call(this, value, scope);
      if (Array.isArray(ret2)) {
        const len = ret2.length;
        for (let i = 0; i < len; ++i) {
          ret2[i] = this.caster.applyGetters(ret2[i], scope);
        }
      }
      return ret2;
    };
    SchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {
      if (this.casterConstructor.$isMongooseArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {
        let depth = 0;
        let arr = this;
        while (arr != null && arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {
          ++depth;
          arr = arr.casterConstructor;
        }
        if (value != null && value.length > 0) {
          const valueDepth = arrayDepth(value);
          if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {
            for (let i = valueDepth.max; i < depth; ++i) {
              value = [value];
            }
          }
        }
      }
      return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);
    };
    SchemaArray.prototype.cast = function(value, doc, init, prev, options) {
      MongooseArray || (MongooseArray = require_types2().Array);
      let i;
      let l;
      if (Array.isArray(value)) {
        const len = value.length;
        if (!len && doc) {
          const indexes = doc.schema.indexedPaths();
          const arrayPath = this.path;
          for (i = 0, l = indexes.length; i < l; ++i) {
            const pathIndex = indexes[i][0][arrayPath];
            if (pathIndex === "2dsphere" || pathIndex === "2d") {
              return;
            }
          }
          const arrayGeojsonPath = this.path.endsWith(".coordinates") ? this.path.substr(0, this.path.lastIndexOf(".")) : null;
          if (arrayGeojsonPath != null) {
            for (i = 0, l = indexes.length; i < l; ++i) {
              const pathIndex = indexes[i][0][arrayGeojsonPath];
              if (pathIndex === "2dsphere") {
                return;
              }
            }
          }
        }
        options = options || emptyOpts;
        value = MongooseArray(value, options.path || this._arrayPath || this.path, doc, this);
        if (init && doc != null && doc.$__ != null && doc.populated(this.path)) {
          return value;
        }
        const caster = this.caster;
        const isMongooseArray = caster.$isMongooseArray;
        const isArrayOfNumbers = caster.instance === "Number";
        if (caster && this.casterConstructor !== Mixed) {
          try {
            for (i = 0; i < len; i++) {
              if (isArrayOfNumbers && value[i] === void 0) {
                throw new MongooseError("Mongoose number arrays disallow storing undefined");
              }
              const opts = {};
              if (isMongooseArray) {
                if (options.arrayPath != null) {
                  opts.arrayPathIndex = i;
                } else if (caster._arrayParentPath != null) {
                  opts.arrayPathIndex = i;
                }
              }
              value[i] = caster.applySetters(value[i], doc, init, void 0, opts);
            }
          } catch (e) {
            throw new CastError("[" + e.kind + "]", util.inspect(value), this.path + "." + i, e, this);
          }
        }
        return value;
      }
      if (init || SchemaArray.options.castNonArrays) {
        if (!!doc && !!init) {
          doc.markModified(this.path);
        }
        return this.cast([value], doc, init);
      }
      throw new CastError("Array", util.inspect(value), this.path, null, this);
    };
    SchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {
      MongooseArray || (MongooseArray = require_types2().Array);
      if (Array.isArray(value)) {
        let i;
        const len = value.length;
        const caster = this.caster;
        if (caster && this.casterConstructor !== Mixed) {
          try {
            for (i = 0; i < len; i++) {
              const opts = {};
              if (caster.$isMongooseArray && caster._arrayParentPath != null) {
                opts.arrayPathIndex = i;
              }
              value[i] = caster.cast(value[i], doc, false, void 0, opts);
            }
          } catch (e) {
            throw new CastError("[" + e.kind + "]", util.inspect(value), this.path + "." + i, e, this);
          }
        }
        return value;
      }
      throw new CastError("Array", util.inspect(value), this.path, null, this);
    };
    SchemaArray.prototype.discriminator = function(name, schema) {
      let arr = this;
      while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {
        arr = arr.casterConstructor;
        if (arr == null || typeof arr === "function") {
          throw new MongooseError("You can only add an embedded discriminator on a document array, " + this.path + " is a plain array");
        }
      }
      return arr.discriminator(name, schema);
    };
    SchemaArray.prototype.clone = function() {
      const options = Object.assign({}, this.options);
      const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0) {
        schematype.requiredValidator = this.requiredValidator;
      }
      return schematype;
    };
    SchemaArray.prototype.castForQuery = function($conditional, value) {
      let handler;
      let val;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new Error("Can't use " + $conditional + " with Array.");
        }
        val = handler.call(this, value);
      } else {
        val = $conditional;
        let Constructor = this.casterConstructor;
        if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
          if (typeof val[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {
            Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];
          } else {
            const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);
            if (constructorByValue) {
              Constructor = constructorByValue;
            }
          }
        }
        const proto = this.casterConstructor.prototype;
        let method = proto && (proto.castForQuery || proto.cast);
        if (!method && Constructor.castForQuery) {
          method = Constructor.castForQuery;
        }
        const caster = this.caster;
        if (Array.isArray(val)) {
          this.setters.reverse().forEach((setter) => {
            val = setter.call(this, val, this);
          });
          val = val.map(function(v) {
            if (utils2.isObject(v) && v.$elemMatch) {
              return v;
            }
            if (method) {
              v = method.call(caster, v);
              return v;
            }
            if (v != null) {
              v = new Constructor(v);
              return v;
            }
            return v;
          });
        } else if (method) {
          val = method.call(caster, val);
        } else if (val != null) {
          val = new Constructor(val);
        }
      }
      return val;
    };
    function cast$all(val) {
      if (!Array.isArray(val)) {
        val = [val];
      }
      val = val.map(function(v) {
        if (utils2.isObject(v)) {
          const o = {};
          o[this.path] = v;
          return cast(this.casterConstructor.schema, o)[this.path];
        }
        return v;
      }, this);
      return this.castForQuery(val);
    }
    function cast$elemMatch(val) {
      const keys = Object.keys(val);
      const numKeys = keys.length;
      for (let i = 0; i < numKeys; ++i) {
        const key = keys[i];
        const value = val[key];
        if (isOperator(key) && value != null) {
          val[key] = this.castForQuery(key, value);
        }
      }
      const discriminatorKey = get(this, "casterConstructor.schema.options.discriminatorKey");
      const discriminators = get(this, "casterConstructor.schema.discriminators", {});
      if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {
        return cast(discriminators[val[discriminatorKey]], val);
      }
      return cast(this.casterConstructor.schema, val);
    }
    var handle = SchemaArray.prototype.$conditionalHandlers = {};
    handle.$all = cast$all;
    handle.$options = String;
    handle.$elemMatch = cast$elemMatch;
    handle.$geoIntersects = geospatial.cast$geoIntersects;
    handle.$or = createLogicalQueryOperatorHandler("$or");
    handle.$and = createLogicalQueryOperatorHandler("$and");
    handle.$nor = createLogicalQueryOperatorHandler("$nor");
    function createLogicalQueryOperatorHandler(op) {
      return function logicalQueryOperatorHandler(val) {
        if (!Array.isArray(val)) {
          throw new TypeError("conditional " + op + " requires an array");
        }
        const ret2 = [];
        for (const obj of val) {
          ret2.push(cast(this.casterConstructor.schema, obj));
        }
        return ret2;
      };
    }
    handle.$near = handle.$nearSphere = geospatial.cast$near;
    handle.$within = handle.$geoWithin = geospatial.cast$within;
    handle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;
    handle.$exists = $exists;
    handle.$type = $type;
    handle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$ne = handle.$regex = SchemaArray.prototype.castForQuery;
    handle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;
    handle.$in = SchemaType.prototype.$conditionalHandlers.$in;
    module2.exports = SchemaArray;
  }
});

// node_modules/mongoose/lib/options/SchemaDocumentArrayOptions.js
var require_SchemaDocumentArrayOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaDocumentArrayOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaDocumentArrayOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaDocumentArrayOptions.prototype, "excludeIndexes", opts);
    Object.defineProperty(SchemaDocumentArrayOptions.prototype, "_id", opts);
    module2.exports = SchemaDocumentArrayOptions;
  }
});

// node_modules/mongoose/lib/helpers/document/compile.js
var require_compile = __commonJS({
  "node_modules/mongoose/lib/helpers/document/compile.js"(exports2) {
    "use strict";
    var documentSchemaSymbol = require_symbols().documentSchemaSymbol;
    var get = require_get();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var utils2 = require_utils8();
    var Document2;
    var getSymbol = require_symbols().getSymbol;
    var scopeSymbol = require_symbols().scopeSymbol;
    exports2.compile = compile;
    exports2.defineKey = defineKey;
    function compile(tree, proto, prefix, options) {
      Document2 = Document2 || require_document();
      const keys = Object.keys(tree);
      const len = keys.length;
      let limb;
      let key;
      for (let i = 0; i < len; ++i) {
        key = keys[i];
        limb = tree[key];
        const hasSubprops = utils2.isPOJO(limb) && Object.keys(limb).length && (!limb[options.typeKey] || options.typeKey === "type" && limb.type.type);
        const subprops = hasSubprops ? limb : null;
        defineKey(key, subprops, proto, prefix, keys, options);
      }
    }
    function defineKey(prop, subprops, prototype, prefix, keys, options) {
      Document2 = Document2 || require_document();
      const path = (prefix ? prefix + "." : "") + prop;
      prefix = prefix || "";
      if (subprops) {
        Object.defineProperty(prototype, prop, {
          enumerable: true,
          configurable: true,
          get: function() {
            const _this = this;
            if (!this.$__.getters) {
              this.$__.getters = {};
            }
            if (!this.$__.getters[path]) {
              const nested = Object.create(Document2.prototype, getOwnPropertyDescriptors(this));
              if (!prefix) {
                nested.$__[scopeSymbol] = this;
              }
              nested.$__.nestedPath = path;
              Object.defineProperty(nested, "schema", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: prototype.schema
              });
              Object.defineProperty(nested, "$__schema", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: prototype.schema
              });
              Object.defineProperty(nested, documentSchemaSymbol, {
                enumerable: false,
                configurable: true,
                writable: false,
                value: prototype.schema
              });
              Object.defineProperty(nested, "toObject", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return utils2.clone(_this.get(path, null, {
                    virtuals: get(this, "schema.options.toObject.virtuals", null)
                  }));
                }
              });
              Object.defineProperty(nested, "$__get", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return _this.get(path, null, {
                    virtuals: get(this, "schema.options.toObject.virtuals", null)
                  });
                }
              });
              Object.defineProperty(nested, "toJSON", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return _this.get(path, null, {
                    virtuals: get(_this, "schema.options.toJSON.virtuals", null)
                  });
                }
              });
              Object.defineProperty(nested, "$__isNested", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: true
              });
              const _isEmptyOptions = Object.freeze({
                minimize: true,
                virtuals: false,
                getters: false,
                transform: false
              });
              Object.defineProperty(nested, "$isEmpty", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return Object.keys(this.get(path, null, _isEmptyOptions) || {}).length === 0;
                }
              });
              Object.defineProperty(nested, "$__parent", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: this
              });
              compile(subprops, nested, path, options);
              this.$__.getters[path] = nested;
            }
            return this.$__.getters[path];
          },
          set: function(v) {
            if (v != null && v.$__isNested) {
              v = v.$__get();
            } else if (v instanceof Document2 && !v.$__isNested) {
              v = v.toObject(internalToObjectOptions);
            }
            const doc = this.$__[scopeSymbol] || this;
            doc.$set(path, v);
          }
        });
      } else {
        Object.defineProperty(prototype, prop, {
          enumerable: true,
          configurable: true,
          get: function() {
            return this[getSymbol].call(this.$__[scopeSymbol] || this, path);
          },
          set: function(v) {
            this.$set.call(this.$__[scopeSymbol] || this, path, v);
          }
        });
      }
    }
    function getOwnPropertyDescriptors(object) {
      const result = {};
      Object.getOwnPropertyNames(object).forEach(function(key) {
        const skip = [
          "isNew",
          "$__",
          "errors",
          "_doc",
          "$locals",
          "$op",
          "__parentArray",
          "__index",
          "$isDocumentArrayElement"
        ].indexOf(key) === -1;
        if (skip) {
          return;
        }
        result[key] = Object.getOwnPropertyDescriptor(object, key);
        result[key].enumerable = false;
      });
      return result;
    }
  }
});

// node_modules/mongoose/lib/helpers/model/discriminator.js
var require_discriminator = __commonJS({
  "node_modules/mongoose/lib/helpers/model/discriminator.js"(exports2, module2) {
    "use strict";
    var Mixed = require_mixed();
    var defineKey = require_compile().defineKey;
    var get = require_get();
    var utils2 = require_utils8();
    var CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {
      toJSON: true,
      toObject: true,
      _id: true,
      id: true
    };
    module2.exports = function discriminator(model2, name, schema, tiedValue, applyPlugins) {
      if (!(schema && schema.instanceOfSchema)) {
        throw new Error("You must pass a valid discriminator Schema");
      }
      if (model2.schema.discriminatorMapping && !model2.schema.discriminatorMapping.isRoot) {
        throw new Error('Discriminator "' + name + '" can only be a discriminator of the root model');
      }
      if (applyPlugins) {
        const applyPluginsToDiscriminators = get(model2.base, "options.applyPluginsToDiscriminators", false);
        model2.base._applyPlugins(schema, {
          skipTopLevel: !applyPluginsToDiscriminators
        });
      }
      const key = model2.schema.options.discriminatorKey;
      const existingPath = model2.schema.path(key);
      if (existingPath != null) {
        if (!utils2.hasUserDefinedProperty(existingPath.options, "select")) {
          existingPath.options.select = true;
        }
        existingPath.options.$skipDiscriminatorCheck = true;
      } else {
        const baseSchemaAddition = {};
        baseSchemaAddition[key] = {
          default: void 0,
          select: true,
          $skipDiscriminatorCheck: true
        };
        baseSchemaAddition[key][model2.schema.options.typeKey] = String;
        model2.schema.add(baseSchemaAddition);
        defineKey(key, null, model2.prototype, null, [key], model2.schema.options);
      }
      if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {
        throw new Error('Discriminator "' + name + '" cannot have field with name "' + key + '"');
      }
      let value = name;
      if (typeof tiedValue === "string" && tiedValue.length || tiedValue != null) {
        value = tiedValue;
      }
      function merge(schema2, baseSchema) {
        schema2._baseSchema = baseSchema;
        if (baseSchema.paths._id && baseSchema.paths._id.options && !baseSchema.paths._id.options.auto) {
          schema2.remove("_id");
        }
        const baseSchemaPaths = Object.keys(baseSchema.paths);
        const conflictingPaths = [];
        for (const path of baseSchemaPaths) {
          if (schema2.nested[path]) {
            conflictingPaths.push(path);
            continue;
          }
          if (path.indexOf(".") === -1) {
            continue;
          }
          const sp = path.split(".").slice(0, -1);
          let cur = "";
          for (const piece of sp) {
            cur += (cur.length ? "." : "") + piece;
            if (schema2.paths[cur] instanceof Mixed || schema2.singleNestedPaths[cur] instanceof Mixed) {
              conflictingPaths.push(path);
            }
          }
        }
        utils2.merge(schema2, baseSchema, {
          isDiscriminatorSchemaMerge: true,
          omit: { discriminators: true, base: true },
          omitNested: conflictingPaths.reduce((cur, path) => {
            cur["tree." + path] = true;
            return cur;
          }, {})
        });
        for (const conflictingPath of conflictingPaths) {
          delete schema2.paths[conflictingPath];
        }
        schema2.childSchemas.forEach((obj2) => {
          obj2.model.prototype.$__setSchema(obj2.schema);
        });
        const obj = {};
        obj[key] = {
          default: value,
          select: true,
          set: function(newName) {
            if (newName === value || Array.isArray(value) && utils2.deepEqual(newName, value)) {
              return value;
            }
            throw new Error(`Can't set discriminator key "` + key + '"');
          },
          $skipDiscriminatorCheck: true
        };
        obj[key][schema2.options.typeKey] = existingPath ? existingPath.options[schema2.options.typeKey] : String;
        schema2.add(obj);
        schema2.discriminatorMapping = { key, value, isRoot: false };
        if (baseSchema.options.collection) {
          schema2.options.collection = baseSchema.options.collection;
        }
        const toJSON = schema2.options.toJSON;
        const toObject = schema2.options.toObject;
        const _id = schema2.options._id;
        const id = schema2.options.id;
        const keys = Object.keys(schema2.options);
        schema2.options.discriminatorKey = baseSchema.options.discriminatorKey;
        for (const _key of keys) {
          if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {
            if (_key === "pluralization" && schema2.options[_key] == true && baseSchema.options[_key] == null) {
              continue;
            }
            if (!utils2.deepEqual(schema2.options[_key], baseSchema.options[_key])) {
              throw new Error("Can't customize discriminator option " + _key + " (can only modify " + Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(", ") + ")");
            }
          }
        }
        schema2.options = utils2.clone(baseSchema.options);
        if (toJSON)
          schema2.options.toJSON = toJSON;
        if (toObject)
          schema2.options.toObject = toObject;
        if (typeof _id !== "undefined") {
          schema2.options._id = _id;
        }
        schema2.options.id = id;
        schema2.s.hooks = model2.schema.s.hooks.merge(schema2.s.hooks);
        schema2.plugins = Array.prototype.slice.call(baseSchema.plugins);
        schema2.callQueue = baseSchema.callQueue.concat(schema2.callQueue);
        delete schema2._requiredpaths;
      }
      merge(schema, model2.schema);
      if (!model2.discriminators) {
        model2.discriminators = {};
      }
      if (!model2.schema.discriminatorMapping) {
        model2.schema.discriminatorMapping = { key, value: null, isRoot: true };
      }
      if (!model2.schema.discriminators) {
        model2.schema.discriminators = {};
      }
      model2.schema.discriminators[name] = schema;
      if (model2.discriminators[name]) {
        throw new Error('Discriminator with name "' + name + '" already exists');
      }
      return schema;
    };
  }
});

// node_modules/mongoose/lib/helpers/schema/handleIdOption.js
var require_handleIdOption = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/handleIdOption.js"(exports2, module2) {
    "use strict";
    var addAutoId = require_addAutoId();
    module2.exports = function handleIdOption(schema, options) {
      if (options == null || options._id == null) {
        return schema;
      }
      schema = schema.clone();
      if (!options._id) {
        schema.remove("_id");
        schema.options._id = false;
      } else if (!schema.paths["_id"]) {
        addAutoId(schema);
        schema.options._id = true;
      }
      return schema;
    };
  }
});

// node_modules/mongoose/lib/helpers/discriminator/getConstructor.js
var require_getConstructor = __commonJS({
  "node_modules/mongoose/lib/helpers/discriminator/getConstructor.js"(exports2, module2) {
    "use strict";
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    module2.exports = function getConstructor(Constructor, value) {
      const discriminatorKey = Constructor.schema.options.discriminatorKey;
      if (value != null && Constructor.discriminators && value[discriminatorKey] != null) {
        if (Constructor.discriminators[value[discriminatorKey]]) {
          Constructor = Constructor.discriminators[value[discriminatorKey]];
        } else {
          const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[discriminatorKey]);
          if (constructorByValue) {
            Constructor = constructorByValue;
          }
        }
      }
      return Constructor;
    };
  }
});

// node_modules/mongoose/lib/schema/documentarray.js
var require_documentarray2 = __commonJS({
  "node_modules/mongoose/lib/schema/documentarray.js"(exports2, module2) {
    "use strict";
    var ArrayType = require_array2();
    var CastError = require_cast();
    var EventEmitter = require("events").EventEmitter;
    var SchemaDocumentArrayOptions = require_SchemaDocumentArrayOptions();
    var SchemaType = require_schematype();
    var ValidationError = require_validation();
    var discriminator = require_discriminator();
    var get = require_get();
    var handleIdOption = require_handleIdOption();
    var util = require("util");
    var utils2 = require_utils8();
    var getConstructor = require_getConstructor();
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var documentArrayParent = require_symbols().documentArrayParent;
    var MongooseDocumentArray;
    var Subdocument;
    function DocumentArrayPath(key, schema, options, schemaOptions) {
      if (schemaOptions != null && schemaOptions._id != null) {
        schema = handleIdOption(schema, schemaOptions);
      } else if (options != null && options._id != null) {
        schema = handleIdOption(schema, options);
      }
      const EmbeddedDocument = _createConstructor(schema, options);
      EmbeddedDocument.prototype.$basePath = key;
      ArrayType.call(this, key, EmbeddedDocument, options);
      this.schema = schema;
      this.schemaOptions = schemaOptions || {};
      this.$isMongooseDocumentArray = true;
      this.Constructor = EmbeddedDocument;
      EmbeddedDocument.base = schema.base;
      const fn = this.defaultValue;
      if (!("defaultValue" in this) || fn !== void 0) {
        this.default(function() {
          let arr = fn.call(this);
          if (!Array.isArray(arr)) {
            arr = [arr];
          }
          return arr;
        });
      }
      const parentSchemaType = this;
      this.$embeddedSchemaType = new SchemaType(key + ".$", {
        required: get(this, "schemaOptions.required", false)
      });
      this.$embeddedSchemaType.cast = function(value, doc, init) {
        return parentSchemaType.cast(value, doc, init)[0];
      };
      this.$embeddedSchemaType.$isMongooseDocumentArrayElement = true;
      this.$embeddedSchemaType.caster = this.Constructor;
      this.$embeddedSchemaType.schema = this.schema;
    }
    DocumentArrayPath.schemaName = "DocumentArray";
    DocumentArrayPath.options = { castNonArrays: true };
    DocumentArrayPath.prototype = Object.create(ArrayType.prototype);
    DocumentArrayPath.prototype.constructor = DocumentArrayPath;
    DocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;
    function _createConstructor(schema, options, baseClass) {
      Subdocument || (Subdocument = require_embedded());
      function EmbeddedDocument() {
        Subdocument.apply(this, arguments);
        this.$session(this.ownerDocument().$session());
      }
      const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
      EmbeddedDocument.prototype = Object.create(proto);
      EmbeddedDocument.prototype.$__setSchema(schema);
      EmbeddedDocument.schema = schema;
      EmbeddedDocument.prototype.constructor = EmbeddedDocument;
      EmbeddedDocument.$isArraySubdocument = true;
      EmbeddedDocument.events = new EventEmitter();
      for (const i in schema.methods) {
        EmbeddedDocument.prototype[i] = schema.methods[i];
      }
      for (const i in schema.statics) {
        EmbeddedDocument[i] = schema.statics[i];
      }
      for (const i in EventEmitter.prototype) {
        EmbeddedDocument[i] = EventEmitter.prototype[i];
      }
      EmbeddedDocument.options = options;
      return EmbeddedDocument;
    }
    DocumentArrayPath.prototype.discriminator = function(name, schema, tiedValue) {
      if (typeof name === "function") {
        name = utils2.getFunctionName(name);
      }
      schema = discriminator(this.casterConstructor, name, schema, tiedValue);
      const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);
      EmbeddedDocument.baseCasterConstructor = this.casterConstructor;
      try {
        Object.defineProperty(EmbeddedDocument, "name", {
          value: name
        });
      } catch (error) {
      }
      this.casterConstructor.discriminators[name] = EmbeddedDocument;
      return this.casterConstructor.discriminators[name];
    };
    DocumentArrayPath.prototype.doValidate = function(array, fn, scope, options) {
      MongooseDocumentArray || (MongooseDocumentArray = require_documentarray());
      const _this = this;
      try {
        SchemaType.prototype.doValidate.call(this, array, cb, scope);
      } catch (err) {
        err.$isArrayValidatorError = true;
        return fn(err);
      }
      function cb(err) {
        if (err) {
          err.$isArrayValidatorError = true;
          return fn(err);
        }
        let count = array && array.length;
        let error;
        if (!count) {
          return fn();
        }
        if (options && options.updateValidator) {
          return fn();
        }
        if (!array.isMongooseDocumentArray) {
          array = new MongooseDocumentArray(array, _this.path, scope);
        }
        function callback(err2) {
          if (err2 != null) {
            error = err2;
            if (!(error instanceof ValidationError)) {
              error.$isArrayValidatorError = true;
            }
          }
          --count || fn(error);
        }
        for (let i = 0, len = count; i < len; ++i) {
          let doc = array[i];
          if (doc == null) {
            --count || fn(error);
            continue;
          }
          if (!(doc instanceof Subdocument)) {
            const Constructor = getConstructor(_this.casterConstructor, array[i]);
            doc = array[i] = new Constructor(doc, array, void 0, void 0, i);
          }
          if (options != null && options.validateModifiedOnly && !doc.isModified()) {
            --count || fn(error);
            continue;
          }
          doc.$__validate(callback);
        }
      }
    };
    DocumentArrayPath.prototype.doValidateSync = function(array, scope, options) {
      const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
      if (schemaTypeError != null) {
        schemaTypeError.$isArrayValidatorError = true;
        return schemaTypeError;
      }
      const count = array && array.length;
      let resultError = null;
      if (!count) {
        return;
      }
      for (let i = 0, len = count; i < len; ++i) {
        let doc = array[i];
        if (!doc) {
          continue;
        }
        if (!(doc instanceof Subdocument)) {
          const Constructor = getConstructor(this.casterConstructor, array[i]);
          doc = array[i] = new Constructor(doc, array, void 0, void 0, i);
        }
        if (options != null && options.validateModifiedOnly && !doc.isModified()) {
          continue;
        }
        const subdocValidateError = doc.validateSync();
        if (subdocValidateError && resultError == null) {
          resultError = subdocValidateError;
        }
      }
      return resultError;
    };
    DocumentArrayPath.prototype.getDefault = function(scope) {
      let ret2 = typeof this.defaultValue === "function" ? this.defaultValue.call(scope) : this.defaultValue;
      if (ret2 == null) {
        return ret2;
      }
      MongooseDocumentArray || (MongooseDocumentArray = require_documentarray());
      if (!Array.isArray(ret2)) {
        ret2 = [ret2];
      }
      ret2 = new MongooseDocumentArray(ret2, this.path, scope);
      for (let i = 0; i < ret2.length; ++i) {
        const Constructor = getConstructor(this.casterConstructor, ret2[i]);
        const _subdoc = new Constructor({}, ret2, void 0, void 0, i);
        _subdoc.init(ret2[i]);
        _subdoc.isNew = true;
        Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);
        _subdoc.$__.activePaths.init = {};
        ret2[i] = _subdoc;
      }
      return ret2;
    };
    DocumentArrayPath.prototype.cast = function(value, doc, init, prev, options) {
      MongooseDocumentArray || (MongooseDocumentArray = require_documentarray());
      if (value != null && value[arrayPathSymbol] != null && value === prev) {
        return value;
      }
      let selected;
      let subdoc;
      const _opts = { transform: false, virtuals: false };
      options = options || {};
      if (!Array.isArray(value)) {
        if (!init && !DocumentArrayPath.options.castNonArrays) {
          throw new CastError("DocumentArray", util.inspect(value), this.path, null, this);
        }
        if (!!doc && init) {
          doc.markModified(this.path);
        }
        return this.cast([value], doc, init, prev, options);
      }
      if (!(value && value.isMongooseDocumentArray) && !options.skipDocumentArrayCast) {
        value = new MongooseDocumentArray(value, this.path, doc);
      } else if (value && value.isMongooseDocumentArray) {
        value = new MongooseDocumentArray(value, this.path, doc);
      }
      if (prev != null) {
        value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};
      }
      if (options.arrayPathIndex != null) {
        value[arrayPathSymbol] = this.path + "." + options.arrayPathIndex;
      }
      const len = value.length;
      const initDocumentOptions = { skipId: true, willInit: true };
      for (let i = 0; i < len; ++i) {
        if (!value[i]) {
          continue;
        }
        const Constructor = getConstructor(this.casterConstructor, value[i]);
        if (value[i].$__ && (!(value[i] instanceof Constructor) || value[i][documentArrayParent] !== doc)) {
          value[i] = value[i].toObject({
            transform: false,
            virtuals: value[i].schema === Constructor.schema
          });
        }
        if (value[i] instanceof Subdocument) {
          if (value[i].__index == null) {
            value[i].$setIndex(i);
          }
        } else if (value[i] != null) {
          if (init) {
            if (doc) {
              selected || (selected = scopePaths(this, doc.$__.selected, init));
            } else {
              selected = true;
            }
            subdoc = new Constructor(null, value, initDocumentOptions, selected, i);
            value[i] = subdoc.init(value[i]);
          } else {
            if (prev && typeof prev.id === "function") {
              subdoc = prev.id(value[i]._id);
            }
            if (prev && subdoc && utils2.deepEqual(subdoc.toObject(_opts), value[i])) {
              subdoc.set(value[i]);
              value[i] = subdoc;
            } else {
              try {
                subdoc = new Constructor(value[i], value, void 0, void 0, i);
                value[i] = subdoc;
              } catch (error) {
                const valueInErrorMessage = util.inspect(value[i]);
                throw new CastError("embedded", valueInErrorMessage, value[arrayPathSymbol], error, this);
              }
            }
          }
        }
      }
      return value;
    };
    DocumentArrayPath.prototype.clone = function() {
      const options = Object.assign({}, this.options);
      const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0) {
        schematype.requiredValidator = this.requiredValidator;
      }
      schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);
      return schematype;
    };
    DocumentArrayPath.prototype.applyGetters = function(value, scope) {
      return SchemaType.prototype.applyGetters.call(this, value, scope);
    };
    function scopePaths(array, fields, init) {
      if (!(init && fields)) {
        return void 0;
      }
      const path = array.path + ".";
      const keys = Object.keys(fields);
      let i = keys.length;
      const selected = {};
      let hasKeys;
      let key;
      let sub;
      while (i--) {
        key = keys[i];
        if (key.startsWith(path)) {
          sub = key.substring(path.length);
          if (sub === "$") {
            continue;
          }
          if (sub.startsWith("$.")) {
            sub = sub.substr(2);
          }
          hasKeys || (hasKeys = true);
          selected[sub] = fields[key];
        }
      }
      return hasKeys && selected || void 0;
    }
    DocumentArrayPath.defaultOptions = {};
    DocumentArrayPath.set = SchemaType.set;
    module2.exports = DocumentArrayPath;
  }
});

// node_modules/mongoose/lib/options/SchemaSingleNestedOptions.js
var require_SchemaSingleNestedOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaSingleNestedOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaSingleNestedOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaSingleNestedOptions.prototype, "_id", opts);
    module2.exports = SchemaSingleNestedOptions;
  }
});

// node_modules/mongoose/lib/schema/SingleNestedPath.js
var require_SingleNestedPath = __commonJS({
  "node_modules/mongoose/lib/schema/SingleNestedPath.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    var EventEmitter = require("events").EventEmitter;
    var ObjectExpectedError = require_objectExpected();
    var SchemaSingleNestedOptions = require_SchemaSingleNestedOptions();
    var SchemaType = require_schematype();
    var $exists = require_exists();
    var castToNumber = require_helpers().castToNumber;
    var discriminator = require_discriminator();
    var geospatial = require_geospatial();
    var get = require_get();
    var getConstructor = require_getConstructor();
    var handleIdOption = require_handleIdOption();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var Subdocument;
    module2.exports = SingleNestedPath;
    function SingleNestedPath(schema, path, options) {
      schema = handleIdOption(schema, options);
      this.caster = _createConstructor(schema);
      this.caster.path = path;
      this.caster.prototype.$basePath = path;
      this.schema = schema;
      this.$isSingleNested = true;
      SchemaType.call(this, path, options, "Embedded");
    }
    SingleNestedPath.prototype = Object.create(SchemaType.prototype);
    SingleNestedPath.prototype.constructor = SingleNestedPath;
    SingleNestedPath.prototype.OptionsConstructor = SchemaSingleNestedOptions;
    function _createConstructor(schema, baseClass) {
      Subdocument || (Subdocument = require_subdocument());
      const _embedded = function SingleNested(value, path, parent) {
        const _this = this;
        this.$__parent = parent;
        Subdocument.apply(this, arguments);
        this.$session(this.ownerDocument().$session());
        if (parent) {
          parent.on("save", function() {
            _this.emit("save", _this);
            _this.constructor.emit("save", _this);
          });
          parent.on("isNew", function(val) {
            _this.isNew = val;
            _this.emit("isNew", val);
            _this.constructor.emit("isNew", val);
          });
        }
      };
      const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
      _embedded.prototype = Object.create(proto);
      _embedded.prototype.$__setSchema(schema);
      _embedded.prototype.constructor = _embedded;
      _embedded.schema = schema;
      _embedded.$isSingleNested = true;
      _embedded.events = new EventEmitter();
      _embedded.prototype.toBSON = function() {
        return this.toObject(internalToObjectOptions);
      };
      for (const i in schema.methods) {
        _embedded.prototype[i] = schema.methods[i];
      }
      for (const i in schema.statics) {
        _embedded[i] = schema.statics[i];
      }
      for (const i in EventEmitter.prototype) {
        _embedded[i] = EventEmitter.prototype[i];
      }
      return _embedded;
    }
    SingleNestedPath.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {
      return { $geometry: this.castForQuery(val.$geometry) };
    };
    SingleNestedPath.prototype.$conditionalHandlers.$near = SingleNestedPath.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;
    SingleNestedPath.prototype.$conditionalHandlers.$within = SingleNestedPath.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;
    SingleNestedPath.prototype.$conditionalHandlers.$geoIntersects = geospatial.cast$geoIntersects;
    SingleNestedPath.prototype.$conditionalHandlers.$minDistance = castToNumber;
    SingleNestedPath.prototype.$conditionalHandlers.$maxDistance = castToNumber;
    SingleNestedPath.prototype.$conditionalHandlers.$exists = $exists;
    SingleNestedPath.prototype.cast = function(val, doc, init, priorVal, options) {
      if (val && val.$isSingleNested && val.parent === doc) {
        return val;
      }
      if (val != null && (typeof val !== "object" || Array.isArray(val))) {
        throw new ObjectExpectedError(this.path, val);
      }
      const Constructor = getConstructor(this.caster, val);
      let subdoc;
      const parentSelected = get(doc, "$__.selected", {});
      const path = this.path;
      const selected = Object.keys(parentSelected).reduce((obj, key) => {
        if (key.startsWith(path + ".")) {
          obj[key.substr(path.length + 1)] = parentSelected[key];
        }
        return obj;
      }, {});
      options = Object.assign({}, options, { priorDoc: priorVal });
      if (init) {
        subdoc = new Constructor(void 0, selected, doc);
        subdoc.init(val);
      } else {
        if (Object.keys(val).length === 0) {
          return new Constructor({}, selected, doc, void 0, options);
        }
        return new Constructor(val, selected, doc, void 0, options);
      }
      return subdoc;
    };
    SingleNestedPath.prototype.castForQuery = function($conditional, val, options) {
      let handler;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new Error("Can't use " + $conditional);
        }
        return handler.call(this, val);
      }
      val = $conditional;
      if (val == null) {
        return val;
      }
      if (this.options.runSetters) {
        val = this._applySetters(val);
      }
      const Constructor = getConstructor(this.caster, val);
      const overrideStrict = options != null && options.strict != null ? options.strict : void 0;
      try {
        val = new Constructor(val, overrideStrict);
      } catch (error) {
        if (!(error instanceof CastError)) {
          throw new CastError("Embedded", val, this.path, error, this);
        }
        throw error;
      }
      return val;
    };
    SingleNestedPath.prototype.doValidate = function(value, fn, scope, options) {
      const Constructor = getConstructor(this.caster, value);
      if (options && options.skipSchemaValidators) {
        if (!(value instanceof Constructor)) {
          value = new Constructor(value, null, scope);
        }
        return value.validate(fn);
      }
      SchemaType.prototype.doValidate.call(this, value, function(error) {
        if (error) {
          return fn(error);
        }
        if (!value) {
          return fn(null);
        }
        value.validate(fn);
      }, scope, options);
    };
    SingleNestedPath.prototype.doValidateSync = function(value, scope, options) {
      if (!options || !options.skipSchemaValidators) {
        const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);
        if (schemaTypeError) {
          return schemaTypeError;
        }
      }
      if (!value) {
        return;
      }
      return value.validateSync();
    };
    SingleNestedPath.prototype.discriminator = function(name, schema, value) {
      schema = discriminator(this.caster, name, schema, value);
      this.caster.discriminators[name] = _createConstructor(schema, this.caster);
      return this.caster.discriminators[name];
    };
    SingleNestedPath.defaultOptions = {};
    SingleNestedPath.set = SchemaType.set;
    SingleNestedPath.prototype.clone = function() {
      const options = Object.assign({}, this.options);
      const schematype = new this.constructor(this.schema, this.path, options);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0) {
        schematype.requiredValidator = this.requiredValidator;
      }
      schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);
      return schematype;
    };
  }
});

// node_modules/mongoose/lib/options/SchemaBufferOptions.js
var require_SchemaBufferOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaBufferOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaBufferOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaBufferOptions.prototype, "subtype", opts);
    module2.exports = SchemaBufferOptions;
  }
});

// node_modules/mongoose/lib/schema/buffer.js
var require_buffer2 = __commonJS({
  "node_modules/mongoose/lib/schema/buffer.js"(exports2, module2) {
    "use strict";
    var MongooseBuffer = require_buffer();
    var SchemaBufferOptions = require_SchemaBufferOptions();
    var SchemaType = require_schematype();
    var handleBitwiseOperator = require_bitwise();
    var utils2 = require_utils8();
    var Binary2 = MongooseBuffer.Binary;
    var CastError = SchemaType.CastError;
    function SchemaBuffer(key, options) {
      SchemaType.call(this, key, options, "Buffer");
    }
    SchemaBuffer.schemaName = "Buffer";
    SchemaBuffer.defaultOptions = {};
    SchemaBuffer.prototype = Object.create(SchemaType.prototype);
    SchemaBuffer.prototype.constructor = SchemaBuffer;
    SchemaBuffer.prototype.OptionsConstructor = SchemaBufferOptions;
    SchemaBuffer._checkRequired = (v) => !!(v && v.length);
    SchemaBuffer.set = SchemaType.set;
    SchemaBuffer.checkRequired = SchemaType.checkRequired;
    SchemaBuffer.prototype.checkRequired = function(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      return this.constructor._checkRequired(value);
    };
    SchemaBuffer.prototype.cast = function(value, doc, init) {
      let ret2;
      if (SchemaType._isRef(this, value, doc, init)) {
        if (value && value.isMongooseBuffer) {
          return value;
        }
        if (Buffer.isBuffer(value)) {
          if (!value || !value.isMongooseBuffer) {
            value = new MongooseBuffer(value, [this.path, doc]);
            if (this.options.subtype != null) {
              value._subtype = this.options.subtype;
            }
          }
          return value;
        }
        if (value instanceof Binary2) {
          ret2 = new MongooseBuffer(value.value(true), [this.path, doc]);
          if (typeof value.sub_type !== "number") {
            throw new CastError("Buffer", value, this.path, null, this);
          }
          ret2._subtype = value.sub_type;
          return ret2;
        }
        return this._castRef(value, doc, init);
      }
      if (value && value._id) {
        value = value._id;
      }
      if (value && value.isMongooseBuffer) {
        return value;
      }
      if (Buffer.isBuffer(value)) {
        if (!value || !value.isMongooseBuffer) {
          value = new MongooseBuffer(value, [this.path, doc]);
          if (this.options.subtype != null) {
            value._subtype = this.options.subtype;
          }
        }
        return value;
      }
      if (value instanceof Binary2) {
        ret2 = new MongooseBuffer(value.value(true), [this.path, doc]);
        if (typeof value.sub_type !== "number") {
          throw new CastError("Buffer", value, this.path, null, this);
        }
        ret2._subtype = value.sub_type;
        return ret2;
      }
      if (value === null) {
        return value;
      }
      const type = typeof value;
      if (type === "string" || type === "number" || Array.isArray(value) || type === "object" && value.type === "Buffer" && Array.isArray(value.data)) {
        if (type === "number") {
          value = [value];
        }
        ret2 = new MongooseBuffer(value, [this.path, doc]);
        if (this.options.subtype != null) {
          ret2._subtype = this.options.subtype;
        }
        return ret2;
      }
      throw new CastError("Buffer", value, this.path, null, this);
    };
    SchemaBuffer.prototype.subtype = function(subtype) {
      this.options.subtype = subtype;
      return this;
    };
    function handleSingle(val) {
      return this.castForQuery(val);
    }
    SchemaBuffer.prototype.$conditionalHandlers = utils2.options(SchemaType.prototype.$conditionalHandlers, {
      $bitsAllClear: handleBitwiseOperator,
      $bitsAnyClear: handleBitwiseOperator,
      $bitsAllSet: handleBitwiseOperator,
      $bitsAnySet: handleBitwiseOperator,
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    SchemaBuffer.prototype.castForQuery = function($conditional, val) {
      let handler;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new Error("Can't use " + $conditional + " with Buffer.");
        }
        return handler.call(this, val);
      }
      val = $conditional;
      const casted = this._castForQuery(val);
      return casted ? casted.toObject({ transform: false, virtuals: false }) : casted;
    };
    module2.exports = SchemaBuffer;
  }
});

// node_modules/mongoose/lib/options/SchemaDateOptions.js
var require_SchemaDateOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaDateOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaDateOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaDateOptions.prototype, "min", opts);
    Object.defineProperty(SchemaDateOptions.prototype, "max", opts);
    Object.defineProperty(SchemaDateOptions.prototype, "expires", opts);
    module2.exports = SchemaDateOptions;
  }
});

// node_modules/mongoose/lib/cast/date.js
var require_date = __commonJS({
  "node_modules/mongoose/lib/cast/date.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    module2.exports = function castDate(value) {
      if (value == null || value === "") {
        return null;
      }
      if (value instanceof Date) {
        assert.ok(!isNaN(value.valueOf()));
        return value;
      }
      let date;
      assert.ok(typeof value !== "boolean");
      if (value instanceof Number || typeof value === "number") {
        date = new Date(value);
      } else if (typeof value === "string" && !isNaN(Number(value)) && (Number(value) >= 275761 || Number(value) < -271820)) {
        date = new Date(Number(value));
      } else if (typeof value.valueOf === "function") {
        date = new Date(value.valueOf());
      } else {
        date = new Date(value);
      }
      if (!isNaN(date.valueOf())) {
        return date;
      }
      assert.ok(false);
    };
  }
});

// node_modules/mongoose/lib/schema/date.js
var require_date2 = __commonJS({
  "node_modules/mongoose/lib/schema/date.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var SchemaDateOptions = require_SchemaDateOptions();
    var SchemaType = require_schematype();
    var castDate = require_date();
    var getConstructorName = require_getConstructorName();
    var utils2 = require_utils8();
    var CastError = SchemaType.CastError;
    function SchemaDate(key, options) {
      SchemaType.call(this, key, options, "Date");
    }
    SchemaDate.schemaName = "Date";
    SchemaDate.defaultOptions = {};
    SchemaDate.prototype = Object.create(SchemaType.prototype);
    SchemaDate.prototype.constructor = SchemaDate;
    SchemaDate.prototype.OptionsConstructor = SchemaDateOptions;
    SchemaDate._cast = castDate;
    SchemaDate.set = SchemaType.set;
    SchemaDate.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaDate._defaultCaster = (v) => {
      if (v != null && !(v instanceof Date)) {
        throw new Error();
      }
      return v;
    };
    SchemaDate.prototype.expires = function(when) {
      if (getConstructorName(this._index) !== "Object") {
        this._index = {};
      }
      this._index.expires = when;
      utils2.expires(this._index);
      return this;
    };
    SchemaDate._checkRequired = (v) => v instanceof Date;
    SchemaDate.checkRequired = SchemaType.checkRequired;
    SchemaDate.prototype.checkRequired = function(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : SchemaDate.checkRequired();
      return _checkRequired(value);
    };
    SchemaDate.prototype.min = function(value, message) {
      if (this.minValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.minValidator;
        }, this);
      }
      if (value) {
        let msg = message || MongooseError.messages.Date.min;
        if (typeof msg === "string") {
          msg = msg.replace(/{MIN}/, value === Date.now ? "Date.now()" : value.toString());
        }
        const _this = this;
        this.validators.push({
          validator: this.minValidator = function(val) {
            let _value = value;
            if (typeof value === "function" && value !== Date.now) {
              _value = _value.call(this);
            }
            const min = _value === Date.now ? _value() : _this.cast(_value);
            return val === null || val.valueOf() >= min.valueOf();
          },
          message: msg,
          type: "min",
          min: value
        });
      }
      return this;
    };
    SchemaDate.prototype.max = function(value, message) {
      if (this.maxValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.maxValidator;
        }, this);
      }
      if (value) {
        let msg = message || MongooseError.messages.Date.max;
        if (typeof msg === "string") {
          msg = msg.replace(/{MAX}/, value === Date.now ? "Date.now()" : value.toString());
        }
        const _this = this;
        this.validators.push({
          validator: this.maxValidator = function(val) {
            let _value = value;
            if (typeof _value === "function" && _value !== Date.now) {
              _value = _value.call(this);
            }
            const max = _value === Date.now ? _value() : _this.cast(_value);
            return val === null || val.valueOf() <= max.valueOf();
          },
          message: msg,
          type: "max",
          max: value
        });
      }
      return this;
    };
    SchemaDate.prototype.cast = function(value) {
      let castDate2;
      if (typeof this._castFunction === "function") {
        castDate2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castDate2 = this.constructor.cast();
      } else {
        castDate2 = SchemaDate.cast();
      }
      try {
        return castDate2(value);
      } catch (error) {
        throw new CastError("date", value, this.path, error, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    SchemaDate.prototype.$conditionalHandlers = utils2.options(SchemaType.prototype.$conditionalHandlers, {
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    SchemaDate.prototype.castForQuery = function($conditional, val) {
      if (arguments.length !== 2) {
        return this._castForQuery($conditional);
      }
      const handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can't use " + $conditional + " with Date.");
      }
      return handler.call(this, val);
    };
    module2.exports = SchemaDate;
  }
});

// node_modules/mongoose/lib/options/SchemaObjectIdOptions.js
var require_SchemaObjectIdOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaObjectIdOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaObjectIdOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaObjectIdOptions.prototype, "auto", opts);
    Object.defineProperty(SchemaObjectIdOptions.prototype, "populate", opts);
    module2.exports = SchemaObjectIdOptions;
  }
});

// node_modules/mongoose/lib/schema/objectid.js
var require_objectid5 = __commonJS({
  "node_modules/mongoose/lib/schema/objectid.js"(exports2, module2) {
    "use strict";
    var SchemaObjectIdOptions = require_SchemaObjectIdOptions();
    var SchemaType = require_schematype();
    var castObjectId = require_objectid4();
    var getConstructorName = require_getConstructorName();
    var oid = require_objectid3();
    var utils2 = require_utils8();
    var CastError = SchemaType.CastError;
    var Document2;
    function ObjectId2(key, options) {
      const isKeyHexStr = typeof key === "string" && key.length === 24 && /^[a-f0-9]+$/i.test(key);
      const suppressWarning = options && options.suppressWarning;
      if ((isKeyHexStr || typeof key === "undefined") && !suppressWarning) {
        console.warn("mongoose: To create a new ObjectId please try `Mongoose.Types.ObjectId` instead of using `Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if you're trying to create a hex char path in your schema.");
        console.trace();
      }
      SchemaType.call(this, key, options, "ObjectID");
    }
    ObjectId2.schemaName = "ObjectId";
    ObjectId2.defaultOptions = {};
    ObjectId2.prototype = Object.create(SchemaType.prototype);
    ObjectId2.prototype.constructor = ObjectId2;
    ObjectId2.prototype.OptionsConstructor = SchemaObjectIdOptions;
    ObjectId2.get = SchemaType.get;
    ObjectId2.set = SchemaType.set;
    ObjectId2.prototype.auto = function(turnOn) {
      if (turnOn) {
        this.default(defaultId);
        this.set(resetId);
      }
      return this;
    };
    ObjectId2._checkRequired = (v) => v instanceof oid;
    ObjectId2._cast = castObjectId;
    ObjectId2.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    ObjectId2._defaultCaster = (v) => {
      if (!(v instanceof oid)) {
        throw new Error(v + " is not an instance of ObjectId");
      }
      return v;
    };
    ObjectId2.checkRequired = SchemaType.checkRequired;
    ObjectId2.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : ObjectId2.checkRequired();
      return _checkRequired(value);
    };
    ObjectId2.prototype.cast = function(value, doc, init) {
      if (SchemaType._isRef(this, value, doc, init)) {
        if (value instanceof oid) {
          return value;
        } else if ((getConstructorName(value) || "").toLowerCase() === "objectid") {
          return new oid(value.toHexString());
        }
        return this._castRef(value, doc, init);
      }
      let castObjectId2;
      if (typeof this._castFunction === "function") {
        castObjectId2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castObjectId2 = this.constructor.cast();
      } else {
        castObjectId2 = ObjectId2.cast();
      }
      try {
        return castObjectId2(value);
      } catch (error) {
        throw new CastError("ObjectId", value, this.path, error, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    ObjectId2.prototype.$conditionalHandlers = utils2.options(SchemaType.prototype.$conditionalHandlers, {
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    function defaultId() {
      return new oid();
    }
    defaultId.$runBeforeSetters = true;
    function resetId(v) {
      Document2 || (Document2 = require_document());
      if (this instanceof Document2) {
        if (v === void 0) {
          const _v = new oid();
          this.$__._id = _v;
          return _v;
        }
        this.$__._id = v;
      }
      return v;
    }
    module2.exports = ObjectId2;
  }
});

// node_modules/mongoose/lib/cast/decimal128.js
var require_decimal1283 = __commonJS({
  "node_modules/mongoose/lib/cast/decimal128.js"(exports2, module2) {
    "use strict";
    var Decimal128Type = require_decimal1282();
    var assert = require("assert");
    module2.exports = function castDecimal128(value) {
      if (value == null) {
        return value;
      }
      if (typeof value === "object" && typeof value.$numberDecimal === "string") {
        return Decimal128Type.fromString(value.$numberDecimal);
      }
      if (value instanceof Decimal128Type) {
        return value;
      }
      if (typeof value === "string") {
        return Decimal128Type.fromString(value);
      }
      if (Buffer.isBuffer(value)) {
        return new Decimal128Type(value);
      }
      if (typeof value === "number") {
        return Decimal128Type.fromString(String(value));
      }
      if (typeof value.valueOf === "function" && typeof value.valueOf() === "string") {
        return Decimal128Type.fromString(value.valueOf());
      }
      assert.ok(false);
    };
  }
});

// node_modules/mongoose/lib/schema/decimal128.js
var require_decimal1284 = __commonJS({
  "node_modules/mongoose/lib/schema/decimal128.js"(exports2, module2) {
    "use strict";
    var SchemaType = require_schematype();
    var CastError = SchemaType.CastError;
    var Decimal128Type = require_decimal1282();
    var castDecimal128 = require_decimal1283();
    var utils2 = require_utils8();
    function Decimal1282(key, options) {
      SchemaType.call(this, key, options, "Decimal128");
    }
    Decimal1282.schemaName = "Decimal128";
    Decimal1282.defaultOptions = {};
    Decimal1282.prototype = Object.create(SchemaType.prototype);
    Decimal1282.prototype.constructor = Decimal1282;
    Decimal1282._cast = castDecimal128;
    Decimal1282.set = SchemaType.set;
    Decimal1282.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    Decimal1282._defaultCaster = (v) => {
      if (v != null && !(v instanceof Decimal128Type)) {
        throw new Error();
      }
      return v;
    };
    Decimal1282._checkRequired = (v) => v instanceof Decimal128Type;
    Decimal1282.checkRequired = SchemaType.checkRequired;
    Decimal1282.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : Decimal1282.checkRequired();
      return _checkRequired(value);
    };
    Decimal1282.prototype.cast = function(value, doc, init) {
      if (SchemaType._isRef(this, value, doc, init)) {
        if (value instanceof Decimal128Type) {
          return value;
        }
        return this._castRef(value, doc, init);
      }
      let castDecimal1282;
      if (typeof this._castFunction === "function") {
        castDecimal1282 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castDecimal1282 = this.constructor.cast();
      } else {
        castDecimal1282 = Decimal1282.cast();
      }
      try {
        return castDecimal1282(value);
      } catch (error) {
        throw new CastError("Decimal128", value, this.path, error, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    Decimal1282.prototype.$conditionalHandlers = utils2.options(SchemaType.prototype.$conditionalHandlers, {
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    module2.exports = Decimal1282;
  }
});

// node_modules/mongoose/lib/options/SchemaMapOptions.js
var require_SchemaMapOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaMapOptions.js"(exports2, module2) {
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaMapOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaMapOptions.prototype, "of", opts);
    module2.exports = SchemaMapOptions;
  }
});

// node_modules/mongoose/lib/schema/map.js
var require_map4 = __commonJS({
  "node_modules/mongoose/lib/schema/map.js"(exports2, module2) {
    "use strict";
    var MongooseMap = require_map3();
    var SchemaMapOptions = require_SchemaMapOptions();
    var SchemaType = require_schematype();
    var Map2 = class extends SchemaType {
      constructor(key, options) {
        super(key, options, "Map");
        this.$isSchemaMap = true;
      }
      set(option, value) {
        return SchemaType.set(option, value);
      }
      cast(val, doc, init) {
        if (val instanceof MongooseMap) {
          return val;
        }
        const path = this.path;
        if (init) {
          const map = new MongooseMap({}, path, doc, this.$__schemaType);
          if (val instanceof global.Map) {
            for (const key of val.keys()) {
              let _val = val.get(key);
              if (_val == null) {
                _val = map.$__schemaType._castNullish(_val);
              } else {
                _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + "." + key });
              }
              map.$init(key, _val);
            }
          } else {
            for (const key of Object.keys(val)) {
              let _val = val[key];
              if (_val == null) {
                _val = map.$__schemaType._castNullish(_val);
              } else {
                _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + "." + key });
              }
              map.$init(key, _val);
            }
          }
          return map;
        }
        return new MongooseMap(val, path, doc, this.$__schemaType);
      }
      clone() {
        const schematype = super.clone();
        if (this.$__schemaType != null) {
          schematype.$__schemaType = this.$__schemaType.clone();
        }
        return schematype;
      }
    };
    Map2.prototype.OptionsConstructor = SchemaMapOptions;
    Map2.defaultOptions = {};
    module2.exports = Map2;
  }
});

// node_modules/mongoose/lib/schema/index.js
var require_schema = __commonJS({
  "node_modules/mongoose/lib/schema/index.js"(exports2) {
    "use strict";
    exports2.String = require_string2();
    exports2.Number = require_number2();
    exports2.Boolean = require_boolean2();
    exports2.DocumentArray = require_documentarray2();
    exports2.Embedded = require_SingleNestedPath();
    exports2.Array = require_array2();
    exports2.Buffer = require_buffer2();
    exports2.Date = require_date2();
    exports2.ObjectId = require_objectid5();
    exports2.Mixed = require_mixed();
    exports2.Decimal128 = exports2.Decimal = require_decimal1284();
    exports2.Map = require_map4();
    exports2.Oid = exports2.ObjectId;
    exports2.Object = exports2.Mixed;
    exports2.Bool = exports2.Boolean;
    exports2.ObjectID = exports2.ObjectId;
  }
});

// node_modules/mongoose/lib/schema.js
var require_schema2 = __commonJS({
  "node_modules/mongoose/lib/schema.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var Kareem = require_kareem();
    var MongooseError = require_mongooseError();
    var SchemaType = require_schematype();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var VirtualOptions = require_VirtualOptions();
    var VirtualType = require_virtualtype();
    var addAutoId = require_addAutoId();
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var get = require_get();
    var getConstructorName = require_getConstructorName();
    var getIndexes = require_getIndexes();
    var merge = require_merge();
    var mpath = require_mpath();
    var readPref = require_driver().get().ReadPreference;
    var setupTimestamps = require_setupTimestamps();
    var util = require("util");
    var utils2 = require_utils8();
    var validateRef = require_validateRef();
    var MongooseTypes;
    var queryHooks = require_applyQueryMiddleware().middlewareFunctions;
    var documentHooks = require_applyHooks().middlewareFunctions;
    var hookNames = queryHooks.concat(documentHooks).reduce((s, hook) => s.add(hook), new Set());
    var id = 0;
    function Schema2(obj, options) {
      if (!(this instanceof Schema2)) {
        return new Schema2(obj, options);
      }
      this.obj = obj;
      this.paths = {};
      this.aliases = {};
      this.subpaths = {};
      this.virtuals = {};
      this.singleNestedPaths = {};
      this.nested = {};
      this.inherits = {};
      this.callQueue = [];
      this._indexes = [];
      this.methods = {};
      this.methodOptions = {};
      this.statics = {};
      this.tree = {};
      this.query = {};
      this.childSchemas = [];
      this.plugins = [];
      this.$id = ++id;
      this.mapPaths = [];
      this.s = {
        hooks: new Kareem()
      };
      this.options = this.defaultOptions(options);
      if (Array.isArray(obj)) {
        for (const definition of obj) {
          this.add(definition);
        }
      } else if (obj) {
        this.add(obj);
      }
      const _idSubDoc = obj && obj._id && utils2.isObject(obj._id);
      const auto_id = !this.paths["_id"] && (!this.options.noId && this.options._id) && !_idSubDoc;
      if (auto_id) {
        addAutoId(this);
      }
      this.setupTimestamp(this.options.timestamps);
    }
    function aliasFields(schema, paths) {
      paths = paths || Object.keys(schema.paths);
      for (const path of paths) {
        const options = get(schema.paths[path], "options");
        if (options == null) {
          continue;
        }
        const prop = schema.paths[path].path;
        const alias = options.alias;
        if (!alias) {
          continue;
        }
        if (typeof alias !== "string") {
          throw new Error("Invalid value for alias option on " + prop + ", got " + alias);
        }
        schema.aliases[alias] = prop;
        schema.virtual(alias).get(function(p) {
          return function() {
            if (typeof this.get === "function") {
              return this.get(p);
            }
            return this[p];
          };
        }(prop)).set(function(p) {
          return function(v) {
            return this.$set(p, v);
          };
        }(prop));
      }
    }
    Schema2.prototype = Object.create(EventEmitter.prototype);
    Schema2.prototype.constructor = Schema2;
    Schema2.prototype.instanceOfSchema = true;
    Object.defineProperty(Schema2.prototype, "$schemaType", {
      configurable: false,
      enumerable: false,
      writable: true
    });
    Object.defineProperty(Schema2.prototype, "childSchemas", {
      configurable: false,
      enumerable: true,
      writable: true
    });
    Schema2.prototype.obj;
    Schema2.prototype.paths;
    Schema2.prototype.tree;
    Schema2.prototype.clone = function() {
      const Constructor = this.base == null ? Schema2 : this.base.Schema;
      const s = new Constructor({}, this._userProvidedOptions);
      s.base = this.base;
      s.obj = this.obj;
      s.options = utils2.clone(this.options);
      s.callQueue = this.callQueue.map(function(f) {
        return f;
      });
      s.methods = utils2.clone(this.methods);
      s.methodOptions = utils2.clone(this.methodOptions);
      s.statics = utils2.clone(this.statics);
      s.query = utils2.clone(this.query);
      s.plugins = Array.prototype.slice.call(this.plugins);
      s._indexes = utils2.clone(this._indexes);
      s.s.hooks = this.s.hooks.clone();
      s.tree = utils2.clone(this.tree);
      s.paths = utils2.clone(this.paths);
      s.nested = utils2.clone(this.nested);
      s.subpaths = utils2.clone(this.subpaths);
      s.singleNestedPaths = utils2.clone(this.singleNestedPaths);
      s.childSchemas = gatherChildSchemas(s);
      s.virtuals = utils2.clone(this.virtuals);
      s.$globalPluginsApplied = this.$globalPluginsApplied;
      s.$isRootDiscriminator = this.$isRootDiscriminator;
      s.$implicitlyCreated = this.$implicitlyCreated;
      s.mapPaths = [].concat(this.mapPaths);
      if (this.discriminatorMapping != null) {
        s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);
      }
      if (this.discriminators != null) {
        s.discriminators = Object.assign({}, this.discriminators);
      }
      s.aliases = Object.assign({}, this.aliases);
      s.on("init", (v) => this.emit("init", v));
      return s;
    };
    Schema2.prototype.pick = function(paths, options) {
      const newSchema = new Schema2({}, options || this.options);
      if (!Array.isArray(paths)) {
        throw new MongooseError('Schema#pick() only accepts an array argument, got "' + typeof paths + '"');
      }
      for (const path of paths) {
        if (this.nested[path]) {
          newSchema.add({ [path]: get(this.tree, path) });
        } else {
          const schematype = this.path(path);
          if (schematype == null) {
            throw new MongooseError("Path `" + path + "` is not in the schema");
          }
          newSchema.add({ [path]: schematype });
        }
      }
      return newSchema;
    };
    Schema2.prototype.defaultOptions = function(options) {
      if (options && options.safe === false) {
        options.safe = { w: 0 };
      }
      if (options && options.safe && options.safe.w === 0) {
        options.versionKey = false;
      }
      this._userProvidedOptions = options == null ? {} : utils2.clone(options);
      const baseOptions = get(this, "base.options", {});
      options = utils2.options({
        strict: "strict" in baseOptions ? baseOptions.strict : true,
        strictQuery: "strictQuery" in baseOptions ? baseOptions.strictQuery : false,
        bufferCommands: true,
        capped: false,
        versionKey: "__v",
        optimisticConcurrency: false,
        discriminatorKey: "__t",
        minimize: true,
        autoIndex: null,
        shardKey: null,
        read: null,
        validateBeforeSave: true,
        noId: false,
        _id: true,
        noVirtualId: false,
        id: true,
        typeKey: "type",
        typePojoToMixed: "typePojoToMixed" in baseOptions ? baseOptions.typePojoToMixed : true
      }, utils2.clone(options));
      if (options.read) {
        options.read = readPref(options.read);
      }
      if (options.optimisticConcurrency && !options.versionKey) {
        throw new MongooseError("Must set `versionKey` if using `optimisticConcurrency`");
      }
      return options;
    };
    Schema2.prototype.add = function add(obj, prefix) {
      if (obj instanceof Schema2 || obj != null && obj.instanceOfSchema) {
        merge(this, obj);
        return this;
      }
      if (obj._id === false && prefix == null) {
        this.options._id = false;
      }
      prefix = prefix || "";
      if (prefix === "__proto__." || prefix === "constructor." || prefix === "prototype.") {
        return this;
      }
      const keys = Object.keys(obj);
      for (const key of keys) {
        const fullPath = prefix + key;
        if (obj[key] == null) {
          throw new TypeError("Invalid value for schema path `" + fullPath + '`, got value "' + obj[key] + '"');
        }
        if (key === "_id" && obj[key] === false) {
          continue;
        }
        if (obj[key] instanceof VirtualType || get(obj[key], "constructor.name", null) === "VirtualType") {
          this.virtual(obj[key]);
          continue;
        }
        if (Array.isArray(obj[key]) && obj[key].length === 1 && obj[key][0] == null) {
          throw new TypeError("Invalid value for schema Array path `" + fullPath + '`, got value "' + obj[key][0] + '"');
        }
        if (!(utils2.isPOJO(obj[key]) || obj[key] instanceof SchemaTypeOptions)) {
          if (prefix) {
            this.nested[prefix.substr(0, prefix.length - 1)] = true;
          }
          this.path(prefix + key, obj[key]);
        } else if (Object.keys(obj[key]).length < 1) {
          if (prefix) {
            this.nested[prefix.substr(0, prefix.length - 1)] = true;
          }
          this.path(fullPath, obj[key]);
        } else if (!obj[key][this.options.typeKey] || this.options.typeKey === "type" && obj[key].type.type) {
          this.nested[fullPath] = true;
          this.add(obj[key], fullPath + ".");
        } else {
          if (!this.options.typePojoToMixed && utils2.isPOJO(obj[key][this.options.typeKey])) {
            if (prefix) {
              this.nested[prefix.substr(0, prefix.length - 1)] = true;
            }
            const opts = { typePojoToMixed: false };
            const _schema = new Schema2(obj[key][this.options.typeKey], opts);
            const schemaWrappedPath = Object.assign({}, obj[key], { [this.options.typeKey]: _schema });
            this.path(prefix + key, schemaWrappedPath);
          } else {
            if (prefix) {
              this.nested[prefix.substr(0, prefix.length - 1)] = true;
            }
            this.path(prefix + key, obj[key]);
          }
        }
      }
      const addedKeys = Object.keys(obj).map((key) => prefix ? prefix + key : key);
      aliasFields(this, addedKeys);
      return this;
    };
    Schema2.reserved = Object.create(null);
    Schema2.prototype.reserved = Schema2.reserved;
    var reserved = Schema2.reserved;
    reserved["prototype"] = reserved.emit = reserved.listeners = reserved.on = reserved.removeListener = reserved.collection = reserved.errors = reserved.get = reserved.init = reserved.isModified = reserved.isNew = reserved.populated = reserved.remove = reserved.save = reserved.toObject = reserved.validate = 1;
    Schema2.prototype.path = function(path, obj) {
      const cleanPath = _pathToPositionalSyntax(path);
      if (obj === void 0) {
        let schematype = _getPath(this, path, cleanPath);
        if (schematype != null) {
          return schematype;
        }
        const mapPath = getMapPath(this, path);
        if (mapPath != null) {
          return mapPath;
        }
        schematype = this.hasMixedParent(cleanPath);
        if (schematype != null) {
          return schematype;
        }
        return /\.\d+\.?.*$/.test(path) ? getPositionalPath(this, path) : void 0;
      }
      const firstPieceOfPath = path.split(".")[0];
      if (reserved[firstPieceOfPath]) {
        throw new Error("`" + firstPieceOfPath + "` may not be used as a schema pathname");
      }
      if (typeof obj === "object" && utils2.hasUserDefinedProperty(obj, "ref")) {
        validateRef(obj.ref, path);
      }
      const subpaths = path.split(/\./);
      const last = subpaths.pop();
      let branch = this.tree;
      let fullPath = "";
      for (const sub of subpaths) {
        fullPath = fullPath += (fullPath.length > 0 ? "." : "") + sub;
        if (!branch[sub]) {
          this.nested[fullPath] = true;
          branch[sub] = {};
        }
        if (typeof branch[sub] !== "object") {
          const msg = "Cannot set nested path `" + path + "`. Parent path `" + fullPath + "` already set to type " + branch[sub].name + ".";
          throw new Error(msg);
        }
        branch = branch[sub];
      }
      branch[last] = utils2.clone(obj);
      this.paths[path] = this.interpretAsType(path, obj, this.options);
      const schemaType = this.paths[path];
      if (schemaType.$isSchemaMap) {
        const mapPath = path + ".$*";
        let _mapType = { type: {} };
        if (utils2.hasUserDefinedProperty(obj, "of")) {
          const isInlineSchema = utils2.isPOJO(obj.of) && Object.keys(obj.of).length > 0 && !utils2.hasUserDefinedProperty(obj.of, this.options.typeKey);
          _mapType = isInlineSchema ? new Schema2(obj.of) : obj.of;
        }
        if (utils2.hasUserDefinedProperty(obj, "ref")) {
          _mapType = { type: _mapType, ref: obj.ref };
        }
        this.paths[mapPath] = this.interpretAsType(mapPath, _mapType, this.options);
        this.mapPaths.push(this.paths[mapPath]);
        schemaType.$__schemaType = this.paths[mapPath];
      }
      if (schemaType.$isSingleNested) {
        for (const key of Object.keys(schemaType.schema.paths)) {
          this.singleNestedPaths[path + "." + key] = schemaType.schema.paths[key];
        }
        for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
          this.singleNestedPaths[path + "." + key] = schemaType.schema.singleNestedPaths[key];
        }
        for (const key of Object.keys(schemaType.schema.subpaths)) {
          this.singleNestedPaths[path + "." + key] = schemaType.schema.subpaths[key];
        }
        for (const key of Object.keys(schemaType.schema.nested)) {
          this.singleNestedPaths[path + "." + key] = "nested";
        }
        Object.defineProperty(schemaType.schema, "base", {
          configurable: true,
          enumerable: false,
          writable: false,
          value: this.base
        });
        schemaType.caster.base = this.base;
        this.childSchemas.push({
          schema: schemaType.schema,
          model: schemaType.caster
        });
      } else if (schemaType.$isMongooseDocumentArray) {
        Object.defineProperty(schemaType.schema, "base", {
          configurable: true,
          enumerable: false,
          writable: false,
          value: this.base
        });
        schemaType.casterConstructor.base = this.base;
        this.childSchemas.push({
          schema: schemaType.schema,
          model: schemaType.casterConstructor
        });
      }
      if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {
        let arrayPath = path;
        let _schemaType = schemaType;
        const toAdd = [];
        while (_schemaType.$isMongooseArray) {
          arrayPath = arrayPath + ".$";
          if (_schemaType.$isMongooseDocumentArray) {
            _schemaType.$embeddedSchemaType._arrayPath = arrayPath;
            _schemaType.$embeddedSchemaType._arrayParentPath = path;
            _schemaType = _schemaType.$embeddedSchemaType.clone();
          } else {
            _schemaType.caster._arrayPath = arrayPath;
            _schemaType.caster._arrayParentPath = path;
            _schemaType = _schemaType.caster.clone();
          }
          _schemaType.path = arrayPath;
          toAdd.push(_schemaType);
        }
        for (const _schemaType2 of toAdd) {
          this.subpaths[_schemaType2.path] = _schemaType2;
        }
      }
      if (schemaType.$isMongooseDocumentArray) {
        for (const key of Object.keys(schemaType.schema.paths)) {
          const _schemaType = schemaType.schema.paths[key];
          this.subpaths[path + "." + key] = _schemaType;
          if (typeof _schemaType === "object" && _schemaType != null) {
            _schemaType.$isUnderneathDocArray = true;
          }
        }
        for (const key of Object.keys(schemaType.schema.subpaths)) {
          const _schemaType = schemaType.schema.subpaths[key];
          this.subpaths[path + "." + key] = _schemaType;
          if (typeof _schemaType === "object" && _schemaType != null) {
            _schemaType.$isUnderneathDocArray = true;
          }
        }
        for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
          const _schemaType = schemaType.schema.singleNestedPaths[key];
          this.subpaths[path + "." + key] = _schemaType;
          if (typeof _schemaType === "object" && _schemaType != null) {
            _schemaType.$isUnderneathDocArray = true;
          }
        }
      }
      return this;
    };
    function gatherChildSchemas(schema) {
      const childSchemas = [];
      for (const path of Object.keys(schema.paths)) {
        const schematype = schema.paths[path];
        if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {
          childSchemas.push({ schema: schematype.schema, model: schematype.caster });
        }
      }
      return childSchemas;
    }
    function _getPath(schema, path, cleanPath) {
      if (schema.paths.hasOwnProperty(path)) {
        return schema.paths[path];
      }
      if (schema.subpaths.hasOwnProperty(cleanPath)) {
        return schema.subpaths[cleanPath];
      }
      if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === "object") {
        return schema.singleNestedPaths[cleanPath];
      }
      return null;
    }
    function _pathToPositionalSyntax(path) {
      if (!/\.\d+/.test(path)) {
        return path;
      }
      return path.replace(/\.\d+\./g, ".$.").replace(/\.\d+$/, ".$");
    }
    function getMapPath(schema, path) {
      if (schema.mapPaths.length === 0) {
        return null;
      }
      for (const val of schema.mapPaths) {
        const _path = val.path;
        const re = new RegExp("^" + _path.replace(/\.\$\*/g, "\\.[^.]+") + "$");
        if (re.test(path)) {
          return schema.paths[_path];
        }
      }
      return null;
    }
    Object.defineProperty(Schema2.prototype, "base", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: null
    });
    Schema2.prototype.interpretAsType = function(path, obj, options) {
      if (obj instanceof SchemaType) {
        if (obj.path === path) {
          return obj;
        }
        const clone = obj.clone();
        clone.path = path;
        return clone;
      }
      const MongooseTypes2 = this.base != null ? this.base.Schema.Types : Schema2.Types;
      if (!utils2.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {
        const constructorName = utils2.getFunctionName(obj.constructor);
        if (constructorName !== "Object") {
          const oldObj = obj;
          obj = {};
          obj[options.typeKey] = oldObj;
        }
      }
      let type = obj[options.typeKey] && (options.typeKey !== "type" || !obj.type.type) ? obj[options.typeKey] : {};
      let name;
      if (utils2.isPOJO(type) || type === "mixed") {
        return new MongooseTypes2.Mixed(path, obj);
      }
      if (Array.isArray(type) || type === Array || type === "array" || type === MongooseTypes2.Array) {
        let cast = type === Array || type === "array" ? obj.cast || obj.of : type[0];
        if (cast && cast.instanceOfSchema) {
          if (!(cast instanceof Schema2)) {
            throw new TypeError("Schema for array path `" + path + "` is from a different copy of the Mongoose module. Please make sure you're using the same version of Mongoose everywhere with `npm list mongoose`.");
          }
          return new MongooseTypes2.DocumentArray(path, cast, obj);
        }
        if (cast && cast[options.typeKey] && cast[options.typeKey].instanceOfSchema) {
          if (!(cast[options.typeKey] instanceof Schema2)) {
            throw new TypeError("Schema for array path `" + path + "` is from a different copy of the Mongoose module. Please make sure you're using the same version of Mongoose everywhere with `npm list mongoose`.");
          }
          return new MongooseTypes2.DocumentArray(path, cast[options.typeKey], obj, cast);
        }
        if (Array.isArray(cast)) {
          return new MongooseTypes2.Array(path, this.interpretAsType(path, cast, options), obj);
        }
        if (typeof cast === "string") {
          cast = MongooseTypes2[cast.charAt(0).toUpperCase() + cast.substring(1)];
        } else if (cast && (!cast[options.typeKey] || options.typeKey === "type" && cast.type.type) && utils2.isPOJO(cast)) {
          if (Object.keys(cast).length) {
            const childSchemaOptions = { minimize: options.minimize };
            if (options.typeKey) {
              childSchemaOptions.typeKey = options.typeKey;
            }
            if (options.hasOwnProperty("strict")) {
              childSchemaOptions.strict = options.strict;
            }
            if (options.hasOwnProperty("typePojoToMixed")) {
              childSchemaOptions.typePojoToMixed = options.typePojoToMixed;
            }
            if (this._userProvidedOptions.hasOwnProperty("_id")) {
              childSchemaOptions._id = this._userProvidedOptions._id;
            } else if (Schema2.Types.DocumentArray.defaultOptions && Schema2.Types.DocumentArray.defaultOptions._id != null) {
              childSchemaOptions._id = Schema2.Types.DocumentArray.defaultOptions._id;
            }
            const childSchema = new Schema2(cast, childSchemaOptions);
            childSchema.$implicitlyCreated = true;
            return new MongooseTypes2.DocumentArray(path, childSchema, obj);
          } else {
            return new MongooseTypes2.Array(path, MongooseTypes2.Mixed, obj);
          }
        }
        if (cast) {
          type = cast[options.typeKey] && (options.typeKey !== "type" || !cast.type.type) ? cast[options.typeKey] : cast;
          name = typeof type === "string" ? type : type.schemaName || utils2.getFunctionName(type);
          if (name === "ClockDate") {
            name = "Date";
          }
          if (!MongooseTypes2.hasOwnProperty(name)) {
            throw new TypeError(`Invalid schema configuration: \`${name}\` is not a valid type within the array \`${path}\`.See http://bit.ly/mongoose-schematypes for a list of valid schema types.`);
          }
        }
        return new MongooseTypes2.Array(path, cast || MongooseTypes2.Mixed, obj, options);
      }
      if (type && type.instanceOfSchema) {
        return new MongooseTypes2.Embedded(type, path, obj);
      }
      if (Buffer.isBuffer(type)) {
        name = "Buffer";
      } else if (typeof type === "function" || typeof type === "object") {
        name = type.schemaName || utils2.getFunctionName(type);
      } else {
        name = type == null ? "" + type : type.toString();
      }
      if (name) {
        name = name.charAt(0).toUpperCase() + name.substring(1);
      }
      if (name === "ObjectID") {
        name = "ObjectId";
      }
      if (name === "ClockDate") {
        name = "Date";
      }
      if (MongooseTypes2[name] == null) {
        throw new TypeError(`Invalid schema configuration: \`${name}\` is not a valid type at path \`${path}\`. See http://bit.ly/mongoose-schematypes for a list of valid schema types.`);
      }
      return new MongooseTypes2[name](path, obj);
    };
    Schema2.prototype.eachPath = function(fn) {
      const keys = Object.keys(this.paths);
      const len = keys.length;
      for (let i = 0; i < len; ++i) {
        fn(keys[i], this.paths[keys[i]]);
      }
      return this;
    };
    Schema2.prototype.requiredPaths = function requiredPaths(invalidate) {
      if (this._requiredpaths && !invalidate) {
        return this._requiredpaths;
      }
      const paths = Object.keys(this.paths);
      let i = paths.length;
      const ret2 = [];
      while (i--) {
        const path = paths[i];
        if (this.paths[path].isRequired) {
          ret2.push(path);
        }
      }
      this._requiredpaths = ret2;
      return this._requiredpaths;
    };
    Schema2.prototype.indexedPaths = function indexedPaths() {
      if (this._indexedpaths) {
        return this._indexedpaths;
      }
      this._indexedpaths = this.indexes();
      return this._indexedpaths;
    };
    Schema2.prototype.pathType = function(path) {
      const cleanPath = _pathToPositionalSyntax(path);
      if (this.paths.hasOwnProperty(path)) {
        return "real";
      }
      if (this.virtuals.hasOwnProperty(path)) {
        return "virtual";
      }
      if (this.nested.hasOwnProperty(path)) {
        return "nested";
      }
      if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {
        return "real";
      }
      const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);
      if (singleNestedPath) {
        return singleNestedPath === "nested" ? "nested" : "real";
      }
      const mapPath = getMapPath(this, path);
      if (mapPath != null) {
        return "real";
      }
      if (/\.\d+\.|\.\d+$/.test(path)) {
        return getPositionalPathType(this, path);
      }
      return "adhocOrUndefined";
    };
    Schema2.prototype.hasMixedParent = function(path) {
      const subpaths = path.split(/\./g);
      path = "";
      for (let i = 0; i < subpaths.length; ++i) {
        path = i > 0 ? path + "." + subpaths[i] : subpaths[i];
        if (this.paths.hasOwnProperty(path) && this.paths[path] instanceof MongooseTypes.Mixed) {
          return this.paths[path];
        }
      }
      return null;
    };
    Schema2.prototype.setupTimestamp = function(timestamps) {
      return setupTimestamps(this, timestamps);
    };
    function getPositionalPathType(self2, path) {
      const subpaths = path.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
      if (subpaths.length < 2) {
        return self2.paths.hasOwnProperty(subpaths[0]) ? self2.paths[subpaths[0]] : "adhocOrUndefined";
      }
      let val = self2.path(subpaths[0]);
      let isNested = false;
      if (!val) {
        return "adhocOrUndefined";
      }
      const last = subpaths.length - 1;
      for (let i = 1; i < subpaths.length; ++i) {
        isNested = false;
        const subpath = subpaths[i];
        if (i === last && val && !/\D/.test(subpath)) {
          if (val.$isMongooseDocumentArray) {
            val = val.$embeddedSchemaType;
          } else if (val instanceof MongooseTypes.Array) {
            val = val.caster;
          } else {
            val = void 0;
          }
          break;
        }
        if (!/\D/.test(subpath)) {
          if (val instanceof MongooseTypes.Array && i !== last) {
            val = val.caster;
          }
          continue;
        }
        if (!(val && val.schema)) {
          val = void 0;
          break;
        }
        const type = val.schema.pathType(subpath);
        isNested = type === "nested";
        val = val.schema.path(subpath);
      }
      self2.subpaths[path] = val;
      if (val) {
        return "real";
      }
      if (isNested) {
        return "nested";
      }
      return "adhocOrUndefined";
    }
    function getPositionalPath(self2, path) {
      getPositionalPathType(self2, path);
      return self2.subpaths[path];
    }
    Schema2.prototype.queue = function(name, args) {
      this.callQueue.push([name, args]);
      return this;
    };
    Schema2.prototype.pre = function(name) {
      if (name instanceof RegExp) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const fn of hookNames) {
          if (name.test(fn)) {
            this.pre.apply(this, [fn].concat(remainingArgs));
          }
        }
        return this;
      }
      if (Array.isArray(name)) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const el of name) {
          this.pre.apply(this, [el].concat(remainingArgs));
        }
        return this;
      }
      this.s.hooks.pre.apply(this.s.hooks, arguments);
      return this;
    };
    Schema2.prototype.post = function(name) {
      if (name instanceof RegExp) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const fn of hookNames) {
          if (name.test(fn)) {
            this.post.apply(this, [fn].concat(remainingArgs));
          }
        }
        return this;
      }
      if (Array.isArray(name)) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const el of name) {
          this.post.apply(this, [el].concat(remainingArgs));
        }
        return this;
      }
      this.s.hooks.post.apply(this.s.hooks, arguments);
      return this;
    };
    Schema2.prototype.plugin = function(fn, opts) {
      if (typeof fn !== "function") {
        throw new Error('First param to `schema.plugin()` must be a function, got "' + typeof fn + '"');
      }
      if (opts && opts.deduplicate) {
        for (const plugin of this.plugins) {
          if (plugin.fn === fn) {
            return this;
          }
        }
      }
      this.plugins.push({ fn, opts });
      fn(this, opts);
      return this;
    };
    Schema2.prototype.method = function(name, fn, options) {
      if (typeof name !== "string") {
        for (const i in name) {
          this.methods[i] = name[i];
          this.methodOptions[i] = utils2.clone(options);
        }
      } else {
        this.methods[name] = fn;
        this.methodOptions[name] = utils2.clone(options);
      }
      return this;
    };
    Schema2.prototype.static = function(name, fn) {
      if (typeof name !== "string") {
        for (const i in name) {
          this.statics[i] = name[i];
        }
      } else {
        this.statics[name] = fn;
      }
      return this;
    };
    Schema2.prototype.index = function(fields, options) {
      fields || (fields = {});
      options || (options = {});
      if (options.expires) {
        utils2.expires(options);
      }
      this._indexes.push([fields, options]);
      return this;
    };
    Schema2.prototype.set = function(key, value, _tags) {
      if (arguments.length === 1) {
        return this.options[key];
      }
      switch (key) {
        case "read":
          this.options[key] = readPref(value, _tags);
          this._userProvidedOptions[key] = this.options[key];
          break;
        case "safe":
          setSafe(this.options, value);
          this._userProvidedOptions[key] = this.options[key];
          break;
        case "timestamps":
          this.setupTimestamp(value);
          this.options[key] = value;
          this._userProvidedOptions[key] = this.options[key];
          break;
        case "_id":
          this.options[key] = value;
          this._userProvidedOptions[key] = this.options[key];
          if (value && !this.paths["_id"]) {
            addAutoId(this);
          } else if (!value && this.paths["_id"] != null && this.paths["_id"].auto) {
            this.remove("_id");
          }
          break;
        default:
          this.options[key] = value;
          this._userProvidedOptions[key] = this.options[key];
          break;
      }
      return this;
    };
    var safeDeprecationWarning = "Mongoose: The `safe` option for schemas is deprecated. Use the `writeConcern` option instead: http://bit.ly/mongoose-write-concern";
    var setSafe = util.deprecate(function setSafe2(options, value) {
      options.safe = value === false ? { w: 0 } : value;
    }, safeDeprecationWarning);
    Schema2.prototype.get = function(key) {
      return this.options[key];
    };
    var indexTypes = "2d 2dsphere hashed text".split(" ");
    Object.defineProperty(Schema2, "indexTypes", {
      get: function() {
        return indexTypes;
      },
      set: function() {
        throw new Error("Cannot overwrite Schema.indexTypes");
      }
    });
    Schema2.prototype.indexes = function() {
      return getIndexes(this);
    };
    Schema2.prototype.virtual = function(name, options) {
      if (name instanceof VirtualType || getConstructorName(name) === "VirtualType") {
        return this.virtual(name.path, name.options);
      }
      options = new VirtualOptions(options);
      if (utils2.hasUserDefinedProperty(options, ["ref", "refPath"])) {
        if (options.localField == null) {
          throw new Error("Reference virtuals require `localField` option");
        }
        if (options.foreignField == null) {
          throw new Error("Reference virtuals require `foreignField` option");
        }
        this.pre("init", function(obj) {
          if (mpath.has(name, obj)) {
            const _v = mpath.get(name, obj);
            if (!this.$$populatedVirtuals) {
              this.$$populatedVirtuals = {};
            }
            if (options.justOne || options.count) {
              this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;
            } else {
              this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];
            }
            mpath.unset(name, obj);
          }
        });
        const virtual = this.virtual(name);
        virtual.options = options;
        virtual.set(function(_v) {
          if (!this.$$populatedVirtuals) {
            this.$$populatedVirtuals = {};
          }
          if (options.justOne || options.count) {
            this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;
            if (typeof this.$$populatedVirtuals[name] !== "object") {
              this.$$populatedVirtuals[name] = options.count ? _v : null;
            }
          } else {
            this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];
            this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {
              return doc && typeof doc === "object";
            });
          }
        });
        if (typeof options.get === "function") {
          virtual.get(options.get);
        }
        return virtual;
      }
      const virtuals = this.virtuals;
      const parts = name.split(".");
      if (this.pathType(name) === "real") {
        throw new Error('Virtual path "' + name + '" conflicts with a real path in the schema');
      }
      virtuals[name] = parts.reduce(function(mem, part, i) {
        mem[part] || (mem[part] = i === parts.length - 1 ? new VirtualType(options, name) : {});
        return mem[part];
      }, this.tree);
      let cur = parts[0];
      for (let i = 0; i < parts.length - 1; ++i) {
        if (this.paths[cur] != null && this.paths[cur].$isMongooseDocumentArray) {
          const remnant = parts.slice(i + 1).join(".");
          const v = this.paths[cur].schema.virtual(remnant);
          v.get((v2, virtual, doc) => {
            const parent = doc.__parentArray[arrayParentSymbol];
            const path = cur + "." + doc.__index + "." + remnant;
            return parent.get(path);
          });
          break;
        }
        cur += "." + parts[i + 1];
      }
      return virtuals[name];
    };
    Schema2.prototype.virtualpath = function(name) {
      return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;
    };
    Schema2.prototype.remove = function(path) {
      if (typeof path === "string") {
        path = [path];
      }
      if (Array.isArray(path)) {
        path.forEach(function(name) {
          if (this.path(name) == null && !this.nested[name]) {
            return;
          }
          if (this.nested[name]) {
            const allKeys = Object.keys(this.paths).concat(Object.keys(this.nested));
            for (const path2 of allKeys) {
              if (path2.startsWith(name + ".")) {
                delete this.paths[path2];
                delete this.nested[path2];
                _deletePath(this, path2);
              }
            }
            delete this.nested[name];
            _deletePath(this, name);
            return;
          }
          delete this.paths[name];
          _deletePath(this, name);
        }, this);
      }
      return this;
    };
    function _deletePath(schema, name) {
      const pieces = name.split(".");
      const last = pieces.pop();
      let branch = schema.tree;
      for (const piece of pieces) {
        branch = branch[piece];
      }
      delete branch[last];
    }
    Schema2.prototype.loadClass = function(model2, virtualsOnly) {
      if (model2 === Object.prototype || model2 === Function.prototype || model2.prototype.hasOwnProperty("$isMongooseModelPrototype")) {
        return this;
      }
      this.loadClass(Object.getPrototypeOf(model2), virtualsOnly);
      if (!virtualsOnly) {
        Object.getOwnPropertyNames(model2).forEach(function(name) {
          if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {
            return;
          }
          const prop = Object.getOwnPropertyDescriptor(model2, name);
          if (prop.hasOwnProperty("value")) {
            this.static(name, prop.value);
          }
        }, this);
      }
      Object.getOwnPropertyNames(model2.prototype).forEach(function(name) {
        if (name.match(/^(constructor)$/)) {
          return;
        }
        const method = Object.getOwnPropertyDescriptor(model2.prototype, name);
        if (!virtualsOnly) {
          if (typeof method.value === "function") {
            this.method(name, method.value);
          }
        }
        if (typeof method.get === "function") {
          if (this.virtuals[name]) {
            this.virtuals[name].getters = [];
          }
          this.virtual(name).get(method.get);
        }
        if (typeof method.set === "function") {
          if (this.virtuals[name]) {
            this.virtuals[name].setters = [];
          }
          this.virtual(name).set(method.set);
        }
      }, this);
      return this;
    };
    Schema2.prototype._getSchema = function(path) {
      const _this = this;
      const pathschema = _this.path(path);
      const resultPath = [];
      if (pathschema) {
        pathschema.$fullPath = path;
        return pathschema;
      }
      function search(parts2, schema) {
        let p = parts2.length + 1;
        let foundschema;
        let trypath;
        while (p--) {
          trypath = parts2.slice(0, p).join(".");
          foundschema = schema.path(trypath);
          if (foundschema) {
            resultPath.push(trypath);
            if (foundschema.caster) {
              if (foundschema.caster instanceof MongooseTypes.Mixed) {
                foundschema.caster.$fullPath = resultPath.join(".");
                return foundschema.caster;
              }
              if (p !== parts2.length) {
                if (foundschema.schema) {
                  let ret2;
                  if (parts2[p] === "$" || isArrayFilter(parts2[p])) {
                    if (p + 1 === parts2.length) {
                      return foundschema;
                    }
                    ret2 = search(parts2.slice(p + 1), foundschema.schema);
                    if (ret2) {
                      ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                    }
                    return ret2;
                  }
                  ret2 = search(parts2.slice(p), foundschema.schema);
                  if (ret2) {
                    ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                  }
                  return ret2;
                }
              }
            } else if (foundschema.$isSchemaMap) {
              if (p + 1 >= parts2.length) {
                return foundschema;
              }
              const ret2 = search(parts2.slice(p + 1), foundschema.$__schemaType.schema);
              return ret2;
            }
            foundschema.$fullPath = resultPath.join(".");
            return foundschema;
          }
        }
      }
      const parts = path.split(".");
      for (let i = 0; i < parts.length; ++i) {
        if (parts[i] === "$" || isArrayFilter(parts[i])) {
          parts[i] = "0";
        }
      }
      return search(parts, _this);
    };
    Schema2.prototype._getPathType = function(path) {
      const _this = this;
      const pathschema = _this.path(path);
      if (pathschema) {
        return "real";
      }
      function search(parts, schema) {
        let p = parts.length + 1, foundschema, trypath;
        while (p--) {
          trypath = parts.slice(0, p).join(".");
          foundschema = schema.path(trypath);
          if (foundschema) {
            if (foundschema.caster) {
              if (foundschema.caster instanceof MongooseTypes.Mixed) {
                return { schema: foundschema, pathType: "mixed" };
              }
              if (p !== parts.length && foundschema.schema) {
                if (parts[p] === "$" || isArrayFilter(parts[p])) {
                  if (p === parts.length - 1) {
                    return { schema: foundschema, pathType: "nested" };
                  }
                  return search(parts.slice(p + 1), foundschema.schema);
                }
                return search(parts.slice(p), foundschema.schema);
              }
              return {
                schema: foundschema,
                pathType: foundschema.$isSingleNested ? "nested" : "array"
              };
            }
            return { schema: foundschema, pathType: "real" };
          } else if (p === parts.length && schema.nested[trypath]) {
            return { schema, pathType: "nested" };
          }
        }
        return { schema: foundschema || schema, pathType: "undefined" };
      }
      return search(path.split("."), _this);
    };
    function isArrayFilter(piece) {
      return piece.startsWith("$[") && piece.endsWith("]");
    }
    module2.exports = exports2 = Schema2;
    Schema2.Types = MongooseTypes = require_schema();
    exports2.ObjectId = MongooseTypes.ObjectId;
  }
});

// node_modules/mongoose/lib/helpers/common.js
var require_common3 = __commonJS({
  "node_modules/mongoose/lib/helpers/common.js"(exports2) {
    "use strict";
    var Binary2 = require_driver().get().Binary;
    var Decimal1282 = require_decimal1282();
    var ObjectId2 = require_objectid3();
    var isMongooseObject = require_isMongooseObject();
    exports2.flatten = flatten;
    exports2.modifiedPaths = modifiedPaths;
    function flatten(update, path, options, schema) {
      let keys;
      if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {
        keys = Object.keys(update.toObject({ transform: false, virtuals: false }));
      } else {
        keys = Object.keys(update || {});
      }
      const numKeys = keys.length;
      const result = {};
      path = path ? path + "." : "";
      for (let i = 0; i < numKeys; ++i) {
        const key = keys[i];
        const val = update[key];
        result[path + key] = val;
        const keySchema = schema && schema.path && schema.path(path + key);
        const isNested = schema && schema.nested && schema.nested[path + key];
        if (keySchema && keySchema.instance === "Mixed")
          continue;
        if (shouldFlatten(val)) {
          if (options && options.skipArrays && Array.isArray(val)) {
            continue;
          }
          const flat = flatten(val, path + key, options, schema);
          for (const k in flat) {
            result[k] = flat[k];
          }
          if (Array.isArray(val)) {
            result[path + key] = val;
          }
        }
        if (isNested) {
          const paths = Object.keys(schema.paths);
          for (const p of paths) {
            if (p.startsWith(path + key + ".") && !result.hasOwnProperty(p)) {
              result[p] = void 0;
            }
          }
        }
      }
      return result;
    }
    function modifiedPaths(update, path, result) {
      const keys = Object.keys(update || {});
      const numKeys = keys.length;
      result = result || {};
      path = path ? path + "." : "";
      for (let i = 0; i < numKeys; ++i) {
        const key = keys[i];
        let val = update[key];
        result[path + key] = true;
        if (isMongooseObject(val) && !Buffer.isBuffer(val)) {
          val = val.toObject({ transform: false, virtuals: false });
        }
        if (shouldFlatten(val)) {
          modifiedPaths(val, path + key, result);
        }
      }
      return result;
    }
    function shouldFlatten(val) {
      return val && typeof val === "object" && !(val instanceof Date) && !(val instanceof ObjectId2) && (!Array.isArray(val) || val.length > 0) && !(val instanceof Buffer) && !(val instanceof Decimal1282) && !(val instanceof Binary2);
    }
  }
});

// node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js
var require_getEmbeddedDiscriminatorPath = __commonJS({
  "node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    module2.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {
      options = options || {};
      const typeOnly = options.typeOnly;
      const parts = path.split(".");
      let schema = null;
      let type = "adhocOrUndefined";
      for (let i = 0; i < parts.length; ++i) {
        const subpath = parts.slice(0, i + 1).join(".");
        schema = doc.schema.path(subpath);
        if (schema == null) {
          type = "adhocOrUndefined";
          continue;
        }
        if (schema.instance === "Mixed") {
          return typeOnly ? "real" : schema;
        }
        type = doc.schema.pathType(subpath);
        if ((schema.$isSingleNested || schema.$isMongooseDocumentArrayElement) && schema.schema.discriminators != null) {
          const discriminators = schema.schema.discriminators;
          const discriminatorKey = doc.get(subpath + "." + get(schema, "schema.options.discriminatorKey"));
          if (discriminatorKey == null || discriminators[discriminatorKey] == null) {
            continue;
          }
          const rest = parts.slice(i + 1).join(".");
          return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);
        }
      }
      return typeOnly ? type : schema;
    };
  }
});

// node_modules/mongoose/lib/plugins/idGetter.js
var require_idGetter = __commonJS({
  "node_modules/mongoose/lib/plugins/idGetter.js"(exports2, module2) {
    "use strict";
    module2.exports = function(schema) {
      const autoIdGetter = !schema.paths["id"] && (!schema.options.noVirtualId && schema.options.id);
      if (!autoIdGetter) {
        return;
      }
      schema.virtual("id").get(idGetter);
    };
    function idGetter() {
      if (this._id != null) {
        return String(this._id);
      }
      return null;
    }
  }
});

// node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js
var require_isDefiningProjection = __commonJS({
  "node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js"(exports2, module2) {
    "use strict";
    module2.exports = function isDefiningProjection(val) {
      if (val == null) {
        return true;
      }
      if (typeof val === "object") {
        return !("$meta" in val) && !("$slice" in val);
      }
      return true;
    };
  }
});

// node_modules/mongoose/lib/helpers/projection/isExclusive.js
var require_isExclusive = __commonJS({
  "node_modules/mongoose/lib/helpers/projection/isExclusive.js"(exports2, module2) {
    "use strict";
    var isDefiningProjection = require_isDefiningProjection();
    module2.exports = function isExclusive(projection) {
      if (projection == null) {
        return null;
      }
      const keys = Object.keys(projection);
      let ki = keys.length;
      let exclude = null;
      if (ki === 1 && keys[0] === "_id") {
        exclude = !!projection[keys[ki]];
      } else {
        while (ki--) {
          if (keys[ki] !== "_id" && isDefiningProjection(projection[keys[ki]])) {
            exclude = !projection[keys[ki]];
            break;
          }
        }
      }
      return exclude;
    };
  }
});

// node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js
var require_checkEmbeddedDiscriminatorKeyProjection = __commonJS({
  "node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js"(exports2, module2) {
    "use strict";
    module2.exports = function checkEmbeddedDiscriminatorKeyProjection(userProjection, path, schema, selected, addedPaths) {
      const userProjectedInPath = Object.keys(userProjection).reduce((cur, key) => cur || key.startsWith(path + "."), false);
      const _discriminatorKey = path + "." + schema.options.discriminatorKey;
      if (!userProjectedInPath && addedPaths.length === 1 && addedPaths[0] === _discriminatorKey) {
        selected.splice(selected.indexOf(_discriminatorKey), 1);
      }
    };
  }
});

// node_modules/mongoose/lib/queryhelpers.js
var require_queryhelpers = __commonJS({
  "node_modules/mongoose/lib/queryhelpers.js"(exports2) {
    "use strict";
    var checkEmbeddedDiscriminatorKeyProjection = require_checkEmbeddedDiscriminatorKeyProjection();
    var get = require_get();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var isDefiningProjection = require_isDefiningProjection();
    var clone = require_clone();
    exports2.preparePopulationOptions = function preparePopulationOptions(query, options) {
      const _populate = query.options.populate;
      const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);
      if (options.lean != null) {
        pop.filter((p) => get(p, "options.lean") == null).forEach(makeLean(options.lean));
      }
      pop.forEach((opts) => {
        opts._localModel = query.model;
      });
      return pop;
    };
    exports2.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {
      const _populate = query._mongooseOptions.populate;
      const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);
      if (options.lean != null) {
        pop.filter((p) => get(p, "options.lean") == null).forEach(makeLean(options.lean));
      }
      const session = get(query, "options.session", null);
      if (session != null) {
        pop.forEach((path) => {
          if (path.options == null) {
            path.options = { session };
            return;
          }
          if (!("session" in path.options)) {
            path.options.session = session;
          }
        });
      }
      const projection = query._fieldsForExec();
      pop.forEach((p) => {
        p._queryProjection = projection;
      });
      pop.forEach((opts) => {
        opts._localModel = query.model;
      });
      return pop;
    };
    exports2.createModel = function createModel(model2, doc, fields, userProvidedFields, options) {
      model2.hooks.execPreSync("createModel", doc);
      const discriminatorMapping = model2.schema ? model2.schema.discriminatorMapping : null;
      const key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;
      const value = doc[key];
      if (key && value && model2.discriminators) {
        const discriminator = model2.discriminators[value] || getDiscriminatorByValue(model2.discriminators, value);
        if (discriminator) {
          const _fields = clone(userProvidedFields);
          exports2.applyPaths(_fields, discriminator.schema);
          return new discriminator(void 0, _fields, true);
        }
      }
      if (typeof options === "undefined") {
        options = {};
        options.defaults = true;
      }
      return new model2(void 0, fields, {
        skipId: true,
        isNew: false,
        willInit: true,
        defaults: options.defaults
      });
    };
    exports2.applyPaths = function applyPaths(fields, schema) {
      let exclude;
      let keys;
      let keyIndex;
      if (fields) {
        keys = Object.keys(fields);
        keyIndex = keys.length;
        while (keyIndex--) {
          if (keys[keyIndex][0] === "+") {
            continue;
          }
          const field = fields[keys[keyIndex]];
          if (!isDefiningProjection(field)) {
            continue;
          }
          exclude = !field;
          break;
        }
      }
      const selected = [];
      const excluded = [];
      const stack = [];
      analyzeSchema(schema);
      switch (exclude) {
        case true:
          for (const fieldName of excluded) {
            fields[fieldName] = 0;
          }
          break;
        case false:
          if (schema && schema.paths["_id"] && schema.paths["_id"].options && schema.paths["_id"].options.select === false) {
            fields._id = 0;
          }
          for (const fieldName of selected) {
            fields[fieldName] = fields[fieldName] || 1;
          }
          break;
        case void 0:
          if (fields == null) {
            break;
          }
          for (const key of Object.keys(fields || {})) {
            if (key.startsWith("+")) {
              delete fields[key];
            }
          }
          for (const fieldName of excluded) {
            fields[fieldName] = 0;
          }
          break;
      }
      function analyzeSchema(schema2, prefix) {
        prefix || (prefix = "");
        if (stack.indexOf(schema2) !== -1) {
          return [];
        }
        stack.push(schema2);
        const addedPaths = [];
        schema2.eachPath(function(path, type) {
          if (prefix)
            path = prefix + "." + path;
          let addedPath = analyzePath(path, type);
          if (addedPath == null && type.$isMongooseArray && !type.$isMongooseDocumentArray) {
            addedPath = analyzePath(path, type.caster);
          }
          if (addedPath != null) {
            addedPaths.push(addedPath);
          }
          if (type.schema) {
            const _addedPaths = analyzeSchema(type.schema, path);
            if (exclude === false) {
              checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);
            }
          }
        });
        stack.pop();
        return addedPaths;
      }
      function analyzePath(path, type) {
        const plusPath = "+" + path;
        const hasPlusPath = fields && plusPath in fields;
        if (hasPlusPath) {
          delete fields[plusPath];
        }
        if (typeof type.selected !== "boolean")
          return;
        if (hasPlusPath) {
          delete fields[plusPath];
          if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {
            fields[path] = 1;
          }
          return;
        }
        const pieces = path.split(".");
        let cur = "";
        for (let i = 0; i < pieces.length; ++i) {
          cur += cur.length ? "." + pieces[i] : pieces[i];
          if (excluded.indexOf(cur) !== -1) {
            return;
          }
        }
        if (!exclude && get(type, "options.$skipDiscriminatorCheck", false)) {
          let cur2 = "";
          for (let i = 0; i < pieces.length; ++i) {
            cur2 += (cur2.length === 0 ? "" : ".") + pieces[i];
            const projection = get(fields, cur2, false) || get(fields, cur2 + ".$", false);
            if (projection && typeof projection !== "object") {
              return;
            }
          }
        }
        (type.selected ? selected : excluded).push(path);
        return path;
      }
    };
    function makeLean(val) {
      return function(option) {
        option.options || (option.options = {});
        if (val != null && Array.isArray(val.virtuals)) {
          val = Object.assign({}, val);
          val.virtuals = val.virtuals.filter((path) => typeof path === "string" && path.startsWith(option.path + ".")).map((path) => path.slice(option.path.length + 1));
        }
        option.options.lean = val;
      };
    }
    exports2.handleDeleteWriteOpResult = function handleDeleteWriteOpResult(callback) {
      return function _handleDeleteWriteOpResult(error, res) {
        if (error) {
          return callback(error);
        }
        const mongooseResult = Object.assign({}, res.result);
        if (get(res, "result.n", null) != null) {
          mongooseResult.deletedCount = res.result.n;
        }
        if (res.deletedCount != null) {
          mongooseResult.deletedCount = res.deletedCount;
        }
        return callback(null, mongooseResult);
      };
    };
  }
});

// node_modules/mongoose/lib/helpers/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/mongoose/lib/helpers/isPromise.js"(exports2, module2) {
    "use strict";
    function isPromise(val) {
      return !!val && (typeof val === "object" || typeof val === "function") && typeof val.then === "function";
    }
    module2.exports = isPromise;
  }
});

// node_modules/mongoose/lib/document.js
var require_document = __commonJS({
  "node_modules/mongoose/lib/document.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var InternalCache = require_internal2();
    var MongooseError = require_error3();
    var MixedSchema = require_mixed();
    var ObjectExpectedError = require_objectExpected();
    var ObjectParameterError = require_objectParameter();
    var ParallelValidateError = require_parallelValidate();
    var Schema2 = require_schema2();
    var StrictModeError = require_strict();
    var ValidationError = require_validation();
    var ValidatorError = require_validator();
    var VirtualType = require_virtualtype();
    var promiseOrCallback = require_promiseOrCallback();
    var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
    var compile = require_compile().compile;
    var defineKey = require_compile().defineKey;
    var flatten = require_common3().flatten;
    var get = require_get();
    var getEmbeddedDiscriminatorPath = require_getEmbeddedDiscriminatorPath();
    var handleSpreadDoc = require_handleSpreadDoc();
    var idGetter = require_idGetter();
    var immediate = require_immediate();
    var isDefiningProjection = require_isDefiningProjection();
    var isExclusive = require_isExclusive();
    var inspect = require("util").inspect;
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var mpath = require_mpath();
    var queryhelpers = require_queryhelpers();
    var utils2 = require_utils8();
    var isPromise = require_isPromise();
    var clone = utils2.clone;
    var deepEqual = utils2.deepEqual;
    var isMongooseObject = utils2.isMongooseObject;
    var arrayAtomicsBackupSymbol = Symbol("mongoose.Array#atomicsBackup");
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var documentArrayParent = require_symbols().documentArrayParent;
    var documentIsModified = require_symbols().documentIsModified;
    var documentModifiedPaths = require_symbols().documentModifiedPaths;
    var documentSchemaSymbol = require_symbols().documentSchemaSymbol;
    var getSymbol = require_symbols().getSymbol;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var scopeSymbol = require_symbols().scopeSymbol;
    var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
    var DocumentArray;
    var MongooseArray;
    var Embedded;
    var specialProperties = utils2.specialProperties;
    function Document2(obj, fields, skipId, options) {
      if (typeof skipId === "object" && skipId != null) {
        options = skipId;
        skipId = options.skipId;
      }
      options = Object.assign({}, options);
      const defaults = get(options, "defaults", true);
      options.defaults = defaults;
      if (this.$__schema == null) {
        const _schema = utils2.isObject(fields) && !fields.instanceOfSchema ? new Schema2(fields) : fields;
        this.$__setSchema(_schema);
        fields = skipId;
        skipId = options;
        options = arguments[4] || {};
      }
      this.$__ = new InternalCache();
      this.$__.emitter = new EventEmitter();
      this.isNew = "isNew" in options ? options.isNew : true;
      this.errors = void 0;
      this.$__.$options = options || {};
      this.$locals = {};
      this.$op = null;
      if (obj != null && typeof obj !== "object") {
        throw new ObjectParameterError(obj, "obj", "Document");
      }
      const schema = this.$__schema;
      if (typeof fields === "boolean" || fields === "throw") {
        this.$__.strictMode = fields;
        fields = void 0;
      } else {
        this.$__.strictMode = schema.options.strict;
        this.$__.selected = fields;
      }
      const requiredPaths = schema.requiredPaths(true);
      for (const path of requiredPaths) {
        this.$__.activePaths.require(path);
      }
      this.$__.emitter.setMaxListeners(0);
      let exclude = null;
      if (utils2.isPOJO(fields)) {
        exclude = isExclusive(fields);
      }
      const hasIncludedChildren = exclude === false && fields ? $__hasIncludedChildren(fields) : {};
      if (this._doc == null) {
        this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);
        if (defaults) {
          $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true, {
            isNew: this.isNew
          });
        }
      }
      if (obj) {
        if (this.$__original_set) {
          this.$__original_set(obj, void 0, true);
        } else {
          this.$set(obj, void 0, true);
        }
        if (obj instanceof Document2) {
          this.isNew = obj.isNew;
        }
      }
      if (options.willInit && defaults) {
        EventEmitter.prototype.once.call(this, "init", () => {
          $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {
            isNew: this.isNew
          });
        });
      } else if (defaults) {
        $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {
          isNew: this.isNew
        });
      }
      this.$__._id = this._id;
      if (!this.$__.strictMode && obj) {
        const _this = this;
        const keys = Object.keys(this._doc);
        keys.forEach(function(key) {
          if (!(key in schema.tree)) {
            defineKey(key, null, _this);
          }
        });
      }
      applyQueue(this);
    }
    utils2.each([
      "on",
      "once",
      "emit",
      "listeners",
      "removeListener",
      "setMaxListeners",
      "removeAllListeners",
      "addListener"
    ], function(emitterFn) {
      Document2.prototype[emitterFn] = function() {
        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
      };
    });
    Document2.prototype.constructor = Document2;
    for (const i in EventEmitter.prototype) {
      Document2[i] = EventEmitter.prototype[i];
    }
    Document2.prototype.$__schema;
    Document2.prototype.schema;
    Object.defineProperty(Document2.prototype, "$locals", {
      configurable: false,
      enumerable: false,
      writable: true
    });
    Document2.prototype.isNew;
    Document2.prototype.id;
    Document2.prototype.errors;
    Document2.prototype.$op;
    function $__hasIncludedChildren(fields) {
      const hasIncludedChildren = {};
      const keys = Object.keys(fields);
      for (const key of keys) {
        const parts = key.split(".");
        const c = [];
        for (const part of parts) {
          c.push(part);
          hasIncludedChildren[c.join(".")] = 1;
        }
      }
      return hasIncludedChildren;
    }
    function $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {
      const paths = Object.keys(doc.$__schema.paths);
      const plen = paths.length;
      for (let i = 0; i < plen; ++i) {
        let def;
        let curPath = "";
        const p = paths[i];
        if (p === "_id" && skipId) {
          continue;
        }
        const type = doc.$__schema.paths[p];
        const path = type.splitPath();
        const len = path.length;
        let included = false;
        let doc_ = doc._doc;
        for (let j = 0; j < len; ++j) {
          if (doc_ == null) {
            break;
          }
          const piece = path[j];
          curPath += (!curPath.length ? "" : ".") + piece;
          if (exclude === true) {
            if (curPath in fields) {
              break;
            }
          } else if (exclude === false && fields && !included) {
            if (curPath in fields) {
              included = true;
            } else if (!hasIncludedChildren[curPath]) {
              break;
            }
          }
          if (j === len - 1) {
            if (doc_[piece] !== void 0) {
              break;
            }
            if (typeof type.defaultValue === "function") {
              if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {
                break;
              }
              if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {
                break;
              }
            } else if (!isBeforeSetters) {
              continue;
            }
            if (pathsToSkip && pathsToSkip[curPath]) {
              break;
            }
            if (fields && exclude !== null) {
              if (exclude === true) {
                if (p in fields) {
                  continue;
                }
                try {
                  def = type.getDefault(doc, false);
                } catch (err) {
                  doc.invalidate(p, err);
                  break;
                }
                if (typeof def !== "undefined") {
                  doc_[piece] = def;
                  doc.$__.activePaths.default(p);
                }
              } else if (included) {
                try {
                  def = type.getDefault(doc, false);
                } catch (err) {
                  doc.invalidate(p, err);
                  break;
                }
                if (typeof def !== "undefined") {
                  doc_[piece] = def;
                  doc.$__.activePaths.default(p);
                }
              }
            } else {
              try {
                def = type.getDefault(doc, false);
              } catch (err) {
                doc.invalidate(p, err);
                break;
              }
              if (typeof def !== "undefined") {
                doc_[piece] = def;
                doc.$__.activePaths.default(p);
              }
            }
          } else {
            doc_ = doc_[piece];
          }
        }
      }
    }
    Document2.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {
      const doc = {};
      const paths = Object.keys(this.$__schema.paths).filter((p) => !p.includes("$*"));
      const plen = paths.length;
      let ii = 0;
      for (; ii < plen; ++ii) {
        const p = paths[ii];
        if (p === "_id") {
          if (skipId) {
            continue;
          }
          if (obj && "_id" in obj) {
            continue;
          }
        }
        const path = this.$__schema.paths[p].splitPath();
        const len = path.length;
        const last = len - 1;
        let curPath = "";
        let doc_ = doc;
        let included = false;
        for (let i = 0; i < len; ++i) {
          const piece = path[i];
          curPath += (!curPath.length ? "" : ".") + piece;
          if (exclude === true) {
            if (curPath in fields) {
              break;
            }
          } else if (exclude === false && fields && !included) {
            if (curPath in fields) {
              included = true;
            } else if (!hasIncludedChildren[curPath]) {
              break;
            }
          }
          if (i < last) {
            doc_ = doc_[piece] || (doc_[piece] = {});
          }
        }
      }
      this._doc = doc;
    };
    Document2.prototype.toBSON = function() {
      return this.toObject(internalToObjectOptions);
    };
    Document2.prototype.init = function(doc, opts, fn) {
      if (typeof opts === "function") {
        fn = opts;
        opts = null;
      }
      this.$__init(doc, opts);
      if (fn) {
        fn(null, this);
      }
      return this;
    };
    Document2.prototype.$__init = function(doc, opts) {
      this.isNew = false;
      this.$init = true;
      opts = opts || {};
      if (doc._id != null && opts.populated && opts.populated.length) {
        const id = String(doc._id);
        for (const item of opts.populated) {
          if (item.isVirtual) {
            this.populated(item.path, utils2.getValue(item.path, doc), item);
          } else {
            this.populated(item.path, item._docs[id], item);
          }
          if (item._childDocs == null) {
            continue;
          }
          for (const child of item._childDocs) {
            if (child == null || child.$__ == null) {
              continue;
            }
            child.$__.parent = this;
          }
          item._childDocs = [];
        }
      }
      init(this, doc, this._doc, opts);
      markArraySubdocsPopulated(this, opts.populated);
      this.emit("init", this);
      this.constructor.emit("init", this);
      this.$__._id = this._id;
      return this;
    };
    function markArraySubdocsPopulated(doc, populated) {
      if (doc._id == null || populated == null || populated.length === 0) {
        return;
      }
      const id = String(doc._id);
      for (const item of populated) {
        if (item.isVirtual) {
          continue;
        }
        const path = item.path;
        const pieces = path.split(".");
        for (let i = 0; i < pieces.length - 1; ++i) {
          const subpath = pieces.slice(0, i + 1).join(".");
          const rest = pieces.slice(i + 1).join(".");
          const val = doc.get(subpath);
          if (val == null) {
            continue;
          }
          if (val.isMongooseDocumentArray) {
            for (let j = 0; j < val.length; ++j) {
              val[j].populated(rest, item._docs[id] == null ? [] : item._docs[id][j], item);
            }
            break;
          }
        }
      }
    }
    function init(self2, obj, doc, opts, prefix) {
      prefix = prefix || "";
      const keys = Object.keys(obj);
      const len = keys.length;
      let schema;
      let path;
      let i;
      let index = 0;
      while (index < len) {
        _init(index++);
      }
      function _init(index2) {
        i = keys[index2];
        path = prefix + i;
        schema = self2.$__schema.path(path);
        if (self2.$__schema.$isRootDiscriminator && !self2.$__isSelected(path)) {
          return;
        }
        if (!schema && utils2.isPOJO(obj[i])) {
          if (!doc[i]) {
            doc[i] = {};
          }
          init(self2, obj[i], doc[i], opts, path + ".");
        } else if (!schema) {
          doc[i] = obj[i];
        } else {
          if (obj[i] === null) {
            doc[i] = schema._castNullish(null);
          } else if (obj[i] !== void 0) {
            const intCache = obj[i].$__ || {};
            const wasPopulated = intCache.wasPopulated || null;
            if (schema && !wasPopulated) {
              try {
                doc[i] = schema.cast(obj[i], self2, true);
              } catch (e) {
                self2.invalidate(e.path, new ValidatorError({
                  path: e.path,
                  message: e.message,
                  type: "cast",
                  value: e.value,
                  reason: e
                }));
              }
            } else {
              doc[i] = obj[i];
            }
          }
          if (!self2.isModified(path)) {
            self2.$__.activePaths.init(path);
          }
        }
      }
    }
    Document2.prototype.update = function update() {
      const args = utils2.args(arguments);
      args.unshift({ _id: this._id });
      const query = this.constructor.update.apply(this.constructor, args);
      if (this.$session() != null) {
        if (!("session" in query.options)) {
          query.options.session = this.$session();
        }
      }
      return query;
    };
    Document2.prototype.updateOne = function updateOne(doc, options, callback) {
      const query = this.constructor.updateOne({ _id: this._id }, doc, options);
      query.pre((cb) => {
        this.constructor._middleware.execPre("updateOne", this, [this], cb);
      });
      query.post((cb) => {
        this.constructor._middleware.execPost("updateOne", this, [this], {}, cb);
      });
      if (this.$session() != null) {
        if (!("session" in query.options)) {
          query.options.session = this.$session();
        }
      }
      if (callback != null) {
        return query.exec(callback);
      }
      return query;
    };
    Document2.prototype.replaceOne = function replaceOne() {
      const args = utils2.args(arguments);
      args.unshift({ _id: this._id });
      return this.constructor.replaceOne.apply(this.constructor, args);
    };
    Document2.prototype.$session = function $session(session) {
      if (arguments.length === 0) {
        if (this.$__.session != null && this.$__.session.hasEnded) {
          this.$__.session = null;
          return null;
        }
        return this.$__.session;
      }
      if (session != null && session.hasEnded) {
        throw new MongooseError("Cannot set a document's session to a session that has ended. Make sure you haven't called `endSession()` on the session you are passing to `$session()`.");
      }
      this.$__.session = session;
      if (!this.ownerDocument) {
        const subdocs = this.$getAllSubdocs();
        for (const child of subdocs) {
          child.$session(session);
        }
      }
      return session;
    };
    Document2.prototype.overwrite = function overwrite(obj) {
      const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));
      for (const key of keys) {
        if (key === "_id") {
          continue;
        }
        if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {
          continue;
        }
        if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {
          continue;
        }
        this.$set(key, obj[key]);
      }
      return this;
    };
    Document2.prototype.$set = function $set(path, val, type, options) {
      if (utils2.isPOJO(type)) {
        options = type;
        type = void 0;
      }
      options = options || {};
      const merge = options.merge;
      const adhoc = type && type !== true;
      const constructing = type === true;
      const typeKey = this.$__schema.options.typeKey;
      let adhocs;
      let keys;
      let i = 0;
      let pathtype;
      let key;
      let prefix;
      const strict = "strict" in options ? options.strict : this.$__.strictMode;
      if (adhoc) {
        adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
        adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);
      }
      if (path == null) {
        const _ = path;
        path = val;
        val = _;
      } else if (typeof path !== "string") {
        if (path instanceof Document2) {
          if (path.$__isNested) {
            path = path.toObject();
          } else {
            path = path._doc;
          }
        }
        if (path == null) {
          const _ = path;
          path = val;
          val = _;
        }
        prefix = val ? val + "." : "";
        keys = Object.keys(path);
        const len = keys.length;
        const _skipMinimizeTopLevel = get(options, "_skipMinimizeTopLevel", false);
        if (len === 0 && _skipMinimizeTopLevel) {
          delete options._skipMinimizeTopLevel;
          if (val) {
            this.$set(val, {});
          }
          return this;
        }
        for (let i2 = 0; i2 < len; ++i2) {
          key = keys[i2];
          const pathName = prefix + key;
          pathtype = this.$__schema.pathType(pathName);
          if (type === true && !prefix && path[key] != null && pathtype === "nested" && this._doc[key] != null && Object.keys(this._doc[key]).length === 0) {
            delete this._doc[key];
            options = Object.assign({}, options, { _skipMinimizeTopLevel: true });
          } else {
            options = Object.assign({}, options, { _skipMinimizeTopLevel: false });
          }
          const someCondition = typeof path[key] === "object" && !utils2.isNativeObject(path[key]) && !utils2.isMongooseType(path[key]) && path[key] != null && pathtype !== "virtual" && pathtype !== "real" && pathtype !== "adhocOrUndefined" && !(this.$__path(pathName) instanceof MixedSchema) && !(this.$__schema.paths[pathName] && this.$__schema.paths[pathName].options && this.$__schema.paths[pathName].options.ref);
          if (someCondition) {
            this.$__.$setCalled.add(prefix + key);
            this.$set(path[key], prefix + key, constructing, options);
          } else if (strict) {
            if (constructing && path[key] === void 0 && this.get(pathName) !== void 0) {
              continue;
            }
            if (pathtype === "adhocOrUndefined") {
              pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
            }
            if (pathtype === "real" || pathtype === "virtual") {
              let p = path[key];
              if (this.$__schema.paths[pathName] && this.$__schema.paths[pathName].$isSingleNested && path[key] instanceof Document2) {
                p = p.toObject({ virtuals: false, transform: false });
              }
              this.$set(prefix + key, p, constructing, options);
            } else if (pathtype === "nested" && path[key] instanceof Document2) {
              this.$set(prefix + key, path[key].toObject({ transform: false }), constructing, options);
            } else if (strict === "throw") {
              if (pathtype === "nested") {
                throw new ObjectExpectedError(key, path[key]);
              } else {
                throw new StrictModeError(key);
              }
            }
          } else if (path[key] !== void 0) {
            this.$set(prefix + key, path[key], constructing, options);
          }
        }
        return this;
      } else {
        this.$__.$setCalled.add(path);
      }
      let pathType = this.$__schema.pathType(path);
      if (pathType === "adhocOrUndefined") {
        pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });
      }
      val = handleSpreadDoc(val);
      if (pathType === "nested" && val) {
        if (typeof val === "object" && val != null) {
          const hasPriorVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
          if (this.$__.savedState != null && !this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
            const priorVal2 = this.$__getValue(path);
            this.$__.savedState[path] = priorVal2;
            const keys3 = Object.keys(priorVal2 || {});
            for (const key2 of keys3) {
              this.$__.savedState[path + "." + key2] = priorVal2[key2];
            }
          }
          if (!merge) {
            this.$__setValue(path, null);
            cleanModifiedSubpaths(this, path);
          } else {
            return this.$set(val, path, constructing);
          }
          const keys2 = Object.keys(val);
          this.$__setValue(path, {});
          for (const key2 of keys2) {
            this.$set(path + "." + key2, val[key2], constructing);
          }
          if (hasPriorVal && utils2.deepEqual(this.$__.savedState[path], val)) {
            this.unmarkModified(path);
          } else {
            this.markModified(path);
          }
          cleanModifiedSubpaths(this, path, { skipDocArrays: true });
          return this;
        }
        this.invalidate(path, new MongooseError.CastError("Object", val, path));
        return this;
      }
      let schema;
      const parts = path.indexOf(".") === -1 ? [path] : path.split(".");
      if (typeof this.$__schema.aliases[parts[0]] == "string") {
        parts[0] = this.$__schema.aliases[parts[0]];
      }
      if (pathType === "adhocOrUndefined" && strict) {
        let mixed;
        for (i = 0; i < parts.length; ++i) {
          const subpath = parts.slice(0, i + 1).join(".");
          if (i + 1 < parts.length && this.$__schema.pathType(subpath) === "virtual") {
            mpath.set(path, val, this);
            return this;
          }
          schema = this.$__schema.path(subpath);
          if (schema == null) {
            continue;
          }
          if (schema instanceof MixedSchema) {
            mixed = true;
            break;
          }
        }
        if (schema == null) {
          schema = getEmbeddedDiscriminatorPath(this, path);
        }
        if (!mixed && !schema) {
          if (strict === "throw") {
            throw new StrictModeError(path);
          }
          return this;
        }
      } else if (pathType === "virtual") {
        schema = this.$__schema.virtualpath(path);
        schema.applySetters(val, this);
        return this;
      } else {
        schema = this.$__path(path);
      }
      let cur = this._doc;
      let curPath = "";
      for (i = 0; i < parts.length - 1; ++i) {
        cur = cur[parts[i]];
        curPath += (curPath.length > 0 ? "." : "") + parts[i];
        if (!cur) {
          this.$set(curPath, {});
          if (!this.$__isSelected(curPath)) {
            this.unmarkModified(curPath);
          }
          cur = this.$__getValue(curPath);
        }
      }
      let pathToMark;
      if (parts.length <= 1) {
        pathToMark = path;
      } else {
        for (i = 0; i < parts.length; ++i) {
          const subpath = parts.slice(0, i + 1).join(".");
          if (this.get(subpath, null, { getters: false }) === null) {
            pathToMark = subpath;
            break;
          }
        }
        if (!pathToMark) {
          pathToMark = path;
        }
      }
      const priorVal = (() => {
        if (this.$__.$options.priorDoc != null) {
          return this.$__.$options.priorDoc.$__getValue(path);
        }
        if (constructing) {
          return void 0;
        }
        return this.$__getValue(path);
      })();
      if (!schema) {
        this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
        return this;
      }
      if (schema.$isSingleNested || schema.$isMongooseArray) {
        _markValidSubpaths(this, path);
      }
      if (schema.$isSingleNested && val != null && merge) {
        if (val instanceof Document2) {
          val = val.toObject({ virtuals: false, transform: false });
        }
        const keys2 = Object.keys(val);
        for (const key2 of keys2) {
          this.$set(path + "." + key2, val[key2], constructing, options);
        }
        return this;
      }
      let shouldSet = true;
      try {
        const refMatches = (() => {
          if (schema.options == null) {
            return false;
          }
          if (!(val instanceof Document2)) {
            return false;
          }
          const model2 = val.constructor;
          const ref = schema.options.ref;
          if (ref != null && (ref === model2.modelName || ref === model2.baseModelName)) {
            return true;
          }
          const refPath = schema.options.refPath;
          if (refPath == null) {
            return false;
          }
          const modelName = val.get(refPath);
          return modelName === model2.modelName || modelName === model2.baseModelName;
        })();
        let didPopulate = false;
        if (refMatches && val instanceof Document2) {
          this.populated(path, val._id, { [populateModelSymbol]: val.constructor });
          val.$__.wasPopulated = true;
          didPopulate = true;
        }
        let popOpts;
        if (schema.options && Array.isArray(schema.options[typeKey]) && schema.options[typeKey].length && schema.options[typeKey][0].ref && _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {
          popOpts = { [populateModelSymbol]: val[0].constructor };
          this.populated(path, val.map(function(v) {
            return v._id;
          }), popOpts);
          for (const doc of val) {
            doc.$__.wasPopulated = true;
          }
          didPopulate = true;
        }
        if (this.$__schema.singleNestedPaths[path] == null) {
          val = schema.applySetters(val, this, false, priorVal);
        }
        if (schema.$isMongooseDocumentArray && Array.isArray(val) && val.length > 0 && val[0] != null && val[0].$__ != null && val[0].$__.populated != null) {
          const populatedPaths = Object.keys(val[0].$__.populated);
          for (const populatedPath of populatedPaths) {
            this.populated(path + "." + populatedPath, val.map((v) => v.populated(populatedPath)), val[0].$__.populated[populatedPath].options);
          }
          didPopulate = true;
        }
        if (!didPopulate && this.$__.populated) {
          if (Array.isArray(val) && this.$__.populated[path]) {
            for (let i2 = 0; i2 < val.length; ++i2) {
              if (val[i2] instanceof Document2) {
                val[i2] = val[i2]._id;
              }
            }
          }
          delete this.$__.populated[path];
        }
        if (schema.$isSingleNested && val != null) {
          _checkImmutableSubpaths(val, schema, priorVal);
        }
        this.$markValid(path);
      } catch (e) {
        if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
          this.invalidate(path, e);
        } else if (e instanceof MongooseError.CastError) {
          this.invalidate(e.path, e);
          if (e.$originalErrorPath) {
            this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));
          }
        } else {
          this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e));
        }
        shouldSet = false;
      }
      if (shouldSet) {
        this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
        if (this.$__.savedState != null) {
          if (!this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
            this.$__.savedState[path] = priorVal;
          } else if (this.$__.savedState.hasOwnProperty(path) && utils2.deepEqual(val, this.$__.savedState[path])) {
            this.unmarkModified(path);
          }
        }
      }
      if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
        cleanModifiedSubpaths(this, path);
      }
      return this;
    };
    function _isManuallyPopulatedArray(val, ref) {
      if (!Array.isArray(val)) {
        return false;
      }
      if (val.length === 0) {
        return false;
      }
      for (const el of val) {
        if (!(el instanceof Document2)) {
          return false;
        }
        const modelName = el.constructor.modelName;
        if (modelName == null) {
          return false;
        }
        if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {
          return false;
        }
      }
      return true;
    }
    Document2.prototype.set = Document2.prototype.$set;
    Document2.prototype.$__shouldModify = function(pathToMark, path, constructing, parts, schema, val, priorVal) {
      if (this.isNew) {
        return true;
      }
      if (this.$__schema.singleNestedPaths[path] != null) {
        return false;
      }
      if (val === void 0 && !this.$__isSelected(path)) {
        return true;
      }
      if (val === void 0 && path in this.$__.activePaths.states.default) {
        return false;
      }
      if (this.populated(path) && val instanceof Document2 && deepEqual(val._id, priorVal)) {
        return false;
      }
      if (!deepEqual(val, priorVal || utils2.getValue(path, this))) {
        return true;
      }
      if (!constructing && val !== null && val !== void 0 && path in this.$__.activePaths.states.default && deepEqual(val, schema.getDefault(this, constructing))) {
        return true;
      }
      return false;
    };
    Document2.prototype.$__set = function(pathToMark, path, constructing, parts, schema, val, priorVal) {
      Embedded = Embedded || require_embedded();
      const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts, schema, val, priorVal);
      const _this = this;
      if (shouldModify) {
        this.markModified(pathToMark);
        MongooseArray || (MongooseArray = require_array());
        if (val && val.isMongooseArray) {
          val._registerAtomic("$set", val);
          if (val.isMongooseDocumentArray) {
            val.forEach(function(item) {
              item && item.__parentArray && (item.__parentArray = val);
            });
          }
          this.$__.activePaths.forEach(function(modifiedPath) {
            if (modifiedPath.startsWith(path + ".")) {
              _this.$__.activePaths.ignore(modifiedPath);
            }
          });
        }
      }
      let obj = this._doc;
      let i = 0;
      const l = parts.length;
      let cur = "";
      for (; i < l; i++) {
        const next = i + 1;
        const last = next === l;
        cur += cur ? "." + parts[i] : parts[i];
        if (specialProperties.has(parts[i])) {
          return;
        }
        if (last) {
          if (obj instanceof Map) {
            obj.set(parts[i], val);
          } else {
            obj[parts[i]] = val;
          }
        } else {
          if (utils2.isPOJO(obj[parts[i]])) {
            obj = obj[parts[i]];
          } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {
            obj = obj[parts[i]];
          } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {
            obj = obj[parts[i]];
          } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {
            obj = obj[parts[i]];
          } else {
            obj[parts[i]] = obj[parts[i]] || {};
            obj = obj[parts[i]];
          }
        }
      }
    };
    Document2.prototype.$__getValue = function(path) {
      return utils2.getValue(path, this._doc);
    };
    Document2.prototype.$__setValue = function(path, val) {
      utils2.setValue(path, val, this._doc);
      return this;
    };
    Document2.prototype.get = function(path, type, options) {
      let adhoc;
      options = options || {};
      if (type) {
        adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);
      }
      let schema = this.$__path(path);
      if (schema == null) {
        schema = this.$__schema.virtualpath(path);
      }
      if (schema instanceof MixedSchema) {
        const virtual = this.$__schema.virtualpath(path);
        if (virtual != null) {
          schema = virtual;
        }
      }
      const pieces = path.indexOf(".") === -1 ? [path] : path.split(".");
      let obj = this._doc;
      if (schema instanceof VirtualType) {
        return schema.applyGetters(void 0, this);
      }
      if (typeof this.$__schema.aliases[pieces[0]] == "string") {
        pieces[0] = this.$__schema.aliases[pieces[0]];
      }
      for (let i = 0, l = pieces.length; i < l; i++) {
        if (obj && obj._doc) {
          obj = obj._doc;
        }
        if (obj == null) {
          obj = void 0;
        } else if (obj instanceof Map) {
          obj = obj.get(pieces[i], { getters: false });
        } else if (i === l - 1) {
          obj = utils2.getValue(pieces[i], obj);
        } else {
          obj = obj[pieces[i]];
        }
      }
      if (adhoc) {
        obj = adhoc.cast(obj);
      }
      if (schema != null && options.getters !== false) {
        obj = schema.applyGetters(obj, this);
      } else if (this.$__schema.nested[path] && options.virtuals) {
        return applyVirtuals(this, utils2.clone(obj) || {}, { path });
      }
      return obj;
    };
    Document2.prototype[getSymbol] = Document2.prototype.get;
    Document2.prototype.$__path = function(path) {
      const adhocs = this.$__.adhocPaths;
      const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;
      if (adhocType) {
        return adhocType;
      }
      return this.$__schema.path(path);
    };
    Document2.prototype.markModified = function(path, scope) {
      this.$__.activePaths.modify(path);
      if (scope != null && !this.ownerDocument) {
        this.$__.pathsToScopes[path] = scope;
      }
    };
    Document2.prototype.unmarkModified = function(path) {
      this.$__.activePaths.init(path);
      delete this.$__.pathsToScopes[path];
    };
    Document2.prototype.$ignore = function(path) {
      this.$__.activePaths.ignore(path);
    };
    Document2.prototype.directModifiedPaths = function() {
      return Object.keys(this.$__.activePaths.states.modify);
    };
    Document2.prototype.$isEmpty = function(path) {
      const isEmptyOptions = {
        minimize: true,
        virtuals: false,
        getters: false,
        transform: false
      };
      if (arguments.length > 0) {
        const v = this.get(path);
        if (v == null) {
          return true;
        }
        if (typeof v !== "object") {
          return false;
        }
        if (utils2.isPOJO(v)) {
          return _isEmpty(v);
        }
        return Object.keys(v.toObject(isEmptyOptions)).length === 0;
      }
      return Object.keys(this.toObject(isEmptyOptions)).length === 0;
    };
    function _isEmpty(v) {
      if (v == null) {
        return true;
      }
      if (typeof v !== "object" || Array.isArray(v)) {
        return false;
      }
      for (const key of Object.keys(v)) {
        if (!_isEmpty(v[key])) {
          return false;
        }
      }
      return true;
    }
    Document2.prototype.modifiedPaths = function(options) {
      options = options || {};
      const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
      const _this = this;
      return directModifiedPaths.reduce(function(list, path) {
        const parts = path.split(".");
        list = list.concat(parts.reduce(function(chains, part, i) {
          return chains.concat(parts.slice(0, i).concat(part).join("."));
        }, []).filter(function(chain) {
          return list.indexOf(chain) === -1;
        }));
        if (!options.includeChildren) {
          return list;
        }
        let cur = _this.get(path);
        if (cur != null && typeof cur === "object") {
          if (cur._doc) {
            cur = cur._doc;
          }
          if (Array.isArray(cur)) {
            const len = cur.length;
            for (let i = 0; i < len; ++i) {
              if (list.indexOf(path + "." + i) === -1) {
                list.push(path + "." + i);
                if (cur[i] != null && cur[i].$__) {
                  const modified = cur[i].modifiedPaths();
                  for (const childPath of modified) {
                    list.push(path + "." + i + "." + childPath);
                  }
                }
              }
            }
          } else {
            Object.keys(cur).filter(function(key) {
              return list.indexOf(path + "." + key) === -1;
            }).forEach(function(key) {
              list.push(path + "." + key);
            });
          }
        }
        return list;
      }, []);
    };
    Document2.prototype[documentModifiedPaths] = Document2.prototype.modifiedPaths;
    Document2.prototype.isModified = function(paths, modifiedPaths) {
      if (paths) {
        if (!Array.isArray(paths)) {
          paths = paths.split(" ");
        }
        const modified = modifiedPaths || this[documentModifiedPaths]();
        const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
        const isModifiedChild = paths.some(function(path) {
          return !!~modified.indexOf(path);
        });
        return isModifiedChild || paths.some(function(path) {
          return directModifiedPaths.some(function(mod) {
            return mod === path || path.startsWith(mod + ".");
          });
        });
      }
      return this.$__.activePaths.some("modify");
    };
    Document2.prototype[documentIsModified] = Document2.prototype.isModified;
    Document2.prototype.$isDefault = function(path) {
      if (path == null) {
        return this.$__.activePaths.some("default");
      }
      if (typeof path === "string" && path.indexOf(" ") === -1) {
        return this.$__.activePaths.states.default.hasOwnProperty(path);
      }
      let paths = path;
      if (!Array.isArray(paths)) {
        paths = paths.split(" ");
      }
      return paths.some((path2) => this.$__.activePaths.states.default.hasOwnProperty(path2));
    };
    Document2.prototype.$isDeleted = function(val) {
      if (arguments.length === 0) {
        return !!this.$__.isDeleted;
      }
      this.$__.isDeleted = !!val;
      return this;
    };
    Document2.prototype.isDirectModified = function(path) {
      if (path == null) {
        return this.$__.activePaths.some("modify");
      }
      if (typeof path === "string" && path.indexOf(" ") === -1) {
        return this.$__.activePaths.states.modify.hasOwnProperty(path);
      }
      let paths = path;
      if (!Array.isArray(paths)) {
        paths = paths.split(" ");
      }
      return paths.some((path2) => this.$__.activePaths.states.modify.hasOwnProperty(path2));
    };
    Document2.prototype.isInit = function(path) {
      if (path == null) {
        return this.$__.activePaths.some("init");
      }
      if (typeof path === "string" && path.indexOf(" ") === -1) {
        return this.$__.activePaths.states.init.hasOwnProperty(path);
      }
      let paths = path;
      if (!Array.isArray(paths)) {
        paths = paths.split(" ");
      }
      return paths.some((path2) => this.$__.activePaths.states.init.hasOwnProperty(path2));
    };
    Document2.prototype.isSelected = function isSelected(path) {
      if (this.$__.selected == null) {
        return true;
      }
      if (path === "_id") {
        return this.$__.selected._id !== 0;
      }
      if (path.indexOf(" ") !== -1) {
        path = path.split(" ");
      }
      if (Array.isArray(path)) {
        return path.some((p) => this.$__isSelected(p));
      }
      const paths = Object.keys(this.$__.selected);
      let inclusive = null;
      if (paths.length === 1 && paths[0] === "_id") {
        return this.$__.selected._id === 0;
      }
      for (const cur of paths) {
        if (cur === "_id") {
          continue;
        }
        if (!isDefiningProjection(this.$__.selected[cur])) {
          continue;
        }
        inclusive = !!this.$__.selected[cur];
        break;
      }
      if (inclusive === null) {
        return true;
      }
      if (path in this.$__.selected) {
        return inclusive;
      }
      const pathDot = path + ".";
      for (const cur of paths) {
        if (cur === "_id") {
          continue;
        }
        if (cur.startsWith(pathDot)) {
          return inclusive || cur !== pathDot;
        }
        if (pathDot.startsWith(cur + ".")) {
          return inclusive;
        }
      }
      return !inclusive;
    };
    Document2.prototype.$__isSelected = Document2.prototype.isSelected;
    Document2.prototype.isDirectSelected = function isDirectSelected(path) {
      if (this.$__.selected == null) {
        return true;
      }
      if (path === "_id") {
        return this.$__.selected._id !== 0;
      }
      if (path.indexOf(" ") !== -1) {
        path = path.split(" ");
      }
      if (Array.isArray(path)) {
        return path.some((p) => this.isDirectSelected(p));
      }
      const paths = Object.keys(this.$__.selected);
      let inclusive = null;
      if (paths.length === 1 && paths[0] === "_id") {
        return this.$__.selected._id === 0;
      }
      for (const cur of paths) {
        if (cur === "_id") {
          continue;
        }
        if (!isDefiningProjection(this.$__.selected[cur])) {
          continue;
        }
        inclusive = !!this.$__.selected[cur];
        break;
      }
      if (inclusive === null) {
        return true;
      }
      if (this.$__.selected.hasOwnProperty(path)) {
        return inclusive;
      }
      return !inclusive;
    };
    Document2.prototype.validate = function(pathsToValidate, options, callback) {
      let parallelValidate;
      this.$op = "validate";
      if (this.ownerDocument != null) {
      } else if (this.$__.validating) {
        parallelValidate = new ParallelValidateError(this, {
          parentStack: options && options.parentStack,
          conflictStack: this.$__.validating.stack
        });
      } else {
        this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });
      }
      if (arguments.length === 1) {
        if (typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
          options = arguments[0];
          callback = null;
          pathsToValidate = null;
        } else if (typeof arguments[0] === "function") {
          callback = arguments[0];
          options = null;
          pathsToValidate = null;
        }
      } else if (typeof pathsToValidate === "function") {
        callback = pathsToValidate;
        options = null;
        pathsToValidate = null;
      } else if (typeof options === "function") {
        callback = options;
        options = pathsToValidate;
        pathsToValidate = null;
      }
      if (options && typeof options.pathsToSkip === "string") {
        const isOnePathOnly = options.pathsToSkip.indexOf(" ") === -1;
        options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(" ");
      }
      return promiseOrCallback(callback, (cb) => {
        if (parallelValidate != null) {
          return cb(parallelValidate);
        }
        this.$__validate(pathsToValidate, options, (error) => {
          this.$op = null;
          cb(error);
        });
      }, this.constructor.events);
    };
    function _evaluateRequiredFunctions(doc) {
      Object.keys(doc.$__.activePaths.states.require).forEach((path) => {
        const p = doc.$__schema.path(path);
        if (p != null && typeof p.originalRequiredValue === "function") {
          doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);
        }
      });
    }
    function _getPathsToValidate(doc) {
      const skipSchemaValidators = {};
      _evaluateRequiredFunctions(doc);
      let paths = new Set(Object.keys(doc.$__.activePaths.states.require).filter(function(path) {
        if (!doc.$__isSelected(path) && !doc.isModified(path)) {
          return false;
        }
        if (path in doc.$__.cachedRequired) {
          return doc.$__.cachedRequired[path];
        }
        return true;
      }));
      Object.keys(doc.$__.activePaths.states.init).forEach(addToPaths);
      Object.keys(doc.$__.activePaths.states.modify).forEach(addToPaths);
      Object.keys(doc.$__.activePaths.states.default).forEach(addToPaths);
      function addToPaths(p) {
        paths.add(p);
      }
      const subdocs = doc.$getAllSubdocs();
      const modifiedPaths = doc.modifiedPaths();
      for (const subdoc of subdocs) {
        if (subdoc.$basePath) {
          for (const p of paths) {
            if (p === null || p.startsWith(subdoc.$basePath + ".")) {
              paths.delete(p);
            }
          }
          if (doc.isModified(subdoc.$basePath, modifiedPaths) && !doc.isDirectModified(subdoc.$basePath) && !doc.$isDefault(subdoc.$basePath)) {
            paths.add(subdoc.$basePath);
            skipSchemaValidators[subdoc.$basePath] = true;
          }
        }
      }
      for (const path of paths) {
        const _pathType = doc.$__schema.path(path);
        if (!_pathType || !_pathType.$isMongooseArray || _pathType.$isMongooseDocumentArray && !get(_pathType, "schemaOptions.required")) {
          continue;
        }
        const val = doc.$__getValue(path);
        _pushNestedArrayPaths(val, paths, path);
      }
      function _pushNestedArrayPaths(val, paths2, path) {
        if (val != null) {
          const numElements = val.length;
          for (let j = 0; j < numElements; ++j) {
            if (Array.isArray(val[j])) {
              _pushNestedArrayPaths(val[j], paths2, path + "." + j);
            } else {
              paths2.add(path + "." + j);
            }
          }
        }
      }
      const flattenOptions = { skipArrays: true };
      for (const pathToCheck of paths) {
        if (doc.$__schema.nested[pathToCheck]) {
          let _v = doc.$__getValue(pathToCheck);
          if (isMongooseObject(_v)) {
            _v = _v.toObject({ transform: false });
          }
          const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);
          Object.keys(flat).forEach(addToPaths);
        }
      }
      for (const path of paths) {
        if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {
          paths.delete(path);
          continue;
        }
        const _pathType = doc.$__schema.path(path);
        if (!_pathType || !_pathType.$isSchemaMap) {
          continue;
        }
        const val = doc.$__getValue(path);
        if (val == null) {
          continue;
        }
        for (const key of val.keys()) {
          paths.add(path + "." + key);
        }
      }
      paths = Array.from(paths);
      return [paths, skipSchemaValidators];
    }
    Document2.prototype.$__validate = function(pathsToValidate, options, callback) {
      if (typeof pathsToValidate === "function") {
        callback = pathsToValidate;
        options = null;
        pathsToValidate = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
      const pathsToSkip = get(options, "pathsToSkip", null);
      let shouldValidateModifiedOnly;
      if (hasValidateModifiedOnlyOption) {
        shouldValidateModifiedOnly = !!options.validateModifiedOnly;
      } else {
        shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
      }
      const _this = this;
      const _complete = () => {
        let validationError = this.$__.validationError;
        this.$__.validationError = void 0;
        if (shouldValidateModifiedOnly && validationError != null) {
          const errors = Object.keys(validationError.errors);
          for (const errPath of errors) {
            if (!this.isModified(errPath)) {
              delete validationError.errors[errPath];
            }
          }
          if (Object.keys(validationError.errors).length === 0) {
            validationError = void 0;
          }
        }
        this.$__.cachedRequired = {};
        this.emit("validate", _this);
        this.constructor.emit("validate", _this);
        this.$__.validating = null;
        if (validationError) {
          for (const key in validationError.errors) {
            if (!this[documentArrayParent] && validationError.errors[key] instanceof MongooseError.CastError) {
              this.invalidate(key, validationError.errors[key]);
            }
          }
          return validationError;
        }
      };
      const pathDetails = _getPathsToValidate(this);
      let paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path) => this.isModified(path)) : pathDetails[0];
      const skipSchemaValidators = pathDetails[1];
      if (typeof pathsToValidate === "string") {
        pathsToValidate = pathsToValidate.split(" ");
      }
      if (Array.isArray(pathsToValidate)) {
        paths = _handlePathsToValidate(paths, pathsToValidate);
      } else if (pathsToSkip) {
        paths = _handlePathsToSkip(paths, pathsToSkip);
      }
      if (paths.length === 0) {
        return immediate(function() {
          const error = _complete();
          if (error) {
            return _this.$__schema.s.hooks.execPost("validate:error", _this, [_this], { error }, function(error2) {
              callback(error2);
            });
          }
          callback(null, _this);
        });
      }
      const validated = {};
      let total = 0;
      for (const path of paths) {
        validatePath(path);
      }
      function validatePath(path) {
        if (path == null || validated[path]) {
          return;
        }
        validated[path] = true;
        total++;
        immediate(function() {
          const schemaType = _this.$__schema.path(path);
          if (!schemaType) {
            return --total || complete();
          }
          if (!_this.$isValid(path)) {
            --total || complete();
            return;
          }
          if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {
            return --total || complete();
          }
          let val = _this.$__getValue(path);
          let pop;
          if (val == null && (pop = _this.populated(path))) {
            val = pop;
          }
          const scope = path in _this.$__.pathsToScopes ? _this.$__.pathsToScopes[path] : _this;
          const doValidateOptions = {
            skipSchemaValidators: skipSchemaValidators[path],
            path,
            validateModifiedOnly: shouldValidateModifiedOnly
          };
          schemaType.doValidate(val, function(err) {
            if (err && (!schemaType.$isMongooseDocumentArray || err.$isArrayValidatorError)) {
              if (schemaType.$isSingleNested && err instanceof ValidationError && schemaType.schema.options.storeSubdocValidationError === false) {
                return --total || complete();
              }
              _this.invalidate(path, err, void 0, true);
            }
            --total || complete();
          }, scope, doValidateOptions);
        });
      }
      function complete() {
        const error = _complete();
        if (error) {
          return _this.$__schema.s.hooks.execPost("validate:error", _this, [_this], { error }, function(error2) {
            callback(error2);
          });
        }
        callback(null, _this);
      }
    };
    function _handlePathsToValidate(paths, pathsToValidate) {
      const _pathsToValidate = new Set(pathsToValidate);
      const parentPaths = new Map([]);
      for (const path of pathsToValidate) {
        if (path.indexOf(".") === -1) {
          continue;
        }
        const pieces = path.split(".");
        let cur = pieces[0];
        for (let i = 1; i < pieces.length; ++i) {
          parentPaths.set(cur, path);
          cur = cur + "." + pieces[i];
        }
      }
      const ret2 = [];
      for (const path of paths) {
        if (_pathsToValidate.has(path)) {
          ret2.push(path);
        } else if (parentPaths.has(path)) {
          ret2.push(parentPaths.get(path));
        }
      }
      return ret2;
    }
    function _handlePathsToSkip(paths, pathsToSkip) {
      pathsToSkip = new Set(pathsToSkip);
      paths = paths.filter((p) => !pathsToSkip.has(p));
      return paths;
    }
    Document2.prototype.validateSync = function(pathsToValidate, options) {
      const _this = this;
      if (arguments.length === 1 && typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
        options = arguments[0];
        pathsToValidate = null;
      }
      const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
      let shouldValidateModifiedOnly;
      if (hasValidateModifiedOnlyOption) {
        shouldValidateModifiedOnly = !!options.validateModifiedOnly;
      } else {
        shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
      }
      let pathsToSkip = options && options.pathsToSkip;
      if (typeof pathsToValidate === "string") {
        const isOnePathOnly = pathsToValidate.indexOf(" ") === -1;
        pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(" ");
      } else if (typeof pathsToSkip === "string" && pathsToSkip.indexOf(" ") !== -1) {
        pathsToSkip = pathsToSkip.split(" ");
      }
      const pathDetails = _getPathsToValidate(this);
      let paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path) => this.isModified(path)) : pathDetails[0];
      const skipSchemaValidators = pathDetails[1];
      if (Array.isArray(pathsToValidate)) {
        paths = _handlePathsToValidate(paths, pathsToValidate);
      } else if (Array.isArray(pathsToSkip)) {
        paths = _handlePathsToSkip(paths, pathsToSkip);
      }
      const validating = {};
      paths.forEach(function(path) {
        if (validating[path]) {
          return;
        }
        validating[path] = true;
        const p = _this.$__schema.path(path);
        if (!p) {
          return;
        }
        if (!_this.$isValid(path)) {
          return;
        }
        const val = _this.$__getValue(path);
        const err2 = p.doValidateSync(val, _this, {
          skipSchemaValidators: skipSchemaValidators[path],
          path,
          validateModifiedOnly: shouldValidateModifiedOnly
        });
        if (err2 && (!p.$isMongooseDocumentArray || err2.$isArrayValidatorError)) {
          if (p.$isSingleNested && err2 instanceof ValidationError && p.schema.options.storeSubdocValidationError === false) {
            return;
          }
          _this.invalidate(path, err2, void 0, true);
        }
      });
      const err = _this.$__.validationError;
      _this.$__.validationError = void 0;
      _this.emit("validate", _this);
      _this.constructor.emit("validate", _this);
      if (err) {
        for (const key in err.errors) {
          if (err.errors[key] instanceof MongooseError.CastError) {
            _this.invalidate(key, err.errors[key]);
          }
        }
      }
      return err;
    };
    Document2.prototype.invalidate = function(path, err, val, kind) {
      if (!this.$__.validationError) {
        this.$__.validationError = new ValidationError(this);
      }
      if (this.$__.validationError.errors[path]) {
        return;
      }
      if (!err || typeof err === "string") {
        err = new ValidatorError({
          path,
          message: err,
          type: kind || "user defined",
          value: val
        });
      }
      if (this.$__.validationError === err) {
        return this.$__.validationError;
      }
      this.$__.validationError.addError(path, err);
      return this.$__.validationError;
    };
    Document2.prototype.$markValid = function(path) {
      if (!this.$__.validationError || !this.$__.validationError.errors[path]) {
        return;
      }
      delete this.$__.validationError.errors[path];
      if (Object.keys(this.$__.validationError.errors).length === 0) {
        this.$__.validationError = null;
      }
    };
    function _markValidSubpaths(doc, path) {
      if (!doc.$__.validationError) {
        return;
      }
      const keys = Object.keys(doc.$__.validationError.errors);
      for (const key of keys) {
        if (key.startsWith(path + ".")) {
          delete doc.$__.validationError.errors[key];
        }
      }
      if (Object.keys(doc.$__.validationError.errors).length === 0) {
        doc.$__.validationError = null;
      }
    }
    function _checkImmutableSubpaths(subdoc, schematype, priorVal) {
      const schema = schematype.schema;
      if (schema == null) {
        return;
      }
      for (const key of Object.keys(schema.paths)) {
        const path = schema.paths[key];
        if (path.$immutableSetter == null) {
          continue;
        }
        const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);
        path.$immutableSetter.call(subdoc, oldVal);
      }
    }
    Document2.prototype.$isValid = function(path) {
      if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {
        return true;
      }
      if (path == null) {
        return false;
      }
      if (path.indexOf(" ") !== -1) {
        path = path.split(" ");
      }
      if (Array.isArray(path)) {
        return path.some((p) => this.$__.validationError.errors[p] == null);
      }
      return this.$__.validationError.errors[path] == null;
    };
    Document2.prototype.$__reset = function reset() {
      let _this = this;
      DocumentArray || (DocumentArray = require_documentarray());
      this.$__.activePaths.map("init", "modify", function(i) {
        return _this.$__getValue(i);
      }).filter(function(val) {
        return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
      }).forEach(function(array) {
        let i = array.length;
        while (i--) {
          const doc = array[i];
          if (!doc) {
            continue;
          }
          doc.$__reset();
        }
        _this.$__.activePaths.init(array.$path());
        array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];
        array[arrayAtomicsSymbol] = {};
      });
      this.$__.activePaths.map("init", "modify", function(i) {
        return _this.$__getValue(i);
      }).filter(function(val) {
        return val && val.$isSingleNested;
      }).forEach(function(doc) {
        doc.$__reset();
        if (doc.$__parent === _this) {
          _this.$__.activePaths.init(doc.$basePath);
        } else if (doc.$__parent != null && doc.$__parent.ownerDocument) {
          doc.$__parent.$__reset();
        }
      });
      this.$__dirty().forEach(function(dirt) {
        const type = dirt.value;
        if (type && type[arrayAtomicsSymbol]) {
          type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];
          type[arrayAtomicsSymbol] = {};
        }
      });
      this.$__.backup = {};
      this.$__.backup.activePaths = {
        modify: Object.assign({}, this.$__.activePaths.states.modify),
        default: Object.assign({}, this.$__.activePaths.states.default)
      };
      this.$__.backup.validationError = this.$__.validationError;
      this.$__.backup.errors = this.errors;
      this.$__.activePaths.clear("modify");
      this.$__.activePaths.clear("default");
      this.$__.validationError = void 0;
      this.errors = void 0;
      _this = this;
      this.$__schema.requiredPaths().forEach(function(path) {
        _this.$__.activePaths.require(path);
      });
      return this;
    };
    Document2.prototype.$__undoReset = function $__undoReset() {
      if (this.$__.backup == null || this.$__.backup.activePaths == null) {
        return;
      }
      this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;
      this.$__.activePaths.states.default = this.$__.backup.activePaths.default;
      this.$__.validationError = this.$__.backup.validationError;
      this.errors = this.$__.backup.errors;
      for (const dirt of this.$__dirty()) {
        const type = dirt.value;
        if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {
          type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];
        }
      }
      for (const subdoc of this.$getAllSubdocs()) {
        subdoc.$__undoReset();
      }
    };
    Document2.prototype.$__dirty = function() {
      const _this = this;
      let all = this.$__.activePaths.map("modify", function(path) {
        return {
          path,
          value: _this.$__getValue(path),
          schema: _this.$__path(path)
        };
      });
      all = all.concat(this.$__.activePaths.map("default", function(path) {
        if (path === "_id" || _this.$__getValue(path) == null) {
          return;
        }
        return {
          path,
          value: _this.$__getValue(path),
          schema: _this.$__path(path)
        };
      }));
      all.sort(function(a, b) {
        return a.path < b.path ? -1 : a.path > b.path ? 1 : 0;
      });
      const minimal = [];
      let lastPath;
      let top;
      all.forEach(function(item) {
        if (!item) {
          return;
        }
        if (lastPath == null || item.path.indexOf(lastPath) !== 0) {
          lastPath = item.path + ".";
          minimal.push(item);
          top = item;
        } else if (top != null && top.value != null && top.value[arrayAtomicsSymbol] != null && top.value.hasAtomics()) {
          top.value[arrayAtomicsSymbol] = {};
          top.value[arrayAtomicsSymbol].$set = top.value;
        }
      });
      top = lastPath = null;
      return minimal;
    };
    Document2.prototype.$__setSchema = function(schema) {
      schema.plugin(idGetter, { deduplicate: true });
      compile(schema.tree, this, void 0, schema.options);
      for (const key of Object.keys(schema.virtuals)) {
        schema.virtuals[key]._applyDefaultGetters();
      }
      if (schema.path("schema") == null) {
        this.schema = schema;
      }
      this.$__schema = schema;
      this[documentSchemaSymbol] = schema;
    };
    Document2.prototype.$__getArrayPathsToValidate = function() {
      DocumentArray || (DocumentArray = require_documentarray());
      return this.$__.activePaths.map("init", "modify", function(i) {
        return this.$__getValue(i);
      }.bind(this)).filter(function(val) {
        return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
      }).reduce(function(seed, array) {
        return seed.concat(array);
      }, []).filter(function(doc) {
        return doc;
      });
    };
    Document2.prototype.$getAllSubdocs = function $getAllSubdocs() {
      DocumentArray || (DocumentArray = require_documentarray());
      Embedded = Embedded || require_embedded();
      function docReducer(doc, seed, path) {
        let val = doc;
        let isNested = false;
        if (path) {
          if (doc instanceof Document2 && doc[documentSchemaSymbol].paths[path]) {
            val = doc._doc[path];
          } else if (doc instanceof Document2 && doc[documentSchemaSymbol].nested[path]) {
            val = doc._doc[path];
            isNested = true;
          } else {
            val = doc[path];
          }
        }
        if (val instanceof Embedded) {
          seed.push(val);
        } else if (val instanceof Map) {
          seed = Array.from(val.keys()).reduce(function(seed2, path2) {
            return docReducer(val.get(path2), seed2, null);
          }, seed);
        } else if (val && val.$isSingleNested) {
          seed = Object.keys(val._doc).reduce(function(seed2, path2) {
            return docReducer(val._doc, seed2, path2);
          }, seed);
          seed.push(val);
        } else if (val && val.isMongooseDocumentArray) {
          val.forEach(function _docReduce(doc2) {
            if (!doc2 || !doc2._doc) {
              return;
            }
            seed = Object.keys(doc2._doc).reduce(function(seed2, path2) {
              return docReducer(doc2._doc, seed2, path2);
            }, seed);
            if (doc2 instanceof Embedded) {
              seed.push(doc2);
            }
          });
        } else if (isNested && val != null) {
          for (const path2 of Object.keys(val)) {
            docReducer(val, seed, path2);
          }
        }
        return seed;
      }
      const subDocs = [];
      for (const path of Object.keys(this._doc)) {
        docReducer(this, subDocs, path);
      }
      return subDocs;
    };
    function applyQueue(doc) {
      const q = doc.$__schema && doc.$__schema.callQueue;
      if (!q.length) {
        return;
      }
      for (const pair of q) {
        if (pair[0] !== "pre" && pair[0] !== "post" && pair[0] !== "on") {
          doc[pair[0]].apply(doc, pair[1]);
        }
      }
    }
    Document2.prototype.$__handleReject = function handleReject(err) {
      if (this.listeners("error").length) {
        this.emit("error", err);
      } else if (this.constructor.listeners && this.constructor.listeners("error").length) {
        this.constructor.emit("error", err);
      }
    };
    Document2.prototype.$toObject = function(options, json) {
      let defaultOptions = {
        transform: true,
        flattenDecimals: true
      };
      const path = json ? "toJSON" : "toObject";
      const baseOptions = get(this, "constructor.base.options." + path, {});
      const schemaOptions = get(this, "$__schema.options", {});
      defaultOptions = utils2.options(defaultOptions, clone(baseOptions));
      defaultOptions = utils2.options(defaultOptions, clone(schemaOptions[path] || {}));
      options = utils2.isPOJO(options) ? clone(options) : {};
      options._calledWithOptions = options._calledWithOptions || clone(options);
      let _minimize;
      if (options._calledWithOptions.minimize != null) {
        _minimize = options.minimize;
      } else if (defaultOptions.minimize != null) {
        _minimize = defaultOptions.minimize;
      } else {
        _minimize = schemaOptions.minimize;
      }
      let flattenMaps;
      if (options._calledWithOptions.flattenMaps != null) {
        flattenMaps = options.flattenMaps;
      } else if (defaultOptions.flattenMaps != null) {
        flattenMaps = defaultOptions.flattenMaps;
      } else {
        flattenMaps = schemaOptions.flattenMaps;
      }
      const cloneOptions = Object.assign(utils2.clone(options), {
        _isNested: true,
        json,
        minimize: _minimize,
        flattenMaps
      });
      if (utils2.hasUserDefinedProperty(options, "getters")) {
        cloneOptions.getters = options.getters;
      }
      if (utils2.hasUserDefinedProperty(options, "virtuals")) {
        cloneOptions.virtuals = options.virtuals;
      }
      const depopulate = options.depopulate || get(options, "_parentOptions.depopulate", false);
      if (depopulate && options._isNested && this.$__.wasPopulated) {
        return clone(this._id, cloneOptions);
      }
      options = utils2.options(defaultOptions, options);
      options._isNested = true;
      options.json = json;
      options.minimize = _minimize;
      cloneOptions._parentOptions = options;
      cloneOptions._skipSingleNestedGetters = true;
      const gettersOptions = Object.assign({}, cloneOptions);
      gettersOptions._skipSingleNestedGetters = false;
      const originalTransform = options.transform;
      let ret2 = clone(this._doc, cloneOptions) || {};
      if (options.getters) {
        applyGetters(this, ret2, gettersOptions);
        if (options.minimize) {
          ret2 = minimize(ret2) || {};
        }
      }
      if (options.virtuals || options.getters && options.virtuals !== false) {
        applyVirtuals(this, ret2, gettersOptions, options);
      }
      if (options.versionKey === false && this.$__schema.options.versionKey) {
        delete ret2[this.$__schema.options.versionKey];
      }
      let transform = options.transform;
      if (transform) {
        applySchemaTypeTransforms(this, ret2);
      }
      if (options.useProjection) {
        omitDeselectedFields(this, ret2);
      }
      if (transform === true || schemaOptions.toObject && transform) {
        const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;
        if (opts) {
          transform = typeof options.transform === "function" ? options.transform : opts.transform;
        }
      } else {
        options.transform = originalTransform;
      }
      if (typeof transform === "function") {
        const xformed = transform(this, ret2, options);
        if (typeof xformed !== "undefined") {
          ret2 = xformed;
        }
      }
      return ret2;
    };
    Document2.prototype.toObject = function(options) {
      return this.$toObject(options);
    };
    function minimize(obj) {
      const keys = Object.keys(obj);
      let i = keys.length;
      let hasKeys;
      let key;
      let val;
      while (i--) {
        key = keys[i];
        val = obj[key];
        if (utils2.isObject(val) && !Buffer.isBuffer(val)) {
          obj[key] = minimize(val);
        }
        if (obj[key] === void 0) {
          delete obj[key];
          continue;
        }
        hasKeys = true;
      }
      return hasKeys ? obj : void 0;
    }
    function applyVirtuals(self2, json, options, toObjectOptions) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.virtuals);
      let i = paths.length;
      const numPaths = i;
      let path;
      let assignPath;
      let cur = self2._doc;
      let v;
      const aliases = get(toObjectOptions, "aliases", true);
      let virtualsToApply = null;
      if (Array.isArray(options.virtuals)) {
        virtualsToApply = new Set(options.virtuals);
      } else if (options.virtuals && options.virtuals.pathsToSkip) {
        virtualsToApply = new Set(paths);
        for (let i2 = 0; i2 < options.virtuals.pathsToSkip.length; i2++) {
          if (virtualsToApply.has(options.virtuals.pathsToSkip[i2])) {
            virtualsToApply.delete(options.virtuals.pathsToSkip[i2]);
          }
        }
      }
      if (!cur) {
        return json;
      }
      options = options || {};
      for (i = 0; i < numPaths; ++i) {
        path = paths[i];
        if (virtualsToApply != null && !virtualsToApply.has(path)) {
          continue;
        }
        if (!aliases && schema.aliases.hasOwnProperty(path)) {
          continue;
        }
        assignPath = path;
        if (options.path != null) {
          if (!path.startsWith(options.path + ".")) {
            continue;
          }
          assignPath = path.substr(options.path.length + 1);
        }
        const parts = assignPath.split(".");
        v = clone(self2.get(path), options);
        if (v === void 0) {
          continue;
        }
        const plen = parts.length;
        cur = json;
        for (let j = 0; j < plen - 1; ++j) {
          cur[parts[j]] = cur[parts[j]] || {};
          cur = cur[parts[j]];
        }
        cur[parts[plen - 1]] = v;
      }
      return json;
    }
    function applyGetters(self2, json, options) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.paths);
      let i = paths.length;
      let path;
      let cur = self2._doc;
      let v;
      if (!cur) {
        return json;
      }
      while (i--) {
        path = paths[i];
        const parts = path.split(".");
        const plen = parts.length;
        const last = plen - 1;
        let branch = json;
        let part;
        cur = self2._doc;
        if (!self2.$__isSelected(path)) {
          continue;
        }
        for (let ii = 0; ii < plen; ++ii) {
          part = parts[ii];
          v = cur[part];
          if (ii === last) {
            const val = self2.get(path);
            branch[part] = clone(val, options);
          } else if (v == null) {
            if (part in cur) {
              branch[part] = v;
            }
            break;
          } else {
            branch = branch[part] || (branch[part] = {});
          }
          cur = v;
        }
      }
      return json;
    }
    function applySchemaTypeTransforms(self2, json) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.paths || {});
      const cur = self2._doc;
      if (!cur) {
        return json;
      }
      for (const path of paths) {
        const schematype = schema.paths[path];
        if (typeof schematype.options.transform === "function") {
          const val = self2.get(path);
          const transformedValue = schematype.options.transform.call(self2, val);
          throwErrorIfPromise(path, transformedValue);
          utils2.setValue(path, transformedValue, json);
        } else if (schematype.$embeddedSchemaType != null && typeof schematype.$embeddedSchemaType.options.transform === "function") {
          const vals = [].concat(self2.get(path));
          const transform = schematype.$embeddedSchemaType.options.transform;
          for (let i = 0; i < vals.length; ++i) {
            const transformedValue = transform.call(self2, vals[i]);
            vals[i] = transformedValue;
            throwErrorIfPromise(path, transformedValue);
          }
          json[path] = vals;
        }
      }
      return json;
    }
    function throwErrorIfPromise(path, transformedValue) {
      if (isPromise(transformedValue)) {
        throw new Error("`transform` function must be synchronous, but the transform on path `" + path + "` returned a promise.");
      }
    }
    function omitDeselectedFields(self2, json) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.paths || {});
      const cur = self2._doc;
      if (!cur) {
        return json;
      }
      let selected = self2.$__.selected;
      if (selected === void 0) {
        selected = {};
        queryhelpers.applyPaths(selected, schema);
      }
      if (selected == null || Object.keys(selected).length === 0) {
        return json;
      }
      for (const path of paths) {
        if (selected[path] != null && !selected[path]) {
          delete json[path];
        }
      }
      return json;
    }
    Document2.prototype.toJSON = function(options) {
      return this.$toObject(options, true);
    };
    Document2.prototype.parent = function() {
      return this.$__.parent;
    };
    Document2.prototype.$parent = Document2.prototype.parent;
    Document2.prototype.inspect = function(options) {
      const isPOJO = utils2.isPOJO(options);
      let opts;
      if (isPOJO) {
        opts = options;
        opts.minimize = false;
      }
      const ret2 = this.toObject(opts);
      if (ret2 == null) {
        return "MongooseDocument { " + ret2 + " }";
      }
      return ret2;
    };
    if (inspect.custom) {
      Document2.prototype[inspect.custom] = Document2.prototype.inspect;
    }
    Document2.prototype.toString = function() {
      const ret2 = this.inspect();
      if (typeof ret2 === "string") {
        return ret2;
      }
      return inspect(ret2);
    };
    Document2.prototype.equals = function(doc) {
      if (!doc) {
        return false;
      }
      const tid = this.$__getValue("_id");
      const docid = doc.$__ != null ? doc.$__getValue("_id") : doc;
      if (!tid && !docid) {
        return deepEqual(this, doc);
      }
      return tid && tid.equals ? tid.equals(docid) : tid === docid;
    };
    Document2.prototype.populate = function populate() {
      if (arguments.length === 0) {
        return this;
      }
      const pop = this.$__.populate || (this.$__.populate = {});
      const args = utils2.args(arguments);
      let fn;
      if (typeof args[args.length - 1] === "function") {
        fn = args.pop();
      }
      if (args.length) {
        const res = utils2.populate.apply(null, args);
        for (const populateOptions of res) {
          pop[populateOptions.path] = populateOptions;
        }
      }
      if (fn) {
        const paths = utils2.object.vals(pop);
        this.$__.populate = void 0;
        let topLevelModel = this.constructor;
        if (this.$__isNested) {
          topLevelModel = this.$__[scopeSymbol].constructor;
          const nestedPath = this.$__.nestedPath;
          paths.forEach(function(populateOptions) {
            populateOptions.path = nestedPath + "." + populateOptions.path;
          });
        }
        if (this.$session() != null) {
          const session = this.$session();
          paths.forEach((path) => {
            if (path.options == null) {
              path.options = { session };
              return;
            }
            if (!("session" in path.options)) {
              path.options.session = session;
            }
          });
        }
        topLevelModel.populate(this, paths, fn);
      }
      return this;
    };
    Document2.prototype.$getPopulatedDocs = function $getPopulatedDocs() {
      let keys = [];
      if (this.$__.populated != null) {
        keys = keys.concat(Object.keys(this.$__.populated));
      }
      if (this.$$populatedVirtuals != null) {
        keys = keys.concat(Object.keys(this.$$populatedVirtuals));
      }
      let result = [];
      for (const key of keys) {
        const value = this.get(key);
        if (Array.isArray(value)) {
          result = result.concat(value);
        } else if (value instanceof Document2) {
          result.push(value);
        }
      }
      return result;
    };
    Document2.prototype.execPopulate = function(callback) {
      const isUsingShorthand = callback != null && typeof callback !== "function";
      if (isUsingShorthand) {
        return this.populate.apply(this, arguments).execPopulate();
      }
      return promiseOrCallback(callback, (cb) => {
        this.populate(cb);
      }, this.constructor.events);
    };
    Document2.prototype.populated = function(path, val, options) {
      if (val == null || val === true) {
        if (!this.$__.populated) {
          return void 0;
        }
        const _path = path.endsWith(".$*") ? path.replace(/\.\$\*$/, "") : path;
        const v = this.$__.populated[_path];
        if (v) {
          return val === true ? v : v.value;
        }
        return void 0;
      }
      this.$__.populated || (this.$__.populated = {});
      this.$__.populated[path] = { value: val, options };
      const pieces = path.split(".");
      for (let i = 0; i < pieces.length - 1; ++i) {
        const subpath = pieces.slice(0, i + 1).join(".");
        const subdoc = this.get(subpath);
        if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {
          const rest = pieces.slice(i + 1).join(".");
          subdoc.populated(rest, val, options);
          break;
        }
      }
      return val;
    };
    Document2.prototype.depopulate = function(path) {
      if (typeof path === "string") {
        path = path.split(" ");
      }
      let populatedIds;
      const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];
      const populated = get(this, "$__.populated", {});
      if (arguments.length === 0) {
        for (const virtualKey of virtualKeys) {
          delete this.$$populatedVirtuals[virtualKey];
          delete this._doc[virtualKey];
          delete populated[virtualKey];
        }
        const keys = Object.keys(populated);
        for (const key of keys) {
          populatedIds = this.populated(key);
          if (!populatedIds) {
            continue;
          }
          delete populated[key];
          this.$set(key, populatedIds);
        }
        return this;
      }
      for (const singlePath of path) {
        populatedIds = this.populated(singlePath);
        delete populated[singlePath];
        if (virtualKeys.indexOf(singlePath) !== -1) {
          delete this.$$populatedVirtuals[singlePath];
          delete this._doc[singlePath];
        } else if (populatedIds) {
          this.$set(singlePath, populatedIds);
        }
      }
      return this;
    };
    Document2.prototype.$__fullPath = function(path) {
      return path || "";
    };
    Document2.prototype.getChanges = function() {
      const delta = this.$__delta();
      const changes = delta ? delta[1] : {};
      return changes;
    };
    Document2.ValidationError = ValidationError;
    module2.exports = exports2 = Document2;
  }
});

// node_modules/mongoose/lib/utils.js
var require_utils8 = __commonJS({
  "node_modules/mongoose/lib/utils.js"(exports2) {
    "use strict";
    var ms = require_ms7();
    var mpath = require_mpath();
    var sliced = require_sliced();
    var Buffer2 = require_safe_buffer2().Buffer;
    var Decimal = require_decimal1282();
    var ObjectId2 = require_objectid3();
    var PopulateOptions = require_PopulateOptions();
    var clone = require_clone();
    var immediate = require_immediate();
    var isObject2 = require_isObject();
    var isBsonType = require_isBsonType();
    var getFunctionName = require_getFunctionName();
    var isMongooseObject = require_isMongooseObject();
    var promiseOrCallback = require_promiseOrCallback();
    var schemaMerge = require_merge();
    var specialProperties = require_specialProperties();
    var Document2;
    exports2.specialProperties = specialProperties;
    exports2.toCollectionName = function(name, pluralize) {
      if (name === "system.profile") {
        return name;
      }
      if (name === "system.indexes") {
        return name;
      }
      if (typeof pluralize === "function") {
        return pluralize(name);
      }
      return name;
    };
    exports2.deepEqual = function deepEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (typeof a !== "object" && typeof b !== "object") {
        return a === b;
      }
      if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      }
      if (isBsonType(a, "ObjectID") && isBsonType(b, "ObjectID") || isBsonType(a, "Decimal128") && isBsonType(b, "Decimal128")) {
        return a.toString() === b.toString();
      }
      if (a instanceof RegExp && b instanceof RegExp) {
        return a.source === b.source && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.global === b.global;
      }
      if (a == null || b == null) {
        return false;
      }
      if (a.prototype !== b.prototype) {
        return false;
      }
      if (a instanceof Map && b instanceof Map) {
        return deepEqual(Array.from(a.keys()), Array.from(b.keys())) && deepEqual(Array.from(a.values()), Array.from(b.values()));
      }
      if (a instanceof Number && b instanceof Number) {
        return a.valueOf() === b.valueOf();
      }
      if (Buffer2.isBuffer(a)) {
        return exports2.buffer.areEqual(a, b);
      }
      if (Array.isArray(a) && Array.isArray(b)) {
        const len = a.length;
        if (len !== b.length) {
          return false;
        }
        for (let i = 0; i < len; ++i) {
          if (!deepEqual(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      if (a.$__ != null) {
        a = a._doc;
      } else if (isMongooseObject(a)) {
        a = a.toObject();
      }
      if (b.$__ != null) {
        b = b._doc;
      } else if (isMongooseObject(b)) {
        b = b.toObject();
      }
      const ka = Object.keys(a);
      const kb = Object.keys(b);
      const kaLength = ka.length;
      if (kaLength !== kb.length) {
        return false;
      }
      ka.sort();
      kb.sort();
      for (let i = kaLength - 1; i >= 0; i--) {
        if (ka[i] !== kb[i]) {
          return false;
        }
      }
      for (const key of ka) {
        if (!deepEqual(a[key], b[key])) {
          return false;
        }
      }
      return true;
    };
    exports2.last = function(arr) {
      if (arr.length > 0) {
        return arr[arr.length - 1];
      }
      return void 0;
    };
    exports2.clone = clone;
    exports2.promiseOrCallback = promiseOrCallback;
    exports2.omit = function omit(obj, keys) {
      if (keys == null) {
        return Object.assign({}, obj);
      }
      if (!Array.isArray(keys)) {
        keys = [keys];
      }
      const ret2 = Object.assign({}, obj);
      for (const key of keys) {
        delete ret2[key];
      }
      return ret2;
    };
    exports2.options = function(defaults, options) {
      const keys = Object.keys(defaults);
      let i = keys.length;
      let k;
      options = options || {};
      while (i--) {
        k = keys[i];
        if (!(k in options)) {
          options[k] = defaults[k];
        }
      }
      return options;
    };
    exports2.random = function() {
      return Math.random().toString().substr(3);
    };
    exports2.merge = function merge(to, from, options, path) {
      options = options || {};
      const keys = Object.keys(from);
      let i = 0;
      const len = keys.length;
      let key;
      path = path || "";
      const omitNested = options.omitNested || {};
      while (i < len) {
        key = keys[i++];
        if (options.omit && options.omit[key]) {
          continue;
        }
        if (omitNested[path]) {
          continue;
        }
        if (specialProperties.has(key)) {
          continue;
        }
        if (to[key] == null) {
          to[key] = from[key];
        } else if (exports2.isObject(from[key])) {
          if (!exports2.isObject(to[key])) {
            to[key] = {};
          }
          if (from[key] != null) {
            if (options.isDiscriminatorSchemaMerge && (from[key].$isSingleNested && to[key].$isMongooseDocumentArray) || from[key].$isMongooseDocumentArray && to[key].$isSingleNested) {
              continue;
            } else if (from[key].instanceOfSchema) {
              if (to[key].instanceOfSchema) {
                schemaMerge(to[key], from[key].clone(), options.isDiscriminatorSchemaMerge);
              } else {
                to[key] = from[key].clone();
              }
              continue;
            } else if (from[key] instanceof ObjectId2) {
              to[key] = new ObjectId2(from[key]);
              continue;
            }
          }
          merge(to[key], from[key], options, path ? path + "." + key : key);
        } else if (options.overwrite) {
          to[key] = from[key];
        }
      }
    };
    exports2.toObject = function toObject(obj) {
      Document2 || (Document2 = require_document());
      let ret2;
      if (obj == null) {
        return obj;
      }
      if (obj instanceof Document2) {
        return obj.toObject();
      }
      if (Array.isArray(obj)) {
        ret2 = [];
        for (const doc of obj) {
          ret2.push(toObject(doc));
        }
        return ret2;
      }
      if (exports2.isPOJO(obj)) {
        ret2 = {};
        for (const k of Object.keys(obj)) {
          if (specialProperties.has(k)) {
            continue;
          }
          ret2[k] = toObject(obj[k]);
        }
        return ret2;
      }
      return obj;
    };
    exports2.isObject = isObject2;
    exports2.isPOJO = function isPOJO(arg) {
      if (arg == null || typeof arg !== "object") {
        return false;
      }
      const proto = Object.getPrototypeOf(arg);
      return !proto || proto.constructor.name === "Object";
    };
    exports2.isNativeObject = function(arg) {
      return Array.isArray(arg) || arg instanceof Date || arg instanceof Boolean || arg instanceof Number || arg instanceof String;
    };
    exports2.isEmptyObject = function(val) {
      return val != null && typeof val === "object" && Object.keys(val).length === 0;
    };
    exports2.hasKey = function hasKey(obj, key) {
      const props = Object.keys(obj);
      for (const prop of props) {
        if (prop === key) {
          return true;
        }
        if (exports2.isPOJO(obj[prop]) && exports2.hasKey(obj[prop], key)) {
          return true;
        }
      }
      return false;
    };
    exports2.args = sliced;
    exports2.tick = function tick(callback) {
      if (typeof callback !== "function") {
        return;
      }
      return function() {
        try {
          callback.apply(this, arguments);
        } catch (err) {
          immediate(function() {
            throw err;
          });
        }
      };
    };
    exports2.isMongooseType = function(v) {
      return v instanceof ObjectId2 || v instanceof Decimal || v instanceof Buffer2;
    };
    exports2.isMongooseObject = isMongooseObject;
    exports2.expires = function expires(object) {
      if (!(object && object.constructor.name === "Object")) {
        return;
      }
      if (!("expires" in object)) {
        return;
      }
      let when;
      if (typeof object.expires !== "string") {
        when = object.expires;
      } else {
        when = Math.round(ms(object.expires) / 1e3);
      }
      object.expireAfterSeconds = when;
      delete object.expires;
    };
    exports2.populate = function populate(path, select, model2, match, options, subPopulate, justOne, count) {
      let obj = null;
      if (arguments.length === 1) {
        if (path instanceof PopulateOptions) {
          return [path];
        }
        if (Array.isArray(path)) {
          const singles = makeSingles(path);
          return singles.map((o) => exports2.populate(o)[0]);
        }
        if (exports2.isObject(path)) {
          obj = Object.assign({}, path);
        } else {
          obj = { path };
        }
      } else if (typeof model2 === "object") {
        obj = {
          path,
          select,
          match: model2,
          options: match
        };
      } else {
        obj = {
          path,
          select,
          model: model2,
          match,
          options,
          populate: subPopulate,
          justOne,
          count
        };
      }
      if (typeof obj.path !== "string") {
        throw new TypeError("utils.populate: invalid path. Expected string. Got typeof `" + typeof path + "`");
      }
      return _populateObj(obj);
      function makeSingles(arr) {
        const ret2 = [];
        arr.forEach(function(obj2) {
          if (/[\s]/.test(obj2.path)) {
            const paths = obj2.path.split(" ");
            paths.forEach(function(p) {
              const copy = Object.assign({}, obj2);
              copy.path = p;
              ret2.push(copy);
            });
          } else {
            ret2.push(obj2);
          }
        });
        return ret2;
      }
    };
    function _populateObj(obj) {
      if (Array.isArray(obj.populate)) {
        const ret3 = [];
        obj.populate.forEach(function(obj2) {
          if (/[\s]/.test(obj2.path)) {
            const copy = Object.assign({}, obj2);
            const paths2 = copy.path.split(" ");
            paths2.forEach(function(p) {
              copy.path = p;
              ret3.push(exports2.populate(copy)[0]);
            });
          } else {
            ret3.push(exports2.populate(obj2)[0]);
          }
        });
        obj.populate = exports2.populate(ret3);
      } else if (obj.populate != null && typeof obj.populate === "object") {
        obj.populate = exports2.populate(obj.populate);
      }
      const ret2 = [];
      const paths = obj.path.split(" ");
      if (obj.options != null) {
        obj.options = exports2.clone(obj.options);
      }
      for (const path of paths) {
        ret2.push(new PopulateOptions(Object.assign({}, obj, { path })));
      }
      return ret2;
    }
    exports2.getValue = function(path, obj, map) {
      return mpath.get(path, obj, "_doc", map);
    };
    exports2.setValue = function(path, val, obj, map, _copying) {
      mpath.set(path, val, obj, "_doc", map, _copying);
    };
    exports2.object = {};
    exports2.object.vals = function vals(o) {
      const keys = Object.keys(o);
      let i = keys.length;
      const ret2 = [];
      while (i--) {
        ret2.push(o[keys[i]]);
      }
      return ret2;
    };
    exports2.object.shallowCopy = exports2.options;
    var hop = Object.prototype.hasOwnProperty;
    exports2.object.hasOwnProperty = function(obj, prop) {
      return hop.call(obj, prop);
    };
    exports2.isNullOrUndefined = function(val) {
      return val === null || val === void 0;
    };
    exports2.array = {};
    exports2.array.flatten = function flatten(arr, filter, ret2) {
      ret2 || (ret2 = []);
      arr.forEach(function(item) {
        if (Array.isArray(item)) {
          flatten(item, filter, ret2);
        } else {
          if (!filter || filter(item)) {
            ret2.push(item);
          }
        }
      });
      return ret2;
    };
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    exports2.hasUserDefinedProperty = function(obj, key) {
      if (obj == null) {
        return false;
      }
      if (Array.isArray(key)) {
        for (const k of key) {
          if (exports2.hasUserDefinedProperty(obj, k)) {
            return true;
          }
        }
        return false;
      }
      if (_hasOwnProperty.call(obj, key)) {
        return true;
      }
      if (typeof obj === "object" && key in obj) {
        const v = obj[key];
        return v !== Object.prototype[key] && v !== Array.prototype[key];
      }
      return false;
    };
    var MAX_ARRAY_INDEX = Math.pow(2, 32) - 1;
    exports2.isArrayIndex = function(val) {
      if (typeof val === "number") {
        return val >= 0 && val <= MAX_ARRAY_INDEX;
      }
      if (typeof val === "string") {
        if (!/^\d+$/.test(val)) {
          return false;
        }
        val = +val;
        return val >= 0 && val <= MAX_ARRAY_INDEX;
      }
      return false;
    };
    exports2.array.unique = function(arr) {
      const primitives = new Set();
      const ids = new Set();
      const ret2 = [];
      for (const item of arr) {
        if (typeof item === "number" || typeof item === "string" || item == null) {
          if (primitives.has(item)) {
            continue;
          }
          ret2.push(item);
          primitives.add(item);
        } else if (item instanceof ObjectId2) {
          if (ids.has(item.toString())) {
            continue;
          }
          ret2.push(item);
          ids.add(item.toString());
        } else {
          ret2.push(item);
        }
      }
      return ret2;
    };
    exports2.buffer = {};
    exports2.buffer.areEqual = function(a, b) {
      if (!Buffer2.isBuffer(a)) {
        return false;
      }
      if (!Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0, len = a.length; i < len; ++i) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    };
    exports2.getFunctionName = getFunctionName;
    exports2.decorate = function(destination, source) {
      for (const key in source) {
        if (specialProperties.has(key)) {
          continue;
        }
        destination[key] = source[key];
      }
    };
    exports2.mergeClone = function(to, fromObj) {
      if (isMongooseObject(fromObj)) {
        fromObj = fromObj.toObject({
          transform: false,
          virtuals: false,
          depopulate: true,
          getters: false,
          flattenDecimals: false
        });
      }
      const keys = Object.keys(fromObj);
      const len = keys.length;
      let i = 0;
      let key;
      while (i < len) {
        key = keys[i++];
        if (specialProperties.has(key)) {
          continue;
        }
        if (typeof to[key] === "undefined") {
          to[key] = exports2.clone(fromObj[key], {
            transform: false,
            virtuals: false,
            depopulate: true,
            getters: false,
            flattenDecimals: false
          });
        } else {
          let val = fromObj[key];
          if (val != null && val.valueOf && !(val instanceof Date)) {
            val = val.valueOf();
          }
          if (exports2.isObject(val)) {
            let obj = val;
            if (isMongooseObject(val) && !val.isMongooseBuffer) {
              obj = obj.toObject({
                transform: false,
                virtuals: false,
                depopulate: true,
                getters: false,
                flattenDecimals: false
              });
            }
            if (val.isMongooseBuffer) {
              obj = Buffer2.from(obj);
            }
            exports2.mergeClone(to[key], obj);
          } else {
            to[key] = exports2.clone(val, {
              flattenDecimals: false
            });
          }
        }
      }
    };
    exports2.each = function(arr, fn) {
      for (const item of arr) {
        fn(item);
      }
    };
    exports2.getOption = function(name) {
      const sources = Array.prototype.slice.call(arguments, 1);
      for (const source of sources) {
        if (source[name] != null) {
          return source[name];
        }
      }
      return null;
    };
    exports2.noop = function() {
    };
    exports2.errorToPOJO = function errorToPOJO(error) {
      const isError2 = error instanceof Error;
      if (!isError2) {
        throw new Error("`error` must be `instanceof Error`.");
      }
      const ret2 = {};
      for (const properyName of Object.getOwnPropertyNames(error)) {
        ret2[properyName] = error[properyName];
      }
      return ret2;
    };
  }
});

// node_modules/mongoose/lib/helpers/clone.js
var require_clone = __commonJS({
  "node_modules/mongoose/lib/helpers/clone.js"(exports2, module2) {
    "use strict";
    var cloneRegExp = require_regexp_clone();
    var Decimal = require_decimal1282();
    var ObjectId2 = require_objectid3();
    var specialProperties = require_specialProperties();
    var isMongooseObject = require_isMongooseObject();
    var getFunctionName = require_getFunctionName();
    var isBsonType = require_isBsonType();
    var isObject2 = require_isObject();
    var symbols = require_symbols();
    var utils2 = require_utils8();
    function clone(obj, options, isArrayChild) {
      if (obj == null) {
        return obj;
      }
      if (Array.isArray(obj)) {
        return cloneArray(obj, options);
      }
      if (isMongooseObject(obj)) {
        if (options && options._skipSingleNestedGetters && obj.$isSingleNested) {
          options = Object.assign({}, options, { getters: false });
        }
        if (utils2.isPOJO(obj) && obj.$__ != null && obj._doc != null) {
          return obj._doc;
        }
        if (options && options.json && typeof obj.toJSON === "function") {
          return obj.toJSON(options);
        }
        return obj.toObject(options);
      }
      if (obj.constructor) {
        switch (getFunctionName(obj.constructor)) {
          case "Object":
            return cloneObject(obj, options, isArrayChild);
          case "Date":
            return new obj.constructor(+obj);
          case "RegExp":
            return cloneRegExp(obj);
          default:
            break;
        }
      }
      if (obj instanceof ObjectId2) {
        return new ObjectId2(obj.id);
      }
      if (isBsonType(obj, "Decimal128")) {
        if (options && options.flattenDecimals) {
          return obj.toJSON();
        }
        return Decimal.fromString(obj.toString());
      }
      if (!obj.constructor && isObject2(obj)) {
        return cloneObject(obj, options, isArrayChild);
      }
      if (obj[symbols.schemaTypeSymbol]) {
        return obj.clone();
      }
      if (options && options.bson && typeof obj.toBSON === "function") {
        return obj;
      }
      if (obj.valueOf != null) {
        return obj.valueOf();
      }
      return cloneObject(obj, options, isArrayChild);
    }
    module2.exports = clone;
    function cloneObject(obj, options, isArrayChild) {
      const minimize = options && options.minimize;
      const ret2 = {};
      let hasKeys;
      for (const k of Object.keys(obj)) {
        if (specialProperties.has(k)) {
          continue;
        }
        const val = clone(obj[k], options);
        if (!minimize || typeof val !== "undefined") {
          if (minimize === false && typeof val === "undefined") {
            delete ret2[k];
          } else {
            hasKeys || (hasKeys = true);
            ret2[k] = val;
          }
        }
      }
      return minimize && !isArrayChild ? hasKeys && ret2 : ret2;
    }
    function cloneArray(arr, options) {
      const ret2 = [];
      for (const item of arr) {
        ret2.push(clone(item, options, true));
      }
      return ret2;
    }
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js
var require_collection5 = __commonJS({
  "node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js"(exports2, module2) {
    "use strict";
    var MongooseCollection = require_collection2();
    var MongooseError = require_mongooseError();
    var Collection = require_mongodb().Collection;
    var ObjectId2 = require_objectid2();
    var get = require_get();
    var getConstructorName = require_getConstructorName();
    var sliced = require_sliced();
    var stream = require("stream");
    var util = require("util");
    function NativeCollection(name, conn, options) {
      this.collection = null;
      this.Promise = options.Promise || Promise;
      this.modelName = options.modelName;
      delete options.modelName;
      this._closed = false;
      MongooseCollection.apply(this, arguments);
    }
    NativeCollection.prototype.__proto__ = MongooseCollection.prototype;
    NativeCollection.prototype.onOpen = function() {
      const _this = this;
      if (!_this.opts.capped.size) {
        callback(null, _this.conn.db.collection(_this.name));
        return _this.collection;
      }
      if (_this.opts.autoCreate === false) {
        _this.collection = _this.conn.db.collection(_this.name);
        MongooseCollection.prototype.onOpen.call(_this);
        return _this.collection;
      }
      return _this.conn.db.collection(_this.name, function(err, c) {
        if (err)
          return callback(err);
        _this.conn.db.listCollections({ name: _this.name }).toArray(function(err2, docs) {
          if (err2) {
            return callback(err2);
          }
          const doc = docs[0];
          const exists = !!doc;
          if (exists) {
            if (doc.options && doc.options.capped) {
              callback(null, c);
            } else {
              const msg = "A non-capped collection exists with the name: " + _this.name + "\n\n To use this collection as a capped collection, please first convert it.\n http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-Convertingacollectiontocapped";
              err2 = new Error(msg);
              callback(err2);
            }
          } else {
            const opts = Object.assign({}, _this.opts.capped);
            opts.capped = true;
            _this.conn.db.createCollection(_this.name, opts, callback);
          }
        });
      });
      function callback(err, collection) {
        if (err) {
          _this.conn.emit("error", err);
        } else {
          _this.collection = collection;
          MongooseCollection.prototype.onOpen.call(_this);
        }
      }
    };
    NativeCollection.prototype.onClose = function(force) {
      MongooseCollection.prototype.onClose.call(this, force);
    };
    var syncCollectionMethods = { watch: true };
    function iter(i) {
      NativeCollection.prototype[i] = function() {
        const collection = this.collection;
        const args = Array.from(arguments);
        const _this = this;
        const debug = get(_this, "conn.base.options.debug");
        const lastArg = arguments[arguments.length - 1];
        const opId = new ObjectId2();
        if (this.conn.$wasForceClosed) {
          const error = new MongooseError("Connection was force closed");
          if (args.length > 0 && typeof args[args.length - 1] === "function") {
            args[args.length - 1](error);
            return;
          } else {
            throw error;
          }
        }
        let _args = args;
        let callback = null;
        if (this._shouldBufferCommands() && this.buffer) {
          if (syncCollectionMethods[i]) {
            throw new Error("Collection method " + i + " is synchronous");
          }
          this.conn.emit("buffer", {
            _id: opId,
            modelName: _this.modelName,
            collectionName: _this.name,
            method: i,
            args
          });
          let callback2;
          let _args2;
          let promise = null;
          let timeout = null;
          if (typeof lastArg === "function") {
            callback2 = function collectionOperationCallback() {
              if (timeout != null) {
                clearTimeout(timeout);
              }
              return lastArg.apply(this, arguments);
            };
            _args2 = args.slice(0, args.length - 1).concat([callback2]);
          } else {
            promise = new this.Promise((resolve, reject) => {
              callback2 = function collectionOperationCallback(err, res) {
                if (timeout != null) {
                  clearTimeout(timeout);
                }
                if (err != null) {
                  return reject(err);
                }
                resolve(res);
              };
              _args2 = args.concat([callback2]);
              this.addQueue(i, _args2);
            });
          }
          const bufferTimeoutMS = this._getBufferTimeoutMS();
          timeout = setTimeout(() => {
            const removed = this.removeQueue(i, _args2);
            if (removed) {
              const message = "Operation `" + this.name + "." + i + "()` buffering timed out after " + bufferTimeoutMS + "ms";
              const err = new MongooseError(message);
              this.conn.emit("buffer-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });
              callback2(err);
            }
          }, bufferTimeoutMS);
          if (typeof lastArg === "function") {
            this.addQueue(i, _args2);
            return;
          }
          return promise;
        } else if (!syncCollectionMethods[i] && typeof lastArg === "function") {
          callback = function collectionOperationCallback(err, res) {
            if (err != null) {
              _this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });
            } else {
              _this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, result: res });
            }
            return lastArg.apply(this, arguments);
          };
          _args = args.slice(0, args.length - 1).concat([callback]);
        }
        if (debug) {
          if (typeof debug === "function") {
            debug.apply(_this, [_this.name, i].concat(sliced(args, 0, args.length - 1)));
          } else if (debug instanceof stream.Writable) {
            this.$printToStream(_this.name, i, args, debug);
          } else {
            const color = debug.color == null ? true : debug.color;
            const shell = debug.shell == null ? false : debug.shell;
            this.$print(_this.name, i, args, color, shell);
          }
        }
        this.conn.emit("operation-start", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, params: _args });
        try {
          if (collection == null) {
            const message = "Cannot call `" + this.name + "." + i + "()` before initial connection is complete if `bufferCommands = false`. Make sure you `await mongoose.connect()` if you have `bufferCommands = false`.";
            throw new MongooseError(message);
          }
          const ret2 = collection[i].apply(collection, _args);
          if (ret2 != null && typeof ret2.then === "function") {
            return ret2.then((res) => {
              this.conn.emit("operation-end", { _id: opId, modelName: this.modelName, collectionName: this.name, method: i, result: res });
              return res;
            }, (err) => {
              this.conn.emit("operation-end", { _id: opId, modelName: this.modelName, collectionName: this.name, method: i, error: err });
              throw err;
            });
          }
          return ret2;
        } catch (error) {
          if (typeof callback === "function") {
            callback(error);
          } else {
            this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, error });
          }
          if (typeof lastArg === "function") {
            lastArg(error);
          } else {
            throw error;
          }
        }
      };
    }
    for (const key of Object.keys(Collection.prototype)) {
      const descriptor = Object.getOwnPropertyDescriptor(Collection.prototype, key);
      if (descriptor.get !== void 0) {
        continue;
      }
      if (typeof Collection.prototype[key] !== "function") {
        continue;
      }
      iter(key);
    }
    NativeCollection.prototype.$print = function(name, i, args, color, shell) {
      const moduleName = color ? "[0;36mMongoose:[0m " : "Mongoose: ";
      const functionCall = [name, i].join(".");
      const _args = [];
      for (let j = args.length - 1; j >= 0; --j) {
        if (this.$format(args[j]) || _args.length) {
          _args.unshift(this.$format(args[j], color, shell));
        }
      }
      const params = "(" + _args.join(", ") + ")";
      console.info(moduleName + functionCall + params);
    };
    NativeCollection.prototype.$printToStream = function(name, i, args, stream2) {
      const functionCall = [name, i].join(".");
      const _args = [];
      for (let j = args.length - 1; j >= 0; --j) {
        if (this.$format(args[j]) || _args.length) {
          _args.unshift(this.$format(args[j]));
        }
      }
      const params = "(" + _args.join(", ") + ")";
      stream2.write(functionCall + params, "utf8");
    };
    NativeCollection.prototype.$format = function(arg, color, shell) {
      const type = typeof arg;
      if (type === "function" || type === "undefined")
        return "";
      return format(arg, false, color, shell);
    };
    function inspectable(representation) {
      const ret2 = {
        inspect: function() {
          return representation;
        }
      };
      if (util.inspect.custom) {
        ret2[util.inspect.custom] = ret2.inspect;
      }
      return ret2;
    }
    function map(o) {
      return format(o, true);
    }
    function formatObjectId(x, key) {
      x[key] = inspectable('ObjectId("' + x[key].toHexString() + '")');
    }
    function formatDate(x, key, shell) {
      if (shell) {
        x[key] = inspectable('ISODate("' + x[key].toUTCString() + '")');
      } else {
        x[key] = inspectable('new Date("' + x[key].toUTCString() + '")');
      }
    }
    function format(obj, sub, color, shell) {
      if (obj && typeof obj.toBSON === "function") {
        obj = obj.toBSON();
      }
      if (obj == null) {
        return obj;
      }
      const clone = require_clone();
      let x = clone(obj, { transform: false });
      const constructorName = getConstructorName(x);
      if (constructorName === "Binary") {
        x = "BinData(" + x.sub_type + ', "' + x.toString("base64") + '")';
      } else if (constructorName === "ObjectID") {
        x = inspectable('ObjectId("' + x.toHexString() + '")');
      } else if (constructorName === "Date") {
        x = inspectable('new Date("' + x.toUTCString() + '")');
      } else if (constructorName === "Object") {
        const keys = Object.keys(x);
        const numKeys = keys.length;
        let key;
        for (let i = 0; i < numKeys; ++i) {
          key = keys[i];
          if (x[key]) {
            let error;
            if (typeof x[key].toBSON === "function") {
              try {
                x[key] = x[key].toBSON();
              } catch (_error) {
                error = _error;
              }
            }
            const _constructorName = getConstructorName(x[key]);
            if (_constructorName === "Binary") {
              x[key] = "BinData(" + x[key].sub_type + ', "' + x[key].buffer.toString("base64") + '")';
            } else if (_constructorName === "Object") {
              x[key] = format(x[key], true);
            } else if (_constructorName === "ObjectID") {
              formatObjectId(x, key);
            } else if (_constructorName === "Date") {
              formatDate(x, key, shell);
            } else if (_constructorName === "ClientSession") {
              x[key] = inspectable('ClientSession("' + get(x[key], "id.id.buffer", "").toString("hex") + '")');
            } else if (Array.isArray(x[key])) {
              x[key] = x[key].map(map);
            } else if (error != null) {
              throw error;
            }
          }
        }
      }
      if (sub) {
        return x;
      }
      return util.inspect(x, false, 10, color).replace(/\n/g, "").replace(/\s{2,}/g, " ");
    }
    NativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;
    module2.exports = NativeCollection;
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/decimal128.js
var require_decimal1285 = __commonJS({
  "node_modules/mongoose/lib/drivers/node-mongodb-native/decimal128.js"(exports2, module2) {
    "use strict";
    module2.exports = require_mongodb().Decimal128;
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/ReadPreference.js
var require_ReadPreference = __commonJS({
  "node_modules/mongoose/lib/drivers/node-mongodb-native/ReadPreference.js"(exports2, module2) {
    "use strict";
    var mongodb = require_mongodb();
    var ReadPref = mongodb.ReadPreference;
    module2.exports = function readPref(pref, tags) {
      if (Array.isArray(pref)) {
        tags = pref[1];
        pref = pref[0];
      }
      if (pref instanceof ReadPref) {
        return pref;
      }
      switch (pref) {
        case "p":
          pref = "primary";
          break;
        case "pp":
          pref = "primaryPreferred";
          break;
        case "s":
          pref = "secondary";
          break;
        case "sp":
          pref = "secondaryPreferred";
          break;
        case "n":
          pref = "nearest";
          break;
      }
      return new ReadPref(pref, tags);
    };
  }
});

// node_modules/mongoose/lib/cursor/ChangeStream.js
var require_ChangeStream = __commonJS({
  "node_modules/mongoose/lib/cursor/ChangeStream.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var ChangeStream = class extends EventEmitter {
      constructor(changeStreamThunk, pipeline, options) {
        super();
        this.driverChangeStream = null;
        this.closed = false;
        this.pipeline = pipeline;
        this.options = options;
        changeStreamThunk((err, driverChangeStream) => {
          if (err != null) {
            this.emit("error", err);
            return;
          }
          this.driverChangeStream = driverChangeStream;
          this._bindEvents();
          this.emit("ready");
        });
      }
      _bindEvents() {
        this.driverChangeStream.on("close", () => {
          this.closed = true;
        });
        ["close", "change", "end", "error"].forEach((ev) => {
          this.driverChangeStream.on(ev, (data) => this.emit(ev, data));
        });
      }
      _queue(cb) {
        this.once("ready", () => cb());
      }
      close() {
        this.closed = true;
        if (this.driverChangeStream) {
          this.driverChangeStream.close();
        }
      }
    };
    module2.exports = ChangeStream;
  }
});

// node_modules/mongoose/lib/helpers/topology/allServersUnknown.js
var require_allServersUnknown = __commonJS({
  "node_modules/mongoose/lib/helpers/topology/allServersUnknown.js"(exports2, module2) {
    "use strict";
    var getConstructorName = require_getConstructorName();
    module2.exports = function allServersUnknown(topologyDescription) {
      if (getConstructorName(topologyDescription) !== "TopologyDescription") {
        return false;
      }
      const servers = Array.from(topologyDescription.servers.values());
      return servers.length > 0 && servers.every((server) => server.type === "Unknown");
    };
  }
});

// node_modules/mongoose/lib/helpers/topology/isAtlas.js
var require_isAtlas = __commonJS({
  "node_modules/mongoose/lib/helpers/topology/isAtlas.js"(exports2, module2) {
    "use strict";
    var getConstructorName = require_getConstructorName();
    module2.exports = function isAtlas(topologyDescription) {
      if (getConstructorName(topologyDescription) !== "TopologyDescription") {
        return false;
      }
      const hostnames = Array.from(topologyDescription.servers.keys());
      return hostnames.length > 0 && hostnames.every((host) => host.endsWith(".mongodb.net:27017"));
    };
  }
});

// node_modules/mongoose/lib/helpers/topology/isSSLError.js
var require_isSSLError = __commonJS({
  "node_modules/mongoose/lib/helpers/topology/isSSLError.js"(exports2, module2) {
    "use strict";
    var getConstructorName = require_getConstructorName();
    var nonSSLMessage = "Client network socket disconnected before secure TLS connection was established";
    module2.exports = function isSSLError(topologyDescription) {
      if (getConstructorName(topologyDescription) !== "TopologyDescription") {
        return false;
      }
      const descriptions = Array.from(topologyDescription.servers.values());
      return descriptions.length > 0 && descriptions.every((descr) => descr.error && descr.error.message.indexOf(nonSSLMessage) !== -1);
    };
  }
});

// node_modules/mongoose/lib/error/serverSelection.js
var require_serverSelection = __commonJS({
  "node_modules/mongoose/lib/error/serverSelection.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var allServersUnknown = require_allServersUnknown();
    var isAtlas = require_isAtlas();
    var isSSLError = require_isSSLError();
    var atlasMessage = "Could not connect to any servers in your MongoDB Atlas cluster. One common reason is that you're trying to access the database from an IP that isn't whitelisted. Make sure your current IP address is on your Atlas cluster's IP whitelist: https://docs.atlas.mongodb.com/security-whitelist/";
    var sslMessage = "Mongoose is connecting with SSL enabled, but the server is not accepting SSL connections. Please ensure that the MongoDB server you are connecting to is configured to accept SSL connections. Learn more: https://mongoosejs.com/docs/tutorials/ssl.html";
    var MongooseServerSelectionError = class extends MongooseError {
      assimilateError(err) {
        const reason = err.reason;
        const isAtlasWhitelistError = isAtlas(reason) && allServersUnknown(reason) && err.message.indexOf("bad auth") === -1 && err.message.indexOf("Authentication failed") === -1;
        if (isAtlasWhitelistError) {
          this.message = atlasMessage;
        } else if (isSSLError(reason)) {
          this.message = sslMessage;
        } else {
          this.message = err.message;
        }
        for (const key in err) {
          if (key !== "name") {
            this[key] = err[key];
          }
        }
        return this;
      }
    };
    Object.defineProperty(MongooseServerSelectionError.prototype, "name", {
      value: "MongooseServerSelectionError"
    });
    module2.exports = MongooseServerSelectionError;
  }
});

// node_modules/mongoose/lib/helpers/schema/applyPlugins.js
var require_applyPlugins = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/applyPlugins.js"(exports2, module2) {
    "use strict";
    module2.exports = function applyPlugins(schema, plugins, options, cacheKey) {
      if (schema[cacheKey]) {
        return;
      }
      schema[cacheKey] = true;
      if (!options || !options.skipTopLevel) {
        for (const plugin of plugins) {
          schema.plugin(plugin[0], plugin[1]);
        }
      }
      options = Object.assign({}, options);
      delete options.skipTopLevel;
      if (options.applyPluginsToChildSchemas !== false) {
        for (const path of Object.keys(schema.paths)) {
          const type = schema.paths[path];
          if (type.schema != null) {
            applyPlugins(type.schema, plugins, options, cacheKey);
            type.caster.prototype.$__setSchema(type.schema);
          }
        }
      }
      const discriminators = schema.discriminators;
      if (discriminators == null) {
        return;
      }
      const applyPluginsToDiscriminators = options.applyPluginsToDiscriminators;
      const keys = Object.keys(discriminators);
      for (const discriminatorKey of keys) {
        const discriminatorSchema = discriminators[discriminatorKey];
        applyPlugins(discriminatorSchema, plugins, { skipTopLevel: !applyPluginsToDiscriminators }, cacheKey);
      }
    };
  }
});

// node_modules/mongoose/package.json
var require_package2 = __commonJS({
  "node_modules/mongoose/package.json"(exports2, module2) {
    module2.exports = {
      _args: [
        [
          "mongoose@5.13.7",
          "D:\\D_Documents\\Imagine Apps\\Ada\\Proyecto\\ada-back"
        ]
      ],
      _from: "mongoose@5.13.7",
      _id: "mongoose@5.13.7",
      _inBundle: false,
      _integrity: "sha512-ADIvftZ+KfoTALMZ0n8HvBlezFhcUd73hQaHQDwQ+3X+JZlqE47fUy9yhFZ2SjT+qzmuaCcIXCfhewIc38t2fQ==",
      _location: "/mongoose",
      _phantomChildren: {},
      _requested: {
        type: "version",
        registry: true,
        raw: "mongoose@5.13.7",
        name: "mongoose",
        escapedName: "mongoose",
        rawSpec: "5.13.7",
        saveSpec: null,
        fetchSpec: "5.13.7"
      },
      _requiredBy: [
        "/",
        "/@types/mongoose"
      ],
      _resolved: "https://registry.npmjs.org/mongoose/-/mongoose-5.13.7.tgz",
      _spec: "5.13.7",
      _where: "D:\\D_Documents\\Imagine Apps\\Ada\\Proyecto\\ada-back",
      author: {
        name: "Guillermo Rauch",
        email: "guillermo@learnboost.com"
      },
      browser: "./dist/browser.umd.js",
      bugs: {
        url: "https://github.com/Automattic/mongoose/issues/new"
      },
      dependencies: {
        "@types/mongodb": "^3.5.27",
        bson: "^1.1.4",
        kareem: "2.3.2",
        mongodb: "3.6.11",
        "mongoose-legacy-pluralize": "1.0.2",
        mpath: "0.8.3",
        mquery: "3.2.5",
        ms: "2.1.2",
        "optional-require": "1.0.x",
        "regexp-clone": "1.0.0",
        "safe-buffer": "5.2.1",
        sift: "13.5.2",
        sliced: "1.0.1"
      },
      description: "Mongoose MongoDB ODM",
      devDependencies: {
        "@babel/core": "7.10.5",
        "@babel/preset-env": "7.10.4",
        "@typescript-eslint/eslint-plugin": "4.10.0",
        "@typescript-eslint/parser": "4.10.0",
        acquit: "1.x",
        "acquit-ignore": "0.1.x",
        "acquit-require": "0.1.x",
        "babel-loader": "8.1.0",
        benchmark: "2.1.4",
        bluebird: "3.5.5",
        chalk: "2.4.2",
        cheerio: "1.0.0-rc.2",
        co: "4.6.0",
        dox: "0.3.1",
        eslint: "7.1.0",
        "eslint-plugin-mocha-no-only": "1.1.0",
        "highlight.js": "9.18.2",
        "lodash.isequal": "4.5.0",
        "lodash.isequalwith": "4.4.0",
        marked: "1.1.1",
        mkdirp: "0.5.5",
        mocha: "5.x",
        moment: "2.x",
        "mongoose-long": "0.2.1",
        "node-static": "0.7.11",
        "object-sizeof": "1.3.0",
        pug: "2.0.3",
        q: "1.5.1",
        rimraf: "2.6.3",
        semver: "5.5.0",
        typescript: "4.1.x",
        uuid: "2.0.3",
        "uuid-parse": "1.0.0",
        validator: "10.8.0",
        webpack: "4.44.0"
      },
      directories: {
        lib: "./lib/mongoose"
      },
      engines: {
        node: ">=4.0.0"
      },
      eslintConfig: {
        extends: [
          "eslint:recommended"
        ],
        overrides: [
          {
            files: [
              "**/*.{ts,tsx}"
            ],
            extends: [
              "plugin:@typescript-eslint/eslint-recommended",
              "plugin:@typescript-eslint/recommended"
            ],
            plugins: [
              "@typescript-eslint"
            ],
            rules: {
              "@typescript-eslint/no-explicit-any": "off",
              "@typescript-eslint/ban-types": "off",
              "@typescript-eslint/no-unused-vars": "off",
              "@typescript-eslint/explicit-module-boundary-types": "off"
            }
          }
        ],
        plugins: [
          "mocha-no-only"
        ],
        parserOptions: {
          ecmaVersion: 2015
        },
        env: {
          node: true,
          es6: true
        },
        rules: {
          "comma-style": "error",
          indent: [
            "error",
            2,
            {
              SwitchCase: 1,
              VariableDeclarator: 2
            }
          ],
          "keyword-spacing": "error",
          "no-whitespace-before-property": "error",
          "no-buffer-constructor": "warn",
          "no-console": "off",
          "no-multi-spaces": "error",
          "no-constant-condition": "off",
          "func-call-spacing": "error",
          "no-trailing-spaces": "error",
          "no-undef": "error",
          "no-unneeded-ternary": "error",
          "no-const-assign": "error",
          "no-useless-rename": "error",
          "no-dupe-keys": "error",
          "space-in-parens": [
            "error",
            "never"
          ],
          "spaced-comment": [
            "error",
            "always",
            {
              block: {
                markers: [
                  "!"
                ],
                balanced: true
              }
            }
          ],
          "key-spacing": [
            "error",
            {
              beforeColon: false,
              afterColon: true
            }
          ],
          "comma-spacing": [
            "error",
            {
              before: false,
              after: true
            }
          ],
          "array-bracket-spacing": 1,
          "arrow-spacing": [
            "error",
            {
              before: true,
              after: true
            }
          ],
          "object-curly-spacing": [
            "error",
            "always"
          ],
          "comma-dangle": [
            "error",
            "never"
          ],
          "no-unreachable": "error",
          quotes: [
            "error",
            "single"
          ],
          "quote-props": [
            "error",
            "as-needed"
          ],
          semi: "error",
          "no-extra-semi": "error",
          "semi-spacing": "error",
          "no-spaced-func": "error",
          "no-throw-literal": "error",
          "space-before-blocks": "error",
          "space-before-function-paren": [
            "error",
            "never"
          ],
          "space-infix-ops": "error",
          "space-unary-ops": "error",
          "no-var": "warn",
          "prefer-const": "warn",
          strict: [
            "error",
            "global"
          ],
          "no-restricted-globals": [
            "error",
            {
              name: "context",
              message: "Don't use Mocha's global context"
            }
          ],
          "no-prototype-builtins": "off",
          "mocha-no-only/mocha-no-only": [
            "error"
          ]
        }
      },
      funding: {
        type: "opencollective",
        url: "https://opencollective.com/mongoose"
      },
      homepage: "https://mongoosejs.com",
      keywords: [
        "mongodb",
        "document",
        "model",
        "schema",
        "database",
        "odm",
        "data",
        "datastore",
        "query",
        "nosql",
        "orm",
        "db"
      ],
      license: "MIT",
      main: "./index.js",
      mocha: {
        extension: [
          "test.js"
        ],
        "watch-files": [
          "test/**/*.js"
        ]
      },
      name: "mongoose",
      repository: {
        type: "git",
        url: "git://github.com/Automattic/mongoose.git"
      },
      scripts: {
        "build-browser": "node build-browser.js",
        lint: "eslint .",
        prepublishOnly: "npm run build-browser",
        release: "git pull && git push origin master --tags && npm publish",
        "release-legacy": "git pull origin 4.x && git push origin 4.x --tags && npm publish --tag legacy",
        tdd: "mocha ./test/*.test.js ./test/typescript/main.test.js --watch --recursive --watch-files ./**/*.js",
        test: "mocha --exit ./test/*.test.js ./test/typescript/main.test.js",
        "test-cov": "nyc --reporter=html --reporter=text npm test"
      },
      types: "./index.d.ts",
      version: "5.13.7"
    };
  }
});

// node_modules/mongoose/lib/connection.js
var require_connection3 = __commonJS({
  "node_modules/mongoose/lib/connection.js"(exports2, module2) {
    "use strict";
    var ChangeStream = require_ChangeStream();
    var EventEmitter = require("events").EventEmitter;
    var Schema2 = require_schema2();
    var Collection = require_driver().get().Collection;
    var STATES = require_connectionstate();
    var MongooseError = require_error3();
    var PromiseProvider = require_promise_provider();
    var ServerSelectionError = require_serverSelection();
    var applyPlugins = require_applyPlugins();
    var promiseOrCallback = require_promiseOrCallback();
    var get = require_get();
    var immediate = require_immediate();
    var mongodb = require_mongodb();
    var pkg = require_package2();
    var utils2 = require_utils8();
    var parseConnectionString = require_core().parseConnectionString;
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var sessionNewDocuments = require_symbols().sessionNewDocuments;
    var noPasswordAuthMechanisms = [
      "MONGODB-X509"
    ];
    function Connection(base) {
      this.base = base;
      this.collections = {};
      this.models = {};
      this.config = {};
      this.replica = false;
      this.options = null;
      this.otherDbs = [];
      this.relatedDbs = {};
      this.states = STATES;
      this._readyState = STATES.disconnected;
      this._closeCalled = false;
      this._hasOpened = false;
      this.plugins = [];
      if (typeof base === "undefined" || !base.connections.length) {
        this.id = 0;
      } else {
        this.id = base.connections.length;
      }
      this._queue = [];
    }
    Connection.prototype.__proto__ = EventEmitter.prototype;
    Object.defineProperty(Connection.prototype, "readyState", {
      get: function() {
        return this._readyState;
      },
      set: function(val) {
        if (!(val in STATES)) {
          throw new Error("Invalid connection state: " + val);
        }
        if (this._readyState !== val) {
          this._readyState = val;
          for (const db of this.otherDbs) {
            db.readyState = val;
          }
          if (STATES.connected === val) {
            this._hasOpened = true;
          }
          this.emit(STATES[val]);
        }
      }
    });
    Connection.prototype.get = function(key) {
      if (this.config.hasOwnProperty(key)) {
        return this.config[key];
      }
      return get(this.options, key);
    };
    Connection.prototype.set = function(key, val) {
      if (this.config.hasOwnProperty(key)) {
        this.config[key] = val;
        return val;
      }
      this.options = this.options || {};
      this.options[key] = val;
      return val;
    };
    Connection.prototype.collections;
    Connection.prototype.name;
    Connection.prototype.models;
    Connection.prototype.id;
    Object.defineProperty(Connection.prototype, "plugins", {
      configurable: false,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection.prototype, "host", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection.prototype, "port", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection.prototype, "user", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection.prototype, "pass", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Connection.prototype.db;
    Connection.prototype.client;
    Connection.prototype.config;
    Connection.prototype.createCollection = _wrapConnHelper(function createCollection(collection, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      this.db.createCollection(collection, options, cb);
    });
    Connection.prototype.startSession = _wrapConnHelper(function startSession(options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      const session = this.client.startSession(options);
      cb(null, session);
    });
    Connection.prototype.transaction = function transaction(fn, options) {
      return this.startSession().then((session) => {
        session[sessionNewDocuments] = new Map();
        return session.withTransaction(() => fn(session), options).then((res) => {
          delete session[sessionNewDocuments];
          return res;
        }).catch((err) => {
          for (const doc of session[sessionNewDocuments].keys()) {
            const state = session[sessionNewDocuments].get(doc);
            if (state.hasOwnProperty("isNew")) {
              doc.isNew = state.isNew;
            }
            if (state.hasOwnProperty("versionKey")) {
              doc.set(doc.schema.options.versionKey, state.versionKey);
            }
            for (const path of state.modifiedPaths) {
              doc.$__.activePaths.paths[path] = "modify";
              doc.$__.activePaths.states.modify[path] = true;
            }
            for (const path of state.atomics.keys()) {
              const val = doc.$__getValue(path);
              if (val == null) {
                continue;
              }
              val[arrayAtomicsSymbol] = state.atomics.get(path);
            }
          }
          delete session[sessionNewDocuments];
          throw err;
        });
      });
    };
    Connection.prototype.dropCollection = _wrapConnHelper(function dropCollection(collection, cb) {
      this.db.dropCollection(collection, cb);
    });
    Connection.prototype.dropDatabase = _wrapConnHelper(function dropDatabase(cb) {
      for (const name of Object.keys(this.models)) {
        delete this.models[name].$init;
      }
      this.db.dropDatabase(cb);
    });
    function _wrapConnHelper(fn) {
      return function() {
        const cb = arguments.length > 0 ? arguments[arguments.length - 1] : null;
        const argsWithoutCb = typeof cb === "function" ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : Array.prototype.slice.call(arguments);
        const disconnectedError = new MongooseError("Connection " + this.id + " was disconnected when calling `" + fn.name + "`");
        return promiseOrCallback(cb, (cb2) => {
          immediate(() => {
            if (this.readyState === STATES.connecting && this._shouldBufferCommands()) {
              this._queue.push({ fn, ctx: this, args: argsWithoutCb.concat([cb2]) });
            } else if (this.readyState === STATES.disconnected && this.db == null) {
              cb2(disconnectedError);
            } else {
              try {
                fn.apply(this, argsWithoutCb.concat([cb2]));
              } catch (err) {
                return cb2(err);
              }
            }
          });
        });
      };
    }
    Connection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
      if (this.config.bufferCommands != null) {
        return this.config.bufferCommands;
      }
      if (this.base.get("bufferCommands") != null) {
        return this.base.get("bufferCommands");
      }
      return true;
    };
    Connection.prototype.error = function(err, callback) {
      if (callback) {
        callback(err);
        return null;
      }
      if (this.listeners("error").length > 0) {
        this.emit("error", err);
      }
      return Promise.reject(err);
    };
    Connection.prototype.onOpen = function() {
      this.readyState = STATES.connected;
      for (const d of this._queue) {
        d.fn.apply(d.ctx, d.args);
      }
      this._queue = [];
      for (const i in this.collections) {
        if (utils2.object.hasOwnProperty(this.collections, i)) {
          this.collections[i].onOpen();
        }
      }
      this.emit("open");
    };
    Connection.prototype.openUri = function(uri, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (["string", "number"].indexOf(typeof options) !== -1) {
        throw new MongooseError("Mongoose 5.x no longer supports `mongoose.connect(host, dbname, port)` or `mongoose.createConnection(host, dbname, port)`. See http://mongoosejs.com/docs/connections.html for supported connection syntax");
      }
      if (typeof uri !== "string") {
        throw new MongooseError(`The \`uri\` parameter to \`openUri()\` must be a string, got "${typeof uri}". Make sure the first parameter to \`mongoose.connect()\` or \`mongoose.createConnection()\` is a string.`);
      }
      if (callback != null && typeof callback !== "function") {
        throw new MongooseError('3rd parameter to `mongoose.connect()` or `mongoose.createConnection()` must be a function, got "' + typeof callback + '"');
      }
      if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {
        if (this._connectionString !== uri) {
          throw new MongooseError("Can't call `openUri()` on an active connection with different connection strings. Make sure you aren't calling `mongoose.connect()` multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections");
        }
        if (typeof callback === "function") {
          this.$initialConnection = this.$initialConnection.then(() => callback(null, this), (err) => callback(err));
        }
        return this;
      }
      this._connectionString = uri;
      this.readyState = STATES.connecting;
      this._closeCalled = false;
      const Promise2 = PromiseProvider.get();
      const _this = this;
      if (options) {
        options = utils2.clone(options);
        const autoIndex = options.config && options.config.autoIndex != null ? options.config.autoIndex : options.autoIndex;
        if (autoIndex != null) {
          this.config.autoIndex = autoIndex !== false;
          delete options.config;
          delete options.autoIndex;
        }
        if ("autoCreate" in options) {
          this.config.autoCreate = !!options.autoCreate;
          delete options.autoCreate;
        }
        if ("useCreateIndex" in options) {
          this.config.useCreateIndex = !!options.useCreateIndex;
          delete options.useCreateIndex;
        }
        if ("useFindAndModify" in options) {
          this.config.useFindAndModify = !!options.useFindAndModify;
          delete options.useFindAndModify;
        }
        if (options.user || options.pass) {
          options.auth = options.auth || {};
          options.auth.user = options.user;
          options.auth.password = options.pass;
          this.user = options.user;
          this.pass = options.pass;
        }
        delete options.user;
        delete options.pass;
        if (options.bufferCommands != null) {
          if (options.bufferMaxEntries == null) {
            options.bufferMaxEntries = 0;
          }
          this.config.bufferCommands = options.bufferCommands;
          delete options.bufferCommands;
        }
        if (options.useMongoClient != null) {
          handleUseMongoClient(options);
        }
      } else {
        options = {};
      }
      this._connectionOptions = options;
      const dbName = options.dbName;
      if (dbName != null) {
        this.$dbName = dbName;
      }
      delete options.dbName;
      if (!("promiseLibrary" in options)) {
        options.promiseLibrary = PromiseProvider.get();
      }
      if (!("useNewUrlParser" in options)) {
        if ("useNewUrlParser" in this.base.options) {
          options.useNewUrlParser = this.base.options.useNewUrlParser;
        } else {
          options.useNewUrlParser = false;
        }
      }
      if (!utils2.hasUserDefinedProperty(options, "useUnifiedTopology")) {
        if (utils2.hasUserDefinedProperty(this.base.options, "useUnifiedTopology")) {
          options.useUnifiedTopology = this.base.options.useUnifiedTopology;
        } else {
          options.useUnifiedTopology = false;
        }
      }
      if (!utils2.hasUserDefinedProperty(options, "driverInfo")) {
        options.driverInfo = {
          name: "Mongoose",
          version: pkg.version
        };
      }
      const parsePromise = new Promise2((resolve, reject) => {
        parseConnectionString(uri, options, (err, parsed) => {
          if (err) {
            return reject(err);
          }
          if (dbName) {
            this.name = dbName;
          } else if (parsed.defaultDatabase) {
            this.name = parsed.defaultDatabase;
          } else {
            this.name = get(parsed, "auth.db", null);
          }
          this.host = get(parsed, "hosts.0.host", "localhost");
          this.port = get(parsed, "hosts.0.port", 27017);
          this.user = this.user || get(parsed, "auth.username");
          this.pass = this.pass || get(parsed, "auth.password");
          resolve();
        });
      });
      const promise = new Promise2((resolve, reject) => {
        const client = new mongodb.MongoClient(uri, options);
        _this.client = client;
        client.connect((error) => {
          if (error) {
            return reject(error);
          }
          _setClient(_this, client, options, dbName);
          resolve(_this);
        });
      });
      const serverSelectionError = new ServerSelectionError();
      this.$initialConnection = Promise2.all([promise, parsePromise]).then((res) => res[0]).catch((err) => {
        this.readyState = STATES.disconnected;
        if (err != null && err.name === "MongoServerSelectionError") {
          err = serverSelectionError.assimilateError(err);
        }
        if (this.listeners("error").length > 0) {
          immediate(() => this.emit("error", err));
        }
        throw err;
      });
      this.then = function(resolve, reject) {
        return this.$initialConnection.then(() => {
          if (typeof resolve === "function") {
            return resolve(_this);
          }
        }, reject);
      };
      this.catch = function(reject) {
        return this.$initialConnection.catch(reject);
      };
      if (callback != null) {
        this.$initialConnection = this.$initialConnection.then(() => callback(null, this), (err) => callback(err));
      }
      return this;
    };
    function _setClient(conn, client, options, dbName) {
      const db = dbName != null ? client.db(dbName) : client.db();
      conn.db = db;
      conn.client = client;
      conn._closeCalled = client._closeCalled;
      const _handleReconnect = () => {
        if (conn.readyState !== STATES.connected) {
          conn.readyState = STATES.connected;
          conn.emit("reconnect");
          conn.emit("reconnected");
          conn.onOpen();
        }
      };
      const type = get(db, "s.topology.s.description.type", "");
      if (options.useUnifiedTopology) {
        if (type === "Single") {
          const server = Array.from(db.s.topology.s.servers.values())[0];
          server.s.topology.on("serverHeartbeatSucceeded", () => {
            _handleReconnect();
          });
          server.s.pool.on("reconnect", () => {
            _handleReconnect();
          });
          client.on("serverDescriptionChanged", (ev) => {
            const newDescription = ev.newDescription;
            if (newDescription.type === "Standalone") {
              _handleReconnect();
            } else {
              conn.readyState = STATES.disconnected;
            }
          });
        } else if (type.startsWith("ReplicaSet")) {
          client.on("topologyDescriptionChanged", (ev) => {
            const description = ev.newDescription;
            const servers = Array.from(ev.newDescription.servers.values());
            const allServersDisconnected = description.type === "ReplicaSetNoPrimary" && servers.reduce((cur, d) => cur || d.type === "Unknown", false);
            if (conn.readyState === STATES.connected && allServersDisconnected) {
              conn.readyState = STATES.disconnected;
            } else if (conn.readyState === STATES.disconnected && !allServersDisconnected) {
              _handleReconnect();
            }
          });
          client.on("close", function() {
            const type2 = get(db, "s.topology.s.description.type", "");
            if (type2 !== "ReplicaSetWithPrimary") {
              conn.readyState = STATES.disconnected;
            }
          });
        }
      }
      db.s.topology.on("reconnectFailed", function() {
        conn.emit("reconnectFailed");
      });
      if (!options.useUnifiedTopology) {
        client.on("reconnect", function() {
          _handleReconnect();
        });
        db.s.topology.on("left", function(data) {
          conn.emit("left", data);
        });
      }
      db.s.topology.on("joined", function(data) {
        conn.emit("joined", data);
      });
      db.s.topology.on("fullsetup", function(data) {
        conn.emit("fullsetup", data);
      });
      if (get(db, "s.topology.s.coreTopology.s.pool") != null) {
        db.s.topology.s.coreTopology.s.pool.on("attemptReconnect", function() {
          conn.emit("attemptReconnect");
        });
      }
      if (!options.useUnifiedTopology) {
        client.on("close", function() {
          conn.readyState = STATES.disconnected;
        });
      } else if (!type.startsWith("ReplicaSet")) {
        client.on("close", function() {
          conn.readyState = STATES.disconnected;
        });
      }
      if (!options.useUnifiedTopology) {
        client.on("left", function() {
          if (conn.readyState === STATES.connected && get(db, "s.topology.s.coreTopology.s.replicaSetState.topologyType") === "ReplicaSetNoPrimary") {
            conn.readyState = STATES.disconnected;
          }
        });
        client.on("timeout", function() {
          conn.emit("timeout");
        });
      }
      delete conn.then;
      delete conn.catch;
      conn.onOpen();
    }
    var handleUseMongoClient = function handleUseMongoClient2(options) {
      console.warn("WARNING: The `useMongoClient` option is no longer necessary in mongoose 5.x, please remove it.");
      const stack = new Error().stack;
      console.warn(stack.substr(stack.indexOf("\n") + 1));
      delete options.useMongoClient;
    };
    Connection.prototype.close = function(force, callback) {
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      this.$wasForceClosed = !!force;
      return promiseOrCallback(callback, (cb) => {
        this._close(force, cb);
      });
    };
    Connection.prototype._close = function(force, callback) {
      const _this = this;
      const closeCalled = this._closeCalled;
      this._closeCalled = true;
      if (this.client != null) {
        this.client._closeCalled = true;
      }
      switch (this.readyState) {
        case STATES.disconnected:
          if (closeCalled) {
            callback();
          } else {
            this.doClose(force, function(err) {
              if (err) {
                return callback(err);
              }
              _this.onClose(force);
              callback(null);
            });
          }
          break;
        case STATES.connected:
          this.readyState = STATES.disconnecting;
          this.doClose(force, function(err) {
            if (err) {
              return callback(err);
            }
            _this.onClose(force);
            callback(null);
          });
          break;
        case STATES.connecting:
          this.once("open", function() {
            _this.close(callback);
          });
          break;
        case STATES.disconnecting:
          this.once("close", function() {
            callback();
          });
          break;
      }
      return this;
    };
    Connection.prototype.onClose = function(force) {
      this.readyState = STATES.disconnected;
      for (const i in this.collections) {
        if (utils2.object.hasOwnProperty(this.collections, i)) {
          this.collections[i].onClose(force);
        }
      }
      this.emit("close", force);
    };
    Connection.prototype.collection = function(name, options) {
      const defaultOptions = {
        autoIndex: this.config.autoIndex != null ? this.config.autoIndex : this.base.options.autoIndex,
        autoCreate: this.config.autoCreate != null ? this.config.autoCreate : this.base.options.autoCreate
      };
      options = Object.assign({}, defaultOptions, options ? utils2.clone(options) : {});
      options.$wasForceClosed = this.$wasForceClosed;
      if (!(name in this.collections)) {
        this.collections[name] = new Collection(name, this, options);
      }
      return this.collections[name];
    };
    Connection.prototype.plugin = function(fn, opts) {
      this.plugins.push([fn, opts]);
      return this;
    };
    Connection.prototype.model = function(name, schema, collection, options) {
      if (!(this instanceof Connection)) {
        throw new MongooseError("`connection.model()` should not be run with `new`. If you are doing `new db.model(foo)(bar)`, use `db.model(foo)(bar)` instead");
      }
      let fn;
      if (typeof name === "function") {
        fn = name;
        name = fn.name;
      }
      if (typeof schema === "string") {
        collection = schema;
        schema = false;
      }
      if (utils2.isObject(schema) && !schema.instanceOfSchema) {
        schema = new Schema2(schema);
      }
      if (schema && !schema.instanceOfSchema) {
        throw new Error("The 2nd parameter to `mongoose.model()` should be a schema or a POJO");
      }
      const defaultOptions = { cache: false, overwriteModels: this.base.options.overwriteModels };
      const opts = Object.assign(defaultOptions, options, { connection: this });
      if (this.models[name] && !collection && opts.overwriteModels !== true) {
        if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {
          throw new MongooseError.OverwriteModelError(name);
        }
        return this.models[name];
      }
      let model2;
      if (schema && schema.instanceOfSchema) {
        applyPlugins(schema, this.plugins, null, "$connectionPluginsApplied");
        model2 = this.base.model(fn || name, schema, collection, opts);
        if (!this.models[name]) {
          this.models[name] = model2;
        }
        model2.init(function $modelInitNoop() {
        });
        return model2;
      }
      if (this.models[name] && collection) {
        model2 = this.models[name];
        schema = model2.prototype.schema;
        const sub = model2.__subclass(this, schema, collection);
        return sub;
      }
      model2 = this.base.models[name];
      if (!model2) {
        throw new MongooseError.MissingSchemaError(name);
      }
      if (this === model2.prototype.db && (!collection || collection === model2.collection.name)) {
        if (!this.models[name]) {
          this.models[name] = model2;
        }
        return model2;
      }
      this.models[name] = model2.__subclass(this, schema, collection);
      return this.models[name];
    };
    Connection.prototype.deleteModel = function(name) {
      if (typeof name === "string") {
        const model2 = this.model(name);
        if (model2 == null) {
          return this;
        }
        const collectionName = model2.collection.name;
        delete this.models[name];
        delete this.collections[collectionName];
        delete this.base.modelSchemas[name];
        this.emit("deleteModel", model2);
      } else if (name instanceof RegExp) {
        const pattern = name;
        const names = this.modelNames();
        for (const name2 of names) {
          if (pattern.test(name2)) {
            this.deleteModel(name2);
          }
        }
      } else {
        throw new Error('First parameter to `deleteModel()` must be a string or regexp, got "' + name + '"');
      }
      return this;
    };
    Connection.prototype.watch = function(pipeline, options) {
      const disconnectedError = new MongooseError("Connection " + this.id + " was disconnected when calling `watch()`");
      const changeStreamThunk = (cb) => {
        immediate(() => {
          if (this.readyState === STATES.connecting) {
            this.once("open", function() {
              const driverChangeStream = this.db.watch(pipeline, options);
              cb(null, driverChangeStream);
            });
          } else if (this.readyState === STATES.disconnected && this.db == null) {
            cb(disconnectedError);
          } else {
            const driverChangeStream = this.db.watch(pipeline, options);
            cb(null, driverChangeStream);
          }
        });
      };
      const changeStream = new ChangeStream(changeStreamThunk, pipeline, options);
      return changeStream;
    };
    Connection.prototype.modelNames = function() {
      return Object.keys(this.models);
    };
    Connection.prototype.shouldAuthenticate = function() {
      return this.user != null && (this.pass != null || this.authMechanismDoesNotRequirePassword());
    };
    Connection.prototype.authMechanismDoesNotRequirePassword = function() {
      if (this.options && this.options.auth) {
        return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;
      }
      return true;
    };
    Connection.prototype.optionsProvideAuthenticationData = function(options) {
      return options && options.user && (options.pass || this.authMechanismDoesNotRequirePassword());
    };
    Connection.prototype.getClient = function getClient() {
      return this.client;
    };
    Connection.prototype.setClient = function setClient(client) {
      if (!(client instanceof mongodb.MongoClient)) {
        throw new MongooseError("Must call `setClient()` with an instance of MongoClient");
      }
      if (this.client != null || this.readyState !== STATES.disconnected) {
        throw new MongooseError("Cannot call `setClient()` on a connection that is already connected.");
      }
      if (!client.isConnected()) {
        throw new MongooseError("Cannot call `setClient()` with a MongoClient that is not connected.");
      }
      this._connectionString = client.s.url;
      _setClient(this, client, { useUnifiedTopology: client.s.options.useUnifiedTopology }, client.s.options.dbName);
      return this;
    };
    Connection.STATES = STATES;
    module2.exports = Connection;
  }
});

// node_modules/mongoose/lib/helpers/timers.js
var require_timers2 = __commonJS({
  "node_modules/mongoose/lib/helpers/timers.js"(exports2) {
    "use strict";
    exports2.setTimeout = setTimeout;
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js
var require_connection4 = __commonJS({
  "node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js"(exports2, module2) {
    "use strict";
    var MongooseConnection = require_connection3();
    var STATES = require_connectionstate();
    var immediate = require_immediate();
    var setTimeout2 = require_timers2().setTimeout;
    function NativeConnection() {
      MongooseConnection.apply(this, arguments);
      this._listening = false;
    }
    NativeConnection.STATES = STATES;
    NativeConnection.prototype.__proto__ = MongooseConnection.prototype;
    NativeConnection.prototype.useDb = function(name, options) {
      options = options || {};
      if (options.useCache && this.relatedDbs[name]) {
        return this.relatedDbs[name];
      }
      const newConn = new this.constructor();
      newConn.name = name;
      newConn.base = this.base;
      newConn.collections = {};
      newConn.models = {};
      newConn.replica = this.replica;
      newConn.config = Object.assign({}, this.config, newConn.config);
      newConn.name = this.name;
      newConn.options = this.options;
      newConn._readyState = this._readyState;
      newConn._closeCalled = this._closeCalled;
      newConn._hasOpened = this._hasOpened;
      newConn._listening = false;
      newConn.host = this.host;
      newConn.port = this.port;
      newConn.user = this.user;
      newConn.pass = this.pass;
      const _this = this;
      newConn.client = _this.client;
      if (this.db && this._readyState === STATES.connected) {
        wireup();
      } else {
        this.once("connected", wireup);
      }
      function wireup() {
        newConn.client = _this.client;
        const _opts = {};
        if (options.hasOwnProperty("noListener")) {
          _opts.noListener = options.noListener;
        }
        newConn.db = _this.client.db(name, _opts);
        newConn.onOpen();
        if (options.noListener !== true) {
          listen(newConn);
        }
      }
      newConn.name = name;
      if (options.noListener !== true) {
        this.otherDbs.push(newConn);
      }
      newConn.otherDbs.push(this);
      if (options && options.useCache) {
        this.relatedDbs[newConn.name] = newConn;
        newConn.relatedDbs = this.relatedDbs;
      }
      return newConn;
    };
    function listen(conn) {
      if (conn._listening) {
        return;
      }
      conn._listening = true;
      conn.client.on("close", function(force) {
        if (conn._closeCalled) {
          return;
        }
        conn._closeCalled = conn.client._closeCalled;
        if (conn.db.serverConfig.autoReconnect) {
          conn.readyState = STATES.disconnected;
          conn.emit("close");
          return;
        }
        conn.onClose(force);
      });
      conn.client.on("error", function(err) {
        conn.emit("error", err);
      });
      if (!conn.client.s.options.useUnifiedTopology) {
        conn.db.on("reconnect", function() {
          conn.readyState = STATES.connected;
          conn.emit("reconnect");
          conn.emit("reconnected");
          conn.onOpen();
        });
        conn.db.on("open", function(err, db) {
          if (STATES.disconnected === conn.readyState && db && db.databaseName) {
            conn.readyState = STATES.connected;
            conn.emit("reconnect");
            conn.emit("reconnected");
          }
        });
      }
      conn.client.on("timeout", function(err) {
        conn.emit("timeout", err);
      });
      conn.client.on("parseError", function(err) {
        conn.emit("parseError", err);
      });
    }
    NativeConnection.prototype.doClose = function(force, fn) {
      if (this.client == null) {
        immediate(() => fn());
        return this;
      }
      this.client.close(force, (err, res) => {
        setTimeout2(() => fn(err, res), 1);
      });
      return this;
    };
    module2.exports = NativeConnection;
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/index.js
var require_node_mongodb_native = __commonJS({
  "node_modules/mongoose/lib/drivers/node-mongodb-native/index.js"(exports2) {
    "use strict";
    exports2.Binary = require_binary2();
    exports2.Collection = require_collection5();
    exports2.Decimal128 = require_decimal1285();
    exports2.ObjectId = require_objectid2();
    exports2.ReadPreference = require_ReadPreference();
    exports2.getConnection = () => require_connection4();
  }
});

// node_modules/mongoose/lib/validoptions.js
var require_validoptions = __commonJS({
  "node_modules/mongoose/lib/validoptions.js"(exports2, module2) {
    "use strict";
    var VALID_OPTIONS = Object.freeze([
      "applyPluginsToChildSchemas",
      "applyPluginsToDiscriminators",
      "autoCreate",
      "autoIndex",
      "bufferCommands",
      "bufferTimeoutMS",
      "cloneSchemas",
      "debug",
      "maxTimeMS",
      "objectIdGetter",
      "overwriteModels",
      "returnOriginal",
      "runValidators",
      "sanitizeProjection",
      "selectPopulatedPaths",
      "setDefaultsOnInsert",
      "strict",
      "strictQuery",
      "toJSON",
      "toObject",
      "typePojoToMixed",
      "useCreateIndex",
      "useFindAndModify",
      "useNewUrlParser",
      "usePushEach",
      "useUnifiedTopology"
    ]);
    module2.exports = VALID_OPTIONS;
  }
});

// node_modules/mongoose/lib/helpers/cursor/eachAsync.js
var require_eachAsync = __commonJS({
  "node_modules/mongoose/lib/helpers/cursor/eachAsync.js"(exports2, module2) {
    "use strict";
    var immediate = require_immediate();
    var promiseOrCallback = require_promiseOrCallback();
    module2.exports = function eachAsync(next, fn, options, callback) {
      const parallel = options.parallel || 1;
      const batchSize = options.batchSize;
      const enqueue = asyncQueue();
      return promiseOrCallback(callback, (cb) => {
        if (batchSize != null) {
          if (typeof batchSize !== "number") {
            throw new TypeError("batchSize must be a number");
          }
          if (batchSize < 1) {
            throw new TypeError("batchSize must be at least 1");
          }
          if (batchSize !== Math.floor(batchSize)) {
            throw new TypeError("batchSize must be a positive integer");
          }
        }
        iterate(cb);
      });
      function iterate(finalCallback) {
        let drained = false;
        let handleResultsInProgress = 0;
        let currentDocumentIndex = 0;
        let documentsBatch = [];
        let error = null;
        for (let i = 0; i < parallel; ++i) {
          enqueue(fetch);
        }
        function fetch(done) {
          if (drained || error) {
            return done();
          }
          next(function(err, doc) {
            if (drained || error != null) {
              return done();
            }
            if (err != null) {
              error = err;
              finalCallback(err);
              return done();
            }
            if (doc == null) {
              drained = true;
              if (handleResultsInProgress <= 0) {
                finalCallback(null);
              } else if (batchSize != null && documentsBatch.length) {
                handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);
              }
              return done();
            }
            ++handleResultsInProgress;
            immediate(() => done());
            if (batchSize != null) {
              documentsBatch.push(doc);
            }
            if (batchSize != null && documentsBatch.length !== batchSize) {
              setTimeout(() => enqueue(fetch), 0);
              return;
            }
            const docsToProcess = batchSize != null ? documentsBatch : doc;
            function handleNextResultCallBack(err2) {
              if (batchSize != null) {
                handleResultsInProgress -= documentsBatch.length;
                documentsBatch = [];
              } else {
                --handleResultsInProgress;
              }
              if (err2 != null) {
                error = err2;
                return finalCallback(err2);
              }
              if (drained && handleResultsInProgress <= 0) {
                return finalCallback(null);
              }
              setTimeout(() => enqueue(fetch), 0);
            }
            handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);
          });
        }
      }
      function handleNextResult(doc, i, callback2) {
        const promise = fn(doc, i);
        if (promise && typeof promise.then === "function") {
          promise.then(function() {
            callback2(null);
          }, function(error) {
            callback2(error || new Error("`eachAsync()` promise rejected without error"));
          });
        } else {
          callback2(null);
        }
      }
    };
    function asyncQueue() {
      const _queue = [];
      let inProgress = null;
      let id = 0;
      return function enqueue(fn) {
        if (_queue.length === 0 && inProgress == null) {
          inProgress = id++;
          return fn(_step);
        }
        _queue.push(fn);
      };
      function _step() {
        inProgress = null;
        if (_queue.length > 0) {
          inProgress = id++;
          const fn = _queue.shift();
          fn(_step);
        }
      }
    }
  }
});

// node_modules/mongoose/lib/cursor/QueryCursor.js
var require_QueryCursor = __commonJS({
  "node_modules/mongoose/lib/cursor/QueryCursor.js"(exports2, module2) {
    "use strict";
    var Readable = require("stream").Readable;
    var promiseOrCallback = require_promiseOrCallback();
    var eachAsync = require_eachAsync();
    var helpers = require_queryhelpers();
    var immediate = require_immediate();
    var util = require("util");
    function QueryCursor(query, options) {
      Readable.call(this, { objectMode: true });
      this.cursor = null;
      this.query = query;
      const _this = this;
      const model2 = query.model;
      this._mongooseOptions = {};
      this._transforms = [];
      this.model = model2;
      this.options = options || {};
      model2.hooks.execPre("find", query, () => {
        this._transforms = this._transforms.concat(query._transforms.slice());
        if (this.options.transform) {
          this._transforms.push(options.transform);
        }
        if (this.options.batchSize) {
          this.options.cursor = options.cursor || {};
          this.options.cursor.batchSize = options.batchSize;
          this.options._populateBatchSize = Math.min(this.options.batchSize, 5e3);
        }
        model2.collection.find(query._conditions, this.options, function(err, cursor) {
          if (_this._error) {
            if (cursor != null) {
              cursor.close(function() {
              });
            }
            _this.emit("cursor", null);
            _this.listeners("error").length > 0 && _this.emit("error", _this._error);
            return;
          }
          if (err) {
            return _this.emit("error", err);
          }
          _this.cursor = cursor;
          _this.emit("cursor", cursor);
        });
      });
    }
    util.inherits(QueryCursor, Readable);
    QueryCursor.prototype._read = function() {
      const _this = this;
      _next(this, function(error, doc) {
        if (error) {
          return _this.emit("error", error);
        }
        if (!doc) {
          _this.push(null);
          _this.cursor.close(function(error2) {
            if (error2) {
              return _this.emit("error", error2);
            }
            setTimeout(function() {
              const isNotClosedAutomatically = !_this.destroyed;
              if (isNotClosedAutomatically) {
                _this.emit("close");
              }
            }, 0);
          });
          return;
        }
        _this.push(doc);
      });
    };
    QueryCursor.prototype.map = function(fn) {
      this._transforms.push(fn);
      return this;
    };
    QueryCursor.prototype._markError = function(error) {
      this._error = error;
      return this;
    };
    QueryCursor.prototype.close = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        this.cursor.close((error) => {
          if (error) {
            cb(error);
            return this.listeners("error").length > 0 && this.emit("error", error);
          }
          this.emit("close");
          cb(null);
        });
      }, this.model.events);
    };
    QueryCursor.prototype.next = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        _next(this, function(error, doc) {
          if (error) {
            return cb(error);
          }
          cb(null, doc);
        });
      }, this.model.events);
    };
    QueryCursor.prototype.eachAsync = function(fn, opts, callback) {
      const _this = this;
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      opts = opts || {};
      return eachAsync(function(cb) {
        return _next(_this, cb);
      }, fn, opts, callback);
    };
    QueryCursor.prototype.options;
    QueryCursor.prototype.addCursorFlag = function(flag, value) {
      const _this = this;
      _waitForCursor(this, function() {
        _this.cursor.addCursorFlag(flag, value);
      });
      return this;
    };
    QueryCursor.prototype.transformNull = function(val) {
      if (arguments.length === 0) {
        val = true;
      }
      this._mongooseOptions.transformNull = val;
      return this;
    };
    QueryCursor.prototype._transformForAsyncIterator = function() {
      if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
        this.map(_transformForAsyncIterator);
      }
      return this;
    };
    if (Symbol.asyncIterator != null) {
      QueryCursor.prototype[Symbol.asyncIterator] = function() {
        return this.transformNull()._transformForAsyncIterator();
      };
    }
    function _transformForAsyncIterator(doc) {
      return doc == null ? { done: true } : { value: doc, done: false };
    }
    function _next(ctx, cb) {
      let callback = cb;
      if (ctx._transforms.length) {
        callback = function(err, doc) {
          if (err || doc === null && !ctx._mongooseOptions.transformNull) {
            return cb(err, doc);
          }
          cb(err, ctx._transforms.reduce(function(doc2, fn) {
            return fn.call(ctx, doc2);
          }, doc));
        };
      }
      if (ctx._error) {
        return immediate(function() {
          callback(ctx._error);
        });
      }
      if (ctx.cursor) {
        if (ctx.query._mongooseOptions.populate && !ctx._pop) {
          ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query, ctx.query._mongooseOptions);
          ctx._pop.__noPromise = true;
        }
        if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {
          if (ctx._batchDocs && ctx._batchDocs.length) {
            return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);
          } else if (ctx._batchExhausted) {
            return callback(null, null);
          } else {
            ctx._batchDocs = [];
            return ctx.cursor.next(_onNext.bind({ ctx, callback }));
          }
        } else {
          return ctx.cursor.next(function(error, doc) {
            if (error) {
              return callback(error);
            }
            if (!doc) {
              return callback(null, null);
            }
            if (!ctx.query._mongooseOptions.populate) {
              return _nextDoc(ctx, doc, null, callback);
            }
            ctx.query.model.populate(doc, ctx._pop, function(err, doc2) {
              if (err) {
                return callback(err);
              }
              return _nextDoc(ctx, doc2, ctx._pop, callback);
            });
          });
        }
      } else {
        ctx.once("cursor", function(cursor) {
          if (cursor == null) {
            return;
          }
          _next(ctx, cb);
        });
      }
    }
    function _onNext(error, doc) {
      if (error) {
        return this.callback(error);
      }
      if (!doc) {
        this.ctx._batchExhausted = true;
        return _populateBatch.call(this);
      }
      this.ctx._batchDocs.push(doc);
      if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {
        if (this.ctx._batchDocs.length > 0 && this.ctx._batchDocs.length % 1e3 === 0) {
          return immediate(() => this.ctx.cursor.next(_onNext.bind(this)));
        }
        this.ctx.cursor.next(_onNext.bind(this));
      } else {
        _populateBatch.call(this);
      }
    }
    function _populateBatch() {
      if (!this.ctx._batchDocs.length) {
        return this.callback(null, null);
      }
      const _this = this;
      this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop, function(err) {
        if (err) {
          return _this.callback(err);
        }
        _nextDoc(_this.ctx, _this.ctx._batchDocs.shift(), _this.ctx._pop, _this.callback);
      });
    }
    function _nextDoc(ctx, doc, pop, callback) {
      if (ctx.query._mongooseOptions.lean) {
        return ctx.model.hooks.execPost("find", ctx.query, [[doc]], (err) => {
          if (err != null) {
            return callback(err);
          }
          callback(null, doc);
        });
      }
      _create(ctx, doc, pop, (err, doc2) => {
        if (err != null) {
          return callback(err);
        }
        ctx.model.hooks.execPost("find", ctx.query, [[doc2]], (err2) => {
          if (err2 != null) {
            return callback(err2);
          }
          callback(null, doc2);
        });
      });
    }
    function _waitForCursor(ctx, cb) {
      if (ctx.cursor) {
        return cb();
      }
      ctx.once("cursor", function(cursor) {
        if (cursor == null) {
          return;
        }
        cb();
      });
    }
    function _create(ctx, doc, populatedIds, cb) {
      const instance = helpers.createModel(ctx.query.model, doc, ctx.query._fields);
      const opts = populatedIds ? { populated: populatedIds } : void 0;
      instance.init(doc, opts, function(err) {
        if (err) {
          return cb(err);
        }
        cb(null, instance);
      });
    }
    module2.exports = QueryCursor;
  }
});

// node_modules/mongoose/lib/helpers/query/applyGlobalMaxTimeMS.js
var require_applyGlobalMaxTimeMS = __commonJS({
  "node_modules/mongoose/lib/helpers/query/applyGlobalMaxTimeMS.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    module2.exports = function applyGlobalMaxTimeMS(options, model2) {
      if (utils2.hasUserDefinedProperty(options, "maxTimeMS")) {
        return;
      }
      if (utils2.hasUserDefinedProperty(model2.db.options, "maxTimeMS")) {
        options.maxTimeMS = model2.db.options.maxTimeMS;
      } else if (utils2.hasUserDefinedProperty(model2.base.options, "maxTimeMS")) {
        options.maxTimeMS = model2.base.options.maxTimeMS;
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js
var require_applyWriteConcern = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    module2.exports = function applyWriteConcern(schema, options) {
      const writeConcern = get(schema, "options.writeConcern", {});
      if (Object.keys(writeConcern).length != 0) {
        options.writeConcern = {};
        if (!("w" in options) && writeConcern.w != null) {
          options.writeConcern.w = writeConcern.w;
        }
        if (!("j" in options) && writeConcern.j != null) {
          options.writeConcern.j = writeConcern.j;
        }
        if (!("wtimeout" in options) && writeConcern.wtimeout != null) {
          options.writeConcern.wtimeout = writeConcern.wtimeout;
        }
      } else {
        if (!("w" in options) && writeConcern.w != null) {
          options.w = writeConcern.w;
        }
        if (!("j" in options) && writeConcern.j != null) {
          options.j = writeConcern.j;
        }
        if (!("wtimeout" in options) && writeConcern.wtimeout != null) {
          options.wtimeout = writeConcern.wtimeout;
        }
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/query/castFilterPath.js
var require_castFilterPath = __commonJS({
  "node_modules/mongoose/lib/helpers/query/castFilterPath.js"(exports2, module2) {
    "use strict";
    var isOperator = require_isOperator();
    module2.exports = function castFilterPath(query, schematype, val) {
      const ctx = query;
      const any$conditionals = Object.keys(val).some(isOperator);
      if (!any$conditionals) {
        return schematype.castForQueryWrapper({
          val,
          context: ctx
        });
      }
      const ks = Object.keys(val);
      let k = ks.length;
      while (k--) {
        const $cond = ks[k];
        const nested = val[$cond];
        if ($cond === "$not") {
          if (nested && schematype && !schematype.caster) {
            const _keys = Object.keys(nested);
            if (_keys.length && isOperator(_keys[0])) {
              for (const key of Object.keys(nested)) {
                nested[key] = schematype.castForQueryWrapper({
                  $conditional: key,
                  val: nested[key],
                  context: ctx
                });
              }
            } else {
              val[$cond] = schematype.castForQueryWrapper({
                $conditional: $cond,
                val: nested,
                context: ctx
              });
            }
            continue;
          }
        } else {
          val[$cond] = schematype.castForQueryWrapper({
            $conditional: $cond,
            val: nested,
            context: ctx
          });
        }
      }
      return val;
    };
  }
});

// node_modules/mongoose/lib/helpers/schema/getPath.js
var require_getPath = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/getPath.js"(exports2, module2) {
    "use strict";
    module2.exports = function getPath(schema, path) {
      let schematype = schema.path(path);
      if (schematype != null) {
        return schematype;
      }
      const pieces = path.split(".");
      let cur = "";
      let isArray = false;
      for (const piece of pieces) {
        if (/^\d+$/.test(piece) && isArray) {
          continue;
        }
        cur = cur.length === 0 ? piece : cur + "." + piece;
        schematype = schema.path(cur);
        if (schematype != null && schematype.schema) {
          schema = schematype.schema;
          cur = "";
          if (schematype.$isMongooseDocumentArray) {
            isArray = true;
          }
        }
      }
      return schematype;
    };
  }
});

// node_modules/mongoose/lib/helpers/update/modifiedPaths.js
var require_modifiedPaths = __commonJS({
  "node_modules/mongoose/lib/helpers/update/modifiedPaths.js"(exports2, module2) {
    "use strict";
    var _modifiedPaths = require_common3().modifiedPaths;
    module2.exports = function modifiedPaths(update) {
      const keys = Object.keys(update);
      const res = {};
      const withoutDollarKeys = {};
      for (const key of keys) {
        if (key.startsWith("$")) {
          _modifiedPaths(update[key], "", res);
          continue;
        }
        withoutDollarKeys[key] = update[key];
      }
      _modifiedPaths(withoutDollarKeys, "", res);
      return res;
    };
  }
});

// node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js
var require_updatedPathsByArrayFilter = __commonJS({
  "node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js"(exports2, module2) {
    "use strict";
    var modifiedPaths = require_modifiedPaths();
    module2.exports = function updatedPathsByArrayFilter(update) {
      const updatedPaths = modifiedPaths(update);
      return Object.keys(updatedPaths).reduce((cur, path) => {
        const matches = path.match(/\$\[[^\]]+\]/g);
        if (matches == null) {
          return cur;
        }
        for (const match of matches) {
          const firstMatch = path.indexOf(match);
          if (firstMatch !== path.lastIndexOf(match)) {
            throw new Error(`Path '${path}' contains the same array filter multiple times`);
          }
          cur[match.substring(2, match.length - 1)] = path.substr(0, firstMatch - 1).replace(/\$\[[^\]]+\]/g, "0");
        }
        return cur;
      }, {});
    };
  }
});

// node_modules/mongoose/lib/helpers/update/castArrayFilters.js
var require_castArrayFilters = __commonJS({
  "node_modules/mongoose/lib/helpers/update/castArrayFilters.js"(exports2, module2) {
    "use strict";
    var castFilterPath = require_castFilterPath();
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var getPath = require_getPath();
    var updatedPathsByArrayFilter = require_updatedPathsByArrayFilter();
    module2.exports = function castArrayFilters(query) {
      const arrayFilters = query.options.arrayFilters;
      if (!Array.isArray(arrayFilters)) {
        return;
      }
      const update = query.getUpdate();
      const schema = query.schema;
      const strictQuery = schema.options.strictQuery;
      const updatedPathsByFilter = updatedPathsByArrayFilter(update);
      for (const filter of arrayFilters) {
        if (filter == null) {
          throw new Error(`Got null array filter in ${arrayFilters}`);
        }
        for (const key of Object.keys(filter)) {
          if (filter[key] == null) {
            continue;
          }
          const dot = key.indexOf(".");
          let filterPath = dot === -1 ? updatedPathsByFilter[key] + ".0" : updatedPathsByFilter[key.substr(0, dot)] + ".0" + key.substr(dot);
          if (filterPath == null) {
            throw new Error(`Filter path not found for ${key}`);
          }
          filterPath = cleanPositionalOperators(filterPath);
          const schematype = getPath(schema, filterPath);
          if (schematype == null) {
            if (!strictQuery) {
              return;
            }
            throw new Error(`Could not find path "${filterPath}" in schema`);
          }
          if (typeof filter[key] === "object") {
            filter[key] = castFilterPath(query, schematype, filter[key]);
          } else {
            filter[key] = schematype.castForQuery(filter[key]);
          }
        }
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js
var require_getEmbeddedDiscriminatorPath2 = __commonJS({
  "node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js"(exports2, module2) {
    "use strict";
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var get = require_get();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var updatedPathsByArrayFilter = require_updatedPathsByArrayFilter();
    module2.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {
      const parts = path.split(".");
      let schematype = null;
      let type = "adhocOrUndefined";
      filter = filter || {};
      update = update || {};
      const arrayFilters = options != null && Array.isArray(options.arrayFilters) ? options.arrayFilters : [];
      const updatedPathsByFilter = updatedPathsByArrayFilter(update);
      for (let i = 0; i < parts.length; ++i) {
        const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join("."));
        schematype = schema.path(subpath);
        if (schematype == null) {
          continue;
        }
        type = schema.pathType(subpath);
        if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) && schematype.schema.discriminators != null) {
          const key = get(schematype, "schema.options.discriminatorKey");
          const discriminatorValuePath = subpath + "." + key;
          const discriminatorFilterPath = discriminatorValuePath.replace(/\.\d+\./, ".");
          let discriminatorKey = null;
          if (discriminatorValuePath in filter) {
            discriminatorKey = filter[discriminatorValuePath];
          }
          if (discriminatorFilterPath in filter) {
            discriminatorKey = filter[discriminatorFilterPath];
          }
          const wrapperPath = subpath.replace(/\.\d+$/, "");
          if (schematype.$isMongooseDocumentArrayElement && get(filter[wrapperPath], "$elemMatch." + key) != null) {
            discriminatorKey = filter[wrapperPath].$elemMatch[key];
          }
          if (discriminatorValuePath in update) {
            discriminatorKey = update[discriminatorValuePath];
          }
          for (const filterKey of Object.keys(updatedPathsByFilter)) {
            const schemaKey = updatedPathsByFilter[filterKey] + "." + key;
            const arrayFilterKey = filterKey + "." + key;
            if (schemaKey === discriminatorFilterPath) {
              const filter2 = arrayFilters.find((filter3) => filter3.hasOwnProperty(arrayFilterKey));
              if (filter2 != null) {
                discriminatorKey = filter2[arrayFilterKey];
              }
            }
          }
          if (discriminatorKey == null) {
            continue;
          }
          const discriminatorSchema = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey).schema;
          const rest = parts.slice(i + 1).join(".");
          schematype = discriminatorSchema.path(rest);
          if (schematype != null) {
            type = discriminatorSchema._getPathType(rest);
            break;
          }
        }
      }
      return { type, schematype };
    };
  }
});

// node_modules/mongoose/lib/helpers/query/handleImmutable.js
var require_handleImmutable2 = __commonJS({
  "node_modules/mongoose/lib/helpers/query/handleImmutable.js"(exports2, module2) {
    "use strict";
    var StrictModeError = require_strict();
    module2.exports = function handleImmutable(schematype, strict, obj, key, fullPath, ctx) {
      if (schematype == null || !schematype.options || !schematype.options.immutable) {
        return false;
      }
      let immutable = schematype.options.immutable;
      if (typeof immutable === "function") {
        immutable = immutable.call(ctx, ctx);
      }
      if (!immutable) {
        return false;
      }
      if (strict === false) {
        return false;
      }
      if (strict === "throw") {
        throw new StrictModeError(null, `Field ${fullPath} is immutable and strict = 'throw'`);
      }
      delete obj[key];
      return true;
    };
  }
});

// node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js
var require_moveImmutableProperties = __commonJS({
  "node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    module2.exports = function moveImmutableProperties(schema, update, ctx) {
      if (update == null) {
        return;
      }
      const keys = Object.keys(update);
      for (const key of keys) {
        const isDollarKey = key.startsWith("$");
        if (key === "$set") {
          const updatedPaths = Object.keys(update[key]);
          for (const path of updatedPaths) {
            _walkUpdatePath(schema, update[key], path, update, ctx);
          }
        } else if (!isDollarKey) {
          _walkUpdatePath(schema, update, key, update, ctx);
        }
      }
    };
    function _walkUpdatePath(schema, op, path, update, ctx) {
      const schematype = schema.path(path);
      if (schematype == null) {
        return;
      }
      let immutable = get(schematype, "options.immutable", null);
      if (immutable == null) {
        return;
      }
      if (typeof immutable === "function") {
        immutable = immutable.call(ctx, ctx);
      }
      if (!immutable) {
        return;
      }
      update.$setOnInsert = update.$setOnInsert || {};
      update.$setOnInsert[path] = op[path];
      delete op[path];
    }
  }
});

// node_modules/mongoose/lib/helpers/path/setDottedPath.js
var require_setDottedPath = __commonJS({
  "node_modules/mongoose/lib/helpers/path/setDottedPath.js"(exports2, module2) {
    "use strict";
    module2.exports = function setDottedPath(obj, path, val) {
      const parts = path.split(".");
      let cur = obj;
      for (const part of parts.slice(0, -1)) {
        if (cur[part] == null) {
          cur[part] = {};
        }
        cur = cur[part];
      }
      const last = parts[parts.length - 1];
      cur[last] = val;
    };
  }
});

// node_modules/mongoose/lib/helpers/query/castUpdate.js
var require_castUpdate = __commonJS({
  "node_modules/mongoose/lib/helpers/query/castUpdate.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    var MongooseError = require_mongooseError();
    var StrictModeError = require_strict();
    var ValidationError = require_validation();
    var castNumber = require_number();
    var cast = require_cast2();
    var getConstructorName = require_getConstructorName();
    var getEmbeddedDiscriminatorPath = require_getEmbeddedDiscriminatorPath2();
    var handleImmutable = require_handleImmutable2();
    var moveImmutableProperties = require_moveImmutableProperties();
    var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
    var setDottedPath = require_setDottedPath();
    var utils2 = require_utils8();
    module2.exports = function castUpdate(schema, obj, options, context, filter) {
      if (obj == null) {
        return void 0;
      }
      options = options || {};
      if (Array.isArray(obj)) {
        const len = obj.length;
        for (let i2 = 0; i2 < len; ++i2) {
          const ops2 = Object.keys(obj[i2]);
          for (const op of ops2) {
            obj[i2][op] = castPipelineOperator(op, obj[i2][op]);
          }
        }
        return obj;
      }
      if (options.upsert) {
        moveImmutableProperties(schema, obj, context);
      }
      const ops = Object.keys(obj);
      let i = ops.length;
      const ret2 = {};
      let val;
      let hasDollarKey = false;
      const overwrite = options.overwrite;
      filter = filter || {};
      while (i--) {
        const op = ops[i];
        if (op[0] !== "$" && !overwrite) {
          if (!ret2.$set) {
            if (obj.$set) {
              ret2.$set = obj.$set;
            } else {
              ret2.$set = {};
            }
          }
          ret2.$set[op] = obj[op];
          ops.splice(i, 1);
          if (!~ops.indexOf("$set"))
            ops.push("$set");
        } else if (op === "$set") {
          if (!ret2.$set) {
            ret2[op] = obj[op];
          }
        } else {
          ret2[op] = obj[op];
        }
      }
      i = ops.length;
      while (i--) {
        const op = ops[i];
        val = ret2[op];
        hasDollarKey = hasDollarKey || op.startsWith("$");
        if (val && typeof val === "object" && !Buffer.isBuffer(val) && (!overwrite || hasDollarKey)) {
          walkUpdatePath(schema, val, op, options, context, filter);
        } else if (overwrite && ret2 && typeof ret2 === "object") {
          walkUpdatePath(schema, ret2, "$set", options, context, filter);
        } else {
          const msg = "Invalid atomic update value for " + op + ". Expected an object, received " + typeof val;
          throw new Error(msg);
        }
        if (op.startsWith("$") && utils2.isEmptyObject(val)) {
          delete ret2[op];
        }
      }
      if (Object.keys(ret2).length === 0 && options.upsert && Object.keys(filter).length > 0) {
        return { $setOnInsert: filter };
      }
      return ret2;
    };
    function castPipelineOperator(op, val) {
      if (op === "$unset") {
        if (!Array.isArray(val) || val.find((v) => typeof v !== "string")) {
          throw new MongooseError("Invalid $unset in pipeline, must be an array of strings");
        }
        return val;
      }
      if (op === "$project") {
        if (val == null || typeof val !== "object") {
          throw new MongooseError("Invalid $project in pipeline, must be an object");
        }
        return val;
      }
      if (op === "$addFields" || op === "$set") {
        if (val == null || typeof val !== "object") {
          throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
        }
        return val;
      } else if (op === "$replaceRoot" || op === "$replaceWith") {
        if (val == null || typeof val !== "object") {
          throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
        }
        return val;
      }
      throw new MongooseError('Invalid update pipeline operator: "' + op + '"');
    }
    function walkUpdatePath(schema, obj, op, options, context, filter, pref) {
      const strict = options.strict;
      const prefix = pref ? pref + "." : "";
      const keys = Object.keys(obj);
      let i = keys.length;
      let hasKeys = false;
      let schematype;
      let key;
      let val;
      let aggregatedError = null;
      let useNestedStrict;
      if (options.useNestedStrict === void 0) {
        useNestedStrict = schema.options.useNestedStrict;
      } else {
        useNestedStrict = options.useNestedStrict;
      }
      while (i--) {
        key = keys[i];
        val = obj[key];
        if (op === "$pull") {
          schematype = schema._getSchema(prefix + key);
          if (schematype != null && schematype.schema != null) {
            obj[key] = cast(schematype.schema, obj[key], options, context);
            hasKeys = true;
            continue;
          }
        }
        if (getConstructorName(val) === "Object") {
          schematype = schema._getSchema(prefix + key);
          if (schematype == null) {
            const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);
            if (_res.schematype != null) {
              schematype = _res.schematype;
            }
          }
          if (op !== "$setOnInsert" && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {
            continue;
          }
          if (schematype && schematype.caster && op in castOps) {
            if ("$each" in val) {
              hasKeys = true;
              try {
                obj[key] = {
                  $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)
                };
              } catch (error) {
                aggregatedError = _handleCastError(error, context, key, aggregatedError);
              }
              if (val.$slice != null) {
                obj[key].$slice = val.$slice | 0;
              }
              if (val.$sort) {
                obj[key].$sort = val.$sort;
              }
              if (val.$position != null) {
                obj[key].$position = castNumber(val.$position);
              }
            } else {
              if (schematype != null && schematype.$isSingleNested) {
                let _strict = strict;
                if (useNestedStrict !== false && schematype.schema.options.hasOwnProperty("strict")) {
                  _strict = schematype.schema.options.strict;
                } else if (useNestedStrict === false) {
                  _strict = schema.options.strict;
                }
                try {
                  obj[key] = schematype.castForQuery(val, context, { strict: _strict });
                } catch (error) {
                  aggregatedError = _handleCastError(error, context, key, aggregatedError);
                }
              } else {
                try {
                  obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
                } catch (error) {
                  aggregatedError = _handleCastError(error, context, key, aggregatedError);
                }
              }
              if (options.omitUndefined && obj[key] === void 0) {
                delete obj[key];
                continue;
              }
              hasKeys = true;
            }
          } else if (op === "$currentDate" || op in castOps && schematype) {
            try {
              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
            } catch (error) {
              aggregatedError = _handleCastError(error, context, key, aggregatedError);
            }
            if (options.omitUndefined && obj[key] === void 0) {
              delete obj[key];
              continue;
            }
            hasKeys = true;
          } else {
            const pathToCheck = prefix + key;
            const v = schema._getPathType(pathToCheck);
            let _strict = strict;
            if (useNestedStrict && v && v.schema && "strict" in v.schema.options) {
              _strict = v.schema.options.strict;
            }
            if (v.pathType === "undefined") {
              if (_strict === "throw") {
                throw new StrictModeError(pathToCheck);
              } else if (_strict) {
                delete obj[key];
                continue;
              }
            }
            hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) || utils2.isObject(val) && Object.keys(val).length === 0;
          }
        } else {
          const checkPath = key === "$each" || key === "$or" || key === "$and" || key === "$in" ? pref : prefix + key;
          schematype = schema._getSchema(checkPath);
          if (op !== "$setOnInsert" && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {
            continue;
          }
          let pathDetails = schema._getPathType(checkPath);
          if (schematype == null) {
            const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);
            if (_res.schematype != null) {
              schematype = _res.schematype;
              pathDetails = _res.type;
            }
          }
          let isStrict = strict;
          if (useNestedStrict && pathDetails && pathDetails.schema && "strict" in pathDetails.schema.options) {
            isStrict = pathDetails.schema.options.strict;
          }
          const skip = isStrict && !schematype && !/real|nested/.test(pathDetails.pathType);
          if (skip) {
            if (isStrict === "throw" && schema.virtuals[checkPath] == null) {
              throw new StrictModeError(prefix + key);
            } else {
              delete obj[key];
            }
          } else {
            if (op === "$rename") {
              hasKeys = true;
              continue;
            }
            try {
              if (prefix.length === 0 || key.indexOf(".") === -1) {
                obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
              } else {
                setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));
                delete obj[key];
              }
            } catch (error) {
              aggregatedError = _handleCastError(error, context, key, aggregatedError);
            }
            if (Array.isArray(obj[key]) && (op === "$addToSet" || op === "$push") && key !== "$each") {
              if (schematype && schematype.caster && !schematype.caster.$isMongooseArray) {
                obj[key] = { $each: obj[key] };
              }
            }
            if (options.omitUndefined && obj[key] === void 0) {
              delete obj[key];
              continue;
            }
            hasKeys = true;
          }
        }
      }
      if (aggregatedError != null) {
        throw aggregatedError;
      }
      return hasKeys;
    }
    function _handleCastError(error, query, key, aggregatedError) {
      if (typeof query !== "object" || !query.options.multipleCastError) {
        throw error;
      }
      aggregatedError = aggregatedError || new ValidationError();
      aggregatedError.addError(key, error);
      return aggregatedError;
    }
    var numberOps = {
      $pop: 1,
      $inc: 1
    };
    var noCastOps = {
      $unset: 1
    };
    var castOps = {
      $push: 1,
      $addToSet: 1,
      $set: 1,
      $setOnInsert: 1
    };
    var overwriteOps = {
      $set: 1,
      $setOnInsert: 1
    };
    function castUpdateVal(schema, val, op, $conditional, context, path) {
      if (!schema) {
        if (op in numberOps) {
          try {
            return castNumber(val);
          } catch (err) {
            throw new CastError("number", val, path);
          }
        }
        return val;
      }
      const cond = schema.caster && op in castOps && (utils2.isObject(val) || Array.isArray(val));
      if (cond && !overwriteOps[op]) {
        let schemaArrayDepth = 0;
        let cur = schema;
        while (cur.$isMongooseArray) {
          ++schemaArrayDepth;
          cur = cur.caster;
        }
        let arrayDepth = 0;
        let _val = val;
        while (Array.isArray(_val)) {
          ++arrayDepth;
          _val = _val[0];
        }
        const additionalNesting = schemaArrayDepth - arrayDepth;
        while (arrayDepth < schemaArrayDepth) {
          val = [val];
          ++arrayDepth;
        }
        let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);
        for (let i = 0; i < additionalNesting; ++i) {
          tmp = tmp[0];
        }
        return tmp;
      }
      if (op in noCastOps) {
        return val;
      }
      if (op in numberOps) {
        if (val == null) {
          throw new CastError("number", val, schema.path);
        }
        if (op === "$inc") {
          return schema.castForQueryWrapper({
            val,
            context
          });
        }
        try {
          return castNumber(val);
        } catch (error) {
          throw new CastError("number", val, schema.path);
        }
      }
      if (op === "$currentDate") {
        if (typeof val === "object") {
          return { $type: val.$type };
        }
        return Boolean(val);
      }
      if (/^\$/.test($conditional)) {
        return schema.castForQueryWrapper({
          $conditional,
          val,
          context
        });
      }
      if (overwriteOps[op]) {
        return schema.castForQueryWrapper({
          val,
          context,
          $skipQueryCastForUpdate: val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\d+$/),
          $applySetters: schema[schemaMixedSymbol] != null
        });
      }
      return schema.castForQueryWrapper({ val, context });
    }
  }
});

// node_modules/mongoose/lib/helpers/query/completeMany.js
var require_completeMany = __commonJS({
  "node_modules/mongoose/lib/helpers/query/completeMany.js"(exports2, module2) {
    "use strict";
    var helpers = require_queryhelpers();
    var immediate = require_immediate();
    module2.exports = completeMany;
    function completeMany(model2, docs, fields, userProvidedFields, opts, callback) {
      const arr = [];
      let count = docs.length;
      const len = count;
      let error = null;
      function init(_error) {
        if (_error != null) {
          error = error || _error;
        }
        if (error != null) {
          --count || immediate(() => callback(error));
          return;
        }
        --count || immediate(() => callback(error, arr));
      }
      for (let i = 0; i < len; ++i) {
        arr[i] = helpers.createModel(model2, docs[i], fields, userProvidedFields);
        try {
          arr[i].init(docs[i], opts, init);
        } catch (error2) {
          init(error2);
        }
        if (opts.session != null) {
          arr[i].$session(opts.session);
        }
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/query/hasDollarKeys.js
var require_hasDollarKeys = __commonJS({
  "node_modules/mongoose/lib/helpers/query/hasDollarKeys.js"(exports2, module2) {
    "use strict";
    module2.exports = function(obj) {
      if (obj == null) {
        return false;
      }
      const keys = Object.keys(obj);
      const len = keys.length;
      for (let i = 0; i < len; ++i) {
        if (keys[i].startsWith("$")) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/mongoose/lib/helpers/projection/isInclusive.js
var require_isInclusive = __commonJS({
  "node_modules/mongoose/lib/helpers/projection/isInclusive.js"(exports2, module2) {
    "use strict";
    var isDefiningProjection = require_isDefiningProjection();
    module2.exports = function isInclusive(projection) {
      if (projection == null) {
        return false;
      }
      const props = Object.keys(projection);
      const numProps = props.length;
      if (numProps === 0) {
        return false;
      }
      for (let i = 0; i < numProps; ++i) {
        const prop = props[i];
        if (prop.startsWith("+")) {
          continue;
        }
        if (isDefiningProjection(projection[prop]) && !!projection[prop]) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/mongoose/lib/helpers/projection/parseProjection.js
var require_parseProjection = __commonJS({
  "node_modules/mongoose/lib/helpers/projection/parseProjection.js"(exports2, module2) {
    "use strict";
    module2.exports = function parseProjection(v, retainMinusPaths) {
      const type = typeof v;
      if (type === "string") {
        v = v.split(/\s+/);
      }
      if (!Array.isArray(v) && Object.prototype.toString.call(v) !== "[object Arguments]") {
        return v;
      }
      const len = v.length;
      const ret2 = {};
      for (let i = 0; i < len; ++i) {
        let field = v[i];
        if (!field) {
          continue;
        }
        const include = field[0] == "-" ? 0 : 1;
        if (!retainMinusPaths && include === 0) {
          field = field.substring(1);
        }
        ret2[field] = include;
      }
      return ret2;
    };
  }
});

// node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js
var require_removeUnusedArrayFilters = __commonJS({
  "node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js"(exports2, module2) {
    "use strict";
    module2.exports = function removeUnusedArrayFilters(update, arrayFilters) {
      const updateKeys = Object.keys(update).map((key) => Object.keys(update[key])).reduce((cur, arr) => cur.concat(arr), []);
      return arrayFilters.filter((obj) => {
        const firstKey = Object.keys(obj)[0];
        const firstDot = firstKey.indexOf(".");
        const arrayFilterKey = firstDot === -1 ? firstKey : firstKey.slice(0, firstDot);
        return updateKeys.find((key) => key.includes("$[" + arrayFilterKey + "]")) != null;
      });
    };
  }
});

// node_modules/mongoose/lib/helpers/query/sanitizeProjection.js
var require_sanitizeProjection = __commonJS({
  "node_modules/mongoose/lib/helpers/query/sanitizeProjection.js"(exports2, module2) {
    "use strict";
    module2.exports = function sanitizeProjection(projection) {
      if (projection == null) {
        return;
      }
      const keys = Object.keys(projection);
      for (let i = 0; i < keys.length; ++i) {
        if (typeof projection[keys[i]] === "string") {
          projection[keys[i]] = 1;
        }
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js
var require_selectPopulatedFields = __commonJS({
  "node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js"(exports2, module2) {
    "use strict";
    var isExclusive = require_isExclusive();
    var isInclusive = require_isInclusive();
    module2.exports = function selectPopulatedFields(fields, userProvidedFields, populateOptions) {
      if (populateOptions == null) {
        return;
      }
      const paths = Object.keys(populateOptions);
      userProvidedFields = userProvidedFields || {};
      if (isInclusive(fields)) {
        for (const path of paths) {
          if (!isPathInFields(userProvidedFields, path)) {
            fields[path] = 1;
          } else if (userProvidedFields[path] === 0) {
            delete fields[path];
          }
        }
      } else if (isExclusive(fields)) {
        for (const path of paths) {
          if (userProvidedFields[path] == null) {
            delete fields[path];
          }
        }
      }
    };
    function isPathInFields(userProvidedFields, path) {
      const pieces = path.split(".");
      const len = pieces.length;
      let cur = pieces[0];
      for (let i = 1; i < len; ++i) {
        if (userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null) {
          return true;
        }
        cur += "." + pieces[i];
      }
      return userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null;
    }
  }
});

// node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js
var require_setDefaultsOnInsert = __commonJS({
  "node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js"(exports2, module2) {
    "use strict";
    var modifiedPaths = require_common3().modifiedPaths;
    var get = require_get();
    module2.exports = function(filter, schema, castedDoc, options) {
      options = options || {};
      const shouldSetDefaultsOnInsert = options.setDefaultsOnInsert != null ? options.setDefaultsOnInsert : schema.base.options.setDefaultsOnInsert;
      if (!options.upsert || !shouldSetDefaultsOnInsert) {
        return castedDoc;
      }
      const keys = Object.keys(castedDoc || {});
      const updatedKeys = {};
      const updatedValues = {};
      const numKeys = keys.length;
      const modified = {};
      let hasDollarUpdate = false;
      for (let i = 0; i < numKeys; ++i) {
        if (keys[i].startsWith("$")) {
          modifiedPaths(castedDoc[keys[i]], "", modified);
          hasDollarUpdate = true;
        }
      }
      if (!hasDollarUpdate) {
        modifiedPaths(castedDoc, "", modified);
      }
      const paths = Object.keys(filter);
      const numPaths = paths.length;
      for (let i = 0; i < numPaths; ++i) {
        const path = paths[i];
        const condition = filter[path];
        if (condition && typeof condition === "object") {
          const conditionKeys = Object.keys(condition);
          const numConditionKeys = conditionKeys.length;
          let hasDollarKey = false;
          for (let j = 0; j < numConditionKeys; ++j) {
            if (conditionKeys[j].startsWith("$")) {
              hasDollarKey = true;
              break;
            }
          }
          if (hasDollarKey) {
            continue;
          }
        }
        updatedKeys[path] = true;
        modified[path] = true;
      }
      if (options && options.overwrite && !hasDollarUpdate) {
        return castedDoc;
      }
      schema.eachPath(function(path, schemaType) {
        const isUnderneathMap = schemaType.path.endsWith(".$*") || schemaType.path.indexOf(".$*.") !== -1;
        if (schemaType.$isSingleNested && !isUnderneathMap) {
          schemaType.schema.eachPath(function(_path, _schemaType) {
            if (_path === "_id" && _schemaType.auto) {
              return;
            }
            const def = _schemaType.getDefault(null, true);
            if (!isModified(modified, path + "." + _path) && typeof def !== "undefined") {
              castedDoc = castedDoc || {};
              castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};
              castedDoc.$setOnInsert[path + "." + _path] = def;
              updatedValues[path + "." + _path] = def;
            }
          });
        } else {
          const def = schemaType.getDefault(null, true);
          if (!isModified(modified, path) && typeof def !== "undefined") {
            castedDoc = castedDoc || {};
            castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};
            if (get(castedDoc, path) == null) {
              castedDoc.$setOnInsert[path] = def;
            }
            updatedValues[path] = def;
          }
        }
      });
      return castedDoc;
    };
    function isModified(modified, path) {
      if (modified[path]) {
        return true;
      }
      const sp = path.split(".");
      let cur = sp[0];
      for (let i = 1; i < sp.length; ++i) {
        if (modified[cur]) {
          return true;
        }
        cur += "." + sp[i];
      }
      return false;
    }
  }
});

// node_modules/mongoose/lib/helpers/updateValidators.js
var require_updateValidators = __commonJS({
  "node_modules/mongoose/lib/helpers/updateValidators.js"(exports2, module2) {
    "use strict";
    var ValidationError = require_validation();
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var flatten = require_common3().flatten;
    var modifiedPaths = require_common3().modifiedPaths;
    module2.exports = function(query, schema, castedDoc, options, callback) {
      let _keys;
      const keys = Object.keys(castedDoc || {});
      let updatedKeys = {};
      let updatedValues = {};
      const isPull = {};
      const arrayAtomicUpdates = {};
      const numKeys = keys.length;
      let hasDollarUpdate = false;
      const modified = {};
      let currentUpdate;
      let key;
      let i;
      for (i = 0; i < numKeys; ++i) {
        if (keys[i].startsWith("$")) {
          hasDollarUpdate = true;
          if (keys[i] === "$push" || keys[i] === "$addToSet") {
            _keys = Object.keys(castedDoc[keys[i]]);
            for (let ii = 0; ii < _keys.length; ++ii) {
              currentUpdate = castedDoc[keys[i]][_keys[ii]];
              if (currentUpdate && currentUpdate.$each) {
                arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat(currentUpdate.$each);
              } else {
                arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat([currentUpdate]);
              }
            }
            continue;
          }
          modifiedPaths(castedDoc[keys[i]], "", modified);
          const flat = flatten(castedDoc[keys[i]], null, null, schema);
          const paths = Object.keys(flat);
          const numPaths = paths.length;
          for (let j = 0; j < numPaths; ++j) {
            const updatedPath = cleanPositionalOperators(paths[j]);
            key = keys[i];
            if (updatedPath.includes("$")) {
              continue;
            }
            if (key === "$set" || key === "$setOnInsert" || key === "$pull" || key === "$pullAll") {
              updatedValues[updatedPath] = flat[paths[j]];
              isPull[updatedPath] = key === "$pull" || key === "$pullAll";
            } else if (key === "$unset") {
              updatedValues[updatedPath] = void 0;
            }
            updatedKeys[updatedPath] = true;
          }
        }
      }
      if (!hasDollarUpdate) {
        modifiedPaths(castedDoc, "", modified);
        updatedValues = flatten(castedDoc, null, null, schema);
        updatedKeys = Object.keys(updatedValues);
      }
      const updates = Object.keys(updatedValues);
      const numUpdates = updates.length;
      const validatorsToExecute = [];
      const validationErrors = [];
      const alreadyValidated = [];
      const context = options && options.context === "query" ? query : null;
      function iter(i2, v) {
        const schemaPath = schema._getSchema(updates[i2]);
        if (schemaPath == null) {
          return;
        }
        if (schemaPath.instance === "Mixed" && schemaPath.path !== updates[i2]) {
          return;
        }
        if (v && Array.isArray(v.$in)) {
          v.$in.forEach((v2, i3) => {
            validatorsToExecute.push(function(callback2) {
              schemaPath.doValidate(v2, function(err) {
                if (err) {
                  err.path = updates[i3] + ".$in." + i3;
                  validationErrors.push(err);
                }
                callback2(null);
              }, context, { updateValidator: true });
            });
          });
        } else {
          if (isPull[updates[i2]] && schemaPath.$isMongooseArray) {
            return;
          }
          if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {
            alreadyValidated.push(updates[i2]);
            validatorsToExecute.push(function(callback2) {
              schemaPath.doValidate(v, function(err) {
                if (err) {
                  err.path = updates[i2];
                  validationErrors.push(err);
                  return callback2(null);
                }
                v.validate(function(err2) {
                  if (err2) {
                    if (err2.errors) {
                      for (const key2 of Object.keys(err2.errors)) {
                        const _err = err2.errors[key2];
                        _err.path = updates[i2] + "." + key2;
                        validationErrors.push(_err);
                      }
                    } else {
                      err2.path = updates[i2];
                      validationErrors.push(err2);
                    }
                  }
                  callback2(null);
                });
              }, context, { updateValidator: true });
            });
          } else {
            validatorsToExecute.push(function(callback2) {
              for (const path of alreadyValidated) {
                if (updates[i2].startsWith(path + ".")) {
                  return callback2(null);
                }
              }
              schemaPath.doValidate(v, function(err) {
                if (schemaPath.schema != null && schemaPath.schema.options.storeSubdocValidationError === false && err instanceof ValidationError) {
                  return callback2(null);
                }
                if (err) {
                  err.path = updates[i2];
                  validationErrors.push(err);
                }
                callback2(null);
              }, context, { updateValidator: true });
            });
          }
        }
      }
      for (i = 0; i < numUpdates; ++i) {
        iter(i, updatedValues[updates[i]]);
      }
      const arrayUpdates = Object.keys(arrayAtomicUpdates);
      for (const arrayUpdate of arrayUpdates) {
        let schemaPath = schema._getSchema(arrayUpdate);
        if (schemaPath && schemaPath.$isMongooseDocumentArray) {
          validatorsToExecute.push(function(callback2) {
            schemaPath.doValidate(arrayAtomicUpdates[arrayUpdate], getValidationCallback(arrayUpdate, validationErrors, callback2), options && options.context === "query" ? query : null);
          });
        } else {
          schemaPath = schema._getSchema(arrayUpdate + ".0");
          for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {
            validatorsToExecute.push(function(callback2) {
              schemaPath.doValidate(atomicUpdate, getValidationCallback(arrayUpdate, validationErrors, callback2), options && options.context === "query" ? query : null, { updateValidator: true });
            });
          }
        }
      }
      if (callback != null) {
        let numValidators = validatorsToExecute.length;
        if (numValidators === 0) {
          return _done(callback);
        }
        for (const validator of validatorsToExecute) {
          validator(function() {
            if (--numValidators <= 0) {
              _done(callback);
            }
          });
        }
        return;
      }
      return function(callback2) {
        let numValidators = validatorsToExecute.length;
        if (numValidators === 0) {
          return _done(callback2);
        }
        for (const validator of validatorsToExecute) {
          validator(function() {
            if (--numValidators <= 0) {
              _done(callback2);
            }
          });
        }
      };
      function _done(callback2) {
        if (validationErrors.length) {
          const err = new ValidationError(null);
          for (const validationError of validationErrors) {
            err.addError(validationError.path, validationError);
          }
          return callback2(err);
        }
        callback2(null);
      }
      function getValidationCallback(arrayUpdate, validationErrors2, callback2) {
        return function(err) {
          if (err) {
            err.path = arrayUpdate;
            validationErrors2.push(err);
          }
          callback2(null);
        };
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/query/wrapThunk.js
var require_wrapThunk = __commonJS({
  "node_modules/mongoose/lib/helpers/query/wrapThunk.js"(exports2, module2) {
    "use strict";
    module2.exports = function wrapThunk(fn) {
      return function _wrappedThunk(cb) {
        ++this._executionCount;
        fn.call(this, cb);
      };
    };
  }
});

// node_modules/mongoose/lib/query.js
var require_query3 = __commonJS({
  "node_modules/mongoose/lib/query.js"(exports2, module2) {
    "use strict";
    var CastError = require_cast();
    var DocumentNotFoundError = require_notFound();
    var Kareem = require_kareem();
    var MongooseError = require_mongooseError();
    var ObjectParameterError = require_objectParameter();
    var QueryCursor = require_QueryCursor();
    var ReadPreference = require_driver().get().ReadPreference;
    var applyGlobalMaxTimeMS = require_applyGlobalMaxTimeMS();
    var applyWriteConcern = require_applyWriteConcern();
    var cast = require_cast2();
    var castArrayFilters = require_castArrayFilters();
    var castUpdate = require_castUpdate();
    var completeMany = require_completeMany();
    var get = require_get();
    var promiseOrCallback = require_promiseOrCallback();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var hasDollarKeys = require_hasDollarKeys();
    var helpers = require_queryhelpers();
    var immediate = require_immediate();
    var isExclusive = require_isExclusive();
    var isInclusive = require_isInclusive();
    var mquery = require_mquery();
    var parseProjection = require_parseProjection();
    var removeUnusedArrayFilters = require_removeUnusedArrayFilters();
    var sanitizeProjection = require_sanitizeProjection();
    var selectPopulatedFields = require_selectPopulatedFields();
    var setDefaultsOnInsert = require_setDefaultsOnInsert();
    var slice = require_sliced();
    var updateValidators = require_updateValidators();
    var util = require("util");
    var utils2 = require_utils8();
    var wrapThunk = require_wrapThunk();
    function Query(conditions, options, model2, collection) {
      if (!this._mongooseOptions) {
        this._mongooseOptions = {};
      }
      options = options || {};
      this._transforms = [];
      this._hooks = new Kareem();
      this._executionCount = 0;
      const keys = Object.keys(options);
      for (const key of keys) {
        this._mongooseOptions[key] = options[key];
      }
      if (collection) {
        this.mongooseCollection = collection;
      }
      if (model2) {
        this.model = model2;
        this.schema = model2.schema;
      }
      if (this.model && this.model._mapreduce) {
        this.lean();
      }
      mquery.call(this, this.mongooseCollection, options);
      if (conditions) {
        this.find(conditions);
      }
      this.options = this.options || {};
      this.$useProjection = true;
      const collation = get(this, "schema.options.collation", null);
      if (collation != null) {
        this.options.collation = collation;
      }
    }
    Query.prototype = new mquery();
    Query.prototype.constructor = Query;
    Query.base = mquery.prototype;
    Query.use$geoWithin = mquery.use$geoWithin;
    Query.prototype.toConstructor = function toConstructor() {
      const model2 = this.model;
      const coll = this.mongooseCollection;
      const CustomQuery = function(criteria, options2) {
        if (!(this instanceof CustomQuery)) {
          return new CustomQuery(criteria, options2);
        }
        this._mongooseOptions = utils2.clone(p._mongooseOptions);
        Query.call(this, criteria, options2 || null, model2, coll);
      };
      util.inherits(CustomQuery, model2.Query);
      const p = CustomQuery.prototype;
      p.options = {};
      const options = Object.assign({}, this.options);
      if (options.sort != null) {
        p.sort(options.sort);
        delete options.sort;
      }
      p.setOptions(options);
      p.op = this.op;
      p._conditions = utils2.clone(this._conditions);
      p._fields = utils2.clone(this._fields);
      p._update = utils2.clone(this._update, {
        flattenDecimals: false
      });
      p._path = this._path;
      p._distinct = this._distinct;
      p._collection = this._collection;
      p._mongooseOptions = this._mongooseOptions;
      return CustomQuery;
    };
    Query.prototype.slice = function() {
      if (arguments.length === 0) {
        return this;
      }
      this._validate("slice");
      let path;
      let val;
      if (arguments.length === 1) {
        const arg = arguments[0];
        if (typeof arg === "object" && !Array.isArray(arg)) {
          const keys = Object.keys(arg);
          const numKeys = keys.length;
          for (let i = 0; i < numKeys; ++i) {
            this.slice(keys[i], arg[keys[i]]);
          }
          return this;
        }
        this._ensurePath("slice");
        path = this._path;
        val = arguments[0];
      } else if (arguments.length === 2) {
        if (typeof arguments[0] === "number") {
          this._ensurePath("slice");
          path = this._path;
          val = slice(arguments);
        } else {
          path = arguments[0];
          val = arguments[1];
        }
      } else if (arguments.length === 3) {
        path = arguments[0];
        val = slice(arguments, 1);
      }
      const p = {};
      p[path] = { $slice: val };
      this.select(p);
      return this;
    };
    Query.prototype.mod = function() {
      let val;
      let path;
      if (arguments.length === 1) {
        this._ensurePath("mod");
        val = arguments[0];
        path = this._path;
      } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {
        this._ensurePath("mod");
        val = slice(arguments);
        path = this._path;
      } else if (arguments.length === 3) {
        val = slice(arguments, 1);
        path = arguments[0];
      } else {
        val = arguments[1];
        path = arguments[0];
      }
      const conds = this._conditions[path] || (this._conditions[path] = {});
      conds.$mod = val;
      return this;
    };
    Query.prototype.projection = function(arg) {
      if (arguments.length === 0) {
        return this._fields;
      }
      this._fields = {};
      this._userProvidedFields = {};
      this.select(arg);
      return this._fields;
    };
    Query.prototype.select = function select() {
      let arg = arguments[0];
      if (!arg)
        return this;
      if (arguments.length !== 1) {
        throw new Error("Invalid select: select only takes 1 argument");
      }
      this._validate("select");
      const fields = this._fields || (this._fields = {});
      const userProvidedFields = this._userProvidedFields || (this._userProvidedFields = {});
      let sanitizeProjection2 = void 0;
      if (this.model != null && utils2.hasUserDefinedProperty(this.model.db.options, "sanitizeProjection")) {
        sanitizeProjection2 = this.model.db.options.sanitizeProjection;
      } else if (this.model != null && utils2.hasUserDefinedProperty(this.model.base.options, "sanitizeProjection")) {
        sanitizeProjection2 = this.model.base.options.sanitizeProjection;
      } else {
        sanitizeProjection2 = this._mongooseOptions.sanitizeProjection;
      }
      arg = parseProjection(arg);
      if (utils2.isObject(arg)) {
        const keys = Object.keys(arg);
        for (let i = 0; i < keys.length; ++i) {
          let value = arg[keys[i]];
          if (typeof value === "string" && sanitizeProjection2) {
            value = 1;
          }
          fields[keys[i]] = value;
          userProvidedFields[keys[i]] = value;
        }
        return this;
      }
      throw new TypeError("Invalid select() argument. Must be string or object.");
    };
    Query.prototype.read = function read(pref, tags) {
      const read2 = new ReadPreference(pref, tags);
      this.options.readPreference = read2;
      return this;
    };
    Query.prototype.session = function session(v) {
      if (v == null) {
        delete this.options.session;
      }
      this.options.session = v;
      return this;
    };
    Query.prototype.writeConcern = function writeConcern(val) {
      if (val == null) {
        delete this.options.writeConcern;
        return this;
      }
      this.options.writeConcern = val;
      return this;
    };
    Query.prototype.w = function w(val) {
      if (val == null) {
        delete this.options.w;
      }
      if (this.options.writeConcern != null) {
        this.options.writeConcern.w = val;
      } else {
        this.options.w = val;
      }
      return this;
    };
    Query.prototype.j = function j(val) {
      if (val == null) {
        delete this.options.j;
      }
      if (this.options.writeConcern != null) {
        this.options.writeConcern.j = val;
      } else {
        this.options.j = val;
      }
      return this;
    };
    Query.prototype.wtimeout = function wtimeout(ms) {
      if (ms == null) {
        delete this.options.wtimeout;
      }
      if (this.options.writeConcern != null) {
        this.options.writeConcern.wtimeout = ms;
      } else {
        this.options.wtimeout = ms;
      }
      return this;
    };
    Query.prototype.getOptions = function() {
      return this.options;
    };
    Query.prototype.setOptions = function(options, overwrite) {
      if (overwrite) {
        this._mongooseOptions = options && utils2.clone(options) || {};
        this.options = options || {};
        if ("populate" in options) {
          this.populate(this._mongooseOptions);
        }
        return this;
      }
      if (options == null) {
        return this;
      }
      if (typeof options !== "object") {
        throw new Error('Options must be an object, got "' + options + '"');
      }
      if (Array.isArray(options.populate)) {
        const populate = options.populate;
        delete options.populate;
        const _numPopulate = populate.length;
        for (let i = 0; i < _numPopulate; ++i) {
          this.populate(populate[i]);
        }
      }
      if ("useFindAndModify" in options) {
        this._mongooseOptions.useFindAndModify = options.useFindAndModify;
        delete options.useFindAndModify;
      }
      if ("omitUndefined" in options) {
        this._mongooseOptions.omitUndefined = options.omitUndefined;
        delete options.omitUndefined;
      }
      if ("setDefaultsOnInsert" in options) {
        this._mongooseOptions.setDefaultsOnInsert = options.setDefaultsOnInsert;
        delete options.setDefaultsOnInsert;
      }
      if ("overwriteDiscriminatorKey" in options) {
        this._mongooseOptions.overwriteDiscriminatorKey = options.overwriteDiscriminatorKey;
        delete options.overwriteDiscriminatorKey;
      }
      if ("sanitizeProjection" in options) {
        if (options.sanitizeProjection && !this._mongooseOptions.sanitizeProjection) {
          sanitizeProjection(this._fields);
        }
        this._mongooseOptions.sanitizeProjection = options.sanitizeProjection;
        delete options.sanitizeProjection;
      }
      if ("defaults" in options) {
        this._mongooseOptions.defaults = options.defaults;
      }
      return Query.base.setOptions.call(this, options);
    };
    Query.prototype.explain = function(verbose) {
      if (arguments.length === 0) {
        this.options.explain = true;
      } else if (verbose === false) {
        delete this.options.explain;
      } else {
        this.options.explain = verbose;
      }
      return this;
    };
    Query.prototype.allowDiskUse = function(v) {
      if (arguments.length === 0) {
        this.options.allowDiskUse = true;
      } else if (v === false) {
        delete this.options.allowDiskUse;
      } else {
        this.options.allowDiskUse = v;
      }
      return this;
    };
    Query.prototype.maxTimeMS = function(ms) {
      this.options.maxTimeMS = ms;
      return this;
    };
    Query.prototype.getFilter = function() {
      return this._conditions;
    };
    Query.prototype.getQuery = function() {
      return this._conditions;
    };
    Query.prototype.setQuery = function(val) {
      this._conditions = val;
    };
    Query.prototype.getUpdate = function() {
      return this._update;
    };
    Query.prototype.setUpdate = function(val) {
      this._update = val;
    };
    Query.prototype._fieldsForExec = function() {
      return utils2.clone(this._fields);
    };
    Query.prototype._updateForExec = function() {
      const update = utils2.clone(this._update, {
        transform: false,
        depopulate: true
      });
      const ops = Object.keys(update);
      let i = ops.length;
      const ret2 = {};
      while (i--) {
        const op = ops[i];
        if (this.options.overwrite) {
          ret2[op] = update[op];
          continue;
        }
        if (op[0] !== "$") {
          if (!ret2.$set) {
            if (update.$set) {
              ret2.$set = update.$set;
            } else {
              ret2.$set = {};
            }
          }
          ret2.$set[op] = update[op];
          ops.splice(i, 1);
          if (!~ops.indexOf("$set"))
            ops.push("$set");
        } else if (op === "$set") {
          if (!ret2.$set) {
            ret2[op] = update[op];
          }
        } else {
          ret2[op] = update[op];
        }
      }
      return ret2;
    };
    Query.prototype._optionsForExec = function(model2) {
      const options = utils2.clone(this.options);
      delete options.populate;
      model2 = model2 || this.model;
      if (!model2) {
        return options;
      }
      const safe = get(model2, "schema.options.safe", null);
      if (!("safe" in options) && safe != null) {
        setSafe(options, safe);
      }
      applyWriteConcern(model2.schema, options);
      const readPreference = get(model2, "schema.options.read");
      if (!("readPreference" in options) && readPreference) {
        options.readPreference = readPreference;
      }
      if (options.upsert !== void 0) {
        options.upsert = !!options.upsert;
      }
      if (options.writeConcern) {
        if (options.j) {
          options.writeConcern.j = options.j;
          delete options.j;
        }
        if (options.w) {
          options.writeConcern.w = options.w;
          delete options.w;
        }
        if (options.wtimeout) {
          options.writeConcern.wtimeout = options.wtimeout;
          delete options.wtimeout;
        }
      }
      return options;
    };
    var safeDeprecationWarning = "Mongoose: the `safe` option is deprecated. Use write concerns instead: http://bit.ly/mongoose-w";
    var setSafe = util.deprecate(function setSafe2(options, safe) {
      options.safe = safe;
    }, safeDeprecationWarning);
    Query.prototype.lean = function(v) {
      this._mongooseOptions.lean = arguments.length ? v : true;
      return this;
    };
    Query.prototype.set = function(path, val) {
      if (typeof path === "object") {
        const keys = Object.keys(path);
        for (const key of keys) {
          this.set(key, path[key]);
        }
        return this;
      }
      this._update = this._update || {};
      this._update.$set = this._update.$set || {};
      this._update.$set[path] = val;
      return this;
    };
    Query.prototype.get = function get2(path) {
      const update = this._update;
      if (update == null) {
        return void 0;
      }
      const $set = update.$set;
      if ($set == null) {
        return update[path];
      }
      if (utils2.hasUserDefinedProperty(update, path)) {
        return update[path];
      }
      if (utils2.hasUserDefinedProperty($set, path)) {
        return $set[path];
      }
      return void 0;
    };
    Query.prototype.error = function error(err) {
      if (arguments.length === 0) {
        return this._error;
      }
      this._error = err;
      return this;
    };
    Query.prototype._unsetCastError = function _unsetCastError() {
      if (this._error != null && !(this._error instanceof CastError)) {
        return;
      }
      return this.error(null);
    };
    Query.prototype.mongooseOptions = function(v) {
      if (arguments.length > 0) {
        this._mongooseOptions = v;
      }
      return this._mongooseOptions;
    };
    Query.prototype._castConditions = function() {
      try {
        this.cast(this.model);
        this._unsetCastError();
      } catch (err) {
        this.error(err);
      }
    };
    function _castArrayFilters(query) {
      try {
        castArrayFilters(query);
      } catch (err) {
        query.error(err);
      }
    }
    Query.prototype._find = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      callback = _wrapThunkCallback(this, callback);
      this._applyPaths();
      this._fields = this._castFields(this._fields);
      const fields = this._fieldsForExec();
      const mongooseOptions = this._mongooseOptions;
      const _this = this;
      const userProvidedFields = _this._userProvidedFields || {};
      applyGlobalMaxTimeMS(this.options, this.model);
      const completeManyOptions = Object.assign({}, {
        session: get(this, "options.session", null)
      });
      const cb = (err, docs) => {
        if (err) {
          return callback(err);
        }
        if (docs.length === 0) {
          return callback(null, docs);
        }
        if (this.options.explain) {
          return callback(null, docs);
        }
        if (!mongooseOptions.populate) {
          return mongooseOptions.lean ? callback(null, docs) : completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, callback);
        }
        const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);
        completeManyOptions.populated = pop;
        _this.model.populate(docs, pop, function(err2, docs2) {
          if (err2)
            return callback(err2);
          return mongooseOptions.lean ? callback(null, docs2) : completeMany(_this.model, docs2, fields, userProvidedFields, completeManyOptions, callback);
        });
      };
      const options = this._optionsForExec();
      options.projection = this._fieldsForExec();
      const filter = this._conditions;
      this._collection.find(filter, options, cb);
      return null;
    });
    Query.prototype.find = function(conditions, callback) {
      this.op = "find";
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      conditions = utils2.toObject(conditions);
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
        prepareDiscriminatorCriteria(this);
      } else if (conditions != null) {
        this.error(new ObjectParameterError(conditions, "filter", "find"));
      }
      if (!callback) {
        return Query.base.find.call(this);
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.merge = function(source) {
      if (!source) {
        return this;
      }
      const opts = { overwrite: true };
      if (source instanceof Query) {
        if (source._conditions) {
          utils2.merge(this._conditions, source._conditions, opts);
        }
        if (source._fields) {
          this._fields || (this._fields = {});
          utils2.merge(this._fields, source._fields, opts);
        }
        if (source.options) {
          this.options || (this.options = {});
          utils2.merge(this.options, source.options, opts);
        }
        if (source._update) {
          this._update || (this._update = {});
          utils2.mergeClone(this._update, source._update);
        }
        if (source._distinct) {
          this._distinct = source._distinct;
        }
        utils2.merge(this._mongooseOptions, source._mongooseOptions);
        return this;
      }
      utils2.merge(this._conditions, source, opts);
      return this;
    };
    Query.prototype.collation = function(value) {
      if (this.options == null) {
        this.options = {};
      }
      this.options.collation = value;
      return this;
    };
    Query.prototype._completeOne = function(doc, res, callback) {
      if (!doc && !this.options.rawResult) {
        return callback(null, null);
      }
      const model2 = this.model;
      const projection = utils2.clone(this._fields);
      const userProvidedFields = this._userProvidedFields || {};
      const mongooseOptions = this._mongooseOptions;
      const options = this.options;
      if (options.explain) {
        return callback(null, doc);
      }
      if (!mongooseOptions.populate) {
        return mongooseOptions.lean ? _completeOneLean(doc, res, options, callback) : completeOne(model2, doc, res, options, projection, userProvidedFields, null, callback);
      }
      const pop = helpers.preparePopulationOptionsMQ(this, this._mongooseOptions);
      model2.populate(doc, pop, (err, doc2) => {
        if (err) {
          return callback(err);
        }
        return mongooseOptions.lean ? _completeOneLean(doc2, res, options, callback) : completeOne(model2, doc2, res, options, projection, userProvidedFields, pop, callback);
      });
    };
    Query.prototype._findOne = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error()) {
        callback(this.error());
        return null;
      }
      this._applyPaths();
      this._fields = this._castFields(this._fields);
      applyGlobalMaxTimeMS(this.options, this.model);
      Query.base.findOne.call(this, {}, (err, doc) => {
        if (err) {
          callback(err);
          return null;
        }
        this._completeOne(doc, null, _wrapThunkCallback(this, callback));
      });
    });
    Query.prototype.findOne = function(conditions, projection, options, callback) {
      this.op = "findOne";
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = null;
        projection = null;
        options = null;
      } else if (typeof projection === "function") {
        callback = projection;
        options = null;
        projection = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      conditions = utils2.toObject(conditions);
      if (options) {
        this.setOptions(options);
      }
      if (projection) {
        this.select(projection);
      }
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
        prepareDiscriminatorCriteria(this);
      } else if (conditions != null) {
        this.error(new ObjectParameterError(conditions, "filter", "findOne"));
      }
      if (!callback) {
        return Query.base.findOne.call(this);
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._count = wrapThunk(function(callback) {
      try {
        this.cast(this.model);
      } catch (err) {
        this.error(err);
      }
      if (this.error()) {
        return callback(this.error());
      }
      applyGlobalMaxTimeMS(this.options, this.model);
      const conds = this._conditions;
      const options = this._optionsForExec();
      this._collection.count(conds, options, utils2.tick(callback));
    });
    Query.prototype._countDocuments = wrapThunk(function(callback) {
      try {
        this.cast(this.model);
      } catch (err) {
        this.error(err);
      }
      if (this.error()) {
        return callback(this.error());
      }
      applyGlobalMaxTimeMS(this.options, this.model);
      const conds = this._conditions;
      const options = this._optionsForExec();
      this._collection.collection.countDocuments(conds, options, utils2.tick(callback));
    });
    Query.prototype._estimatedDocumentCount = wrapThunk(function(callback) {
      if (this.error()) {
        return callback(this.error());
      }
      const options = this._optionsForExec();
      this._collection.collection.estimatedDocumentCount(options, utils2.tick(callback));
    });
    Query.prototype.count = function(filter, callback) {
      this.op = "count";
      if (typeof filter === "function") {
        callback = filter;
        filter = void 0;
      }
      filter = utils2.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
      }
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.estimatedDocumentCount = function(options, callback) {
      this.op = "estimatedDocumentCount";
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      if (typeof options === "object" && options != null) {
        this.setOptions(options);
      }
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.countDocuments = function(conditions, callback) {
      this.op = "countDocuments";
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
      }
      conditions = utils2.toObject(conditions);
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
      }
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.__distinct = wrapThunk(function __distinct(callback) {
      this._castConditions();
      if (this.error()) {
        callback(this.error());
        return null;
      }
      applyGlobalMaxTimeMS(this.options, this.model);
      const options = this._optionsForExec();
      this._collection.collection.distinct(this._distinct, this._conditions, options, callback);
    });
    Query.prototype.distinct = function(field, conditions, callback) {
      this.op = "distinct";
      if (!callback) {
        if (typeof conditions === "function") {
          callback = conditions;
          conditions = void 0;
        } else if (typeof field === "function") {
          callback = field;
          field = void 0;
          conditions = void 0;
        }
      }
      conditions = utils2.toObject(conditions);
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
        prepareDiscriminatorCriteria(this);
      } else if (conditions != null) {
        this.error(new ObjectParameterError(conditions, "filter", "distinct"));
      }
      if (field != null) {
        this._distinct = field;
      }
      if (callback != null) {
        this.exec(callback);
      }
      return this;
    };
    Query.prototype.sort = function(arg) {
      if (arguments.length > 1) {
        throw new Error("sort() only takes 1 Argument");
      }
      return Query.base.sort.call(this, arg);
    };
    Query.prototype.remove = function(filter, callback) {
      this.op = "remove";
      if (typeof filter === "function") {
        callback = filter;
        filter = null;
      }
      filter = utils2.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
        prepareDiscriminatorCriteria(this);
      } else if (filter != null) {
        this.error(new ObjectParameterError(filter, "filter", "remove"));
      }
      if (!callback) {
        return Query.base.remove.call(this);
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._remove = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return this;
      }
      callback = _wrapThunkCallback(this, callback);
      return Query.base.remove.call(this, helpers.handleDeleteWriteOpResult(callback));
    });
    Query.prototype.deleteOne = function(filter, options, callback) {
      this.op = "deleteOne";
      if (typeof filter === "function") {
        callback = filter;
        filter = null;
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      } else {
        this.setOptions(options);
      }
      filter = utils2.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
        prepareDiscriminatorCriteria(this);
      } else if (filter != null) {
        this.error(new ObjectParameterError(filter, "filter", "deleteOne"));
      }
      if (!callback) {
        return Query.base.deleteOne.call(this);
      }
      this.exec.call(this, callback);
      return this;
    };
    Query.prototype._deleteOne = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return this;
      }
      callback = _wrapThunkCallback(this, callback);
      return Query.base.deleteOne.call(this, helpers.handleDeleteWriteOpResult(callback));
    });
    Query.prototype.deleteMany = function(filter, options, callback) {
      this.op = "deleteMany";
      if (typeof filter === "function") {
        callback = filter;
        filter = null;
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      } else {
        this.setOptions(options);
      }
      filter = utils2.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
        prepareDiscriminatorCriteria(this);
      } else if (filter != null) {
        this.error(new ObjectParameterError(filter, "filter", "deleteMany"));
      }
      if (!callback) {
        return Query.base.deleteMany.call(this);
      }
      this.exec.call(this, callback);
      return this;
    };
    Query.prototype._deleteMany = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return this;
      }
      callback = _wrapThunkCallback(this, callback);
      return Query.base.deleteMany.call(this, helpers.handleDeleteWriteOpResult(callback));
    });
    function completeOne(model2, doc, res, options, fields, userProvidedFields, pop, callback) {
      const opts = pop ? { populated: pop } : void 0;
      if (options.rawResult && doc == null) {
        _init(null);
        return null;
      }
      const casted = helpers.createModel(model2, doc, fields, userProvidedFields, options);
      try {
        casted.init(doc, opts, _init);
      } catch (error) {
        _init(error);
      }
      function _init(err) {
        if (err) {
          return immediate(() => callback(err));
        }
        if (options.rawResult) {
          if (doc && casted) {
            if (options.session != null) {
              casted.$session(options.session);
            }
            res.value = casted;
          } else {
            res.value = null;
          }
          return immediate(() => callback(null, res));
        }
        if (options.session != null) {
          casted.$session(options.session);
        }
        immediate(() => callback(null, casted));
      }
    }
    function prepareDiscriminatorCriteria(query) {
      if (!query || !query.model || !query.model.schema) {
        return;
      }
      const schema = query.model.schema;
      if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
        query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
      }
    }
    Query.prototype.findOneAndUpdate = function(criteria, doc, options, callback) {
      this.op = "findOneAndUpdate";
      this._validate();
      switch (arguments.length) {
        case 3:
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          break;
        case 2:
          if (typeof doc === "function") {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          options = void 0;
          break;
        case 1:
          if (typeof criteria === "function") {
            callback = criteria;
            criteria = options = doc = void 0;
          } else {
            doc = criteria;
            criteria = options = void 0;
          }
      }
      if (mquery.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (doc) {
        this._mergeUpdate(doc);
      }
      options = options ? utils2.clone(options) : {};
      if (options.projection) {
        this.select(options.projection);
        delete options.projection;
      }
      if (options.fields) {
        this.select(options.fields);
        delete options.fields;
      }
      const returnOriginal = get(this, "model.base.options.returnOriginal");
      if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
        options.returnOriginal = returnOriginal;
      }
      this.setOptions(options);
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._findOneAndUpdate = wrapThunk(function(callback) {
      if (this.error() != null) {
        return callback(this.error());
      }
      this._findAndModify("update", callback);
    });
    Query.prototype.findOneAndRemove = function(conditions, options, callback) {
      this.op = "findOneAndRemove";
      this._validate();
      switch (arguments.length) {
        case 2:
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          break;
        case 1:
          if (typeof conditions === "function") {
            callback = conditions;
            conditions = void 0;
            options = void 0;
          }
          break;
      }
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
      }
      options && this.setOptions(options);
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.findOneAndDelete = function(conditions, options, callback) {
      this.op = "findOneAndDelete";
      this._validate();
      switch (arguments.length) {
        case 2:
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          break;
        case 1:
          if (typeof conditions === "function") {
            callback = conditions;
            conditions = void 0;
            options = void 0;
          }
          break;
      }
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
      }
      options && this.setOptions(options);
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._findOneAndDelete = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      const filter = this._conditions;
      const options = this._optionsForExec();
      let fields = null;
      if (this._fields != null) {
        options.projection = this._castFields(utils2.clone(this._fields));
        fields = options.projection;
        if (fields instanceof Error) {
          callback(fields);
          return null;
        }
      }
      this._collection.collection.findOneAndDelete(filter, options, _wrapThunkCallback(this, (err, res) => {
        if (err) {
          return callback(err);
        }
        const doc = res.value;
        return this._completeOne(doc, res, callback);
      }));
    });
    Query.prototype.findOneAndReplace = function(filter, replacement, options, callback) {
      this.op = "findOneAndReplace";
      this._validate();
      switch (arguments.length) {
        case 3:
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
          break;
        case 2:
          if (typeof replacement === "function") {
            callback = replacement;
            replacement = void 0;
          }
          break;
        case 1:
          if (typeof filter === "function") {
            callback = filter;
            filter = void 0;
            replacement = void 0;
            options = void 0;
          }
          break;
      }
      if (mquery.canMerge(filter)) {
        this.merge(filter);
      }
      if (replacement != null) {
        if (hasDollarKeys(replacement)) {
          throw new Error("The replacement document must not contain atomic operators.");
        }
        this._mergeUpdate(replacement);
      }
      options = options || {};
      const returnOriginal = get(this, "model.base.options.returnOriginal");
      if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
        options.returnOriginal = returnOriginal;
      }
      this.setOptions(options);
      this.setOptions({ overwrite: true });
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._findOneAndReplace = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      const filter = this._conditions;
      const options = this._optionsForExec();
      convertNewToReturnDocument(options);
      let fields = null;
      let castedDoc = new this.model(this._update, null, true);
      this._update = castedDoc;
      this._applyPaths();
      if (this._fields != null) {
        options.projection = this._castFields(utils2.clone(this._fields));
        fields = options.projection;
        if (fields instanceof Error) {
          callback(fields);
          return null;
        }
      }
      castedDoc.validate((err) => {
        if (err != null) {
          return callback(err);
        }
        if (castedDoc.toBSON) {
          castedDoc = castedDoc.toBSON();
        }
        this._collection.collection.findOneAndReplace(filter, castedDoc, options, _wrapThunkCallback(this, (err2, res) => {
          if (err2) {
            return callback(err2);
          }
          const doc = res.value;
          return this._completeOne(doc, res, callback);
        }));
      });
    });
    function convertNewToReturnDocument(options) {
      if ("new" in options) {
        options.returnDocument = options["new"] ? "after" : "before";
        delete options["new"];
      }
      if ("returnOriginal" in options) {
        options.returnDocument = options["returnOriginal"] ? "before" : "after";
        delete options["returnOriginal"];
      }
    }
    Query.prototype._findOneAndRemove = wrapThunk(function(callback) {
      if (this.error() != null) {
        callback(this.error());
        return;
      }
      this._findAndModify("remove", callback);
    });
    function _getOption(query, option, def) {
      const opts = query._optionsForExec(query.model);
      if (option in opts) {
        return opts[option];
      }
      if (option in query.model.base.options) {
        return query.model.base.options[option];
      }
      return def;
    }
    Query.prototype._findAndModify = function(type, callback) {
      if (typeof callback !== "function") {
        throw new Error("Expected callback in _findAndModify");
      }
      const model2 = this.model;
      const schema = model2.schema;
      const _this = this;
      let fields;
      const castedQuery = castQuery(this);
      if (castedQuery instanceof Error) {
        return callback(castedQuery);
      }
      _castArrayFilters(this);
      const opts = this._optionsForExec(model2);
      if ("strict" in opts) {
        this._mongooseOptions.strict = opts.strict;
      }
      const isOverwriting = this.options.overwrite && !hasDollarKeys(this._update);
      if (isOverwriting) {
        this._update = new this.model(this._update, null, true);
      }
      if (type === "remove") {
        opts.remove = true;
      } else {
        if (!("new" in opts) && !("returnOriginal" in opts) && !("returnDocument" in opts)) {
          opts.new = false;
        }
        if (!("upsert" in opts)) {
          opts.upsert = false;
        }
        if (opts.upsert || opts["new"]) {
          opts.remove = false;
        }
        if (!isOverwriting) {
          this._update = castDoc(this, opts.overwrite);
          const _opts = Object.assign({}, opts, {
            setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
          });
          this._update = setDefaultsOnInsert(this._conditions, schema, this._update, _opts);
          if (!this._update || Object.keys(this._update).length === 0) {
            if (opts.upsert) {
              const doc = utils2.clone(castedQuery);
              delete doc._id;
              this._update = { $set: doc };
            } else {
              this.findOne(callback);
              return this;
            }
          } else if (this._update instanceof Error) {
            return callback(this._update);
          } else {
            if (this._update.$set && Object.keys(this._update.$set).length === 0) {
              delete this._update.$set;
            }
          }
        }
        if (Array.isArray(opts.arrayFilters)) {
          opts.arrayFilters = removeUnusedArrayFilters(this._update, opts.arrayFilters);
        }
      }
      this._applyPaths();
      const options = this._mongooseOptions;
      if (this._fields) {
        fields = utils2.clone(this._fields);
        opts.projection = this._castFields(fields);
        if (opts.projection instanceof Error) {
          return callback(opts.projection);
        }
      }
      if (opts.sort)
        convertSortToArray(opts);
      const cb = function(err, doc, res) {
        if (err) {
          return callback(err);
        }
        _this._completeOne(doc, res, callback);
      };
      let useFindAndModify = true;
      const runValidators = _getOption(this, "runValidators", false);
      const base = _this.model && _this.model.base;
      const conn = get(model2, "collection.conn", {});
      if ("useFindAndModify" in base.options) {
        useFindAndModify = base.get("useFindAndModify");
      }
      if ("useFindAndModify" in conn.config) {
        useFindAndModify = conn.config.useFindAndModify;
      }
      if ("useFindAndModify" in options) {
        useFindAndModify = options.useFindAndModify;
      }
      if (useFindAndModify === false) {
        const collection = _this._collection.collection;
        convertNewToReturnDocument(opts);
        if (type === "remove") {
          collection.findOneAndDelete(castedQuery, opts, _wrapThunkCallback(_this, function(error, res) {
            return cb(error, res ? res.value : res, res);
          }));
          return this;
        }
        const updateMethod = isOverwriting ? "findOneAndReplace" : "findOneAndUpdate";
        if (runValidators) {
          this.validate(this._update, opts, isOverwriting, (error) => {
            if (error) {
              return callback(error);
            }
            if (this._update && this._update.toBSON) {
              this._update = this._update.toBSON();
            }
            collection[updateMethod](castedQuery, this._update, opts, _wrapThunkCallback(_this, function(error2, res) {
              return cb(error2, res ? res.value : res, res);
            }));
          });
        } else {
          if (this._update && this._update.toBSON) {
            this._update = this._update.toBSON();
          }
          collection[updateMethod](castedQuery, this._update, opts, _wrapThunkCallback(_this, function(error, res) {
            return cb(error, res ? res.value : res, res);
          }));
        }
        return this;
      }
      if (runValidators) {
        this.validate(this._update, opts, isOverwriting, function(error) {
          if (error) {
            return callback(error);
          }
          _legacyFindAndModify.call(_this, castedQuery, _this._update, opts, cb);
        });
      } else {
        _legacyFindAndModify.call(_this, castedQuery, _this._update, opts, cb);
      }
      return this;
    };
    function _completeOneLean(doc, res, opts, callback) {
      if (opts.rawResult) {
        return callback(null, res);
      }
      return callback(null, doc);
    }
    var _legacyFindAndModify = util.deprecate(function(filter, update, opts, cb) {
      if (update && update.toBSON) {
        update = update.toBSON();
      }
      const collection = this._collection;
      const sort = opts != null && Array.isArray(opts.sort) ? opts.sort : [];
      const _cb = _wrapThunkCallback(this, function(error, res) {
        return cb(error, res ? res.value : res, res);
      });
      collection.collection._findAndModify(filter, sort, update, opts, _cb);
    }, "Mongoose: `findOneAndUpdate()` and `findOneAndDelete()` without the `useFindAndModify` option set to false are deprecated. See: https://mongoosejs.com/docs/deprecations.html#findandmodify");
    Query.prototype._mergeUpdate = function(doc) {
      if (doc == null || typeof doc === "object" && Object.keys(doc).length === 0) {
        return;
      }
      if (!this._update) {
        this._update = Array.isArray(doc) ? [] : {};
      }
      if (doc instanceof Query) {
        if (Array.isArray(this._update)) {
          throw new Error("Cannot mix array and object updates");
        }
        if (doc._update) {
          utils2.mergeClone(this._update, doc._update);
        }
      } else if (Array.isArray(doc)) {
        if (!Array.isArray(this._update)) {
          throw new Error("Cannot mix array and object updates");
        }
        this._update = this._update.concat(doc);
      } else {
        if (Array.isArray(this._update)) {
          throw new Error("Cannot mix array and object updates");
        }
        utils2.mergeClone(this._update, doc);
      }
    };
    function convertSortToArray(opts) {
      if (Array.isArray(opts.sort)) {
        return;
      }
      if (!utils2.isObject(opts.sort)) {
        return;
      }
      const sort = [];
      for (const key in opts.sort) {
        if (utils2.object.hasOwnProperty(opts.sort, key)) {
          sort.push([key, opts.sort[key]]);
        }
      }
      opts.sort = sort;
    }
    function _updateThunk(op, callback) {
      this._castConditions();
      _castArrayFilters(this);
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      callback = _wrapThunkCallback(this, callback);
      const oldCb = callback;
      callback = function(error, result) {
        oldCb(error, result ? result.result : { ok: 0, n: 0, nModified: 0 });
      };
      const castedQuery = this._conditions;
      const options = this._optionsForExec(this.model);
      ++this._executionCount;
      this._update = utils2.clone(this._update, options);
      const isOverwriting = this.options.overwrite && !hasDollarKeys(this._update);
      if (isOverwriting) {
        if (op === "updateOne" || op === "updateMany") {
          return callback(new MongooseError("The MongoDB server disallows overwriting documents using `" + op + "`. See: https://mongoosejs.com/docs/deprecations.html#update"));
        }
        this._update = new this.model(this._update, null, true);
      } else {
        this._update = castDoc(this, options.overwrite);
        if (this._update instanceof Error) {
          callback(this._update);
          return null;
        }
        if (this._update == null || Object.keys(this._update).length === 0) {
          callback(null, 0);
          return null;
        }
        const _opts = Object.assign({}, options, {
          setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
        });
        this._update = setDefaultsOnInsert(this._conditions, this.model.schema, this._update, _opts);
      }
      if (Array.isArray(options.arrayFilters)) {
        options.arrayFilters = removeUnusedArrayFilters(this._update, options.arrayFilters);
      }
      const runValidators = _getOption(this, "runValidators", false);
      if (runValidators) {
        this.validate(this._update, options, isOverwriting, (err) => {
          if (err) {
            return callback(err);
          }
          if (this._update.toBSON) {
            this._update = this._update.toBSON();
          }
          this._collection[op](castedQuery, this._update, options, callback);
        });
        return null;
      }
      if (this._update.toBSON) {
        this._update = this._update.toBSON();
      }
      this._collection[op](castedQuery, this._update, options, callback);
      return null;
    }
    Query.prototype.validate = function validate(castedDoc, options, isOverwriting, callback) {
      return promiseOrCallback(callback, (cb) => {
        try {
          if (isOverwriting) {
            castedDoc.validate(cb);
          } else {
            updateValidators(this, this.model.schema, castedDoc, options, cb);
          }
        } catch (err) {
          immediate(function() {
            cb(err);
          });
        }
      });
    };
    Query.prototype._execUpdate = wrapThunk(function(callback) {
      return _updateThunk.call(this, "update", callback);
    });
    Query.prototype._updateMany = wrapThunk(function(callback) {
      return _updateThunk.call(this, "updateMany", callback);
    });
    Query.prototype._updateOne = wrapThunk(function(callback) {
      return _updateThunk.call(this, "updateOne", callback);
    });
    Query.prototype._replaceOne = wrapThunk(function(callback) {
      return _updateThunk.call(this, "replaceOne", callback);
    });
    Query.prototype.update = function(conditions, doc, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options = void 0;
      } else if (typeof conditions === "object" && !doc && !options && !callback) {
        doc = conditions;
        conditions = void 0;
        options = void 0;
        callback = void 0;
      }
      return _update(this, "update", conditions, doc, options, callback);
    };
    Query.prototype.updateMany = function(conditions, doc, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options = void 0;
      } else if (typeof conditions === "object" && !doc && !options && !callback) {
        doc = conditions;
        conditions = void 0;
        options = void 0;
        callback = void 0;
      }
      return _update(this, "updateMany", conditions, doc, options, callback);
    };
    Query.prototype.updateOne = function(conditions, doc, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options = void 0;
      } else if (typeof conditions === "object" && !doc && !options && !callback) {
        doc = conditions;
        conditions = void 0;
        options = void 0;
        callback = void 0;
      }
      return _update(this, "updateOne", conditions, doc, options, callback);
    };
    Query.prototype.replaceOne = function(conditions, doc, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options = void 0;
      } else if (typeof conditions === "object" && !doc && !options && !callback) {
        doc = conditions;
        conditions = void 0;
        options = void 0;
        callback = void 0;
      }
      this.setOptions({ overwrite: true });
      return _update(this, "replaceOne", conditions, doc, options, callback);
    };
    function _update(query, op, filter, doc, options, callback) {
      query.op = op;
      filter = utils2.toObject(filter);
      doc = doc || {};
      if (options != null) {
        if ("strict" in options) {
          query._mongooseOptions.strict = options.strict;
        }
      }
      if (!(filter instanceof Query) && filter != null && filter.toString() !== "[object Object]") {
        query.error(new ObjectParameterError(filter, "filter", op));
      } else {
        query.merge(filter);
      }
      if (utils2.isObject(options)) {
        query.setOptions(options);
      }
      query._mergeUpdate(doc);
      if (callback) {
        query.exec(callback);
        return query;
      }
      return Query.base[op].call(query, filter, void 0, options, callback);
    }
    Query.prototype.map = function(fn) {
      this._transforms.push(fn);
      return this;
    };
    Query.prototype.orFail = function(err) {
      this.map((res) => {
        switch (this.op) {
          case "find":
            if (res.length === 0) {
              throw _orFailError(err, this);
            }
            break;
          case "findOne":
            if (res == null) {
              throw _orFailError(err, this);
            }
            break;
          case "update":
          case "updateMany":
          case "updateOne":
            if (get(res, "nModified") === 0) {
              throw _orFailError(err, this);
            }
            break;
          case "findOneAndDelete":
          case "findOneAndRemove":
            if (get(res, "lastErrorObject.n") === 0) {
              throw _orFailError(err, this);
            }
            break;
          case "findOneAndUpdate":
          case "findOneAndReplace":
            if (get(res, "lastErrorObject.updatedExisting") === false) {
              throw _orFailError(err, this);
            }
            break;
          case "deleteMany":
          case "deleteOne":
          case "remove":
            if (res.n === 0) {
              throw _orFailError(err, this);
            }
            break;
          default:
            break;
        }
        return res;
      });
      return this;
    };
    function _orFailError(err, query) {
      if (typeof err === "function") {
        err = err.call(query);
      }
      if (err == null) {
        err = new DocumentNotFoundError(query.getQuery(), query.model.modelName);
      }
      return err;
    }
    Query.prototype.exec = function exec(op, callback) {
      const _this = this;
      const castError = new CastError();
      if (typeof op === "function") {
        callback = op;
        op = null;
      } else if (typeof op === "string") {
        this.op = op;
      }
      callback = this.model.$handleCallbackError(callback);
      return promiseOrCallback(callback, (cb) => {
        cb = this.model.$wrapCallback(cb);
        if (!_this.op) {
          cb();
          return;
        }
        this._hooks.execPre("exec", this, [], (error) => {
          if (error != null) {
            return cb(_cleanCastErrorStack(castError, error));
          }
          let thunk = "_" + this.op;
          if (this.op === "update") {
            thunk = "_execUpdate";
          } else if (this.op === "distinct") {
            thunk = "__distinct";
          }
          this[thunk].call(this, (error2, res) => {
            if (error2) {
              return cb(_cleanCastErrorStack(castError, error2));
            }
            this._hooks.execPost("exec", this, [], {}, (error3) => {
              if (error3) {
                return cb(_cleanCastErrorStack(castError, error3));
              }
              cb(null, res);
            });
          });
        });
      }, this.model.events);
    };
    function _cleanCastErrorStack(castError, error) {
      if (error instanceof CastError) {
        castError.copy(error);
        return castError;
      }
      return error;
    }
    function _wrapThunkCallback(query, cb) {
      return function(error, res) {
        if (error != null) {
          return cb(error);
        }
        for (const fn of query._transforms) {
          try {
            res = fn(res);
          } catch (error2) {
            return cb(error2);
          }
        }
        return cb(null, res);
      };
    }
    Query.prototype.then = function(resolve, reject) {
      return this.exec().then(resolve, reject);
    };
    Query.prototype.catch = function(reject) {
      return this.exec().then(null, reject);
    };
    Query.prototype.pre = function(fn) {
      this._hooks.pre("exec", fn);
      return this;
    };
    Query.prototype.post = function(fn) {
      this._hooks.post("exec", fn);
      return this;
    };
    Query.prototype._castUpdate = function _castUpdate(obj, overwrite) {
      let strict;
      let schema = this.schema;
      const discriminatorKey = schema.options.discriminatorKey;
      const baseSchema = schema._baseSchema ? schema._baseSchema : schema;
      if (this._mongooseOptions.overwriteDiscriminatorKey && obj[discriminatorKey] != null && baseSchema.discriminators) {
        const _schema = baseSchema.discriminators[obj[discriminatorKey]];
        if (_schema != null) {
          schema = _schema;
        }
      }
      if ("strict" in this._mongooseOptions) {
        strict = this._mongooseOptions.strict;
      } else if (this.schema && this.schema.options) {
        strict = this.schema.options.strict;
      } else {
        strict = true;
      }
      let omitUndefined = false;
      if ("omitUndefined" in this._mongooseOptions) {
        omitUndefined = this._mongooseOptions.omitUndefined;
      }
      let useNestedStrict;
      if ("useNestedStrict" in this.options) {
        useNestedStrict = this.options.useNestedStrict;
      }
      let upsert;
      if ("upsert" in this.options) {
        upsert = this.options.upsert;
      }
      const filter = this._conditions;
      if (schema != null && utils2.hasUserDefinedProperty(filter, schema.options.discriminatorKey) && typeof filter[schema.options.discriminatorKey] !== "object" && schema.discriminators != null) {
        const discriminatorValue = filter[schema.options.discriminatorKey];
        const byValue = getDiscriminatorByValue(this.model.discriminators, discriminatorValue);
        schema = schema.discriminators[discriminatorValue] || byValue && byValue.schema || schema;
      }
      return castUpdate(schema, obj, {
        overwrite,
        strict,
        omitUndefined,
        useNestedStrict,
        upsert,
        arrayFilters: this.options.arrayFilters
      }, this, this._conditions);
    };
    function castQuery(query) {
      try {
        return query.cast(query.model);
      } catch (err) {
        return err;
      }
    }
    function castDoc(query, overwrite) {
      try {
        return query._castUpdate(query._update, overwrite);
      } catch (err) {
        return err;
      }
    }
    Query.prototype.populate = function() {
      if (!Array.from(arguments).some(Boolean)) {
        return this;
      }
      const res = utils2.populate.apply(null, arguments);
      if (this.options != null) {
        const readConcern = this.options.readConcern;
        const readPref = this.options.readPreference;
        for (const populateOptions of res) {
          if (readConcern != null && get(populateOptions, "options.readConcern") == null) {
            populateOptions.options = populateOptions.options || {};
            populateOptions.options.readConcern = readConcern;
          }
          if (readPref != null && get(populateOptions, "options.readPreference") == null) {
            populateOptions.options = populateOptions.options || {};
            populateOptions.options.readPreference = readPref;
          }
        }
      }
      const opts = this._mongooseOptions;
      if (opts.lean != null) {
        const lean = opts.lean;
        for (const populateOptions of res) {
          if (get(populateOptions, "options.lean") == null) {
            populateOptions.options = populateOptions.options || {};
            populateOptions.options.lean = lean;
          }
        }
      }
      if (!utils2.isObject(opts.populate)) {
        opts.populate = {};
      }
      const pop = opts.populate;
      for (const populateOptions of res) {
        const path = populateOptions.path;
        if (pop[path] && pop[path].populate && populateOptions.populate) {
          populateOptions.populate = pop[path].populate.concat(populateOptions.populate);
        }
        pop[populateOptions.path] = populateOptions;
      }
      return this;
    };
    Query.prototype.getPopulatedPaths = function getPopulatedPaths() {
      const obj = this._mongooseOptions.populate || {};
      const ret2 = Object.keys(obj);
      for (const path of Object.keys(obj)) {
        const pop = obj[path];
        if (!Array.isArray(pop.populate)) {
          continue;
        }
        _getPopulatedPaths(ret2, pop.populate, path + ".");
      }
      return ret2;
    };
    function _getPopulatedPaths(list, arr, prefix) {
      for (const pop of arr) {
        list.push(prefix + pop.path);
        if (!Array.isArray(pop.populate)) {
          continue;
        }
        _getPopulatedPaths(list, pop.populate, prefix + pop.path + ".");
      }
    }
    Query.prototype.cast = function(model2, obj) {
      obj || (obj = this._conditions);
      model2 = model2 || this.model;
      const discriminatorKey = model2.schema.options.discriminatorKey;
      if (obj != null && obj.hasOwnProperty(discriminatorKey)) {
        model2 = getDiscriminatorByValue(model2.discriminators, obj[discriminatorKey]) || model2;
      }
      try {
        return cast(model2.schema, obj, {
          upsert: this.options && this.options.upsert,
          strict: this.options && "strict" in this.options ? this.options.strict : get(model2, "schema.options.strict", null),
          strictQuery: this.options && this.options.strictQuery || get(model2, "schema.options.strictQuery", null)
        }, this);
      } catch (err) {
        if (typeof err.setModel === "function") {
          err.setModel(model2);
        }
        throw err;
      }
    };
    Query.prototype._castFields = function _castFields(fields) {
      let selected, elemMatchKeys, keys, key, out, i;
      if (fields) {
        keys = Object.keys(fields);
        elemMatchKeys = [];
        i = keys.length;
        while (i--) {
          key = keys[i];
          if (fields[key].$elemMatch) {
            selected || (selected = {});
            selected[key] = fields[key];
            elemMatchKeys.push(key);
          }
        }
      }
      if (selected) {
        try {
          out = this.cast(this.model, selected);
        } catch (err) {
          return err;
        }
        i = elemMatchKeys.length;
        while (i--) {
          key = elemMatchKeys[i];
          fields[key] = out[key];
        }
      }
      return fields;
    };
    Query.prototype._applyPaths = function applyPaths() {
      this._fields = this._fields || {};
      helpers.applyPaths(this._fields, this.model.schema);
      let _selectPopulatedPaths = true;
      if ("selectPopulatedPaths" in this.model.base.options) {
        _selectPopulatedPaths = this.model.base.options.selectPopulatedPaths;
      }
      if ("selectPopulatedPaths" in this.model.schema.options) {
        _selectPopulatedPaths = this.model.schema.options.selectPopulatedPaths;
      }
      if (_selectPopulatedPaths) {
        selectPopulatedFields(this._fields, this._userProvidedFields, this._mongooseOptions.populate);
      }
    };
    Query.prototype.cursor = function cursor(opts) {
      this._applyPaths();
      this._fields = this._castFields(this._fields);
      this.setOptions({ projection: this._fieldsForExec() });
      if (opts) {
        this.setOptions(opts);
      }
      const options = Object.assign({}, this._optionsForExec(), {
        projection: this.projection()
      });
      try {
        this.cast(this.model);
      } catch (err) {
        return new QueryCursor(this, options)._markError(err);
      }
      return new QueryCursor(this, options);
    };
    Query.prototype.maxscan = Query.base.maxScan;
    Query.prototype.tailable = function(val, opts) {
      if (val != null && typeof val.constructor === "function" && val.constructor.name === "Object") {
        opts = val;
        val = true;
      }
      if (val === void 0) {
        val = true;
      }
      if (opts && typeof opts === "object") {
        for (const key of Object.keys(opts)) {
          if (key === "awaitdata") {
            this.options[key] = !!opts[key];
          } else {
            this.options[key] = opts[key];
          }
        }
      }
      return Query.base.tailable.call(this, val);
    };
    Query.prototype.near = function() {
      const params = [];
      const sphere = this._mongooseOptions.nearSphere;
      if (arguments.length === 1) {
        if (Array.isArray(arguments[0])) {
          params.push({ center: arguments[0], spherical: sphere });
        } else if (typeof arguments[0] === "string") {
          params.push(arguments[0]);
        } else if (utils2.isObject(arguments[0])) {
          if (typeof arguments[0].spherical !== "boolean") {
            arguments[0].spherical = sphere;
          }
          params.push(arguments[0]);
        } else {
          throw new TypeError("invalid argument");
        }
      } else if (arguments.length === 2) {
        if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
          params.push({ center: [arguments[0], arguments[1]], spherical: sphere });
        } else if (typeof arguments[0] === "string" && Array.isArray(arguments[1])) {
          params.push(arguments[0]);
          params.push({ center: arguments[1], spherical: sphere });
        } else if (typeof arguments[0] === "string" && utils2.isObject(arguments[1])) {
          params.push(arguments[0]);
          if (typeof arguments[1].spherical !== "boolean") {
            arguments[1].spherical = sphere;
          }
          params.push(arguments[1]);
        } else {
          throw new TypeError("invalid argument");
        }
      } else if (arguments.length === 3) {
        if (typeof arguments[0] === "string" && typeof arguments[1] === "number" && typeof arguments[2] === "number") {
          params.push(arguments[0]);
          params.push({ center: [arguments[1], arguments[2]], spherical: sphere });
        } else {
          throw new TypeError("invalid argument");
        }
      } else {
        throw new TypeError("invalid argument");
      }
      return Query.base.near.apply(this, params);
    };
    Query.prototype.nearSphere = function() {
      this._mongooseOptions.nearSphere = true;
      this.near.apply(this, arguments);
      return this;
    };
    if (Symbol.asyncIterator != null) {
      Query.prototype[Symbol.asyncIterator] = function() {
        return this.cursor().transformNull()._transformForAsyncIterator();
      };
    }
    Query.prototype.box = function(ll, ur) {
      if (!Array.isArray(ll) && utils2.isObject(ll)) {
        ur = ll.ur;
        ll = ll.ll;
      }
      return Query.base.box.call(this, ll, ur);
    };
    Query.prototype.center = Query.base.circle;
    Query.prototype.centerSphere = function() {
      if (arguments[0] != null && typeof arguments[0].constructor === "function" && arguments[0].constructor.name === "Object") {
        arguments[0].spherical = true;
      }
      if (arguments[1] != null && typeof arguments[1].constructor === "function" && arguments[1].constructor.name === "Object") {
        arguments[1].spherical = true;
      }
      Query.base.circle.apply(this, arguments);
    };
    Query.prototype.selectedInclusively = function selectedInclusively() {
      return isInclusive(this._fields);
    };
    Query.prototype.selectedExclusively = function selectedExclusively() {
      return isExclusive(this._fields);
    };
    Query.prototype.model;
    module2.exports = Query;
  }
});

// node_modules/mongoose/lib/cursor/AggregationCursor.js
var require_AggregationCursor = __commonJS({
  "node_modules/mongoose/lib/cursor/AggregationCursor.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_mongooseError();
    var Readable = require("stream").Readable;
    var promiseOrCallback = require_promiseOrCallback();
    var eachAsync = require_eachAsync();
    var immediate = require_immediate();
    var util = require("util");
    function AggregationCursor(agg) {
      Readable.call(this, { objectMode: true });
      this.cursor = null;
      this.agg = agg;
      this._transforms = [];
      const model2 = agg._model;
      delete agg.options.cursor.useMongooseAggCursor;
      this._mongooseOptions = {};
      _init(model2, this, agg);
    }
    util.inherits(AggregationCursor, Readable);
    function _init(model2, c, agg) {
      if (!model2.collection.buffer) {
        model2.hooks.execPre("aggregate", agg, function() {
          c.cursor = model2.collection.aggregate(agg._pipeline, agg.options || {});
          c.emit("cursor", c.cursor);
        });
      } else {
        model2.collection.emitter.once("queue", function() {
          model2.hooks.execPre("aggregate", agg, function() {
            c.cursor = model2.collection.aggregate(agg._pipeline, agg.options || {});
            c.emit("cursor", c.cursor);
          });
        });
      }
    }
    AggregationCursor.prototype._read = function() {
      const _this = this;
      _next(this, function(error, doc) {
        if (error) {
          return _this.emit("error", error);
        }
        if (!doc) {
          _this.push(null);
          _this.cursor.close(function(error2) {
            if (error2) {
              return _this.emit("error", error2);
            }
            setTimeout(function() {
              const isNotClosedAutomatically = !_this.destroyed;
              if (isNotClosedAutomatically) {
                _this.emit("close");
              }
            }, 0);
          });
          return;
        }
        _this.push(doc);
      });
    };
    if (Symbol.asyncIterator != null) {
      const msg = "Mongoose does not support using async iterators with an existing aggregation cursor. See http://bit.ly/mongoose-async-iterate-aggregation";
      AggregationCursor.prototype[Symbol.asyncIterator] = function() {
        throw new MongooseError(msg);
      };
    }
    AggregationCursor.prototype.map = function(fn) {
      this._transforms.push(fn);
      return this;
    };
    AggregationCursor.prototype._markError = function(error) {
      this._error = error;
      return this;
    };
    AggregationCursor.prototype.close = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        this.cursor.close((error) => {
          if (error) {
            cb(error);
            return this.listeners("error").length > 0 && this.emit("error", error);
          }
          this.emit("close");
          cb(null);
        });
      });
    };
    AggregationCursor.prototype.next = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        _next(this, cb);
      });
    };
    AggregationCursor.prototype.eachAsync = function(fn, opts, callback) {
      const _this = this;
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      opts = opts || {};
      return eachAsync(function(cb) {
        return _next(_this, cb);
      }, fn, opts, callback);
    };
    if (Symbol.asyncIterator != null) {
      AggregationCursor.prototype[Symbol.asyncIterator] = function() {
        return this.transformNull()._transformForAsyncIterator();
      };
    }
    AggregationCursor.prototype._transformForAsyncIterator = function() {
      if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
        this.map(_transformForAsyncIterator);
      }
      return this;
    };
    AggregationCursor.prototype.transformNull = function(val) {
      if (arguments.length === 0) {
        val = true;
      }
      this._mongooseOptions.transformNull = val;
      return this;
    };
    function _transformForAsyncIterator(doc) {
      return doc == null ? { done: true } : { value: doc, done: false };
    }
    AggregationCursor.prototype.addCursorFlag = function(flag, value) {
      const _this = this;
      _waitForCursor(this, function() {
        _this.cursor.addCursorFlag(flag, value);
      });
      return this;
    };
    function _waitForCursor(ctx, cb) {
      if (ctx.cursor) {
        return cb();
      }
      ctx.once("cursor", function() {
        cb();
      });
    }
    function _next(ctx, cb) {
      let callback = cb;
      if (ctx._transforms.length) {
        callback = function(err, doc) {
          if (err || doc === null && !ctx._mongooseOptions.transformNull) {
            return cb(err, doc);
          }
          cb(err, ctx._transforms.reduce(function(doc2, fn) {
            return fn(doc2);
          }, doc));
        };
      }
      if (ctx._error) {
        return immediate(function() {
          callback(ctx._error);
        });
      }
      if (ctx.cursor) {
        return ctx.cursor.next(function(error, doc) {
          if (error) {
            return callback(error);
          }
          if (!doc) {
            return callback(null, null);
          }
          callback(null, doc);
        });
      } else {
        ctx.once("cursor", function() {
          _next(ctx, cb);
        });
      }
    }
    module2.exports = AggregationCursor;
  }
});

// node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js
var require_stringifyFunctionOperators = __commonJS({
  "node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js"(exports2, module2) {
    "use strict";
    module2.exports = function stringifyFunctionOperators(pipeline) {
      if (!Array.isArray(pipeline)) {
        return;
      }
      for (const stage of pipeline) {
        if (stage == null) {
          continue;
        }
        const canHaveAccumulator = stage.$group || stage.$bucket || stage.$bucketAuto;
        if (canHaveAccumulator != null) {
          for (const key of Object.keys(canHaveAccumulator)) {
            handleAccumulator(canHaveAccumulator[key]);
          }
        }
        const stageType = Object.keys(stage)[0];
        if (stageType && typeof stage[stageType] === "object") {
          const stageOptions = stage[stageType];
          for (const key of Object.keys(stageOptions)) {
            if (stageOptions[key] != null && stageOptions[key].$function != null && typeof stageOptions[key].$function.body === "function") {
              stageOptions[key].$function.body = stageOptions[key].$function.body.toString();
            }
          }
        }
        if (stage.$facet != null) {
          for (const key of Object.keys(stage.$facet)) {
            stringifyFunctionOperators(stage.$facet[key]);
          }
        }
      }
    };
    function handleAccumulator(operator) {
      if (operator == null || operator.$accumulator == null) {
        return;
      }
      for (const key of ["init", "accumulate", "merge", "finalize"]) {
        if (typeof operator.$accumulator[key] === "function") {
          operator.$accumulator[key] = String(operator.$accumulator[key]);
        }
      }
    }
  }
});

// node_modules/mongoose/lib/aggregate.js
var require_aggregate2 = __commonJS({
  "node_modules/mongoose/lib/aggregate.js"(exports2, module2) {
    "use strict";
    var AggregationCursor = require_AggregationCursor();
    var Query = require_query3();
    var applyGlobalMaxTimeMS = require_applyGlobalMaxTimeMS();
    var getConstructorName = require_getConstructorName();
    var promiseOrCallback = require_promiseOrCallback();
    var stringifyFunctionOperators = require_stringifyFunctionOperators();
    var util = require("util");
    var utils2 = require_utils8();
    var read = Query.prototype.read;
    var readConcern = Query.prototype.readConcern;
    function Aggregate(pipeline) {
      this._pipeline = [];
      this._model = void 0;
      this.options = {};
      if (arguments.length === 1 && util.isArray(pipeline)) {
        this.append.apply(this, pipeline);
      }
    }
    Aggregate.prototype.options;
    Aggregate.prototype.model = function(model2) {
      if (arguments.length === 0) {
        return this._model;
      }
      this._model = model2;
      if (model2.schema != null) {
        if (this.options.readPreference == null && model2.schema.options.read != null) {
          this.options.readPreference = model2.schema.options.read;
        }
        if (this.options.collation == null && model2.schema.options.collation != null) {
          this.options.collation = model2.schema.options.collation;
        }
      }
      return this;
    };
    Aggregate.prototype.append = function() {
      const args = arguments.length === 1 && util.isArray(arguments[0]) ? arguments[0] : utils2.args(arguments);
      if (!args.every(isOperator)) {
        throw new Error("Arguments must be aggregate pipeline operators");
      }
      this._pipeline = this._pipeline.concat(args);
      return this;
    };
    Aggregate.prototype.addFields = function(arg) {
      const fields = {};
      if (typeof arg === "object" && !util.isArray(arg)) {
        Object.keys(arg).forEach(function(field) {
          fields[field] = arg[field];
        });
      } else {
        throw new Error("Invalid addFields() argument. Must be an object");
      }
      return this.append({ $addFields: fields });
    };
    Aggregate.prototype.project = function(arg) {
      const fields = {};
      if (typeof arg === "object" && !util.isArray(arg)) {
        Object.keys(arg).forEach(function(field) {
          fields[field] = arg[field];
        });
      } else if (arguments.length === 1 && typeof arg === "string") {
        arg.split(/\s+/).forEach(function(field) {
          if (!field) {
            return;
          }
          const include = field[0] === "-" ? 0 : 1;
          if (include === 0) {
            field = field.substring(1);
          }
          fields[field] = include;
        });
      } else {
        throw new Error("Invalid project() argument. Must be string or object");
      }
      return this.append({ $project: fields });
    };
    Aggregate.prototype.near = function(arg) {
      const op = {};
      op.$geoNear = arg;
      return this.append(op);
    };
    "group match skip limit out".split(" ").forEach(function($operator) {
      Aggregate.prototype[$operator] = function(arg) {
        const op = {};
        op["$" + $operator] = arg;
        return this.append(op);
      };
    });
    Aggregate.prototype.unwind = function() {
      const args = utils2.args(arguments);
      const res = [];
      for (const arg of args) {
        if (arg && typeof arg === "object") {
          res.push({ $unwind: arg });
        } else if (typeof arg === "string") {
          res.push({
            $unwind: arg && arg.startsWith("$") ? arg : "$" + arg
          });
        } else {
          throw new Error('Invalid arg "' + arg + '" to unwind(), must be string or object');
        }
      }
      return this.append.apply(this, res);
    };
    Aggregate.prototype.replaceRoot = function(newRoot) {
      let ret2;
      if (typeof newRoot === "string") {
        ret2 = newRoot.startsWith("$") ? newRoot : "$" + newRoot;
      } else {
        ret2 = newRoot;
      }
      return this.append({
        $replaceRoot: {
          newRoot: ret2
        }
      });
    };
    Aggregate.prototype.count = function(countName) {
      return this.append({ $count: countName });
    };
    Aggregate.prototype.sortByCount = function(arg) {
      if (arg && typeof arg === "object") {
        return this.append({ $sortByCount: arg });
      } else if (typeof arg === "string") {
        return this.append({
          $sortByCount: arg && arg.startsWith("$") ? arg : "$" + arg
        });
      } else {
        throw new TypeError('Invalid arg "' + arg + '" to sortByCount(), must be string or object');
      }
    };
    Aggregate.prototype.lookup = function(options) {
      return this.append({ $lookup: options });
    };
    Aggregate.prototype.graphLookup = function(options) {
      const cloneOptions = {};
      if (options) {
        if (!utils2.isObject(options)) {
          throw new TypeError("Invalid graphLookup() argument. Must be an object.");
        }
        utils2.mergeClone(cloneOptions, options);
        const startWith = cloneOptions.startWith;
        if (startWith && typeof startWith === "string") {
          cloneOptions.startWith = cloneOptions.startWith.startsWith("$") ? cloneOptions.startWith : "$" + cloneOptions.startWith;
        }
      }
      return this.append({ $graphLookup: cloneOptions });
    };
    Aggregate.prototype.sample = function(size) {
      return this.append({ $sample: { size } });
    };
    Aggregate.prototype.sort = function(arg) {
      const sort = {};
      if (getConstructorName(arg) === "Object") {
        const desc = ["desc", "descending", -1];
        Object.keys(arg).forEach(function(field) {
          if (arg[field] instanceof Object && arg[field].$meta) {
            sort[field] = arg[field];
            return;
          }
          sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;
        });
      } else if (arguments.length === 1 && typeof arg === "string") {
        arg.split(/\s+/).forEach(function(field) {
          if (!field) {
            return;
          }
          const ascend = field[0] === "-" ? -1 : 1;
          if (ascend === -1) {
            field = field.substring(1);
          }
          sort[field] = ascend;
        });
      } else {
        throw new TypeError("Invalid sort() argument. Must be a string or object.");
      }
      return this.append({ $sort: sort });
    };
    Aggregate.prototype.read = function(pref, tags) {
      if (!this.options) {
        this.options = {};
      }
      read.call(this, pref, tags);
      return this;
    };
    Aggregate.prototype.readConcern = function(level) {
      if (!this.options) {
        this.options = {};
      }
      readConcern.call(this, level);
      return this;
    };
    Aggregate.prototype.redact = function(expression, thenExpr, elseExpr) {
      if (arguments.length === 3) {
        if (typeof thenExpr === "string" && !thenExpr.startsWith("$$") || typeof elseExpr === "string" && !elseExpr.startsWith("$$")) {
          throw new Error("If thenExpr or elseExpr is string, it must start with $$. e.g. $$DESCEND, $$PRUNE, $$KEEP");
        }
        expression = {
          $cond: {
            if: expression,
            then: thenExpr,
            else: elseExpr
          }
        };
      } else if (arguments.length !== 1) {
        throw new TypeError("Invalid arguments");
      }
      return this.append({ $redact: expression });
    };
    Aggregate.prototype.explain = function(callback) {
      const model2 = this._model;
      return promiseOrCallback(callback, (cb) => {
        if (!this._pipeline.length) {
          const err = new Error("Aggregate has empty pipeline");
          return cb(err);
        }
        prepareDiscriminatorPipeline(this);
        model2.hooks.execPre("aggregate", this, (error) => {
          if (error) {
            const _opts = { error };
            return model2.hooks.execPost("aggregate", this, [null], _opts, (error2) => {
              cb(error2);
            });
          }
          this.options.explain = true;
          model2.collection.aggregate(this._pipeline, this.options || {}).explain((error2, result) => {
            const _opts = { error: error2 };
            return model2.hooks.execPost("aggregate", this, [result], _opts, (error3) => {
              if (error3) {
                return cb(error3);
              }
              return cb(null, result);
            });
          });
        });
      }, model2.events);
    };
    Aggregate.prototype.allowDiskUse = function(value) {
      this.options.allowDiskUse = value;
      return this;
    };
    Aggregate.prototype.hint = function(value) {
      this.options.hint = value;
      return this;
    };
    Aggregate.prototype.session = function(session) {
      if (session == null) {
        delete this.options.session;
      } else {
        this.options.session = session;
      }
      return this;
    };
    Aggregate.prototype.option = function(value) {
      for (const key in value) {
        this.options[key] = value[key];
      }
      return this;
    };
    Aggregate.prototype.cursor = function(options) {
      if (!this.options) {
        this.options = {};
      }
      this.options.cursor = options || {};
      return this;
    };
    Aggregate.prototype.addCursorFlag = util.deprecate(function(flag, value) {
      if (!this.options) {
        this.options = {};
      }
      this.options[flag] = value;
      return this;
    }, "Mongoose: `Aggregate#addCursorFlag()` is deprecated, use `option()` instead");
    Aggregate.prototype.collation = function(collation) {
      if (!this.options) {
        this.options = {};
      }
      this.options.collation = collation;
      return this;
    };
    Aggregate.prototype.facet = function(options) {
      return this.append({ $facet: options });
    };
    Aggregate.prototype.search = function(options) {
      return this.append({ $search: options });
    };
    Aggregate.prototype.pipeline = function() {
      return this._pipeline;
    };
    Aggregate.prototype.exec = function(callback) {
      if (!this._model) {
        throw new Error("Aggregate not bound to any Model");
      }
      const model2 = this._model;
      const collection = this._model.collection;
      applyGlobalMaxTimeMS(this.options, model2);
      if (this.options && this.options.cursor) {
        return new AggregationCursor(this);
      }
      return promiseOrCallback(callback, (cb) => {
        prepareDiscriminatorPipeline(this);
        stringifyFunctionOperators(this._pipeline);
        model2.hooks.execPre("aggregate", this, (error) => {
          if (error) {
            const _opts = { error };
            return model2.hooks.execPost("aggregate", this, [null], _opts, (error2) => {
              cb(error2);
            });
          }
          if (!this._pipeline.length) {
            return cb(new Error("Aggregate has empty pipeline"));
          }
          const options = utils2.clone(this.options || {});
          collection.aggregate(this._pipeline, options, (error2, cursor) => {
            if (error2) {
              const _opts = { error: error2 };
              return model2.hooks.execPost("aggregate", this, [null], _opts, (error3) => {
                if (error3) {
                  return cb(error3);
                }
                return cb(null);
              });
            }
            cursor.toArray((error3, result) => {
              const _opts = { error: error3 };
              model2.hooks.execPost("aggregate", this, [result], _opts, (error4, result2) => {
                if (error4) {
                  return cb(error4);
                }
                cb(null, result2);
              });
            });
          });
        });
      }, model2.events);
    };
    Aggregate.prototype.then = function(resolve, reject) {
      return this.exec().then(resolve, reject);
    };
    Aggregate.prototype.catch = function(reject) {
      return this.exec().then(null, reject);
    };
    if (Symbol.asyncIterator != null) {
      Aggregate.prototype[Symbol.asyncIterator] = function() {
        return this.cursor({ useMongooseAggCursor: true }).exec().transformNull()._transformForAsyncIterator();
      };
    }
    function isOperator(obj) {
      if (typeof obj !== "object") {
        return false;
      }
      const k = Object.keys(obj);
      return k.length === 1 && k.some((key) => {
        return key[0] === "$";
      });
    }
    Aggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;
    function prepareDiscriminatorPipeline(aggregate) {
      const schema = aggregate._model.schema;
      const discriminatorMapping = schema && schema.discriminatorMapping;
      if (discriminatorMapping && !discriminatorMapping.isRoot) {
        const originalPipeline = aggregate._pipeline;
        const discriminatorKey = discriminatorMapping.key;
        const discriminatorValue = discriminatorMapping.value;
        if (originalPipeline[0] && originalPipeline[0].$match && !originalPipeline[0].$match[discriminatorKey]) {
          originalPipeline[0].$match[discriminatorKey] = discriminatorValue;
        } else if (originalPipeline[0] && originalPipeline[0].$geoNear) {
          originalPipeline[0].$geoNear.query = originalPipeline[0].$geoNear.query || {};
          originalPipeline[0].$geoNear.query[discriminatorKey] = discriminatorValue;
        } else if (originalPipeline[0] && originalPipeline[0].$search) {
          if (originalPipeline[1] && originalPipeline[1].$match != null) {
            originalPipeline[1].$match[discriminatorKey] = originalPipeline[1].$match[discriminatorKey] || discriminatorValue;
          } else {
            const match = {};
            match[discriminatorKey] = discriminatorValue;
            originalPipeline.splice(1, 0, { $match: match });
          }
        } else {
          const match = {};
          match[discriminatorKey] = discriminatorValue;
          aggregate._pipeline.unshift({ $match: match });
        }
      }
    }
    module2.exports = Aggregate;
  }
});

// node_modules/mongoose/lib/options/removeOptions.js
var require_removeOptions = __commonJS({
  "node_modules/mongoose/lib/options/removeOptions.js"(exports2, module2) {
    "use strict";
    var clone = require_clone();
    var RemoveOptions = class {
      constructor(obj) {
        if (obj == null) {
          return;
        }
        Object.assign(this, clone(obj));
      }
    };
    module2.exports = RemoveOptions;
  }
});

// node_modules/mongoose/lib/options/saveOptions.js
var require_saveOptions = __commonJS({
  "node_modules/mongoose/lib/options/saveOptions.js"(exports2, module2) {
    "use strict";
    var clone = require_clone();
    var SaveOptions = class {
      constructor(obj) {
        if (obj == null) {
          return;
        }
        Object.assign(this, clone(obj));
      }
    };
    module2.exports = SaveOptions;
  }
});

// node_modules/mongoose/lib/helpers/model/applyMethods.js
var require_applyMethods = __commonJS({
  "node_modules/mongoose/lib/helpers/model/applyMethods.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    module2.exports = function applyMethods(model2, schema) {
      function apply(method, schema2) {
        Object.defineProperty(model2.prototype, method, {
          get: function() {
            const h = {};
            for (const k in schema2.methods[method]) {
              h[k] = schema2.methods[method][k].bind(this);
            }
            return h;
          },
          configurable: true
        });
      }
      for (const method of Object.keys(schema.methods)) {
        const fn = schema.methods[method];
        if (schema.tree.hasOwnProperty(method)) {
          throw new Error('You have a method and a property in your schema both named "' + method + '"');
        }
        if (schema.reserved[method] && !get(schema, `methodOptions.${method}.suppressWarning`, false)) {
          console.warn(`mongoose: the method name "${method}" is used by mongoose internally, overwriting it may cause bugs. If you're sure you know what you're doing, you can suppress this error by using \`schema.method('${method}', fn, { suppressWarning: true })\`.`);
        }
        if (typeof fn === "function") {
          model2.prototype[method] = fn;
        } else {
          apply(method, schema);
        }
      }
      model2.$appliedMethods = true;
      for (const key of Object.keys(schema.paths)) {
        const type = schema.paths[key];
        if (type.$isSingleNested && !type.caster.$appliedMethods) {
          applyMethods(type.caster, type.schema);
        }
        if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {
          applyMethods(type.Constructor, type.schema);
        }
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/model/applyStaticHooks.js
var require_applyStaticHooks = __commonJS({
  "node_modules/mongoose/lib/helpers/model/applyStaticHooks.js"(exports2, module2) {
    "use strict";
    var middlewareFunctions = require_applyQueryMiddleware().middlewareFunctions;
    var promiseOrCallback = require_promiseOrCallback();
    module2.exports = function applyStaticHooks(model2, hooks, statics) {
      const kareemOptions = {
        useErrorHandlers: true,
        numCallbackParams: 1
      };
      hooks = hooks.filter((hook) => {
        if (middlewareFunctions.indexOf(hook.name) !== -1) {
          return !!hook.model;
        }
        return hook.model !== false;
      });
      model2.$__insertMany = hooks.createWrapper("insertMany", model2.$__insertMany, model2, kareemOptions);
      for (const key of Object.keys(statics)) {
        if (hooks.hasHooks(key)) {
          const original = model2[key];
          model2[key] = function() {
            const numArgs = arguments.length;
            const lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;
            const cb = typeof lastArg === "function" ? lastArg : null;
            const args = Array.prototype.slice.call(arguments, 0, cb == null ? numArgs : numArgs - 1);
            return promiseOrCallback(cb, (callback) => {
              hooks.execPre(key, model2, args, function(err) {
                if (err != null) {
                  return callback(err);
                }
                let postCalled = 0;
                const ret2 = original.apply(model2, args.concat(post));
                if (ret2 != null && typeof ret2.then === "function") {
                  ret2.then((res) => post(null, res), (err2) => post(err2));
                }
                function post(error, res) {
                  if (postCalled++ > 0) {
                    return;
                  }
                  if (error != null) {
                    return callback(error);
                  }
                  hooks.execPost(key, model2, [res], function(error2) {
                    if (error2 != null) {
                      return callback(error2);
                    }
                    callback(null, res);
                  });
                }
              });
            }, model2.events);
          };
        }
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/model/applyStatics.js
var require_applyStatics = __commonJS({
  "node_modules/mongoose/lib/helpers/model/applyStatics.js"(exports2, module2) {
    "use strict";
    module2.exports = function applyStatics(model2, schema) {
      for (const i in schema.statics) {
        model2[i] = schema.statics[i];
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/populate/SkipPopulateValue.js
var require_SkipPopulateValue = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/SkipPopulateValue.js"(exports2, module2) {
    "use strict";
    module2.exports = function SkipPopulateValue(val) {
      if (!(this instanceof SkipPopulateValue)) {
        return new SkipPopulateValue(val);
      }
      this.val = val;
      return this;
    };
  }
});

// node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js
var require_leanPopulateMap = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js"(exports2, module2) {
    "use strict";
    module2.exports = new WeakMap();
  }
});

// node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js
var require_assignRawDocsToIdStructure = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js"(exports2, module2) {
    "use strict";
    var leanPopulateMap = require_leanPopulateMap();
    var modelSymbol = require_symbols().modelSymbol;
    var utils2 = require_utils8();
    module2.exports = assignRawDocsToIdStructure;
    function assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {
      const newOrder = [];
      const sorting = options.sort && rawIds.length > 1;
      const nullIfNotFound = options.$nullIfNotFound;
      let doc;
      let sid;
      let id;
      for (let i = 0; i < rawIds.length; ++i) {
        id = rawIds[i];
        if (Array.isArray(id)) {
          assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);
          newOrder.push(id);
          continue;
        }
        if (id === null && !sorting) {
          newOrder.push(id);
          continue;
        }
        sid = String(id);
        doc = resultDocs[sid];
        if (options.clone && doc != null) {
          if (options.lean) {
            const _model = leanPopulateMap.get(doc);
            doc = utils2.clone(doc);
            leanPopulateMap.set(doc, _model);
          } else {
            doc = doc.constructor.hydrate(doc._doc);
          }
        }
        if (recursed) {
          if (doc) {
            if (sorting) {
              newOrder[resultOrder[sid]] = doc;
            } else {
              newOrder.push(doc);
            }
          } else if (id != null && id[modelSymbol] != null) {
            newOrder.push(id);
          } else {
            newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);
          }
        } else {
          newOrder[i] = doc || null;
        }
      }
      rawIds.length = 0;
      if (newOrder.length) {
        newOrder.forEach(function(doc2, i) {
          rawIds[i] = doc2;
        });
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/populate/getVirtual.js
var require_getVirtual = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/getVirtual.js"(exports2, module2) {
    "use strict";
    module2.exports = getVirtual;
    function getVirtual(schema, name) {
      if (schema.virtuals[name]) {
        return { virtual: schema.virtuals[name], path: void 0 };
      }
      const parts = name.split(".");
      let cur = "";
      let nestedSchemaPath = "";
      for (let i = 0; i < parts.length; ++i) {
        cur += (cur.length > 0 ? "." : "") + parts[i];
        if (schema.virtuals[cur]) {
          if (i === parts.length - 1) {
            return { virtual: schema.virtuals[cur], path: nestedSchemaPath };
          }
          continue;
        }
        if (schema.nested[cur]) {
          continue;
        }
        if (schema.paths[cur] && schema.paths[cur].schema) {
          schema = schema.paths[cur].schema;
          const rest = parts.slice(i + 1).join(".");
          if (schema.virtuals[rest]) {
            if (i === parts.length - 2) {
              return {
                virtual: schema.virtuals[rest],
                nestedSchemaPath: [nestedSchemaPath, cur].filter((v) => !!v).join(".")
              };
            }
            continue;
          }
          if (i + 1 < parts.length && schema.discriminators) {
            for (const key of Object.keys(schema.discriminators)) {
              const res = getVirtual(schema.discriminators[key], rest);
              if (res != null) {
                const _path = [nestedSchemaPath, cur, res.nestedSchemaPath].filter((v) => !!v).join(".");
                return {
                  virtual: res.virtual,
                  nestedSchemaPath: _path
                };
              }
            }
          }
          nestedSchemaPath += (nestedSchemaPath.length > 0 ? "." : "") + cur;
          cur = "";
          continue;
        }
        if (schema.discriminators) {
          for (const discriminatorKey of Object.keys(schema.discriminators)) {
            const virtualFromDiscriminator = getVirtual(schema.discriminators[discriminatorKey], name);
            if (virtualFromDiscriminator)
              return virtualFromDiscriminator;
          }
        }
        return null;
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js
var require_lookupLocalFields = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js"(exports2, module2) {
    "use strict";
    module2.exports = function lookupLocalFields(cur, path, val) {
      if (cur == null) {
        return cur;
      }
      if (cur._doc != null) {
        cur = cur._doc;
      }
      if (arguments.length >= 3) {
        if (typeof cur !== "object") {
          return void 0;
        }
        cur[path] = val;
        return val;
      }
      if (path === "$*") {
        return cur instanceof Map ? Array.from(cur.values()) : Object.keys(cur).map((key) => cur[key]);
      }
      return cur[path];
    };
  }
});

// node_modules/sift/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/sift/lib/index.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.sift = {}));
    })(exports2, function(exports3) {
      "use strict";
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      function __extends(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      var typeChecker = function(type) {
        var typeString = "[object " + type + "]";
        return function(value) {
          return getClassName(value) === typeString;
        };
      };
      var getClassName = function(value) {
        return Object.prototype.toString.call(value);
      };
      var comparable = function(value) {
        if (value instanceof Date) {
          return value.getTime();
        } else if (isArray(value)) {
          return value.map(comparable);
        } else if (value && typeof value.toJSON === "function") {
          return value.toJSON();
        }
        return value;
      };
      var isArray = typeChecker("Array");
      var isObject2 = typeChecker("Object");
      var isFunction = typeChecker("Function");
      var isVanillaObject = function(value) {
        return value && (value.constructor === Object || value.constructor === Array || value.constructor.toString() === "function Object() { [native code] }" || value.constructor.toString() === "function Array() { [native code] }") && !value.toJSON;
      };
      var equals = function(a, b) {
        if (a == null && a == b) {
          return true;
        }
        if (a === b) {
          return true;
        }
        if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {
          return false;
        }
        if (isArray(a)) {
          if (a.length !== b.length) {
            return false;
          }
          for (var i = 0, length_1 = a.length; i < length_1; i++) {
            if (!equals(a[i], b[i]))
              return false;
          }
          return true;
        } else if (isObject2(a)) {
          if (Object.keys(a).length !== Object.keys(b).length) {
            return false;
          }
          for (var key in a) {
            if (!equals(a[key], b[key]))
              return false;
          }
          return true;
        }
        return false;
      };
      var walkKeyPathValues = function(item, keyPath, next, depth, key, owner) {
        var currentKey = keyPath[depth];
        if (isArray(item) && isNaN(Number(currentKey))) {
          for (var i = 0, length_1 = item.length; i < length_1; i++) {
            if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {
              return false;
            }
          }
        }
        if (depth === keyPath.length || item == null) {
          return next(item, key, owner);
        }
        return walkKeyPathValues(item[currentKey], keyPath, next, depth + 1, currentKey, item);
      };
      var BaseOperation = function() {
        function BaseOperation2(params, owneryQuery, options) {
          this.params = params;
          this.owneryQuery = owneryQuery;
          this.options = options;
          this.init();
        }
        BaseOperation2.prototype.init = function() {
        };
        BaseOperation2.prototype.reset = function() {
          this.done = false;
          this.keep = false;
        };
        return BaseOperation2;
      }();
      var NamedBaseOperation = function(_super) {
        __extends(NamedBaseOperation2, _super);
        function NamedBaseOperation2(params, owneryQuery, options, name) {
          var _this = _super.call(this, params, owneryQuery, options) || this;
          _this.name = name;
          return _this;
        }
        return NamedBaseOperation2;
      }(BaseOperation);
      var GroupOperation = function(_super) {
        __extends(GroupOperation2, _super);
        function GroupOperation2(params, owneryQuery, options, children) {
          var _this = _super.call(this, params, owneryQuery, options) || this;
          _this.children = children;
          return _this;
        }
        GroupOperation2.prototype.reset = function() {
          this.keep = false;
          this.done = false;
          for (var i = 0, length_2 = this.children.length; i < length_2; i++) {
            this.children[i].reset();
          }
        };
        GroupOperation2.prototype.childrenNext = function(item, key, owner) {
          var done = true;
          var keep = true;
          for (var i = 0, length_3 = this.children.length; i < length_3; i++) {
            var childOperation = this.children[i];
            childOperation.next(item, key, owner);
            if (!childOperation.keep) {
              keep = false;
            }
            if (childOperation.done) {
              if (!childOperation.keep) {
                break;
              }
            } else {
              done = false;
            }
          }
          this.done = done;
          this.keep = keep;
        };
        return GroupOperation2;
      }(BaseOperation);
      var NamedGroupOperation = function(_super) {
        __extends(NamedGroupOperation2, _super);
        function NamedGroupOperation2(params, owneryQuery, options, children, name) {
          var _this = _super.call(this, params, owneryQuery, options, children) || this;
          _this.name = name;
          return _this;
        }
        return NamedGroupOperation2;
      }(GroupOperation);
      var QueryOperation = function(_super) {
        __extends(QueryOperation2, _super);
        function QueryOperation2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        QueryOperation2.prototype.next = function(item, key, parent) {
          this.childrenNext(item, key, parent);
        };
        return QueryOperation2;
      }(GroupOperation);
      var NestedOperation = function(_super) {
        __extends(NestedOperation2, _super);
        function NestedOperation2(keyPath, params, owneryQuery, options, children) {
          var _this = _super.call(this, params, owneryQuery, options, children) || this;
          _this.keyPath = keyPath;
          _this._nextNestedValue = function(value, key, owner) {
            _this.childrenNext(value, key, owner);
            return !_this.done;
          };
          return _this;
        }
        NestedOperation2.prototype.next = function(item, key, parent) {
          walkKeyPathValues(item, this.keyPath, this._nextNestedValue, 0, key, parent);
        };
        return NestedOperation2;
      }(GroupOperation);
      var createTester = function(a, compare) {
        if (a instanceof Function) {
          return a;
        }
        if (a instanceof RegExp) {
          return function(b) {
            var result = typeof b === "string" && a.test(b);
            a.lastIndex = 0;
            return result;
          };
        }
        var comparableA = comparable(a);
        return function(b) {
          return compare(comparableA, comparable(b));
        };
      };
      var EqualsOperation = function(_super) {
        __extends(EqualsOperation2, _super);
        function EqualsOperation2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        EqualsOperation2.prototype.init = function() {
          this._test = createTester(this.params, this.options.compare);
        };
        EqualsOperation2.prototype.next = function(item, key, parent) {
          if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {
            if (this._test(item, key, parent)) {
              this.done = true;
              this.keep = true;
            }
          }
        };
        return EqualsOperation2;
      }(BaseOperation);
      var createEqualsOperation = function(params, owneryQuery, options) {
        return new EqualsOperation(params, owneryQuery, options);
      };
      var NopeOperation = function(_super) {
        __extends(NopeOperation2, _super);
        function NopeOperation2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NopeOperation2.prototype.next = function() {
          this.done = true;
          this.keep = false;
        };
        return NopeOperation2;
      }(BaseOperation);
      var numericalOperationCreator = function(createNumericalOperation) {
        return function(params, owneryQuery, options, name) {
          if (params == null) {
            return new NopeOperation(params, owneryQuery, options);
          }
          return createNumericalOperation(params, owneryQuery, options, name);
        };
      };
      var numericalOperation = function(createTester2) {
        return numericalOperationCreator(function(params, owneryQuery, options) {
          var typeofParams = typeof comparable(params);
          var test = createTester2(params);
          return new EqualsOperation(function(b) {
            return typeof comparable(b) === typeofParams && test(b);
          }, owneryQuery, options);
        });
      };
      var createNamedOperation = function(name, params, parentQuery, options) {
        var operationCreator = options.operations[name];
        if (!operationCreator) {
          throw new Error("Unsupported operation: " + name);
        }
        return operationCreator(params, parentQuery, options, name);
      };
      var containsOperation = function(query) {
        for (var key in query) {
          if (key.charAt(0) === "$")
            return true;
        }
        return false;
      };
      var createNestedOperation = function(keyPath, nestedQuery, owneryQuery, options) {
        if (containsOperation(nestedQuery)) {
          var _a = createQueryOperations(nestedQuery, options), selfOperations = _a[0], nestedOperations = _a[1];
          if (nestedOperations.length) {
            throw new Error("Property queries must contain only operations, or exact objects.");
          }
          return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, selfOperations);
        }
        return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, [
          new EqualsOperation(nestedQuery, owneryQuery, options)
        ]);
      };
      var createQueryOperation = function(query, owneryQuery, _a) {
        if (owneryQuery === void 0) {
          owneryQuery = null;
        }
        var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;
        var options = {
          compare: compare || equals,
          operations: Object.assign({}, operations || {})
        };
        var _c = createQueryOperations(query, options), selfOperations = _c[0], nestedOperations = _c[1];
        var ops = [];
        if (selfOperations.length) {
          ops.push(new NestedOperation([], query, owneryQuery, options, selfOperations));
        }
        ops.push.apply(ops, nestedOperations);
        if (ops.length === 1) {
          return ops[0];
        }
        return new QueryOperation(query, owneryQuery, options, ops);
      };
      var createQueryOperations = function(query, options) {
        var selfOperations = [];
        var nestedOperations = [];
        if (!isVanillaObject(query)) {
          selfOperations.push(new EqualsOperation(query, query, options));
          return [selfOperations, nestedOperations];
        }
        for (var key in query) {
          if (key.charAt(0) === "$") {
            var op = createNamedOperation(key, query[key], query, options);
            if (op != null) {
              selfOperations.push(op);
            }
          } else {
            nestedOperations.push(createNestedOperation(key.split("."), query[key], query, options));
          }
        }
        return [selfOperations, nestedOperations];
      };
      var createOperationTester = function(operation) {
        return function(item, key, owner) {
          operation.reset();
          operation.next(item, key, owner);
          return operation.keep;
        };
      };
      var createQueryTester = function(query, options) {
        if (options === void 0) {
          options = {};
        }
        return createOperationTester(createQueryOperation(query, null, options));
      };
      var $Ne = function(_super) {
        __extends($Ne2, _super);
        function $Ne2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $Ne2.prototype.init = function() {
          this._test = createTester(this.params, this.options.compare);
        };
        $Ne2.prototype.reset = function() {
          _super.prototype.reset.call(this);
          this.keep = true;
        };
        $Ne2.prototype.next = function(item) {
          if (this._test(item)) {
            this.done = true;
            this.keep = false;
          }
        };
        return $Ne2;
      }(NamedBaseOperation);
      var $ElemMatch = function(_super) {
        __extends($ElemMatch2, _super);
        function $ElemMatch2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $ElemMatch2.prototype.init = function() {
          this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
        };
        $ElemMatch2.prototype.reset = function() {
          _super.prototype.reset.call(this);
          this._queryOperation.reset();
        };
        $ElemMatch2.prototype.next = function(item) {
          if (isArray(item)) {
            for (var i = 0, length_1 = item.length; i < length_1; i++) {
              this._queryOperation.reset();
              this._queryOperation.next(item[i], i, item);
              this.keep = this.keep || this._queryOperation.keep;
            }
            this.done = true;
          } else {
            this.done = false;
            this.keep = false;
          }
        };
        return $ElemMatch2;
      }(NamedBaseOperation);
      var $Not = function(_super) {
        __extends($Not2, _super);
        function $Not2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $Not2.prototype.init = function() {
          this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
        };
        $Not2.prototype.reset = function() {
          this._queryOperation.reset();
        };
        $Not2.prototype.next = function(item, key, owner) {
          this._queryOperation.next(item, key, owner);
          this.done = this._queryOperation.done;
          this.keep = !this._queryOperation.keep;
        };
        return $Not2;
      }(NamedBaseOperation);
      var $Size = function(_super) {
        __extends($Size2, _super);
        function $Size2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $Size2.prototype.init = function() {
        };
        $Size2.prototype.next = function(item) {
          if (isArray(item) && item.length === this.params) {
            this.done = true;
            this.keep = true;
          }
        };
        return $Size2;
      }(NamedBaseOperation);
      var $Or = function(_super) {
        __extends($Or2, _super);
        function $Or2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $Or2.prototype.init = function() {
          var _this = this;
          this._ops = this.params.map(function(op) {
            return createQueryOperation(op, null, _this.options);
          });
        };
        $Or2.prototype.reset = function() {
          this.done = false;
          this.keep = false;
          for (var i = 0, length_2 = this._ops.length; i < length_2; i++) {
            this._ops[i].reset();
          }
        };
        $Or2.prototype.next = function(item, key, owner) {
          var done = false;
          var success = false;
          for (var i = 0, length_3 = this._ops.length; i < length_3; i++) {
            var op = this._ops[i];
            op.next(item, key, owner);
            if (op.keep) {
              done = true;
              success = op.keep;
              break;
            }
          }
          this.keep = success;
          this.done = done;
        };
        return $Or2;
      }(NamedBaseOperation);
      var $Nor = function(_super) {
        __extends($Nor2, _super);
        function $Nor2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $Nor2.prototype.next = function(item, key, owner) {
          _super.prototype.next.call(this, item, key, owner);
          this.keep = !this.keep;
        };
        return $Nor2;
      }($Or);
      var $In = function(_super) {
        __extends($In2, _super);
        function $In2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $In2.prototype.init = function() {
          var _this = this;
          this._testers = this.params.map(function(value) {
            if (containsOperation(value)) {
              throw new Error("cannot nest $ under " + _this.constructor.name.toLowerCase());
            }
            return createTester(value, _this.options.compare);
          });
        };
        $In2.prototype.next = function(item, key, owner) {
          var done = false;
          var success = false;
          for (var i = 0, length_4 = this._testers.length; i < length_4; i++) {
            var test = this._testers[i];
            if (test(item)) {
              done = true;
              success = true;
              break;
            }
          }
          this.keep = success;
          this.done = done;
        };
        return $In2;
      }(NamedBaseOperation);
      var $Nin = function(_super) {
        __extends($Nin2, _super);
        function $Nin2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $Nin2.prototype.next = function(item, key, owner) {
          _super.prototype.next.call(this, item, key, owner);
          this.keep = !this.keep;
        };
        return $Nin2;
      }($In);
      var $Exists = function(_super) {
        __extends($Exists2, _super);
        function $Exists2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $Exists2.prototype.next = function(item, key, owner) {
          if (owner.hasOwnProperty(key) === this.params) {
            this.done = true;
            this.keep = true;
          }
        };
        return $Exists2;
      }(NamedBaseOperation);
      var $And = function(_super) {
        __extends($And2, _super);
        function $And2(params, owneryQuery, options, name) {
          return _super.call(this, params, owneryQuery, options, params.map(function(query) {
            return createQueryOperation(query, owneryQuery, options);
          }), name) || this;
        }
        $And2.prototype.next = function(item, key, owner) {
          this.childrenNext(item, key, owner);
        };
        return $And2;
      }(NamedGroupOperation);
      var $eq = function(params, owneryQuery, options) {
        return new EqualsOperation(params, owneryQuery, options);
      };
      var $ne = function(params, owneryQuery, options, name) {
        return new $Ne(params, owneryQuery, options, name);
      };
      var $or = function(params, owneryQuery, options, name) {
        return new $Or(params, owneryQuery, options, name);
      };
      var $nor = function(params, owneryQuery, options, name) {
        return new $Nor(params, owneryQuery, options, name);
      };
      var $elemMatch = function(params, owneryQuery, options, name) {
        return new $ElemMatch(params, owneryQuery, options, name);
      };
      var $nin = function(params, owneryQuery, options, name) {
        return new $Nin(params, owneryQuery, options, name);
      };
      var $in = function(params, owneryQuery, options, name) {
        return new $In(params, owneryQuery, options, name);
      };
      var $lt = numericalOperation(function(params) {
        return function(b) {
          return b < params;
        };
      });
      var $lte = numericalOperation(function(params) {
        return function(b) {
          return b <= params;
        };
      });
      var $gt = numericalOperation(function(params) {
        return function(b) {
          return b > params;
        };
      });
      var $gte = numericalOperation(function(params) {
        return function(b) {
          return b >= params;
        };
      });
      var $mod = function(_a, owneryQuery, options) {
        var mod = _a[0], equalsValue = _a[1];
        return new EqualsOperation(function(b) {
          return comparable(b) % mod === equalsValue;
        }, owneryQuery, options);
      };
      var $exists = function(params, owneryQuery, options, name) {
        return new $Exists(params, owneryQuery, options, name);
      };
      var $regex = function(pattern, owneryQuery, options) {
        return new EqualsOperation(new RegExp(pattern, owneryQuery.$options), owneryQuery, options);
      };
      var $not = function(params, owneryQuery, options, name) {
        return new $Not(params, owneryQuery, options, name);
      };
      var typeAliases = {
        number: function(v) {
          return typeof v === "number";
        },
        string: function(v) {
          return typeof v === "string";
        },
        bool: function(v) {
          return typeof v === "boolean";
        },
        array: function(v) {
          return Array.isArray(v);
        },
        null: function(v) {
          return v === null;
        },
        timestamp: function(v) {
          return v instanceof Date;
        }
      };
      var $type = function(clazz, owneryQuery, options) {
        return new EqualsOperation(function(b) {
          if (typeof clazz === "string") {
            if (!typeAliases[clazz]) {
              throw new Error("Type alias does not exist");
            }
            return typeAliases[clazz](b);
          }
          return b != null ? b instanceof clazz || b.constructor === clazz : false;
        }, owneryQuery, options);
      };
      var $and = function(params, ownerQuery, options, name) {
        return new $And(params, ownerQuery, options, name);
      };
      var $all = $and;
      var $size = function(params, ownerQuery, options) {
        return new $Size(params, ownerQuery, options, "$size");
      };
      var $options = function() {
        return null;
      };
      var $where = function(params, ownerQuery, options) {
        var test;
        if (isFunction(params)) {
          test = params;
        } else if (!process.env.CSP_ENABLED) {
          test = new Function("obj", "return " + params);
        } else {
          throw new Error('In CSP mode, sift does not support strings in "$where" condition');
        }
        return new EqualsOperation(function(b) {
          return test.bind(b)(b);
        }, ownerQuery, options);
      };
      var defaultOperations = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        $Size,
        $eq,
        $ne,
        $or,
        $nor,
        $elemMatch,
        $nin,
        $in,
        $lt,
        $lte,
        $gt,
        $gte,
        $mod,
        $exists,
        $regex,
        $not,
        $type,
        $and,
        $all,
        $size,
        $options,
        $where
      });
      var createDefaultQueryOperation = function(query, ownerQuery, _a) {
        var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;
        return createQueryOperation(query, ownerQuery, {
          compare,
          operations: Object.assign({}, defaultOperations, operations || {})
        });
      };
      var createDefaultQueryTester = function(query, options) {
        if (options === void 0) {
          options = {};
        }
        var op = createDefaultQueryOperation(query, null, options);
        return createOperationTester(op);
      };
      exports3.$Size = $Size;
      exports3.$all = $all;
      exports3.$and = $and;
      exports3.$elemMatch = $elemMatch;
      exports3.$eq = $eq;
      exports3.$exists = $exists;
      exports3.$gt = $gt;
      exports3.$gte = $gte;
      exports3.$in = $in;
      exports3.$lt = $lt;
      exports3.$lte = $lte;
      exports3.$mod = $mod;
      exports3.$ne = $ne;
      exports3.$nin = $nin;
      exports3.$nor = $nor;
      exports3.$not = $not;
      exports3.$options = $options;
      exports3.$or = $or;
      exports3.$regex = $regex;
      exports3.$size = $size;
      exports3.$type = $type;
      exports3.$where = $where;
      exports3.EqualsOperation = EqualsOperation;
      exports3.createDefaultQueryOperation = createDefaultQueryOperation;
      exports3.createEqualsOperation = createEqualsOperation;
      exports3.createOperationTester = createOperationTester;
      exports3.createQueryOperation = createQueryOperation;
      exports3.createQueryTester = createQueryTester;
      exports3.default = createDefaultQueryTester;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/sift/index.js
var require_sift = __commonJS({
  "node_modules/sift/index.js"(exports2, module2) {
    var lib = require_lib4();
    module2.exports = lib.default;
    Object.assign(module2.exports, lib);
  }
});

// node_modules/mongoose/lib/helpers/populate/assignVals.js
var require_assignVals = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/assignVals.js"(exports2, module2) {
    "use strict";
    var SkipPopulateValue = require_SkipPopulateValue();
    var assignRawDocsToIdStructure = require_assignRawDocsToIdStructure();
    var get = require_get();
    var getVirtual = require_getVirtual();
    var leanPopulateMap = require_leanPopulateMap();
    var lookupLocalFields = require_lookupLocalFields();
    var mpath = require_mpath();
    var sift = require_sift().default;
    var utils2 = require_utils8();
    module2.exports = function assignVals(o) {
      const userOptions = Object.assign({}, get(o, "allOptions.options.options"), get(o, "allOptions.options"));
      const populateOptions = Object.assign({}, o.options, userOptions, {
        justOne: o.justOne
      });
      populateOptions.$nullIfNotFound = o.isVirtual;
      const populatedModel = o.populatedModel;
      const originalIds = [].concat(o.rawIds);
      o.allIds = [].concat(o.allIds);
      assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);
      const docs = o.docs;
      const rawIds = o.rawIds;
      const options = o.options;
      const count = o.count && o.isVirtual;
      let i;
      function setValue(val) {
        if (count) {
          return val;
        }
        if (val instanceof SkipPopulateValue) {
          return val.val;
        }
        const _allIds = o.allIds[i];
        if (o.justOne === true && Array.isArray(val)) {
          const ret2 = [];
          for (const doc of val) {
            const _docPopulatedModel = leanPopulateMap.get(doc);
            if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {
              ret2.push(doc);
            }
          }
          while (val.length > ret2.length) {
            Array.prototype.pop.apply(val, []);
          }
          for (let i2 = 0; i2 < ret2.length; ++i2) {
            val[i2] = ret2[i2];
          }
          return valueFilter(val[0], options, populateOptions, _allIds);
        } else if (o.justOne === false && !Array.isArray(val)) {
          return valueFilter([val], options, populateOptions, _allIds);
        }
        return valueFilter(val, options, populateOptions, _allIds);
      }
      for (i = 0; i < docs.length; ++i) {
        const _path = o.path.endsWith(".$*") ? o.path.slice(0, -3) : o.path;
        const existingVal = mpath.get(_path, docs[i], lookupLocalFields);
        if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {
          continue;
        }
        let valueToSet;
        if (count) {
          valueToSet = numDocs(rawIds[i]);
        } else if (Array.isArray(o.match)) {
          valueToSet = Array.isArray(rawIds[i]) ? rawIds[i].filter(sift(o.match[i])) : [rawIds[i]].filter(sift(o.match[i]))[0];
        } else {
          valueToSet = rawIds[i];
        }
        const originalSchema = o.originalModel.schema;
        const isDoc = get(docs[i], "$__", null) != null;
        let isMap = isDoc ? existingVal instanceof Map : utils2.isPOJO(existingVal);
        isMap = isMap && get(originalSchema._getSchema(_path), "$isSchemaMap");
        if (!o.isVirtual && isMap) {
          const _keys = existingVal instanceof Map ? Array.from(existingVal.keys()) : Object.keys(existingVal);
          valueToSet = valueToSet.reduce((cur2, v, i2) => {
            cur2.set(_keys[i2], v);
            return cur2;
          }, new Map());
        }
        if (isDoc && Array.isArray(valueToSet)) {
          for (const val of valueToSet) {
            if (val != null && val.$__ != null) {
              val.$__.parent = docs[i];
            }
          }
        } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {
          valueToSet.$__.parent = docs[i];
        }
        if (o.isVirtual && isDoc) {
          docs[i].populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);
          mpath.set(_path, valueToSet, docs[i], setValue);
          continue;
        }
        const parts = _path.split(".");
        let cur = docs[i];
        const curPath = parts[0];
        for (let j = 0; j < parts.length - 1; ++j) {
          if (Array.isArray(cur) && !utils2.isArrayIndex(parts[j])) {
            break;
          }
          if (parts[j] === "$*") {
            break;
          }
          if (cur[parts[j]] == null) {
            const schematype = originalSchema._getSchema(curPath);
            if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {
              break;
            }
            cur[parts[j]] = {};
          }
          cur = cur[parts[j]];
          if (typeof cur !== "object") {
            break;
          }
        }
        if (docs[i].$__) {
          docs[i].populated(_path, o.allIds[i], o.allOptions);
        }
        mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);
      }
    };
    function numDocs(v) {
      if (Array.isArray(v)) {
        if (v.some((el) => Array.isArray(el))) {
          return v.map((el) => numDocs(el));
        }
        return v.length;
      }
      return v == null ? 0 : 1;
    }
    function valueFilter(val, assignmentOpts, populateOptions, allIds) {
      const userSpecifiedTransform = typeof populateOptions.transform === "function";
      const transform = userSpecifiedTransform ? populateOptions.transform : noop;
      if (Array.isArray(val)) {
        const ret2 = [];
        const numValues = val.length;
        for (let i = 0; i < numValues; ++i) {
          let subdoc = val[i];
          const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;
          if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {
            continue;
          } else if (userSpecifiedTransform) {
            subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);
          }
          maybeRemoveId(subdoc, assignmentOpts);
          ret2.push(subdoc);
          if (assignmentOpts.originalLimit && ret2.length >= assignmentOpts.originalLimit) {
            break;
          }
        }
        while (val.length > ret2.length) {
          Array.prototype.pop.apply(val, []);
        }
        for (let i = 0; i < ret2.length; ++i) {
          val[i] = ret2[i];
        }
        return val;
      }
      if (isPopulatedObject(val) || utils2.isPOJO(val)) {
        maybeRemoveId(val, assignmentOpts);
        return transform(val, allIds);
      }
      if (val instanceof Map) {
        return val;
      }
      if (populateOptions.justOne === false) {
        return [];
      }
      return val == null ? transform(val, allIds) : transform(null, allIds);
    }
    function maybeRemoveId(subdoc, assignmentOpts) {
      if (subdoc != null && assignmentOpts.excludeId) {
        if (typeof subdoc.$__setValue === "function") {
          delete subdoc._doc._id;
        } else {
          delete subdoc._id;
        }
      }
    }
    function isPopulatedObject(obj) {
      if (obj == null) {
        return false;
      }
      return Array.isArray(obj) || obj.$isMongooseMap || obj.$__ != null || leanPopulateMap.has(obj);
    }
    function noop(v) {
      return v;
    }
  }
});

// node_modules/mongoose/lib/helpers/model/castBulkWrite.js
var require_castBulkWrite = __commonJS({
  "node_modules/mongoose/lib/helpers/model/castBulkWrite.js"(exports2, module2) {
    "use strict";
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var applyTimestampsToChildren = require_applyTimestampsToChildren();
    var applyTimestampsToUpdate = require_applyTimestampsToUpdate();
    var cast = require_cast2();
    var castUpdate = require_castUpdate();
    var setDefaultsOnInsert = require_setDefaultsOnInsert();
    module2.exports = function castBulkWrite(originalModel, op, options) {
      const now = originalModel.base.now();
      if (op["insertOne"]) {
        return (callback) => {
          const model2 = decideModelByObject(originalModel, op["insertOne"]["document"]);
          const doc = new model2(op["insertOne"]["document"]);
          if (model2.schema.options.timestamps) {
            doc.initializeTimestamps();
          }
          if (options.session != null) {
            doc.$session(options.session);
          }
          op["insertOne"]["document"] = doc;
          op["insertOne"]["document"].validate({ __noPromise: true }, function(error) {
            if (error) {
              return callback(error, null);
            }
            callback(null);
          });
        };
      } else if (op["updateOne"]) {
        return (callback) => {
          try {
            if (!op["updateOne"]["filter"]) {
              throw new Error("Must provide a filter object.");
            }
            if (!op["updateOne"]["update"]) {
              throw new Error("Must provide an update object.");
            }
            const model2 = decideModelByObject(originalModel, op["updateOne"]["filter"]);
            const schema = model2.schema;
            const strict = options.strict != null ? options.strict : model2.schema.options.strict;
            _addDiscriminatorToObject(schema, op["updateOne"]["filter"]);
            if (model2.schema.$timestamps != null && op["updateOne"].timestamps !== false) {
              const createdAt = model2.schema.$timestamps.createdAt;
              const updatedAt = model2.schema.$timestamps.updatedAt;
              applyTimestampsToUpdate(now, createdAt, updatedAt, op["updateOne"]["update"], {});
            }
            applyTimestampsToChildren(now, op["updateOne"]["update"], model2.schema);
            if (op["updateOne"].setDefaultsOnInsert) {
              setDefaultsOnInsert(op["updateOne"]["filter"], model2.schema, op["updateOne"]["update"], {
                setDefaultsOnInsert: true,
                upsert: op["updateOne"].upsert
              });
            }
            op["updateOne"]["filter"] = cast(model2.schema, op["updateOne"]["filter"], {
              strict,
              upsert: op["updateOne"].upsert
            });
            op["updateOne"]["update"] = castUpdate(model2.schema, op["updateOne"]["update"], {
              strict,
              overwrite: false,
              upsert: op["updateOne"].upsert
            }, model2, op["updateOne"]["filter"]);
          } catch (error) {
            return callback(error, null);
          }
          callback(null);
        };
      } else if (op["updateMany"]) {
        return (callback) => {
          try {
            if (!op["updateMany"]["filter"]) {
              throw new Error("Must provide a filter object.");
            }
            if (!op["updateMany"]["update"]) {
              throw new Error("Must provide an update object.");
            }
            const model2 = decideModelByObject(originalModel, op["updateMany"]["filter"]);
            const schema = model2.schema;
            const strict = options.strict != null ? options.strict : model2.schema.options.strict;
            if (op["updateMany"].setDefaultsOnInsert) {
              setDefaultsOnInsert(op["updateMany"]["filter"], model2.schema, op["updateMany"]["update"], {
                setDefaultsOnInsert: true,
                upsert: op["updateMany"].upsert
              });
            }
            if (model2.schema.$timestamps != null && op["updateMany"].timestamps !== false) {
              const createdAt = model2.schema.$timestamps.createdAt;
              const updatedAt = model2.schema.$timestamps.updatedAt;
              applyTimestampsToUpdate(now, createdAt, updatedAt, op["updateMany"]["update"], {});
            }
            applyTimestampsToChildren(now, op["updateMany"]["update"], model2.schema);
            _addDiscriminatorToObject(schema, op["updateMany"]["filter"]);
            op["updateMany"]["filter"] = cast(model2.schema, op["updateMany"]["filter"], {
              strict,
              upsert: op["updateMany"].upsert
            });
            op["updateMany"]["update"] = castUpdate(model2.schema, op["updateMany"]["update"], {
              strict,
              overwrite: false,
              upsert: op["updateMany"].upsert
            }, model2, op["updateMany"]["filter"]);
          } catch (error) {
            return callback(error, null);
          }
          callback(null);
        };
      } else if (op["replaceOne"]) {
        return (callback) => {
          const model2 = decideModelByObject(originalModel, op["replaceOne"]["filter"]);
          const schema = model2.schema;
          const strict = options.strict != null ? options.strict : model2.schema.options.strict;
          _addDiscriminatorToObject(schema, op["replaceOne"]["filter"]);
          try {
            op["replaceOne"]["filter"] = cast(model2.schema, op["replaceOne"]["filter"], {
              strict,
              upsert: op["replaceOne"].upsert
            });
          } catch (error) {
            return callback(error, null);
          }
          const doc = new model2(op["replaceOne"]["replacement"], strict, true);
          if (model2.schema.options.timestamps) {
            doc.initializeTimestamps();
          }
          if (options.session != null) {
            doc.$session(options.session);
          }
          op["replaceOne"]["replacement"] = doc;
          op["replaceOne"]["replacement"].validate({ __noPromise: true }, function(error) {
            if (error) {
              return callback(error, null);
            }
            op["replaceOne"]["replacement"] = op["replaceOne"]["replacement"].toBSON();
            callback(null);
          });
        };
      } else if (op["deleteOne"]) {
        return (callback) => {
          const model2 = decideModelByObject(originalModel, op["deleteOne"]["filter"]);
          const schema = model2.schema;
          _addDiscriminatorToObject(schema, op["deleteOne"]["filter"]);
          try {
            op["deleteOne"]["filter"] = cast(model2.schema, op["deleteOne"]["filter"]);
          } catch (error) {
            return callback(error, null);
          }
          callback(null);
        };
      } else if (op["deleteMany"]) {
        return (callback) => {
          const model2 = decideModelByObject(originalModel, op["deleteMany"]["filter"]);
          const schema = model2.schema;
          _addDiscriminatorToObject(schema, op["deleteMany"]["filter"]);
          try {
            op["deleteMany"]["filter"] = cast(model2.schema, op["deleteMany"]["filter"]);
          } catch (error) {
            return callback(error, null);
          }
          callback(null);
        };
      } else {
        return (callback) => {
          callback(new Error("Invalid op passed to `bulkWrite()`"), null);
        };
      }
    };
    function _addDiscriminatorToObject(schema, obj) {
      if (schema == null) {
        return;
      }
      if (schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
        obj[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
      }
    }
    function decideModelByObject(model2, object) {
      const discriminatorKey = model2.schema.options.discriminatorKey;
      if (object != null && object.hasOwnProperty(discriminatorKey)) {
        model2 = getDiscriminatorByValue(model2.discriminators, object[discriminatorKey]) || model2;
      }
      return model2;
    }
  }
});

// node_modules/mongoose/lib/helpers/path/parentPaths.js
var require_parentPaths = __commonJS({
  "node_modules/mongoose/lib/helpers/path/parentPaths.js"(exports2, module2) {
    "use strict";
    module2.exports = function parentPaths(path) {
      const pieces = path.split(".");
      let cur = "";
      const ret2 = [];
      for (let i = 0; i < pieces.length; ++i) {
        cur += (cur.length > 0 ? "." : "") + pieces[i];
        ret2.push(cur);
      }
      return ret2;
    };
  }
});

// node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js
var require_createPopulateQueryFilter = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js"(exports2, module2) {
    "use strict";
    var SkipPopulateValue = require_SkipPopulateValue();
    var parentPaths = require_parentPaths();
    module2.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model2, skipInvalidIds) {
      const match = _formatMatch(_match);
      if (_foreignField.size === 1) {
        const foreignField = Array.from(_foreignField)[0];
        const foreignSchemaType = model2.schema.path(foreignField);
        if (foreignField !== "_id" || !match["_id"]) {
          ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
          match[foreignField] = { $in: ids };
        }
        const _parentPaths = parentPaths(foreignField);
        for (let i = 0; i < _parentPaths.length - 1; ++i) {
          const cur = _parentPaths[i];
          if (match[cur] != null && match[cur].$elemMatch != null) {
            match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = { $in: ids };
            delete match[foreignField];
            break;
          }
        }
      } else {
        const $or = [];
        if (Array.isArray(match.$or)) {
          match.$and = [{ $or: match.$or }, { $or }];
          delete match.$or;
        } else {
          match.$or = $or;
        }
        for (const foreignField of _foreignField) {
          if (foreignField !== "_id" || !match["_id"]) {
            const foreignSchemaType = model2.schema.path(foreignField);
            ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
            $or.push({ [foreignField]: { $in: ids } });
          }
        }
      }
      return match;
    };
    function _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {
      ids = ids.filter((v) => !(v instanceof SkipPopulateValue));
      if (!skipInvalidIds) {
        return ids;
      }
      return ids.filter((id) => {
        try {
          foreignSchemaType.cast(id);
          return true;
        } catch (err) {
          return false;
        }
      });
    }
    function _formatMatch(match) {
      if (Array.isArray(match)) {
        if (match.length > 1) {
          return { $or: [].concat(match.map((m) => Object.assign({}, m))) };
        }
        return Object.assign({}, match[0]);
      }
      return Object.assign({}, match);
    }
  }
});

// node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js
var require_getDefaultBulkwriteResult = __commonJS({
  "node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js"(exports2, module2) {
    "use strict";
    function getDefaultBulkwriteResult() {
      return {
        result: {
          ok: 1,
          writeErrors: [],
          writeConcernErrors: [],
          insertedIds: [],
          nInserted: 0,
          nUpserted: 0,
          nMatched: 0,
          nModified: 0,
          nRemoved: 0,
          upserted: []
        },
        insertedCount: 0,
        matchedCount: 0,
        modifiedCount: 0,
        deletedCount: 0,
        upsertedCount: 0,
        upsertedIds: {},
        insertedIds: {},
        n: 0
      };
    }
    module2.exports = getDefaultBulkwriteResult;
  }
});

// node_modules/mongoose/lib/helpers/each.js
var require_each2 = __commonJS({
  "node_modules/mongoose/lib/helpers/each.js"(exports2, module2) {
    "use strict";
    module2.exports = function each(arr, cb, done) {
      if (arr.length === 0) {
        return done();
      }
      let remaining = arr.length;
      let err = null;
      for (const v of arr) {
        cb(v, function(_err) {
          if (err != null) {
            return;
          }
          if (_err != null) {
            err = _err;
            return done(err);
          }
          if (--remaining <= 0) {
            return done();
          }
        });
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/projection/isPathExcluded.js
var require_isPathExcluded = __commonJS({
  "node_modules/mongoose/lib/helpers/projection/isPathExcluded.js"(exports2, module2) {
    "use strict";
    var isDefiningProjection = require_isDefiningProjection();
    module2.exports = function isPathExcluded(projection, path) {
      if (path === "_id") {
        return projection._id === 0;
      }
      const paths = Object.keys(projection);
      let type = null;
      for (const _path of paths) {
        if (isDefiningProjection(projection[_path])) {
          type = projection[path] === 1 ? "inclusive" : "exclusive";
          break;
        }
      }
      if (type === "inclusive") {
        return projection[path] !== 1;
      }
      if (type === "exclusive") {
        return projection[path] === 0;
      }
      return false;
    };
  }
});

// node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js
var require_getSchemaTypes = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js"(exports2, module2) {
    "use strict";
    var Mixed = require_mixed();
    var get = require_get();
    var leanPopulateMap = require_leanPopulateMap();
    var mpath = require_mpath();
    var populateModelSymbol = require_symbols().populateModelSymbol;
    module2.exports = function getSchemaTypes(schema, doc, path) {
      const pathschema = schema.path(path);
      const topLevelDoc = doc;
      if (pathschema) {
        return pathschema;
      }
      function search(parts2, schema2, subdoc, nestedPath) {
        let p = parts2.length + 1;
        let foundschema;
        let trypath;
        while (p--) {
          trypath = parts2.slice(0, p).join(".");
          foundschema = schema2.path(trypath);
          if (foundschema == null) {
            continue;
          }
          if (foundschema.caster) {
            if (foundschema.caster instanceof Mixed) {
              return foundschema.caster;
            }
            let schemas = null;
            if (foundschema.schema != null && foundschema.schema.discriminators != null) {
              const discriminators = foundschema.schema.discriminators;
              const discriminatorKeyPath = trypath + "." + foundschema.schema.options.discriminatorKey;
              const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];
              schemas = Object.keys(discriminators).reduce(function(cur, discriminator) {
                const tiedValue = discriminators[discriminator].discriminatorMapping.value;
                if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {
                  cur.push(discriminators[discriminator]);
                }
                return cur;
              }, []);
            }
            if (p !== parts2.length && foundschema.schema) {
              let ret2;
              if (parts2[p] === "$") {
                if (p + 1 === parts2.length) {
                  return foundschema;
                }
                ret2 = search(parts2.slice(p + 1), schema2, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
                if (ret2) {
                  ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                }
                return ret2;
              }
              if (schemas != null && schemas.length > 0) {
                ret2 = [];
                for (const schema3 of schemas) {
                  const _ret = search(parts2.slice(p), schema3, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
                  if (_ret != null) {
                    _ret.$isUnderneathDocArray = _ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                    if (_ret.$isUnderneathDocArray) {
                      ret2.$isUnderneathDocArray = true;
                    }
                    ret2.push(_ret);
                  }
                }
                return ret2;
              } else {
                ret2 = search(parts2.slice(p), foundschema.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
                if (ret2) {
                  ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                }
                return ret2;
              }
            } else if (p !== parts2.length && foundschema.$isMongooseArray && foundschema.casterConstructor.$isMongooseArray) {
              let type = foundschema;
              while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {
                type = type.casterConstructor;
              }
              const ret2 = search(parts2.slice(p), type.schema, null, nestedPath.concat(parts2.slice(0, p)));
              if (ret2 != null) {
                return ret2;
              }
              if (type.schema.discriminators) {
                const discriminatorPaths = [];
                for (const discriminatorName of Object.keys(type.schema.discriminators)) {
                  const _schema = type.schema.discriminators[discriminatorName] || type.schema;
                  const ret3 = search(parts2.slice(p), _schema, null, nestedPath.concat(parts2.slice(0, p)));
                  if (ret3 != null) {
                    discriminatorPaths.push(ret3);
                  }
                }
                if (discriminatorPaths.length > 0) {
                  return discriminatorPaths;
                }
              }
            }
          }
          const fullPath = nestedPath.concat([trypath]).join(".");
          if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.populated(fullPath) && p < parts2.length) {
            const model2 = doc.$__.populated[fullPath].options[populateModelSymbol];
            if (model2 != null) {
              const ret2 = search(parts2.slice(p), model2.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
              if (ret2) {
                ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !model2.schema.$isSingleNested;
              }
              return ret2;
            }
          }
          const _val = get(topLevelDoc, trypath);
          if (_val != null) {
            const model2 = Array.isArray(_val) && _val.length > 0 ? leanPopulateMap.get(_val[0]) : leanPopulateMap.get(_val);
            const schema3 = model2 != null ? model2.schema : null;
            if (schema3 != null) {
              const ret2 = search(parts2.slice(p), schema3, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
              if (ret2 != null) {
                ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !schema3.$isSingleNested;
                return ret2;
              }
            }
          }
          return foundschema;
        }
      }
      const parts = path.split(".");
      for (let i = 0; i < parts.length; ++i) {
        if (parts[i] === "$") {
          parts[i] = "0";
        }
      }
      return search(parts, schema, doc, []);
    };
  }
});

// node_modules/mongoose/lib/helpers/populate/normalizeRefPath.js
var require_normalizeRefPath = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/normalizeRefPath.js"(exports2, module2) {
    "use strict";
    module2.exports = function normalizeRefPath(refPath, doc, populatedPath) {
      if (refPath == null) {
        return refPath;
      }
      if (typeof refPath === "function") {
        refPath = refPath.call(doc, doc, populatedPath);
      }
      const hasNumericProp = /(\.\d+$|\.\d+\.)/g;
      if (hasNumericProp.test(populatedPath)) {
        const chunks = populatedPath.split(hasNumericProp);
        if (chunks[chunks.length - 1] === "") {
          throw new Error("Can't populate individual element in an array");
        }
        let _refPath = "";
        let _remaining = refPath;
        for (let i = 0; i < chunks.length; i += 2) {
          const chunk = chunks[i];
          if (_remaining.startsWith(chunk + ".")) {
            _refPath += _remaining.substr(0, chunk.length) + chunks[i + 1];
            _remaining = _remaining.substr(chunk.length + 1);
          } else if (i === chunks.length - 1) {
            _refPath += _remaining;
            _remaining = "";
            break;
          } else {
            throw new Error("Could not normalize ref path, chunk " + chunk + " not in populated path");
          }
        }
        return _refPath;
      }
      return refPath;
    };
  }
});

// node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js
var require_getModelsMapForPopulate = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js"(exports2, module2) {
    "use strict";
    var MongooseError = require_error3();
    var SkipPopulateValue = require_SkipPopulateValue();
    var get = require_get();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var isPathExcluded = require_isPathExcluded();
    var getConstructorName = require_getConstructorName();
    var getSchemaTypes = require_getSchemaTypes();
    var getVirtual = require_getVirtual();
    var lookupLocalFields = require_lookupLocalFields();
    var mpath = require_mpath();
    var normalizeRefPath = require_normalizeRefPath();
    var util = require("util");
    var utils2 = require_utils8();
    var modelSymbol = require_symbols().modelSymbol;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
    module2.exports = function getModelsMapForPopulate(model2, docs, options) {
      let i;
      let doc;
      const len = docs.length;
      const available = {};
      const map = [];
      const modelNameFromQuery = options.model && options.model.modelName || options.model;
      let schema;
      let refPath;
      let Model;
      let currentOptions;
      let modelNames;
      let modelName;
      const originalModel = options.model;
      let isVirtual = false;
      const modelSchema = model2.schema;
      let allSchemaTypes = getSchemaTypes(modelSchema, null, options.path);
      allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter((v) => v != null);
      const _firstWithRefPath = allSchemaTypes.find((schematype) => get(schematype, "options.refPath", null) != null);
      for (i = 0; i < len; i++) {
        doc = docs[i];
        let justOne = null;
        schema = getSchemaTypes(modelSchema, doc, options.path);
        if (schema != null && schema.$isMongooseDocumentArray && schema.options.ref == null && schema.options.refPath == null) {
          continue;
        }
        if (options._localModel != null && options._localModel.schema.nested[options.path]) {
          continue;
        }
        const isUnderneathDocArray = schema && schema.$isUnderneathDocArray;
        if (isUnderneathDocArray && get(options, "options.sort") != null) {
          return new MongooseError("Cannot populate with `sort` on path " + options.path + " because it is a subproperty of a document array");
        }
        modelNames = null;
        let isRefPath = !!_firstWithRefPath;
        let normalizedRefPath = _firstWithRefPath ? get(_firstWithRefPath, "options.refPath", null) : null;
        let schemaOptions = null;
        if (Array.isArray(schema)) {
          const schemasArray = schema;
          for (const _schema of schemasArray) {
            let _modelNames;
            let res;
            try {
              res = _getModelNames(doc, _schema);
              _modelNames = res.modelNames;
              isRefPath = isRefPath || res.isRefPath;
              normalizedRefPath = normalizeRefPath(normalizedRefPath, doc, options.path) || res.refPath;
              justOne = res.justOne;
            } catch (error) {
              return error;
            }
            if (isRefPath && !res.isRefPath) {
              continue;
            }
            if (!_modelNames) {
              continue;
            }
            modelNames = modelNames || [];
            for (const modelName2 of _modelNames) {
              if (modelNames.indexOf(modelName2) === -1) {
                modelNames.push(modelName2);
              }
            }
          }
        } else {
          try {
            const res = _getModelNames(doc, schema);
            modelNames = res.modelNames;
            isRefPath = res.isRefPath;
            normalizedRefPath = res.refPath;
            justOne = res.justOne;
            schemaOptions = get(schema, "options.populate", null);
          } catch (error) {
            return error;
          }
          if (!modelNames) {
            continue;
          }
        }
        const _virtualRes = getVirtual(model2.schema, options.path);
        const virtual = _virtualRes == null ? null : _virtualRes.virtual;
        let localField;
        let count = false;
        if (virtual && virtual.options) {
          const virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + "." : "";
          if (typeof virtual.options.localField === "function") {
            localField = virtualPrefix + virtual.options.localField.call(doc, doc);
          } else if (Array.isArray(virtual.options.localField)) {
            localField = virtual.options.localField.map((field) => virtualPrefix + field);
          } else {
            localField = virtualPrefix + virtual.options.localField;
          }
          count = virtual.options.count;
          if (virtual.options.skip != null && !options.hasOwnProperty("skip")) {
            options.skip = virtual.options.skip;
          }
          if (virtual.options.limit != null && !options.hasOwnProperty("limit")) {
            options.limit = virtual.options.limit;
          }
          if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty("perDocumentLimit")) {
            options.perDocumentLimit = virtual.options.perDocumentLimit;
          }
        } else {
          localField = options.path;
        }
        let foreignField = virtual && virtual.options ? virtual.options.foreignField : "_id";
        if ("justOne" in options && options.justOne !== void 0) {
          justOne = options.justOne;
        } else if (virtual && virtual.options && virtual.options.refPath) {
          const normalizedRefPath2 = normalizeRefPath(virtual.options.refPath, doc, options.path);
          justOne = !!virtual.options.justOne;
          isVirtual = true;
          const refValue = utils2.getValue(normalizedRefPath2, doc);
          modelNames = Array.isArray(refValue) ? refValue : [refValue];
        } else if (virtual && virtual.options && virtual.options.ref) {
          let normalizedRef;
          if (typeof virtual.options.ref === "function") {
            normalizedRef = virtual.options.ref.call(doc, doc);
          } else {
            normalizedRef = virtual.options.ref;
          }
          justOne = !!virtual.options.justOne;
          isVirtual = true;
          if (!modelNames) {
            modelNames = [].concat(normalizedRef);
          }
        } else if (schema && !schema[schemaMixedSymbol]) {
          if (options.path.endsWith("." + schema.path)) {
            justOne = Array.isArray(schema) ? schema.every((schema2) => !schema2.$isMongooseArray) : !schema.$isMongooseArray;
          }
        }
        if (!modelNames) {
          continue;
        }
        if (virtual && (!localField || !foreignField)) {
          return new MongooseError("If you are populating a virtual, you must set the localField and foreignField options");
        }
        options.isVirtual = isVirtual;
        options.virtual = virtual;
        if (typeof localField === "function") {
          localField = localField.call(doc, doc);
        }
        if (typeof foreignField === "function") {
          foreignField = foreignField.call(doc);
        }
        let match = get(options, "match", null) || get(currentOptions, "match", null) || get(options, "virtual.options.match", null) || get(options, "virtual.options.options.match", null);
        let hasMatchFunction = typeof match === "function";
        if (hasMatchFunction) {
          match = match.call(doc, doc);
        }
        if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {
          match = Object.assign({}, match);
          for (let i2 = 1; i2 < localField.length; ++i2) {
            match[foreignField[i2]] = convertTo_id(mpath.get(localField[i2], doc, lookupLocalFields), schema);
            hasMatchFunction = true;
          }
          localField = localField[0];
          foreignField = foreignField[0];
        }
        const localFieldPathType = modelSchema._getPathType(localField);
        const localFieldPath = localFieldPathType === "real" ? modelSchema.path(localField) : localFieldPathType.schema;
        const localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];
        let ret2;
        const _populateOptions = get(options, "options", {});
        const getters = "getters" in _populateOptions ? _populateOptions.getters : options.isVirtual && get(virtual, "options.getters", false);
        if (localFieldGetters.length > 0 && getters) {
          const hydratedDoc = doc.$__ != null ? doc : model2.hydrate(doc);
          const localFieldValue = mpath.get(localField, doc, lookupLocalFields);
          if (Array.isArray(localFieldValue)) {
            const localFieldHydratedValue = mpath.get(localField.split(".").slice(0, -1), hydratedDoc, lookupLocalFields);
            ret2 = localFieldValue.map((localFieldArrVal, localFieldArrIndex) => localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));
          } else {
            ret2 = localFieldPath.applyGetters(localFieldValue, hydratedDoc);
          }
        } else {
          ret2 = convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);
        }
        const id = String(utils2.getValue(foreignField, doc));
        options._docs[id] = Array.isArray(ret2) ? ret2.slice() : ret2;
        if (isRefPath && normalizedRefPath != null) {
          const pieces = normalizedRefPath.split(".");
          let cur = "";
          for (let j = 0; j < pieces.length; ++j) {
            const piece = pieces[j];
            cur = cur + (cur.length === 0 ? "" : ".") + piece;
            const schematype = modelSchema.path(cur);
            if (schematype != null && schematype.$isMongooseArray && schematype.caster.discriminators != null && Object.keys(schematype.caster.discriminators).length > 0) {
              const subdocs = utils2.getValue(cur, doc);
              const remnant = options.path.substr(cur.length + 1);
              const discriminatorKey = schematype.caster.schema.options.discriminatorKey;
              modelNames = [];
              for (const subdoc of subdocs) {
                const discriminatorName = utils2.getValue(discriminatorKey, subdoc);
                const discriminator = schematype.caster.discriminators[discriminatorName];
                const discriminatorSchema = discriminator && discriminator.schema;
                if (discriminatorSchema == null) {
                  continue;
                }
                const _path = discriminatorSchema.path(remnant);
                if (_path == null || _path.options.refPath == null) {
                  const docValue = utils2.getValue(localField.substr(cur.length + 1), subdoc);
                  ret2 = ret2.map((v) => v === docValue ? SkipPopulateValue(v) : v);
                  continue;
                }
                const modelName2 = utils2.getValue(pieces.slice(j + 1).join("."), subdoc);
                modelNames.push(modelName2);
              }
            }
          }
        }
        let k = modelNames.length;
        while (k--) {
          modelName = modelNames[k];
          if (modelName == null) {
            continue;
          }
          const connection = options.connection != null ? options.connection : model2.db;
          try {
            Model = originalModel && originalModel[modelSymbol] ? originalModel : modelName[modelSymbol] ? modelName : connection.model(modelName);
          } catch (error) {
            if (ret2 !== void 0) {
              return error;
            }
          }
          let ids = ret2;
          const flat = Array.isArray(ret2) ? utils2.array.flatten(ret2) : [];
          if (isRefPath && Array.isArray(ret2) && flat.length === modelNames.length) {
            ids = flat.filter((val, i2) => modelNames[i2] === modelName);
          }
          if (!available[modelName] || currentOptions.perDocumentLimit != null || get(currentOptions, "options.perDocumentLimit") != null) {
            currentOptions = {
              model: Model
            };
            if (isVirtual && get(virtual, "options.options")) {
              currentOptions.options = utils2.clone(virtual.options.options);
            } else if (schemaOptions != null) {
              currentOptions.options = Object.assign({}, schemaOptions);
            }
            utils2.merge(currentOptions, options);
            options[populateModelSymbol] = Model;
            available[modelName] = {
              model: Model,
              options: currentOptions,
              match: hasMatchFunction ? [match] : match,
              docs: [doc],
              ids: [ids],
              allIds: [ret2],
              localField: new Set([localField]),
              foreignField: new Set([foreignField]),
              justOne,
              isVirtual,
              virtual,
              count,
              [populateModelSymbol]: Model
            };
            map.push(available[modelName]);
          } else {
            available[modelName].localField.add(localField);
            available[modelName].foreignField.add(foreignField);
            available[modelName].docs.push(doc);
            available[modelName].ids.push(ids);
            available[modelName].allIds.push(ret2);
            if (hasMatchFunction) {
              available[modelName].match.push(match);
            }
          }
        }
      }
      return map;
      function _getModelNames(doc2, schema2) {
        let modelNames2;
        let discriminatorKey;
        let isRefPath = false;
        let justOne = null;
        if (schema2 && schema2.caster) {
          schema2 = schema2.caster;
        }
        if (schema2 && schema2.$isSchemaMap) {
          schema2 = schema2.$__schemaType;
        }
        if (!schema2 && model2.discriminators) {
          discriminatorKey = model2.schema.discriminatorMapping.key;
        }
        refPath = schema2 && schema2.options && schema2.options.refPath;
        const normalizedRefPath = normalizeRefPath(refPath, doc2, options.path);
        if (modelNameFromQuery) {
          modelNames2 = [modelNameFromQuery];
        } else if (normalizedRefPath) {
          if (options._queryProjection != null && isPathExcluded(options._queryProjection, normalizedRefPath)) {
            throw new MongooseError("refPath `" + normalizedRefPath + "` must not be excluded in projection, got " + util.inspect(options._queryProjection));
          }
          if (modelSchema.virtuals.hasOwnProperty(normalizedRefPath) && doc2.$__ == null) {
            modelNames2 = [modelSchema.virtuals[normalizedRefPath].applyGetters(void 0, doc2)];
          } else {
            modelNames2 = utils2.getValue(normalizedRefPath, doc2);
          }
          if (Array.isArray(modelNames2)) {
            modelNames2 = utils2.array.flatten(modelNames2);
          }
          isRefPath = true;
        } else {
          let modelForCurrentDoc = model2;
          let schemaForCurrentDoc;
          let discriminatorValue;
          if (!schema2 && discriminatorKey && (discriminatorValue = utils2.getValue(discriminatorKey, doc2))) {
            const discriminatorModel = getDiscriminatorByValue(model2.discriminators, discriminatorValue) || model2;
            if (discriminatorModel != null) {
              modelForCurrentDoc = discriminatorModel;
            } else {
              try {
                modelForCurrentDoc = model2.db.model(discriminatorValue);
              } catch (error) {
                return error;
              }
            }
            schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);
            if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {
              schemaForCurrentDoc = schemaForCurrentDoc.caster;
            }
          } else {
            schemaForCurrentDoc = schema2;
          }
          const _virtualRes = getVirtual(modelForCurrentDoc.schema, options.path);
          const virtual = _virtualRes == null ? null : _virtualRes.virtual;
          if (schemaForCurrentDoc != null) {
            justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;
          }
          let ref;
          let refPath2;
          if ((ref = get(schemaForCurrentDoc, "options.ref")) != null) {
            ref = handleRefFunction(ref, doc2);
            modelNames2 = [ref];
          } else if ((ref = get(virtual, "options.ref")) != null) {
            ref = handleRefFunction(ref, doc2);
            if (Array.isArray(ref)) {
              modelNames2 = ref;
            } else {
              modelNames2 = [ref];
            }
            isVirtual = true;
          } else if ((refPath2 = get(schemaForCurrentDoc, "options.refPath")) != null) {
            isRefPath = true;
            refPath2 = normalizeRefPath(refPath2, doc2, options.path);
            modelNames2 = utils2.getValue(refPath2, doc2);
            if (Array.isArray(modelNames2)) {
              modelNames2 = utils2.array.flatten(modelNames2);
            }
          } else {
            modelNames2 = discriminatorKey ? null : [model2.modelName];
          }
        }
        if (!modelNames2) {
          return { modelNames: modelNames2, isRefPath, refPath: normalizedRefPath, justOne };
        }
        if (!Array.isArray(modelNames2)) {
          modelNames2 = [modelNames2];
        }
        return { modelNames: modelNames2, isRefPath, refPath: normalizedRefPath, justOne };
      }
    };
    function handleRefFunction(ref, doc) {
      if (typeof ref === "function" && !ref[modelSymbol]) {
        return ref.call(doc, doc);
      }
      return ref;
    }
    function convertTo_id(val, schema) {
      if (val != null && val.$__ != null) {
        return val._id;
      }
      if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {
        return val._id;
      }
      if (Array.isArray(val)) {
        for (let i = 0; i < val.length; ++i) {
          if (val[i] != null && val[i].$__ != null) {
            val[i] = val[i]._id;
          }
        }
        if (val.isMongooseArray && val.$schema()) {
          return val.$schema()._castForPopulate(val, val.$parent());
        }
        return [].concat(val);
      }
      if (getConstructorName(val) === "Object" && (schema == null || schema[schemaMixedSymbol] == null)) {
        const ret2 = [];
        for (const key of Object.keys(val)) {
          ret2.push(val[key]);
        }
        return ret2;
      }
      if (val instanceof Map) {
        return Array.from(val.values());
      }
      return val;
    }
  }
});

// node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js
var require_isDefaultIdIndex = __commonJS({
  "node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    module2.exports = function isDefaultIdIndex(index) {
      if (Array.isArray(index)) {
        const keys = Object.keys(index[0]);
        return keys.length === 1 && keys[0] === "_id" && index[0]._id !== "hashed";
      }
      if (typeof index !== "object") {
        return false;
      }
      const key = get(index, "key", {});
      return Object.keys(key).length === 1 && key.hasOwnProperty("_id");
    };
  }
});

// node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js
var require_isIndexEqual = __commonJS({
  "node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    var utils2 = require_utils8();
    module2.exports = function isIndexEqual(key, options, dbIndex) {
      if (dbIndex.textIndexVersion != null) {
        const weights = dbIndex.weights;
        if (Object.keys(weights).length !== Object.keys(key).length) {
          return false;
        }
        for (const prop of Object.keys(weights)) {
          if (!(prop in key)) {
            return false;
          }
          const weight = weights[prop];
          if (weight !== get(options, "weights." + prop) && !(weight === 1 && get(options, "weights." + prop) == null)) {
            return false;
          }
        }
        if (options["default_language"] !== dbIndex["default_language"]) {
          return dbIndex["default_language"] === "english" && options["default_language"] == null;
        }
        return true;
      }
      const optionKeys = [
        "unique",
        "partialFilterExpression",
        "sparse",
        "expireAfterSeconds",
        "collation"
      ];
      for (const key2 of optionKeys) {
        if (!(key2 in options) && !(key2 in dbIndex)) {
          continue;
        }
        if (key2 === "collation") {
          if (options[key2] == null || dbIndex[key2] == null) {
            return options[key2] == null && dbIndex[key2] == null;
          }
          const definedKeys = Object.keys(options.collation);
          const schemaCollation = options.collation;
          const dbCollation = dbIndex.collation;
          for (const opt of definedKeys) {
            if (get(schemaCollation, opt) !== get(dbCollation, opt)) {
              return false;
            }
          }
        } else if (!utils2.deepEqual(options[key2], dbIndex[key2])) {
          return false;
        }
      }
      const schemaIndexKeys = Object.keys(key);
      const dbIndexKeys = Object.keys(dbIndex.key);
      if (schemaIndexKeys.length !== dbIndexKeys.length) {
        return false;
      }
      for (let i = 0; i < schemaIndexKeys.length; ++i) {
        if (schemaIndexKeys[i] !== dbIndexKeys[i]) {
          return false;
        }
        if (!utils2.deepEqual(key[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js
var require_isPathSelectedInclusive = __commonJS({
  "node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js"(exports2, module2) {
    "use strict";
    module2.exports = function isPathSelectedInclusive(fields, path) {
      const chunks = path.split(".");
      let cur = "";
      let j;
      let keys;
      let numKeys;
      for (let i = 0; i < chunks.length; ++i) {
        cur += cur.length ? "." : "" + chunks[i];
        if (fields[cur]) {
          keys = Object.keys(fields);
          numKeys = keys.length;
          for (j = 0; j < numKeys; ++j) {
            if (keys[i].indexOf(cur + ".") === 0 && keys[i].indexOf(path) !== 0) {
              continue;
            }
          }
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/mongoose/lib/helpers/parallelLimit.js
var require_parallelLimit = __commonJS({
  "node_modules/mongoose/lib/helpers/parallelLimit.js"(exports2, module2) {
    "use strict";
    module2.exports = parallelLimit;
    function parallelLimit(fns, limit, callback) {
      let numInProgress = 0;
      let numFinished = 0;
      let error = null;
      if (limit <= 0) {
        throw new Error("Limit must be positive");
      }
      if (fns.length === 0) {
        return callback(null, []);
      }
      for (let i = 0; i < fns.length && i < limit; ++i) {
        _start();
      }
      function _start() {
        fns[numFinished + numInProgress](_done(numFinished + numInProgress));
        ++numInProgress;
      }
      const results = [];
      function _done(index) {
        return (err, res) => {
          --numInProgress;
          ++numFinished;
          if (error != null) {
            return;
          }
          if (err != null) {
            error = err;
            return callback(error);
          }
          results[index] = res;
          if (numFinished === fns.length) {
            return callback(null, results);
          } else if (numFinished + numInProgress < fns.length) {
            _start();
          }
        };
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js
var require_removeDeselectedForeignField = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    var mpath = require_mpath();
    var parseProjection = require_parseProjection();
    module2.exports = function removeDeselectedForeignField(foreignFields, options, docs) {
      const projection = parseProjection(get(options, "select", null), true) || parseProjection(get(options, "options.select", null), true);
      if (projection == null) {
        return;
      }
      for (const foreignField of foreignFields) {
        if (!projection.hasOwnProperty("-" + foreignField)) {
          continue;
        }
        for (const val of docs) {
          if (val.$__ != null) {
            mpath.unset(foreignField, val._doc);
          } else {
            mpath.unset(foreignField, val);
          }
        }
      }
    };
  }
});

// node_modules/mongoose/lib/model.js
var require_model = __commonJS({
  "node_modules/mongoose/lib/model.js"(exports2, module2) {
    "use strict";
    var Aggregate = require_aggregate2();
    var ChangeStream = require_ChangeStream();
    var Document2 = require_document();
    var DocumentNotFoundError = require_notFound();
    var DivergentArrayError = require_divergentArray();
    var EventEmitter = require("events").EventEmitter;
    var MongooseBuffer = require_buffer();
    var MongooseError = require_error3();
    var OverwriteModelError = require_overwriteModel();
    var PromiseProvider = require_promise_provider();
    var Query = require_query3();
    var RemoveOptions = require_removeOptions();
    var SaveOptions = require_saveOptions();
    var Schema2 = require_schema2();
    var ServerSelectionError = require_serverSelection();
    var ValidationError = require_validation();
    var VersionError = require_version();
    var ParallelSaveError = require_parallelSave();
    var applyQueryMiddleware = require_applyQueryMiddleware();
    var applyHooks = require_applyHooks();
    var applyMethods = require_applyMethods();
    var applyStaticHooks = require_applyStaticHooks();
    var applyStatics = require_applyStatics();
    var applyWriteConcern = require_applyWriteConcern();
    var assignVals = require_assignVals();
    var castBulkWrite = require_castBulkWrite();
    var createPopulateQueryFilter = require_createPopulateQueryFilter();
    var getDefaultBulkwriteResult = require_getDefaultBulkwriteResult();
    var discriminator = require_discriminator();
    var each = require_each2();
    var get = require_get();
    var getConstructorName = require_getConstructorName();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var getModelsMapForPopulate = require_getModelsMapForPopulate();
    var immediate = require_immediate();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var isDefaultIdIndex = require_isDefaultIdIndex();
    var isIndexEqual = require_isIndexEqual();
    var isPathSelectedInclusive = require_isPathSelectedInclusive();
    var leanPopulateMap = require_leanPopulateMap();
    var modifiedPaths = require_modifiedPaths();
    var parallelLimit = require_parallelLimit();
    var removeDeselectedForeignField = require_removeDeselectedForeignField();
    var util = require("util");
    var utils2 = require_utils8();
    var VERSION_WHERE = 1;
    var VERSION_INC = 2;
    var VERSION_ALL = VERSION_WHERE | VERSION_INC;
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var modelCollectionSymbol = Symbol("mongoose#Model#collection");
    var modelDbSymbol = Symbol("mongoose#Model#db");
    var modelSymbol = require_symbols().modelSymbol;
    var subclassedSymbol = Symbol("mongoose#Model#subclassed");
    var saveToObjectOptions = Object.assign({}, internalToObjectOptions, {
      bson: true
    });
    function Model(doc, fields, skipId) {
      if (fields instanceof Schema2) {
        throw new TypeError("2nd argument to `Model` must be a POJO or string, **not** a schema. Make sure you're calling `mongoose.model()`, not `mongoose.Model()`.");
      }
      Document2.call(this, doc, fields, skipId);
    }
    Model.prototype.__proto__ = Document2.prototype;
    Model.prototype.$isMongooseModelPrototype = true;
    Model.prototype.db;
    Model.prototype.collection;
    Model.prototype.$__collection;
    Model.prototype.modelName;
    Model.prototype.$where;
    Model.prototype.baseModelName;
    Model.events;
    Model._middleware;
    function _applyCustomWhere(doc, where) {
      if (doc.$where == null) {
        return;
      }
      for (const key of Object.keys(doc.$where)) {
        where[key] = doc.$where[key];
      }
    }
    Model.prototype.$__handleSave = function(options, callback) {
      const _this = this;
      let saveOptions = {};
      if ("safe" in options) {
        _handleSafe(options);
      }
      applyWriteConcern(this.$__schema, options);
      if (typeof options.writeConcern != "undefined") {
        saveOptions.writeConcern = {};
        if ("w" in options.writeConcern) {
          saveOptions.writeConcern.w = options.writeConcern.w;
        }
        if ("j" in options.writeConcern) {
          saveOptions.writeConcern.j = options.writeConcern.j;
        }
        if ("wtimeout" in options.writeConcern) {
          saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;
        }
      } else {
        if ("w" in options) {
          saveOptions.w = options.w;
        }
        if ("j" in options) {
          saveOptions.j = options.j;
        }
        if ("wtimeout" in options) {
          saveOptions.wtimeout = options.wtimeout;
        }
      }
      if ("checkKeys" in options) {
        saveOptions.checkKeys = options.checkKeys;
      }
      const session = this.$session();
      if (!saveOptions.hasOwnProperty("session")) {
        saveOptions.session = session;
      }
      if (Object.keys(saveOptions).length === 0) {
        saveOptions = null;
      }
      if (this.isNew) {
        const obj = this.toObject(saveToObjectOptions);
        if ((obj || {})._id === void 0) {
          immediate(function() {
            callback(new MongooseError("document must have an _id before saving"));
          });
          return;
        }
        this.$__version(true, obj);
        this[modelCollectionSymbol].insertOne(obj, saveOptions, function(err, ret2) {
          if (err) {
            _setIsNew(_this, true);
            callback(err, null);
            return;
          }
          callback(null, ret2);
        });
        this.$__reset();
        _setIsNew(this, false);
        this.$__.inserting = true;
      } else {
        this.$__.inserting = false;
        const delta = this.$__delta();
        if (delta) {
          if (delta instanceof MongooseError) {
            callback(delta);
            return;
          }
          const where = this.$__where(delta[0]);
          if (where instanceof MongooseError) {
            callback(where);
            return;
          }
          _applyCustomWhere(this, where);
          this[modelCollectionSymbol].updateOne(where, delta[1], saveOptions, (err, ret2) => {
            if (err) {
              this.$__undoReset();
              callback(err);
              return;
            }
            ret2.$where = where;
            callback(null, ret2);
          });
        } else {
          const optionsWithCustomValues = Object.assign({}, options, saveOptions);
          const where = this.$__where();
          if (this.$__schema.options.optimisticConcurrency) {
            const key = this.$__schema.options.versionKey;
            const val = this.$__getValue(key);
            if (val != null) {
              where[key] = val;
            }
          }
          this.constructor.exists(where, optionsWithCustomValues).then((documentExists) => {
            if (!documentExists) {
              throw new DocumentNotFoundError(this.$__where(), this.constructor.modelName);
            }
            callback();
          }).catch(callback);
          return;
        }
        this.$__.modifiedPaths = this.modifiedPaths();
        this.$__reset();
        _setIsNew(this, false);
      }
    };
    Model.prototype.$__save = function(options, callback) {
      this.$__handleSave(options, (error, result) => {
        const hooks = this.$__schema.s.hooks;
        if (error) {
          return hooks.execPost("save:error", this, [this], { error }, (error2) => {
            callback(error2, this);
          });
        }
        let numAffected = 0;
        if (get(options, "safe.w") !== 0 && get(options, "w") !== 0) {
          if (result) {
            if (Array.isArray(result)) {
              numAffected = result.length;
            } else if (result.result && result.result.n !== void 0) {
              numAffected = result.result.n;
            } else if (result.result && result.result.nModified !== void 0) {
              numAffected = result.result.nModified;
            } else {
              numAffected = result;
            }
          }
          if (this.$__.version && !this.$__.inserting) {
            const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);
            this.$__.version = void 0;
            const key = this.$__schema.options.versionKey;
            const version = this.$__getValue(key) || 0;
            if (numAffected <= 0) {
              this.$__undoReset();
              const err = this.$__.$versionError || new VersionError(this, version, this.$__.modifiedPaths);
              return callback(err);
            }
            if (doIncrement) {
              this.$__setValue(key, version + 1);
            }
          }
          if (result != null && numAffected <= 0) {
            this.$__undoReset();
            error = new DocumentNotFoundError(result.$where, this.constructor.modelName, numAffected, result);
            return hooks.execPost("save:error", this, [this], { error }, (error2) => {
              callback(error2, this);
            });
          }
        }
        this.$__.saving = void 0;
        this.$__.savedState = {};
        this.emit("save", this, numAffected);
        this.constructor.emit("save", this, numAffected);
        callback(null, this);
      });
    };
    function generateVersionError(doc, modifiedPaths2) {
      const key = doc.$__schema.options.versionKey;
      if (!key) {
        return null;
      }
      const version = doc.$__getValue(key) || 0;
      return new VersionError(doc, version, modifiedPaths2);
    }
    Model.prototype.save = function(options, fn) {
      let parallelSave;
      this.$op = "save";
      if (this.$__.saving) {
        parallelSave = new ParallelSaveError(this);
      } else {
        this.$__.saving = new ParallelSaveError(this);
      }
      if (typeof options === "function") {
        fn = options;
        options = void 0;
      }
      options = new SaveOptions(options);
      if (options.hasOwnProperty("session")) {
        this.$session(options.session);
      }
      this.$__.$versionError = generateVersionError(this, this.modifiedPaths());
      fn = this.constructor.$handleCallbackError(fn);
      return this.constructor.db.base._promiseOrCallback(fn, (cb) => {
        cb = this.constructor.$wrapCallback(cb);
        if (parallelSave) {
          this.$__handleReject(parallelSave);
          return cb(parallelSave);
        }
        this.$__.saveOptions = options;
        this.$__save(options, (error) => {
          this.$__.saving = void 0;
          delete this.$__.saveOptions;
          delete this.$__.$versionError;
          this.$op = null;
          if (error) {
            this.$__handleReject(error);
            return cb(error);
          }
          cb(null, this);
        });
      }, this.constructor.events);
    };
    function shouldSkipVersioning(self2, path) {
      const skipVersioning = self2.$__schema.options.skipVersioning;
      if (!skipVersioning)
        return false;
      path = path.replace(/\.\d+\./, ".");
      return skipVersioning[path];
    }
    function operand(self2, where, delta, data, val, op) {
      op || (op = "$set");
      if (!delta[op])
        delta[op] = {};
      delta[op][data.path] = val;
      if (self2.$__schema.options.versionKey === false)
        return;
      if (shouldSkipVersioning(self2, data.path))
        return;
      if (VERSION_ALL === (VERSION_ALL & self2.$__.version))
        return;
      if (self2.$__schema.options.optimisticConcurrency) {
        self2.$__.version = VERSION_ALL;
        return;
      }
      switch (op) {
        case "$set":
        case "$unset":
        case "$pop":
        case "$pull":
        case "$pullAll":
        case "$push":
        case "$addToSet":
          break;
        default:
          return;
      }
      if (op === "$push" || op === "$addToSet" || op === "$pullAll" || op === "$pull") {
        self2.$__.version = VERSION_INC;
      } else if (/^\$p/.test(op)) {
        increment.call(self2);
      } else if (Array.isArray(val)) {
        increment.call(self2);
      } else if (/\.\d+\.|\.\d+$/.test(data.path)) {
        self2.$__.version = VERSION_WHERE;
      }
    }
    function handleAtomics(self2, where, delta, data, value) {
      if (delta.$set && delta.$set[data.path]) {
        return;
      }
      if (typeof value.$__getAtomics === "function") {
        value.$__getAtomics().forEach(function(atomic) {
          const op2 = atomic[0];
          const val2 = atomic[1];
          operand(self2, where, delta, data, val2, op2);
        });
        return;
      }
      const atomics = value[arrayAtomicsSymbol];
      const ops = Object.keys(atomics);
      let i = ops.length;
      let val;
      let op;
      if (i === 0) {
        if (utils2.isMongooseObject(value)) {
          value = value.toObject({ depopulate: 1, _isNested: true });
        } else if (value.valueOf) {
          value = value.valueOf();
        }
        return operand(self2, where, delta, data, value);
      }
      function iter(mem) {
        return utils2.isMongooseObject(mem) ? mem.toObject({ depopulate: 1, _isNested: true }) : mem;
      }
      while (i--) {
        op = ops[i];
        val = atomics[op];
        if (utils2.isMongooseObject(val)) {
          val = val.toObject({ depopulate: true, transform: false, _isNested: true });
        } else if (Array.isArray(val)) {
          val = val.map(iter);
        } else if (val.valueOf) {
          val = val.valueOf();
        }
        if (op === "$addToSet") {
          val = { $each: val };
        }
        operand(self2, where, delta, data, val, op);
      }
    }
    Model.prototype.$__delta = function() {
      const dirty = this.$__dirty();
      if (!dirty.length && VERSION_ALL !== this.$__.version) {
        return;
      }
      const where = {};
      const delta = {};
      const len = dirty.length;
      const divergent = [];
      let d = 0;
      where._id = this._doc._id;
      if (get(where, "_id.$__", null) != null) {
        where._id = where._id.toObject({ transform: false, depopulate: true });
      }
      for (; d < len; ++d) {
        const data = dirty[d];
        let value = data.value;
        const match = checkDivergentArray(this, data.path, value);
        if (match) {
          divergent.push(match);
          continue;
        }
        const pop = this.populated(data.path, true);
        if (!pop && this.$__.selected) {
          const pathSplit = data.path.split(".");
          const top = pathSplit[0];
          if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {
            if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === "undefined") {
              where[top] = this.$__.selected[top];
              pathSplit[1] = "$";
              data.path = pathSplit.join(".");
            } else {
              divergent.push(data.path);
              continue;
            }
          }
        }
        if (divergent.length)
          continue;
        if (value === void 0) {
          operand(this, where, delta, data, 1, "$unset");
        } else if (value === null) {
          operand(this, where, delta, data, null);
        } else if (value.isMongooseArray && value.$path() && value[arrayAtomicsSymbol]) {
          handleAtomics(this, where, delta, data, value);
        } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {
          value = value.toObject();
          operand(this, where, delta, data, value);
        } else {
          value = utils2.clone(value, {
            depopulate: true,
            transform: false,
            virtuals: false,
            getters: false,
            _isNested: true
          });
          operand(this, where, delta, data, value);
        }
      }
      if (divergent.length) {
        return new DivergentArrayError(divergent);
      }
      if (this.$__.version) {
        this.$__version(where, delta);
      }
      return [where, delta];
    };
    function checkDivergentArray(doc, path, array) {
      const pop = doc.populated(path, true);
      if (!pop && doc.$__.selected) {
        const top = path.split(".")[0];
        if (doc.$__.selected[top + ".$"]) {
          return top;
        }
      }
      if (!(pop && array && array.isMongooseArray))
        return;
      const check = pop.options.match || pop.options.options && utils2.object.hasOwnProperty(pop.options.options, "limit") || pop.options.options && pop.options.options.skip || pop.options.select && (pop.options.select._id === 0 || /\s?-_id\s?/.test(pop.options.select));
      if (check) {
        const atomics = array[arrayAtomicsSymbol];
        if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {
          return path;
        }
      }
    }
    Model.prototype.$__version = function(where, delta) {
      const key = this.$__schema.options.versionKey;
      if (where === true) {
        if (key) {
          this.$__setValue(key, delta[key] = 0);
        }
        return;
      }
      if (!this.$__isSelected(key)) {
        return;
      }
      if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {
        const value = this.$__getValue(key);
        if (value != null)
          where[key] = value;
      }
      if (VERSION_INC === (VERSION_INC & this.$__.version)) {
        if (get(delta.$set, key, null) != null) {
          ++delta.$set[key];
        } else {
          delta.$inc = delta.$inc || {};
          delta.$inc[key] = 1;
        }
      }
    };
    function increment() {
      this.$__.version = VERSION_ALL;
      return this;
    }
    Model.prototype.increment = increment;
    Model.prototype.$__where = function _where(where) {
      where || (where = {});
      if (!where._id) {
        where._id = this._doc._id;
      }
      if (this._doc._id === void 0) {
        return new MongooseError("No _id found on document!");
      }
      return where;
    };
    Model.prototype.remove = function remove(options, fn) {
      if (typeof options === "function") {
        fn = options;
        options = void 0;
      }
      options = new RemoveOptions(options);
      if (options.hasOwnProperty("session")) {
        this.$session(options.session);
      }
      this.$op = "remove";
      fn = this.constructor.$handleCallbackError(fn);
      return this.constructor.db.base._promiseOrCallback(fn, (cb) => {
        cb = this.constructor.$wrapCallback(cb);
        this.$__remove(options, (err, res) => {
          this.$op = null;
          cb(err, res);
        });
      }, this.constructor.events);
    };
    Model.prototype.delete = Model.prototype.remove;
    Model.prototype.deleteOne = function deleteOne(options, fn) {
      if (typeof options === "function") {
        fn = options;
        options = void 0;
      }
      if (!options) {
        options = {};
      }
      fn = this.constructor.$handleCallbackError(fn);
      return this.constructor.db.base._promiseOrCallback(fn, (cb) => {
        cb = this.constructor.$wrapCallback(cb);
        this.$__deleteOne(options, cb);
      }, this.constructor.events);
    };
    Model.prototype.$__remove = function $__remove(options, cb) {
      if (this.$__.isDeleted) {
        return immediate(() => cb(null, this));
      }
      const where = this.$__where();
      if (where instanceof MongooseError) {
        return cb(where);
      }
      _applyCustomWhere(this, where);
      const session = this.$session();
      if (!options.hasOwnProperty("session")) {
        options.session = session;
      }
      this[modelCollectionSymbol].deleteOne(where, options, (err) => {
        if (!err) {
          this.$__.isDeleted = true;
          this.emit("remove", this);
          this.constructor.emit("remove", this);
          return cb(null, this);
        }
        this.$__.isDeleted = false;
        cb(err);
      });
    };
    Model.prototype.$__deleteOne = Model.prototype.$__remove;
    Model.prototype.model = function model2(name) {
      return this[modelDbSymbol].model(name);
    };
    Model.exists = function exists(filter, options, callback) {
      _checkContext(this, "exists");
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const query = this.findOne(filter).select({ _id: 1 }).lean().setOptions(options);
      if (typeof callback === "function") {
        query.exec(function(err, doc) {
          if (err != null) {
            return callback(err);
          }
          callback(null, !!doc);
        });
        return;
      }
      options = options || {};
      if (!options.explain) {
        return query.then((doc) => !!doc);
      }
      return query.exec();
    };
    Model.discriminator = function(name, schema, value) {
      let model2;
      if (typeof name === "function") {
        model2 = name;
        name = utils2.getFunctionName(model2);
        if (!(model2.prototype instanceof Model)) {
          throw new MongooseError("The provided class " + name + " must extend Model");
        }
      }
      _checkContext(this, "discriminator");
      if (utils2.isObject(schema) && !schema.instanceOfSchema) {
        schema = new Schema2(schema);
      }
      schema = discriminator(this, name, schema, value, true);
      if (this.db.models[name]) {
        throw new OverwriteModelError(name);
      }
      schema.$isRootDiscriminator = true;
      schema.$globalPluginsApplied = true;
      model2 = this.db.model(model2 || name, schema, this.$__collection.name);
      this.discriminators[name] = model2;
      const d = this.discriminators[name];
      d.prototype.__proto__ = this.prototype;
      Object.defineProperty(d, "baseModelName", {
        value: this.modelName,
        configurable: true,
        writable: false
      });
      applyMethods(d, schema);
      applyStatics(d, schema);
      if (this[subclassedSymbol] != null) {
        for (const submodel of this[subclassedSymbol]) {
          submodel.discriminators = submodel.discriminators || {};
          submodel.discriminators[name] = model2.__subclass(model2.db, schema, submodel.collection.name);
        }
      }
      return d;
    };
    function _checkContext(ctx, fnName) {
      if (ctx == null || ctx === global) {
        throw new MongooseError("`Model." + fnName + "()` cannot run without a model as `this`. Make sure you are calling `MyModel." + fnName + "()` where `MyModel` is a Mongoose model.");
      } else if (ctx[modelSymbol] == null) {
        throw new MongooseError("`Model." + fnName + "()` cannot run without a model as `this`. Make sure you are not calling `new Model." + fnName + "()`");
      }
    }
    for (const i in EventEmitter.prototype) {
      Model[i] = EventEmitter.prototype[i];
    }
    Model.init = function init(callback) {
      _checkContext(this, "init");
      this.schema.emit("init", this);
      if (this.$init != null) {
        if (callback) {
          this.$init.then(() => callback(), (err) => callback(err));
          return null;
        }
        return this.$init;
      }
      const Promise2 = PromiseProvider.get();
      const autoIndex = utils2.getOption("autoIndex", this.schema.options, this.db.config, this.db.base.options);
      const autoCreate = utils2.getOption("autoCreate", this.schema.options, this.db.config, this.db.base.options);
      const _ensureIndexes2 = autoIndex ? (cb) => this.ensureIndexes({ _automatic: true }, cb) : (cb) => cb();
      const _createCollection = autoCreate ? (cb) => this.createCollection({}, cb) : (cb) => cb();
      this.$init = new Promise2((resolve, reject) => {
        _createCollection((error) => {
          if (error) {
            return reject(error);
          }
          _ensureIndexes2((error2) => {
            if (error2) {
              return reject(error2);
            }
            resolve(this);
          });
        });
      });
      if (callback) {
        this.$init.then(() => callback(), (err) => callback(err));
        this.$caught = true;
        return null;
      } else {
        const _catch = this.$init.catch;
        const _this = this;
        this.$init.catch = function() {
          this.$caught = true;
          return _catch.apply(_this.$init, arguments);
        };
      }
      return this.$init;
    };
    Model.createCollection = function createCollection(options, callback) {
      _checkContext(this, "createCollection");
      if (typeof options === "string") {
        throw new MongooseError("You can't specify a new collection name in Model.createCollection.This is not like Connection.createCollection. Only options are accepted here.");
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const schemaCollation = get(this, "schema.options.collation", null);
      if (schemaCollation != null) {
        options = Object.assign({ collation: schemaCollation }, options);
      }
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        this.db.createCollection(this.$__collection.collectionName, options, utils2.tick((error) => {
          if (error != null && error.codeName !== "NamespaceExists") {
            return cb(error);
          }
          this.$__collection = this.db.collection(this.$__collection.collectionName, options);
          cb(null, this.$__collection);
        }));
      }, this.events);
    };
    Model.syncIndexes = function syncIndexes(options, callback) {
      _checkContext(this, "syncIndexes");
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        this.createCollection((err) => {
          if (err != null && err.codeName !== "NamespaceExists") {
            return cb(err);
          }
          this.cleanIndexes((err2, dropped) => {
            if (err2 != null) {
              return cb(err2);
            }
            this.createIndexes(options, (err3) => {
              if (err3 != null) {
                return cb(err3);
              }
              cb(null, dropped);
            });
          });
        });
      }, this.events);
    };
    Model.diffIndexes = function diffIndexes(options, callback) {
      const toDrop = [];
      const toCreate = [];
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        this.listIndexes((err, indexes) => {
          const schemaIndexes = this.schema.indexes();
          for (const index of indexes) {
            let found = false;
            if (isDefaultIdIndex(index)) {
              continue;
            }
            for (const schemaIndex of schemaIndexes) {
              const key = schemaIndex[0];
              const options2 = _decorateDiscriminatorIndexOptions(this, utils2.clone(schemaIndex[1]));
              if (isIndexEqual(key, options2, index)) {
                found = true;
              }
            }
            if (!found) {
              toDrop.push(index.name);
            }
          }
          for (const schemaIndex of schemaIndexes) {
            const key = schemaIndex[0];
            let found = false;
            const options2 = _decorateDiscriminatorIndexOptions(this, utils2.clone(schemaIndex[1]));
            for (const index of indexes) {
              if (isDefaultIdIndex(index)) {
                continue;
              }
              if (isIndexEqual(key, options2, index)) {
                found = true;
              }
            }
            if (!found) {
              toCreate.push(key);
            }
          }
          cb(null, { toDrop, toCreate });
        });
      });
    };
    Model.cleanIndexes = function cleanIndexes(callback) {
      _checkContext(this, "cleanIndexes");
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        const collection = this.$__collection;
        this.listIndexes((err, indexes) => {
          if (err != null) {
            return cb(err);
          }
          const schemaIndexes = this.schema.indexes();
          const toDrop = [];
          for (const index of indexes) {
            let found = false;
            if (isDefaultIdIndex(index)) {
              continue;
            }
            for (const schemaIndex of schemaIndexes) {
              const key = schemaIndex[0];
              const options = _decorateDiscriminatorIndexOptions(this, utils2.clone(schemaIndex[1]));
              if (isIndexEqual(key, options, index)) {
                found = true;
              }
            }
            if (!found) {
              toDrop.push(index.name);
            }
          }
          if (toDrop.length === 0) {
            return cb(null, []);
          }
          dropIndexes(toDrop, cb);
        });
        function dropIndexes(toDrop, cb2) {
          let remaining = toDrop.length;
          let error = false;
          toDrop.forEach((indexName) => {
            collection.dropIndex(indexName, (err) => {
              if (err != null) {
                error = true;
                return cb2(err);
              }
              if (!error) {
                --remaining || cb2(null, toDrop);
              }
            });
          });
        }
      });
    };
    Model.listIndexes = function init(callback) {
      _checkContext(this, "listIndexes");
      const _listIndexes = (cb) => {
        this.$__collection.listIndexes().toArray(cb);
      };
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        if (this.$__collection.buffer) {
          this.$__collection.addQueue(_listIndexes, [cb]);
        } else {
          _listIndexes(cb);
        }
      }, this.events);
    };
    Model.ensureIndexes = function ensureIndexes(options, callback) {
      _checkContext(this, "ensureIndexes");
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        _ensureIndexes(this, options || {}, (error) => {
          if (error) {
            return cb(error);
          }
          cb(null);
        });
      }, this.events);
    };
    Model.createIndexes = function createIndexes(options, callback) {
      _checkContext(this, "createIndexes");
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      options.createIndex = true;
      return this.ensureIndexes(options, callback);
    };
    function _ensureIndexes(model2, options, callback) {
      const indexes = model2.schema.indexes();
      let indexError;
      options = options || {};
      const done = function(err) {
        if (err && !model2.$caught) {
          model2.emit("error", err);
        }
        model2.emit("index", err || indexError);
        callback && callback(err || indexError);
      };
      for (const index of indexes) {
        if (isDefaultIdIndex(index)) {
          console.warn('mongoose: Cannot specify a custom index on `_id` for model name "' + model2.modelName + '", MongoDB does not allow overwriting the default `_id` index. See http://bit.ly/mongodb-id-index');
        }
      }
      if (!indexes.length) {
        immediate(function() {
          done();
        });
        return;
      }
      const indexSingleDone = function(err, fields, options2, name) {
        model2.emit("index-single-done", err, fields, options2, name);
      };
      const indexSingleStart = function(fields, options2) {
        model2.emit("index-single-start", fields, options2);
      };
      const baseSchema = model2.schema._baseSchema;
      const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];
      const create = function() {
        if (options._automatic) {
          if (model2.schema.options.autoIndex === false || model2.schema.options.autoIndex == null && model2.db.config.autoIndex === false) {
            return done();
          }
        }
        const index = indexes.shift();
        if (!index) {
          return done();
        }
        if (options._automatic && index[1]._autoIndex === false) {
          return create();
        }
        if (baseSchemaIndexes.find((i) => utils2.deepEqual(i, index))) {
          return create();
        }
        const indexFields = utils2.clone(index[0]);
        const indexOptions = utils2.clone(index[1]);
        let isTextIndex = false;
        for (const key of Object.keys(indexFields)) {
          if (indexFields[key] === "text") {
            isTextIndex = true;
          }
        }
        delete indexOptions._autoIndex;
        _decorateDiscriminatorIndexOptions(model2, indexOptions);
        if ("safe" in options) {
          _handleSafe(options);
        }
        applyWriteConcern(model2.schema, indexOptions);
        indexSingleStart(indexFields, options);
        let useCreateIndex = !!model2.base.options.useCreateIndex;
        if ("useCreateIndex" in model2.db.config) {
          useCreateIndex = !!model2.db.config.useCreateIndex;
        }
        if ("createIndex" in options) {
          useCreateIndex = !!options.createIndex;
        }
        if ("background" in options) {
          indexOptions.background = options.background;
        }
        if (model2.schema.options.hasOwnProperty("collation") && !indexOptions.hasOwnProperty("collation") && !isTextIndex) {
          indexOptions.collation = model2.schema.options.collation;
        }
        const methodName = useCreateIndex ? "createIndex" : "ensureIndex";
        model2.collection[methodName](indexFields, indexOptions, utils2.tick(function(err, name) {
          indexSingleDone(err, indexFields, indexOptions, name);
          if (err) {
            if (!indexError) {
              indexError = err;
            }
            if (!model2.$caught) {
              model2.emit("error", err);
            }
          }
          create();
        }));
      };
      immediate(function() {
        if (options._automatic && !model2.collection.collection) {
          model2.collection.addQueue(create, []);
        } else {
          create();
        }
      });
    }
    function _decorateDiscriminatorIndexOptions(model2, indexOptions) {
      if (model2.baseModelName != null && !("partialFilterExpression" in indexOptions) && !("sparse" in indexOptions)) {
        const value = model2.schema.discriminatorMapping && model2.schema.discriminatorMapping.value || model2.modelName;
        const discriminatorKey = model2.schema.options.discriminatorKey;
        indexOptions.partialFilterExpression = { [discriminatorKey]: value };
      }
      return indexOptions;
    }
    var safeDeprecationWarning = "Mongoose: the `safe` option for `save()` is deprecated. Use the `w` option instead: http://bit.ly/mongoose-save";
    var _handleSafe = util.deprecate(function _handleSafe2(options) {
      if (options.safe) {
        if (typeof options.safe === "boolean") {
          options.w = options.safe;
          delete options.safe;
        }
        if (typeof options.safe === "object") {
          options.w = options.safe.w;
          options.j = options.safe.j;
          options.wtimeout = options.safe.wtimeout;
          delete options.safe;
        }
      }
    }, safeDeprecationWarning);
    Model.schema;
    Model.db;
    Model.collection;
    Model.$__collection;
    Model.base;
    Model.discriminators;
    Model.translateAliases = function translateAliases(fields) {
      _checkContext(this, "translateAliases");
      const translate = (key, value) => {
        let alias;
        const translated = [];
        const fieldKeys = key.split(".");
        let currentSchema = this.schema;
        for (const i in fieldKeys) {
          const name = fieldKeys[i];
          if (currentSchema && currentSchema.aliases[name]) {
            alias = currentSchema.aliases[name];
            translated.push(alias);
          } else {
            translated.push(name);
          }
          if (currentSchema && currentSchema.paths[alias]) {
            currentSchema = currentSchema.paths[alias].schema;
          } else
            currentSchema = null;
        }
        const translatedKey = translated.join(".");
        if (fields instanceof Map)
          fields.set(translatedKey, value);
        else
          fields[translatedKey] = value;
        if (translatedKey !== key) {
          if (fields instanceof Map) {
            fields.delete(key);
          } else {
            delete fields[key];
          }
        }
        return fields;
      };
      if (typeof fields === "object") {
        if (fields instanceof Map) {
          for (const field of new Map(fields)) {
            fields = translate(field[0], field[1]);
          }
        } else {
          for (const key of Object.keys(fields)) {
            fields = translate(key, fields[key]);
            if (key[0] === "$") {
              if (Array.isArray(fields[key])) {
                for (const i in fields[key]) {
                  fields[key][i] = this.translateAliases(fields[key][i]);
                }
              }
            }
          }
        }
        return fields;
      } else {
        return fields;
      }
    };
    Model.remove = function remove(conditions, options, callback) {
      _checkContext(this, "remove");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.setOptions(options);
      callback = this.$handleCallbackError(callback);
      return mq.remove(conditions, callback);
    };
    Model.deleteOne = function deleteOne(conditions, options, callback) {
      _checkContext(this, "deleteOne");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.setOptions(options);
      callback = this.$handleCallbackError(callback);
      return mq.deleteOne(conditions, callback);
    };
    Model.deleteMany = function deleteMany(conditions, options, callback) {
      _checkContext(this, "deleteMany");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.setOptions(options);
      callback = this.$handleCallbackError(callback);
      return mq.deleteMany(conditions, callback);
    };
    Model.find = function find(conditions, projection, options, callback) {
      _checkContext(this, "find");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        projection = null;
        options = null;
      } else if (typeof projection === "function") {
        callback = projection;
        projection = null;
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(projection);
      mq.setOptions(options);
      if (this.schema.discriminatorMapping && this.schema.discriminatorMapping.isRoot && mq.selectedInclusively()) {
        mq.select(this.schema.options.discriminatorKey);
      }
      callback = this.$handleCallbackError(callback);
      return mq.find(conditions, callback);
    };
    Model.findById = function findById(id, projection, options, callback) {
      _checkContext(this, "findById");
      if (typeof id === "undefined") {
        id = null;
      }
      callback = this.$handleCallbackError(callback);
      return this.findOne({ _id: id }, projection, options, callback);
    };
    Model.findOne = function findOne(conditions, projection, options, callback) {
      _checkContext(this, "findOne");
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (typeof projection === "function") {
        callback = projection;
        projection = null;
        options = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        projection = null;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(projection);
      mq.setOptions(options);
      if (this.schema.discriminatorMapping && this.schema.discriminatorMapping.isRoot && mq.selectedInclusively()) {
        mq.select(this.schema.options.discriminatorKey);
      }
      callback = this.$handleCallbackError(callback);
      return mq.findOne(conditions, callback);
    };
    Model.estimatedDocumentCount = function estimatedDocumentCount(options, callback) {
      _checkContext(this, "estimatedDocumentCount");
      const mq = new this.Query({}, {}, this, this.$__collection);
      callback = this.$handleCallbackError(callback);
      return mq.estimatedDocumentCount(options, callback);
    };
    Model.countDocuments = function countDocuments(conditions, callback) {
      _checkContext(this, "countDocuments");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      callback = this.$handleCallbackError(callback);
      return mq.countDocuments(conditions, callback);
    };
    Model.count = function count(conditions, callback) {
      _checkContext(this, "count");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      callback = this.$handleCallbackError(callback);
      return mq.count(conditions, callback);
    };
    Model.distinct = function distinct(field, conditions, callback) {
      _checkContext(this, "distinct");
      const mq = new this.Query({}, {}, this, this.$__collection);
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      callback = this.$handleCallbackError(callback);
      return mq.distinct(field, conditions, callback);
    };
    Model.where = function where(path, val) {
      _checkContext(this, "where");
      void 0;
      const mq = new this.Query({}, {}, this, this.$__collection).find({});
      return mq.where.apply(mq, arguments);
    };
    Model.$where = function $where() {
      _checkContext(this, "$where");
      const mq = new this.Query({}, {}, this, this.$__collection).find({});
      return mq.$where.apply(mq, arguments);
    };
    Model.findOneAndUpdate = function(conditions, update, options, callback) {
      _checkContext(this, "findOneAndUpdate");
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (arguments.length === 1) {
        if (typeof conditions === "function") {
          const msg = "Model.findOneAndUpdate(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndUpdate(conditions, update, options, callback)\n  " + this.modelName + ".findOneAndUpdate(conditions, update, options)\n  " + this.modelName + ".findOneAndUpdate(conditions, update)\n  " + this.modelName + ".findOneAndUpdate(update)\n  " + this.modelName + ".findOneAndUpdate()\n";
          throw new TypeError(msg);
        }
        update = conditions;
        conditions = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options) {
        fields = options.fields || options.projection;
      }
      update = utils2.clone(update, {
        depopulate: true,
        _isNested: true
      });
      _decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndUpdate(conditions, update, options, callback);
    };
    function _decorateUpdateWithVersionKey(update, options, versionKey) {
      if (!versionKey || !get(options, "upsert", false)) {
        return;
      }
      const updatedPaths = modifiedPaths(update);
      if (!updatedPaths[versionKey]) {
        if (options.overwrite) {
          update[versionKey] = 0;
        } else {
          if (!update.$setOnInsert) {
            update.$setOnInsert = {};
          }
          update.$setOnInsert[versionKey] = 0;
        }
      }
    }
    Model.findByIdAndUpdate = function(id, update, options, callback) {
      _checkContext(this, "findByIdAndUpdate");
      callback = this.$handleCallbackError(callback);
      if (arguments.length === 1) {
        if (typeof id === "function") {
          const msg = "Model.findByIdAndUpdate(): First argument must not be a function.\n\n  " + this.modelName + ".findByIdAndUpdate(id, callback)\n  " + this.modelName + ".findByIdAndUpdate(id)\n  " + this.modelName + ".findByIdAndUpdate()\n";
          throw new TypeError(msg);
        }
        return this.findOneAndUpdate({ _id: id }, void 0);
      }
      if (id instanceof Document2) {
        id = id._id;
      }
      return this.findOneAndUpdate.call(this, { _id: id }, update, options, callback);
    };
    Model.findOneAndDelete = function(conditions, options, callback) {
      _checkContext(this, "findOneAndDelete");
      if (arguments.length === 1 && typeof conditions === "function") {
        const msg = "Model.findOneAndDelete(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndDelete(conditions, callback)\n  " + this.modelName + ".findOneAndDelete(conditions)\n  " + this.modelName + ".findOneAndDelete()\n";
        throw new TypeError(msg);
      }
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options) {
        fields = options.select;
        options.select = void 0;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndDelete(conditions, options, callback);
    };
    Model.findByIdAndDelete = function(id, options, callback) {
      _checkContext(this, "findByIdAndDelete");
      if (arguments.length === 1 && typeof id === "function") {
        const msg = "Model.findByIdAndDelete(): First argument must not be a function.\n\n  " + this.modelName + ".findByIdAndDelete(id, callback)\n  " + this.modelName + ".findByIdAndDelete(id)\n  " + this.modelName + ".findByIdAndDelete()\n";
        throw new TypeError(msg);
      }
      callback = this.$handleCallbackError(callback);
      return this.findOneAndDelete({ _id: id }, options, callback);
    };
    Model.findOneAndReplace = function(filter, replacement, options, callback) {
      _checkContext(this, "findOneAndReplace");
      if (arguments.length === 1 && typeof filter === "function") {
        const msg = "Model.findOneAndReplace(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndReplace(conditions, callback)\n  " + this.modelName + ".findOneAndReplace(conditions)\n  " + this.modelName + ".findOneAndReplace()\n";
        throw new TypeError(msg);
      }
      if (arguments.length === 3 && typeof options === "function") {
        callback = options;
        options = replacement;
        replacement = void 0;
      }
      if (arguments.length === 2 && typeof replacement === "function") {
        callback = replacement;
        replacement = void 0;
        options = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options) {
        fields = options.select;
        options.select = void 0;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndReplace(filter, replacement, options, callback);
    };
    Model.findOneAndRemove = function(conditions, options, callback) {
      _checkContext(this, "findOneAndRemove");
      if (arguments.length === 1 && typeof conditions === "function") {
        const msg = "Model.findOneAndRemove(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndRemove(conditions, callback)\n  " + this.modelName + ".findOneAndRemove(conditions)\n  " + this.modelName + ".findOneAndRemove()\n";
        throw new TypeError(msg);
      }
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options) {
        fields = options.select;
        options.select = void 0;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndRemove(conditions, options, callback);
    };
    Model.findByIdAndRemove = function(id, options, callback) {
      _checkContext(this, "findByIdAndRemove");
      if (arguments.length === 1 && typeof id === "function") {
        const msg = "Model.findByIdAndRemove(): First argument must not be a function.\n\n  " + this.modelName + ".findByIdAndRemove(id, callback)\n  " + this.modelName + ".findByIdAndRemove(id)\n  " + this.modelName + ".findByIdAndRemove()\n";
        throw new TypeError(msg);
      }
      callback = this.$handleCallbackError(callback);
      return this.findOneAndRemove({ _id: id }, options, callback);
    };
    Model.create = function create(doc, options, callback) {
      _checkContext(this, "create");
      let args;
      let cb;
      const discriminatorKey = this.schema.options.discriminatorKey;
      if (Array.isArray(doc)) {
        args = doc;
        cb = typeof options === "function" ? options : callback;
        options = options != null && typeof options === "object" ? options : {};
      } else {
        const last = arguments[arguments.length - 1];
        options = {};
        if (typeof last === "function" || arguments.length > 1 && !last) {
          cb = last;
          args = utils2.args(arguments, 0, arguments.length - 1);
        } else {
          args = utils2.args(arguments);
        }
        if (args.length === 2 && args[0] != null && args[1] != null && args[0].session == null && getConstructorName(last.session) === "ClientSession" && !this.schema.path("session")) {
          console.warn("WARNING: to pass a `session` to `Model.create()` in Mongoose, you **must** pass an array as the first argument. See: https://mongoosejs.com/docs/api.html#model_Model.create");
        }
      }
      return this.db.base._promiseOrCallback(cb, (cb2) => {
        cb2 = this.$wrapCallback(cb2);
        if (args.length === 0) {
          return cb2(null);
        }
        const toExecute = [];
        let firstError;
        args.forEach((doc2) => {
          toExecute.push((callback2) => {
            const Model2 = this.discriminators && doc2[discriminatorKey] != null ? this.discriminators[doc2[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc2[discriminatorKey]) : this;
            if (Model2 == null) {
              throw new MongooseError(`Discriminator "${doc2[discriminatorKey]}" not found for model "${this.modelName}"`);
            }
            let toSave = doc2;
            const callbackWrapper = (error, doc3) => {
              if (error) {
                if (!firstError) {
                  firstError = error;
                }
                return callback2(null, { error });
              }
              callback2(null, { doc: doc3 });
            };
            if (!(toSave instanceof Model2)) {
              try {
                toSave = new Model2(toSave);
              } catch (error) {
                return callbackWrapper(error);
              }
            }
            toSave.save(options, callbackWrapper);
          });
        });
        let numFns = toExecute.length;
        if (numFns === 0) {
          return cb2(null, []);
        }
        const _done = (error, res) => {
          const savedDocs = [];
          const len = res.length;
          for (let i = 0; i < len; ++i) {
            if (res[i].doc) {
              savedDocs.push(res[i].doc);
            }
          }
          if (firstError) {
            return cb2(firstError, savedDocs);
          }
          if (doc instanceof Array) {
            cb2(null, savedDocs);
          } else {
            cb2.apply(this, [null].concat(savedDocs));
          }
        };
        const _res = [];
        toExecute.forEach((fn, i) => {
          fn((err, res) => {
            _res[i] = res;
            if (--numFns <= 0) {
              return _done(null, _res);
            }
          });
        });
      }, this.events);
    };
    Model.watch = function(pipeline, options) {
      _checkContext(this, "watch");
      const changeStreamThunk = (cb) => {
        if (this.$__collection.buffer) {
          this.$__collection.addQueue(() => {
            if (this.closed) {
              return;
            }
            const driverChangeStream = this.$__collection.watch(pipeline, options);
            cb(null, driverChangeStream);
          });
        } else {
          const driverChangeStream = this.$__collection.watch(pipeline, options);
          cb(null, driverChangeStream);
        }
      };
      return new ChangeStream(changeStreamThunk, pipeline, options);
    };
    Model.startSession = function() {
      _checkContext(this, "startSession");
      return this.db.startSession.apply(this.db, arguments);
    };
    Model.insertMany = function(arr, options, callback) {
      _checkContext(this, "insertMany");
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      return this.db.base._promiseOrCallback(callback, (cb) => {
        this.$__insertMany(arr, options, cb);
      }, this.events);
    };
    Model.$__insertMany = function(arr, options, callback) {
      const _this = this;
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (callback) {
        callback = this.$handleCallbackError(callback);
        callback = this.$wrapCallback(callback);
      }
      callback = callback || utils2.noop;
      options = options || {};
      const limit = get(options, "limit", 1e3);
      const rawResult = get(options, "rawResult", false);
      const ordered = get(options, "ordered", true);
      const lean = get(options, "lean", false);
      if (!Array.isArray(arr)) {
        arr = [arr];
      }
      const validationErrors = [];
      const toExecute = arr.map((doc) => (callback2) => {
        if (!(doc instanceof _this)) {
          try {
            doc = new _this(doc);
          } catch (err) {
            return callback2(err);
          }
        }
        if (options.session != null) {
          doc.$session(options.session);
        }
        if (lean) {
          return immediate(() => callback2(null, doc));
        }
        doc.validate({ __noPromise: true }, function(error) {
          if (error) {
            if (ordered === false) {
              validationErrors.push(error);
              return callback2(null, null);
            }
            return callback2(error);
          }
          callback2(null, doc);
        });
      });
      parallelLimit(toExecute, limit, function(error, docs) {
        if (error) {
          callback(error, null);
          return;
        }
        const docAttributes = docs.filter(function(doc) {
          return doc != null;
        });
        if (docAttributes.length < 1) {
          if (rawResult) {
            const res = {
              mongoose: {
                validationErrors
              }
            };
            return callback(null, res);
          }
          callback(null, []);
          return;
        }
        const docObjects = docAttributes.map(function(doc) {
          if (doc.$__schema.options.versionKey) {
            doc[doc.$__schema.options.versionKey] = 0;
          }
          if (doc.initializeTimestamps) {
            return doc.initializeTimestamps().toObject(internalToObjectOptions);
          }
          return doc.toObject(internalToObjectOptions);
        });
        _this.$__collection.insertMany(docObjects, options, function(error2, res) {
          if (error2) {
            if (error2.writeErrors == null && get(error2, "result.result.writeErrors") != null) {
              error2.writeErrors = error2.result.result.writeErrors;
            }
            const erroredIndexes = new Set(get(error2, "writeErrors", []).map((err) => err.index));
            let firstErroredIndex = -1;
            error2.insertedDocs = docAttributes.filter((doc, i) => {
              const isErrored = erroredIndexes.has(i);
              if (ordered) {
                if (firstErroredIndex > -1) {
                  return i < firstErroredIndex;
                }
                if (isErrored) {
                  firstErroredIndex = i;
                }
              }
              return !isErrored;
            }).map(function setIsNewForInsertedDoc(doc) {
              doc.$__reset();
              _setIsNew(doc, false);
              return doc;
            });
            callback(error2, null);
            return;
          }
          for (const attribute of docAttributes) {
            attribute.$__reset();
            _setIsNew(attribute, false);
          }
          if (rawResult) {
            if (ordered === false) {
              res.mongoose = {
                validationErrors
              };
            }
            return callback(null, res);
          }
          if (options.populate != null) {
            return _this.populate(docAttributes, options.populate, (err) => {
              if (err != null) {
                error2.insertedDocs = docAttributes;
                return callback(err);
              }
              callback(null, docs);
            });
          }
          callback(null, docAttributes);
        });
      });
    };
    function _setIsNew(doc, val) {
      doc.isNew = val;
      doc.emit("isNew", val);
      doc.constructor.emit("isNew", val);
      const subdocs = doc.$getAllSubdocs();
      for (const subdoc of subdocs) {
        subdoc.isNew = val;
      }
    }
    Model.bulkWrite = function(ops, options, callback) {
      _checkContext(this, "bulkWrite");
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      options = options || {};
      const validations = ops.map((op) => castBulkWrite(this, op, options));
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        each(validations, (fn, cb2) => fn(cb2), (error) => {
          if (error) {
            return cb(error);
          }
          if (ops.length === 0) {
            return cb(null, getDefaultBulkwriteResult());
          }
          this.$__collection.bulkWrite(ops, options, (error2, res) => {
            if (error2) {
              return cb(error2);
            }
            cb(null, res);
          });
        });
      }, this.events);
    };
    Model.bulkSave = function(documents) {
      const preSavePromises = documents.map(buildPreSavePromise);
      const writeOperations = this.buildBulkWriteOperations(documents, { skipValidation: true });
      let bulkWriteResultPromise;
      return Promise.all(preSavePromises).then(() => bulkWriteResultPromise = this.bulkWrite(writeOperations)).then(() => documents.map(buildSuccessfulWriteHandlerPromise)).then(() => bulkWriteResultPromise).catch((err) => {
        if (!get(err, "writeErrors.length")) {
          throw err;
        }
        return Promise.all(documents.map((document2) => {
          const documentError = err.writeErrors.find((writeError) => {
            const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;
            return writeErrorDocumentId.toString() === document2._id.toString();
          });
          if (documentError == null) {
            return buildSuccessfulWriteHandlerPromise(document2);
          }
        })).then(() => {
          throw err;
        });
      });
    };
    function buildPreSavePromise(document2) {
      return new Promise((resolve, reject) => {
        document2.schema.s.hooks.execPre("save", document2, (err) => {
          if (err) {
            reject(err);
            return;
          }
          resolve();
        });
      });
    }
    function buildSuccessfulWriteHandlerPromise(document2) {
      return new Promise((resolve, reject) => {
        handleSuccessfulWrite(document2, resolve, reject);
      });
    }
    function handleSuccessfulWrite(document2, resolve, reject) {
      if (document2.isNew) {
        _setIsNew(document2, false);
      }
      document2.$__reset();
      document2.schema.s.hooks.execPost("save", document2, {}, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    }
    Model.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {
      if (!Array.isArray(documents)) {
        throw new Error(`bulkSave expects an array of documents to be passed, received \`${documents}\` instead`);
      }
      setDefaultOptions();
      const writeOperations = documents.reduce((accumulator, document2, i) => {
        if (!options.skipValidation) {
          if (!(document2 instanceof Document2)) {
            throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);
          }
          const validationError = document2.validateSync();
          if (validationError) {
            throw validationError;
          }
        }
        const isANewDocument = document2.isNew;
        if (isANewDocument) {
          accumulator.push({
            insertOne: { document: document2 }
          });
          return accumulator;
        }
        const delta = document2.$__delta();
        const isDocumentWithChanges = delta != null && !utils2.isEmptyObject(delta[0]);
        if (isDocumentWithChanges) {
          const where = document2.$__where(delta[0]);
          const changes = delta[1];
          _applyCustomWhere(document2, where);
          document2.$__version(where, delta);
          accumulator.push({
            updateOne: {
              filter: where,
              update: changes
            }
          });
          return accumulator;
        }
        return accumulator;
      }, []);
      return writeOperations;
      function setDefaultOptions() {
        options = options || {};
        if (options.skipValidation == null) {
          options.skipValidation = false;
        }
      }
    };
    Model.hydrate = function(obj, projection) {
      _checkContext(this, "hydrate");
      const model2 = require_queryhelpers().createModel(this, obj, projection);
      model2.init(obj);
      return model2;
    };
    Model.update = function update(conditions, doc, options, callback) {
      _checkContext(this, "update");
      return _update(this, "update", conditions, doc, options, callback);
    };
    Model.updateMany = function updateMany(conditions, doc, options, callback) {
      _checkContext(this, "updateMany");
      return _update(this, "updateMany", conditions, doc, options, callback);
    };
    Model.updateOne = function updateOne(conditions, doc, options, callback) {
      _checkContext(this, "updateOne");
      return _update(this, "updateOne", conditions, doc, options, callback);
    };
    Model.replaceOne = function replaceOne(conditions, doc, options, callback) {
      _checkContext(this, "replaceOne");
      const versionKey = get(this, "schema.options.versionKey", null);
      if (versionKey && !doc[versionKey]) {
        doc[versionKey] = 0;
      }
      return _update(this, "replaceOne", conditions, doc, options, callback);
    };
    function _update(model2, op, conditions, doc, options, callback) {
      const mq = new model2.Query({}, {}, model2, model2.collection);
      callback = model2.$handleCallbackError(callback);
      if (conditions instanceof Document2) {
        conditions = conditions.toObject();
      } else {
        conditions = utils2.clone(conditions);
      }
      options = typeof options === "function" ? options : utils2.clone(options);
      const versionKey = get(model2, "schema.options.versionKey", null);
      _decorateUpdateWithVersionKey(doc, options, versionKey);
      return mq[op](conditions, doc, options, callback);
    }
    Model.mapReduce = function mapReduce(o, callback) {
      _checkContext(this, "mapReduce");
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        if (!Model.mapReduce.schema) {
          const opts = { noId: true, noVirtualId: true, strict: false };
          Model.mapReduce.schema = new Schema2({}, opts);
        }
        if (!o.out)
          o.out = { inline: 1 };
        if (o.verbose !== false)
          o.verbose = true;
        o.map = String(o.map);
        o.reduce = String(o.reduce);
        if (o.query) {
          let q = new this.Query(o.query);
          q.cast(this);
          o.query = q._conditions;
          q = void 0;
        }
        this.$__collection.mapReduce(null, null, o, (err, res) => {
          if (err) {
            return cb(err);
          }
          if (res.collection) {
            const model2 = Model.compile("_mapreduce_" + res.collection.collectionName, Model.mapReduce.schema, res.collection.collectionName, this.db, this.base);
            model2._mapreduce = true;
            res.model = model2;
            return cb(null, res);
          }
          cb(null, res);
        });
      }, this.events);
    };
    Model.aggregate = function aggregate(pipeline, callback) {
      _checkContext(this, "aggregate");
      if (arguments.length > 2 || get(pipeline, "constructor.name") === "Object") {
        throw new MongooseError("Mongoose 5.x disallows passing a spread of operators to `Model.aggregate()`. Instead of `Model.aggregate({ $match }, { $skip })`, do `Model.aggregate([{ $match }, { $skip }])`");
      }
      if (typeof pipeline === "function") {
        callback = pipeline;
        pipeline = [];
      }
      const aggregate2 = new Aggregate(pipeline || []);
      aggregate2.model(this);
      if (typeof callback === "undefined") {
        return aggregate2;
      }
      callback = this.$handleCallbackError(callback);
      callback = this.$wrapCallback(callback);
      aggregate2.exec(callback);
      return aggregate2;
    };
    Model.validate = function validate(obj, pathsToValidate, context, callback) {
      if (arguments.length < 3 || arguments.length === 3 && typeof arguments[2] === "function") {
        context = obj;
      }
      return this.db.base._promiseOrCallback(callback, (cb) => {
        const schema = this.schema;
        let paths = Object.keys(schema.paths);
        if (pathsToValidate != null) {
          const _pathsToValidate = new Set(pathsToValidate);
          paths = paths.filter((p) => {
            const pieces = p.split(".");
            let cur = pieces[0];
            for (const piece of pieces) {
              if (_pathsToValidate.has(cur)) {
                return true;
              }
              cur += "." + piece;
            }
            return _pathsToValidate.has(p);
          });
        }
        for (const path of paths) {
          const schemaType = schema.path(path);
          if (!schemaType || !schemaType.$isMongooseArray) {
            continue;
          }
          const val = get(obj, path);
          pushNestedArrayPaths(val, path);
        }
        let remaining = paths.length;
        let error = null;
        for (const path of paths) {
          const schemaType = schema.path(path);
          if (schemaType == null) {
            _checkDone();
            continue;
          }
          const pieces = path.split(".");
          let cur = obj;
          for (let i = 0; i < pieces.length - 1; ++i) {
            cur = cur[pieces[i]];
          }
          let val = get(obj, path, void 0);
          if (val != null) {
            try {
              val = schemaType.cast(val);
              cur[pieces[pieces.length - 1]] = val;
            } catch (err) {
              error = error || new ValidationError();
              error.addError(path, err);
              _checkDone();
              continue;
            }
          }
          schemaType.doValidate(val, (err) => {
            if (err) {
              error = error || new ValidationError();
              if (err instanceof ValidationError) {
                for (const _err of Object.keys(err.errors)) {
                  error.addError(`${path}.${err.errors[_err].path}`, _err);
                }
              } else {
                error.addError(err.path, err);
              }
            }
            _checkDone();
          }, context, { path });
        }
        function pushNestedArrayPaths(nestedArray, path) {
          if (nestedArray == null) {
            return;
          }
          for (let i = 0; i < nestedArray.length; ++i) {
            if (Array.isArray(nestedArray[i])) {
              pushNestedArrayPaths(nestedArray[i], path + "." + i);
            } else {
              paths.push(path + "." + i);
            }
          }
        }
        function _checkDone() {
          if (--remaining <= 0) {
            return cb(error);
          }
        }
      });
    };
    Model.geoSearch = function(conditions, options, callback) {
      _checkContext(this, "geoSearch");
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        let error;
        if (conditions === void 0 || !utils2.isObject(conditions)) {
          error = new MongooseError("Must pass conditions to geoSearch");
        } else if (!options.near) {
          error = new MongooseError("Must specify the near option in geoSearch");
        } else if (!Array.isArray(options.near)) {
          error = new MongooseError("near option must be an array [x, y]");
        }
        if (error) {
          return cb(error);
        }
        options.search = conditions;
        this.$__collection.geoHaystackSearch(options.near[0], options.near[1], options, (err, res) => {
          if (err) {
            return cb(err);
          }
          let count = res.results.length;
          if (options.lean || count === 0) {
            return cb(null, res.results);
          }
          const errSeen = false;
          function init(err2) {
            if (err2 && !errSeen) {
              return cb(err2);
            }
            if (!--count && !errSeen) {
              cb(null, res.results);
            }
          }
          for (let i = 0; i < res.results.length; ++i) {
            const temp = res.results[i];
            res.results[i] = new this();
            res.results[i].init(temp, {}, init);
          }
        });
      }, this.events);
    };
    Model.populate = function(docs, paths, callback) {
      _checkContext(this, "populate");
      const _this = this;
      paths = utils2.populate(paths);
      const cache = {};
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        _populate(_this, docs, paths, cache, cb);
      }, this.events);
    };
    function _populate(model2, docs, paths, cache, callback) {
      let pending = paths.length;
      if (paths.length === 0) {
        return callback(null, docs);
      }
      for (const path of paths) {
        populate(model2, docs, path, next);
      }
      function next(err) {
        if (err) {
          return callback(err, null);
        }
        if (--pending) {
          return;
        }
        callback(null, docs);
      }
    }
    var excludeIdReg = /\s?-_id\s?/;
    var excludeIdRegGlobal = /\s?-_id\s?/g;
    function populate(model2, docs, options, callback) {
      if (!Array.isArray(docs)) {
        docs = [docs];
      }
      if (docs.length === 0 || docs.every(utils2.isNullOrUndefined)) {
        return callback();
      }
      const modelsMap = getModelsMapForPopulate(model2, docs, options);
      if (modelsMap instanceof MongooseError) {
        return immediate(function() {
          callback(modelsMap);
        });
      }
      const len = modelsMap.length;
      let vals = [];
      function flatten(item) {
        return item !== void 0;
      }
      let _remaining = len;
      let hasOne = false;
      const params = [];
      for (let i = 0; i < len; ++i) {
        const mod = modelsMap[i];
        let select = mod.options.select;
        let ids = utils2.array.flatten(mod.ids, flatten);
        ids = utils2.array.unique(ids);
        const assignmentOpts = {};
        assignmentOpts.sort = get(mod, "options.options.sort", void 0);
        assignmentOpts.excludeId = excludeIdReg.test(select) || select && select._id === 0;
        if (ids.length === 0 || ids.every(utils2.isNullOrUndefined)) {
          --_remaining;
          if (mod.count || mod.isVirtual) {
            _assign(model2, [], mod, assignmentOpts);
          }
          continue;
        }
        hasOne = true;
        const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);
        if (assignmentOpts.excludeId) {
          if (typeof select === "string") {
            select = select.replace(excludeIdRegGlobal, " ");
          } else {
            select = utils2.object.shallowCopy(select);
            delete select._id;
          }
        }
        if (mod.options.options && mod.options.options.limit != null) {
          assignmentOpts.originalLimit = mod.options.options.limit;
        } else if (mod.options.limit != null) {
          assignmentOpts.originalLimit = mod.options.limit;
        }
        params.push([mod, match, select, assignmentOpts, _next]);
      }
      if (!hasOne) {
        if (options.populate != null) {
          const opts = utils2.populate(options.populate).map((pop) => Object.assign({}, pop, {
            path: options.path + "." + pop.path
          }));
          return model2.populate(docs, opts, callback);
        }
        return callback();
      }
      for (const arr of params) {
        _execPopulateQuery.apply(null, arr);
      }
      function _next(err, valsFromDb) {
        if (err != null) {
          return callback(err, null);
        }
        vals = vals.concat(valsFromDb);
        if (--_remaining === 0) {
          _done();
        }
      }
      function _done() {
        for (const arr of params) {
          const mod = arr[0];
          const assignmentOpts = arr[3];
          for (const val of vals) {
            mod.options._childDocs.push(val);
          }
          _assign(model2, vals, mod, assignmentOpts);
        }
        for (const arr of params) {
          removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);
        }
        callback();
      }
    }
    function _execPopulateQuery(mod, match, select, assignmentOpts, callback) {
      const subPopulate = utils2.clone(mod.options.populate);
      const queryOptions = Object.assign({
        skip: mod.options.skip,
        limit: mod.options.limit,
        perDocumentLimit: mod.options.perDocumentLimit
      }, mod.options.options);
      if (mod.count) {
        delete queryOptions.skip;
      }
      if (queryOptions.perDocumentLimit != null) {
        queryOptions.limit = queryOptions.perDocumentLimit;
        delete queryOptions.perDocumentLimit;
      } else if (queryOptions.limit != null) {
        queryOptions.limit = queryOptions.limit * mod.ids.length;
      }
      const query = mod.model.find(match, select, queryOptions);
      for (const foreignField of mod.foreignField) {
        if (foreignField !== "_id" && query.selectedInclusively() && !isPathSelectedInclusive(query._fields, foreignField)) {
          query.select(foreignField);
        }
      }
      if (mod.count) {
        for (const foreignField of mod.foreignField) {
          query.select(foreignField);
        }
      }
      if (subPopulate) {
        query.populate(subPopulate);
      }
      query.exec((err, docs) => {
        if (err != null) {
          return callback(err);
        }
        for (const val of docs) {
          leanPopulateMap.set(val, mod.model);
        }
        callback(null, docs);
      });
    }
    function _assign(model2, vals, mod, assignmentOpts) {
      const options = mod.options;
      const isVirtual = mod.isVirtual;
      const justOne = mod.justOne;
      let _val;
      const lean = get(options, "options.lean", false);
      const len = vals.length;
      const rawOrder = {};
      const rawDocs = {};
      let key;
      let val;
      const allIds = utils2.clone(mod.allIds);
      for (let i = 0; i < len; i++) {
        val = vals[i];
        if (val == null) {
          continue;
        }
        for (const foreignField of mod.foreignField) {
          _val = utils2.getValue(foreignField, val);
          if (Array.isArray(_val)) {
            _val = utils2.array.unique(utils2.array.flatten(_val));
            for (let __val of _val) {
              if (__val instanceof Document2) {
                __val = __val._id;
              }
              key = String(__val);
              if (rawDocs[key]) {
                if (Array.isArray(rawDocs[key])) {
                  rawDocs[key].push(val);
                  rawOrder[key].push(i);
                } else {
                  rawDocs[key] = [rawDocs[key], val];
                  rawOrder[key] = [rawOrder[key], i];
                }
              } else {
                if (isVirtual && !justOne) {
                  rawDocs[key] = [val];
                  rawOrder[key] = [i];
                } else {
                  rawDocs[key] = val;
                  rawOrder[key] = i;
                }
              }
            }
          } else {
            if (_val instanceof Document2) {
              _val = _val._id;
            }
            key = String(_val);
            if (rawDocs[key]) {
              if (Array.isArray(rawDocs[key])) {
                rawDocs[key].push(val);
                rawOrder[key].push(i);
              } else if (isVirtual || rawDocs[key].constructor !== val.constructor || String(rawDocs[key]._id) !== String(val._id)) {
                rawDocs[key] = [rawDocs[key], val];
                rawOrder[key] = [rawOrder[key], i];
              }
            } else {
              rawDocs[key] = val;
              rawOrder[key] = i;
            }
          }
          if (!lean) {
            val.$__.wasPopulated = true;
          }
        }
      }
      assignVals({
        originalModel: model2,
        rawIds: mod.isVirtual ? allIds : mod.allIds,
        allIds,
        foreignField: mod.foreignField,
        rawDocs,
        rawOrder,
        docs: mod.docs,
        path: options.path,
        options: assignmentOpts,
        justOne: mod.justOne,
        isVirtual: mod.isVirtual,
        allOptions: mod,
        populatedModel: mod.model,
        lean,
        virtual: mod.virtual,
        count: mod.count,
        match: mod.match
      });
    }
    Model.compile = function compile(name, schema, collectionName, connection, base) {
      const versioningEnabled = schema.options.versionKey !== false;
      if (versioningEnabled && !schema.paths[schema.options.versionKey]) {
        const o = {};
        o[schema.options.versionKey] = Number;
        schema.add(o);
      }
      let model2;
      if (typeof name === "function" && name.prototype instanceof Model) {
        model2 = name;
        name = model2.name;
        schema.loadClass(model2, false);
        model2.prototype.$isMongooseModelPrototype = true;
      } else {
        model2 = function model3(doc, fields, skipId) {
          model3.hooks.execPreSync("createModel", doc);
          if (!(this instanceof model3)) {
            return new model3(doc, fields, skipId);
          }
          const discriminatorKey = model3.schema.options.discriminatorKey;
          if (model3.discriminators == null || doc == null || doc[discriminatorKey] == null) {
            Model.call(this, doc, fields, skipId);
            return;
          }
          const Discriminator = model3.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(model3.discriminators, doc[discriminatorKey]);
          if (Discriminator != null) {
            return new Discriminator(doc, fields, skipId);
          }
          Model.call(this, doc, fields, skipId);
        };
      }
      model2.hooks = schema.s.hooks.clone();
      model2.base = base;
      model2.modelName = name;
      if (!(model2.prototype instanceof Model)) {
        model2.__proto__ = Model;
        model2.prototype.__proto__ = Model.prototype;
      }
      model2.model = function model3(name2) {
        return this.db.model(name2);
      };
      model2.db = connection;
      model2.prototype.db = connection;
      model2.prototype[modelDbSymbol] = connection;
      model2.discriminators = model2.prototype.discriminators = void 0;
      model2[modelSymbol] = true;
      model2.events = new EventEmitter();
      model2.prototype.$__setSchema(schema);
      const _userProvidedOptions = schema._userProvidedOptions || {};
      const collectionOptions = {
        schemaUserProvidedOptions: _userProvidedOptions,
        capped: schema.options.capped,
        Promise: model2.base.Promise,
        modelName: name
      };
      if (schema.options.autoCreate !== void 0) {
        collectionOptions.autoCreate = schema.options.autoCreate;
      }
      model2.prototype.collection = connection.collection(collectionName, collectionOptions);
      model2.prototype[modelCollectionSymbol] = model2.prototype.collection;
      applyMethods(model2, schema);
      applyStatics(model2, schema);
      applyHooks(model2, schema);
      applyStaticHooks(model2, schema.s.hooks, schema.statics);
      model2.schema = model2.prototype.$__schema;
      model2.collection = model2.prototype.collection;
      model2.$__collection = model2.collection;
      model2.Query = function() {
        Query.apply(this, arguments);
      };
      model2.Query.prototype = Object.create(Query.prototype);
      model2.Query.base = Query.base;
      applyQueryMiddleware(model2.Query, model2);
      applyQueryMethods(model2, schema.query);
      return model2;
    };
    function applyQueryMethods(model2, methods) {
      for (const i in methods) {
        model2.Query.prototype[i] = methods[i];
      }
    }
    Model.__subclass = function subclass(conn, schema, collection) {
      const _this = this;
      const Model2 = function Model3(doc, fields, skipId) {
        if (!(this instanceof Model3)) {
          return new Model3(doc, fields, skipId);
        }
        _this.call(this, doc, fields, skipId);
      };
      Model2.__proto__ = _this;
      Model2.prototype.__proto__ = _this.prototype;
      Model2.db = conn;
      Model2.prototype.db = conn;
      Model2.prototype[modelDbSymbol] = conn;
      _this[subclassedSymbol] = _this[subclassedSymbol] || [];
      _this[subclassedSymbol].push(Model2);
      if (_this.discriminators != null) {
        Model2.discriminators = {};
        for (const key of Object.keys(_this.discriminators)) {
          Model2.discriminators[key] = _this.discriminators[key].__subclass(_this.db, _this.discriminators[key].schema, collection);
        }
      }
      const s = schema && typeof schema !== "string" ? schema : _this.prototype.$__schema;
      const options = s.options || {};
      const _userProvidedOptions = s._userProvidedOptions || {};
      if (!collection) {
        collection = _this.prototype.$__schema.get("collection") || utils2.toCollectionName(_this.modelName, this.base.pluralize());
      }
      const collectionOptions = {
        schemaUserProvidedOptions: _userProvidedOptions,
        capped: s && options.capped
      };
      Model2.prototype.collection = conn.collection(collection, collectionOptions);
      Model2.prototype[modelCollectionSymbol] = Model2.prototype.collection;
      Model2.collection = Model2.prototype.collection;
      Model2.$__collection = Model2.collection;
      Model2.init(() => {
      });
      return Model2;
    };
    Model.$handleCallbackError = function(callback) {
      if (callback == null) {
        return callback;
      }
      if (typeof callback !== "function") {
        throw new MongooseError("Callback must be a function, got " + callback);
      }
      const _this = this;
      return function() {
        immediate(() => {
          try {
            callback.apply(null, arguments);
          } catch (error) {
            _this.emit("error", error);
          }
        });
      };
    };
    Model.$wrapCallback = function(callback) {
      const serverSelectionError = new ServerSelectionError();
      const _this = this;
      return function(err) {
        if (err != null && err.name === "MongoServerSelectionError") {
          arguments[0] = serverSelectionError.assimilateError(err);
        }
        if (err != null && err.name === "MongoNetworkTimeoutError" && err.message.endsWith("timed out")) {
          _this.db.emit("timeout");
        }
        return callback.apply(null, arguments);
      };
    };
    Model.inspect = function() {
      return `Model { ${this.modelName} }`;
    };
    if (util.inspect.custom) {
      Model[util.inspect.custom] = Model.inspect;
    }
    module2.exports = exports2 = Model;
  }
});

// node_modules/mongoose-legacy-pluralize/index.js
var require_mongoose_legacy_pluralize = __commonJS({
  "node_modules/mongoose-legacy-pluralize/index.js"(exports2, module2) {
    module2.exports = pluralize;
    exports2.pluralization = [
      [/(m)an$/gi, "$1en"],
      [/(pe)rson$/gi, "$1ople"],
      [/(child)$/gi, "$1ren"],
      [/^(ox)$/gi, "$1en"],
      [/(ax|test)is$/gi, "$1es"],
      [/(octop|vir)us$/gi, "$1i"],
      [/(alias|status)$/gi, "$1es"],
      [/(bu)s$/gi, "$1ses"],
      [/(buffal|tomat|potat)o$/gi, "$1oes"],
      [/([ti])um$/gi, "$1a"],
      [/sis$/gi, "ses"],
      [/(?:([^f])fe|([lr])f)$/gi, "$1$2ves"],
      [/(hive)$/gi, "$1s"],
      [/([^aeiouy]|qu)y$/gi, "$1ies"],
      [/(x|ch|ss|sh)$/gi, "$1es"],
      [/(matr|vert|ind)ix|ex$/gi, "$1ices"],
      [/([m|l])ouse$/gi, "$1ice"],
      [/(kn|w|l)ife$/gi, "$1ives"],
      [/(quiz)$/gi, "$1zes"],
      [/s$/gi, "s"],
      [/([^a-z])$/, "$1"],
      [/$/gi, "s"]
    ];
    var rules = exports2.pluralization;
    exports2.uncountables = [
      "advice",
      "energy",
      "excretion",
      "digestion",
      "cooperation",
      "health",
      "justice",
      "labour",
      "machinery",
      "equipment",
      "information",
      "pollution",
      "sewage",
      "paper",
      "money",
      "species",
      "series",
      "rain",
      "rice",
      "fish",
      "sheep",
      "moose",
      "deer",
      "news",
      "expertise",
      "status",
      "media"
    ];
    var uncountables = exports2.uncountables;
    function pluralize(str) {
      var found;
      str = str.toLowerCase();
      if (!~uncountables.indexOf(str)) {
        found = rules.filter(function(rule) {
          return str.match(rule[0]);
        });
        if (found[0]) {
          return str.replace(found[0][0], found[0][1]);
        }
      }
      return str;
    }
  }
});

// node_modules/mongoose/lib/plugins/removeSubdocs.js
var require_removeSubdocs = __commonJS({
  "node_modules/mongoose/lib/plugins/removeSubdocs.js"(exports2, module2) {
    "use strict";
    var each = require_each2();
    module2.exports = function(schema) {
      const unshift = true;
      schema.s.hooks.pre("remove", false, function(next) {
        if (this.ownerDocument) {
          next();
          return;
        }
        const _this = this;
        const subdocs = this.$getAllSubdocs();
        each(subdocs, function(subdoc, cb) {
          subdoc.$__remove(cb);
        }, function(error) {
          if (error) {
            return _this.$__schema.s.hooks.execPost("remove:error", _this, [_this], { error }, function(error2) {
              next(error2);
            });
          }
          next();
        });
      }, null, unshift);
    };
  }
});

// node_modules/mongoose/lib/plugins/saveSubdocs.js
var require_saveSubdocs = __commonJS({
  "node_modules/mongoose/lib/plugins/saveSubdocs.js"(exports2, module2) {
    "use strict";
    var each = require_each2();
    module2.exports = function(schema) {
      const unshift = true;
      schema.s.hooks.pre("save", false, function(next) {
        if (this.ownerDocument) {
          next();
          return;
        }
        const _this = this;
        const subdocs = this.$getAllSubdocs();
        if (!subdocs.length) {
          next();
          return;
        }
        each(subdocs, function(subdoc, cb) {
          subdoc.$__schema.s.hooks.execPre("save", subdoc, function(err) {
            cb(err);
          });
        }, function(error) {
          if (error) {
            return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
              next(error2);
            });
          }
          next();
        });
      }, null, unshift);
      schema.s.hooks.post("save", function(doc, next) {
        if (this.ownerDocument) {
          next();
          return;
        }
        const _this = this;
        const subdocs = this.$getAllSubdocs();
        if (!subdocs.length) {
          next();
          return;
        }
        each(subdocs, function(subdoc, cb) {
          subdoc.$__schema.s.hooks.execPost("save", subdoc, [subdoc], function(err) {
            cb(err);
          });
        }, function(error) {
          if (error) {
            return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
              next(error2);
            });
          }
          next();
        });
      }, null, unshift);
    };
  }
});

// node_modules/mongoose/lib/plugins/trackTransaction.js
var require_trackTransaction = __commonJS({
  "node_modules/mongoose/lib/plugins/trackTransaction.js"(exports2, module2) {
    "use strict";
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var sessionNewDocuments = require_symbols().sessionNewDocuments;
    module2.exports = function trackTransaction(schema) {
      schema.pre("save", function() {
        const session = this.$session();
        if (session == null) {
          return;
        }
        if (session.transaction == null || session[sessionNewDocuments] == null) {
          return;
        }
        if (!session[sessionNewDocuments].has(this)) {
          const initialState = {};
          if (this.isNew) {
            initialState.isNew = true;
          }
          if (this.$__schema.options.versionKey) {
            initialState.versionKey = this.get(this.$__schema.options.versionKey);
          }
          initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.states.modify));
          initialState.atomics = _getAtomics(this);
          session[sessionNewDocuments].set(this, initialState);
        } else {
          const state = session[sessionNewDocuments].get(this);
          for (const path of Object.keys(this.$__.activePaths.states.modify)) {
            state.modifiedPaths.add(path);
          }
          state.atomics = _getAtomics(this, state.atomics);
        }
      });
    };
    function _getAtomics(doc, previous) {
      const pathToAtomics = new Map();
      previous = previous || new Map();
      const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));
      for (const path of pathsToCheck) {
        const val = doc.$__getValue(path);
        if (val != null && val instanceof Array && val.isMongooseDocumentArray && val.length && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length > 0) {
          const existing = previous.get(path) || {};
          pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));
        }
      }
      const dirty = doc.$__dirty();
      for (const dirt of dirty) {
        const path = dirt.path;
        const val = dirt.value;
        if (val != null && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length > 0) {
          const existing = previous.get(path) || {};
          pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));
        }
      }
      return pathToAtomics;
    }
    function mergeAtomics(destination, source) {
      destination = destination || {};
      if (source.$pullAll != null) {
        destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);
      }
      if (source.$push != null) {
        destination.$push = destination.$push || {};
        destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);
      }
      if (source.$addToSet != null) {
        destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);
      }
      if (source.$set != null) {
        destination.$set = Object.assign(destination.$set || {}, source.$set);
      }
      return destination;
    }
  }
});

// node_modules/mongoose/lib/plugins/validateBeforeSave.js
var require_validateBeforeSave = __commonJS({
  "node_modules/mongoose/lib/plugins/validateBeforeSave.js"(exports2, module2) {
    "use strict";
    module2.exports = function(schema) {
      const unshift = true;
      schema.pre("save", false, function validateBeforeSave(next, options) {
        const _this = this;
        if (this.ownerDocument) {
          return next();
        }
        const hasValidateBeforeSaveOption = options && typeof options === "object" && "validateBeforeSave" in options;
        let shouldValidate;
        if (hasValidateBeforeSaveOption) {
          shouldValidate = !!options.validateBeforeSave;
        } else {
          shouldValidate = this.$__schema.options.validateBeforeSave;
        }
        if (shouldValidate) {
          const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
          const validateOptions = hasValidateModifiedOnlyOption ? { validateModifiedOnly: options.validateModifiedOnly } : null;
          this.validate(validateOptions, function(error) {
            return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
              _this.$op = "save";
              next(error2);
            });
          });
        } else {
          next();
        }
      }, null, unshift);
    };
  }
});

// node_modules/mongoose/lib/plugins/sharding.js
var require_sharding = __commonJS({
  "node_modules/mongoose/lib/plugins/sharding.js"(exports2, module2) {
    "use strict";
    var objectIdSymbol = require_symbols().objectIdSymbol;
    var utils2 = require_utils8();
    module2.exports = function shardingPlugin(schema) {
      schema.post("init", function() {
        storeShard.call(this);
        return this;
      });
      schema.pre("save", function(next) {
        applyWhere.call(this);
        next();
      });
      schema.pre("remove", function(next) {
        applyWhere.call(this);
        next();
      });
      schema.post("save", function() {
        storeShard.call(this);
      });
    };
    function applyWhere() {
      let paths;
      let len;
      if (this.$__.shardval) {
        paths = Object.keys(this.$__.shardval);
        len = paths.length;
        this.$where = this.$where || {};
        for (let i = 0; i < len; ++i) {
          this.$where[paths[i]] = this.$__.shardval[paths[i]];
        }
      }
    }
    module2.exports.storeShard = storeShard;
    function storeShard() {
      const key = this.$__schema.options.shardKey || this.$__schema.options.shardkey;
      if (!utils2.isPOJO(key)) {
        return;
      }
      const orig = this.$__.shardval = {};
      const paths = Object.keys(key);
      const len = paths.length;
      let val;
      for (let i = 0; i < len; ++i) {
        val = this.$__getValue(paths[i]);
        if (val == null) {
          orig[paths[i]] = val;
        } else if (utils2.isMongooseObject(val)) {
          orig[paths[i]] = val.toObject({ depopulate: true, _isNested: true });
        } else if (val instanceof Date || val[objectIdSymbol]) {
          orig[paths[i]] = val;
        } else if (typeof val.valueOf === "function") {
          orig[paths[i]] = val.valueOf();
        } else {
          orig[paths[i]] = val;
        }
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/printJestWarning.js
var require_printJestWarning = __commonJS({
  "node_modules/mongoose/lib/helpers/printJestWarning.js"() {
    "use strict";
    if (typeof jest !== "undefined" && typeof window !== "undefined") {
      console.warn("Mongoose: looks like you're trying to test a Mongoose app with Jest's default jsdom test environment. Please make sure you read Mongoose's docs on configuring Jest to test Node.js apps: http://mongoosejs.com/docs/jest.html");
    }
    if (typeof jest !== "undefined" && process.nextTick.toString().indexOf("nextTick") === -1) {
      console.warn("Mongoose: looks like you're trying to test a Mongoose app with Jest's mock timers enabled. Please make sure you read Mongoose's docs on configuring Jest to test Node.js apps: http://mongoosejs.com/docs/jest.html");
    }
  }
});

// node_modules/mongoose/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/mongoose/lib/index.js"(exports2, module2) {
    "use strict";
    if (global.MONGOOSE_DRIVER_PATH) {
      const deprecationWarning = "The `MONGOOSE_DRIVER_PATH` global property is deprecated. Use `mongoose.driver.set()` instead.";
      const setDriver = require("util").deprecate(function() {
        require_driver().set(require(global.MONGOOSE_DRIVER_PATH));
      }, deprecationWarning);
      setDriver();
    } else {
      require_driver().set(require_node_mongodb_native());
    }
    var Document2 = require_document();
    var EventEmitter = require("events").EventEmitter;
    var Schema2 = require_schema2();
    var SchemaType = require_schematype();
    var SchemaTypes = require_schema();
    var VirtualType = require_virtualtype();
    var STATES = require_connectionstate();
    var VALID_OPTIONS = require_validoptions();
    var Types = require_types2();
    var Query = require_query3();
    var Model = require_model();
    var applyPlugins = require_applyPlugins();
    var driver = require_driver();
    var get = require_get();
    var promiseOrCallback = require_promiseOrCallback();
    var legacyPluralize = require_mongoose_legacy_pluralize();
    var utils2 = require_utils8();
    var pkg = require_package2();
    var cast = require_cast2();
    var removeSubdocs = require_removeSubdocs();
    var saveSubdocs = require_saveSubdocs();
    var trackTransaction = require_trackTransaction();
    var validateBeforeSave = require_validateBeforeSave();
    var Aggregate = require_aggregate2();
    var PromiseProvider = require_promise_provider();
    var shardingPlugin = require_sharding();
    var defaultMongooseSymbol = Symbol.for("mongoose:default");
    require_printJestWarning();
    function Mongoose(options) {
      this.connections = [];
      this.models = {};
      this.modelSchemas = {};
      this.events = new EventEmitter();
      this.options = Object.assign({
        pluralization: true,
        autoIndex: true,
        useCreateIndex: false
      }, options);
      const conn = this.createConnection();
      conn.models = this.models;
      if (this.options.pluralization) {
        this._pluralize = legacyPluralize;
      }
      if (!options || !options[defaultMongooseSymbol]) {
        const _this = this;
        this.Schema = function() {
          this.base = _this;
          return Schema2.apply(this, arguments);
        };
        this.Schema.prototype = Object.create(Schema2.prototype);
        Object.assign(this.Schema, Schema2);
        this.Schema.base = this;
        this.Schema.Types = Object.assign({}, Schema2.Types);
      } else {
        for (const key of ["Schema", "model"]) {
          this[key] = Mongoose.prototype[key];
        }
      }
      this.Schema.prototype.base = this;
      Object.defineProperty(this, "plugins", {
        configurable: false,
        enumerable: true,
        writable: false,
        value: [
          [saveSubdocs, { deduplicate: true }],
          [validateBeforeSave, { deduplicate: true }],
          [shardingPlugin, { deduplicate: true }],
          [removeSubdocs, { deduplicate: true }],
          [trackTransaction, { deduplicate: true }]
        ]
      });
    }
    Mongoose.prototype.cast = cast;
    Mongoose.prototype.STATES = STATES;
    Mongoose.prototype.driver = driver;
    Mongoose.prototype.set = function(key, value) {
      const _mongoose = this instanceof Mongoose ? this : mongoose;
      if (VALID_OPTIONS.indexOf(key) === -1)
        throw new Error(`\`${key}\` is an invalid option.`);
      if (arguments.length === 1) {
        return _mongoose.options[key];
      }
      _mongoose.options[key] = value;
      if (key === "objectIdGetter") {
        if (value) {
          Object.defineProperty(mongoose.Types.ObjectId.prototype, "_id", {
            enumerable: false,
            configurable: true,
            get: function() {
              return this;
            }
          });
        } else {
          delete mongoose.Types.ObjectId.prototype._id;
        }
      }
      return _mongoose;
    };
    Mongoose.prototype.get = Mongoose.prototype.set;
    Mongoose.prototype.createConnection = function(uri, options, callback) {
      const _mongoose = this instanceof Mongoose ? this : mongoose;
      const conn = new Connection(_mongoose);
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      _mongoose.connections.push(conn);
      _mongoose.events.emit("createConnection", conn);
      if (arguments.length > 0) {
        return conn.openUri(uri, options, callback);
      }
      return conn;
    };
    Mongoose.prototype.connect = function(uri, options, callback) {
      const _mongoose = this instanceof Mongoose ? this : mongoose;
      const conn = _mongoose.connection;
      return _mongoose._promiseOrCallback(callback, (cb) => {
        conn.openUri(uri, options, (err) => {
          if (err != null) {
            return cb(err);
          }
          return cb(null, _mongoose);
        });
      });
    };
    Mongoose.prototype.disconnect = function(callback) {
      const _mongoose = this instanceof Mongoose ? this : mongoose;
      return _mongoose._promiseOrCallback(callback, (cb) => {
        let remaining = _mongoose.connections.length;
        if (remaining <= 0) {
          return cb(null);
        }
        _mongoose.connections.forEach((conn) => {
          conn.close(function(error) {
            if (error) {
              return cb(error);
            }
            if (!--remaining) {
              cb(null);
            }
          });
        });
      });
    };
    Mongoose.prototype.startSession = function() {
      const _mongoose = this instanceof Mongoose ? this : mongoose;
      return _mongoose.connection.startSession.apply(_mongoose.connection, arguments);
    };
    Mongoose.prototype.pluralize = function(fn) {
      const _mongoose = this instanceof Mongoose ? this : mongoose;
      if (arguments.length > 0) {
        _mongoose._pluralize = fn;
      }
      return _mongoose._pluralize;
    };
    Mongoose.prototype.model = function(name, schema, collection, skipInit) {
      const _mongoose = this instanceof Mongoose ? this : mongoose;
      let model2;
      if (typeof name === "function") {
        model2 = name;
        name = model2.name;
        if (!(model2.prototype instanceof Model)) {
          throw new _mongoose.Error("The provided class " + name + " must extend Model");
        }
      }
      if (typeof schema === "string") {
        collection = schema;
        schema = false;
      }
      if (utils2.isObject(schema) && !(schema instanceof Schema2)) {
        schema = new Schema2(schema);
      }
      if (schema && !(schema instanceof Schema2)) {
        throw new Error("The 2nd parameter to `mongoose.model()` should be a schema or a POJO");
      }
      if (typeof collection === "boolean") {
        skipInit = collection;
        collection = null;
      }
      let options;
      if (skipInit && utils2.isObject(skipInit)) {
        options = skipInit;
        skipInit = true;
      } else {
        options = {};
      }
      if (!_mongoose.modelSchemas[name]) {
        if (schema) {
          _mongoose.modelSchemas[name] = schema;
        } else {
          throw new mongoose.Error.MissingSchemaError(name);
        }
      }
      const originalSchema = schema;
      if (schema) {
        if (_mongoose.get("cloneSchemas")) {
          schema = schema.clone();
        }
        _mongoose._applyPlugins(schema);
      }
      let sub;
      const overwriteModels = _mongoose.options.hasOwnProperty("overwriteModels") ? _mongoose.options.overwriteModels : options.overwriteModels;
      if (_mongoose.models[name] && options.cache !== false && overwriteModels !== true) {
        if (originalSchema && originalSchema.instanceOfSchema && originalSchema !== _mongoose.models[name].schema) {
          throw new _mongoose.Error.OverwriteModelError(name);
        }
        if (collection && collection !== _mongoose.models[name].collection.name) {
          model2 = _mongoose.models[name];
          schema = model2.prototype.schema;
          sub = model2.__subclass(_mongoose.connection, schema, collection);
          return sub;
        }
        return _mongoose.models[name];
      }
      if (!schema) {
        schema = this.modelSchemas[name];
        if (!schema) {
          throw new mongoose.Error.MissingSchemaError(name);
        }
      }
      if (!("pluralization" in schema.options)) {
        schema.options.pluralization = _mongoose.options.pluralization;
      }
      if (!collection) {
        collection = schema.get("collection") || utils2.toCollectionName(name, _mongoose.pluralize());
      }
      const connection = options.connection || _mongoose.connection;
      model2 = _mongoose.Model.compile(model2 || name, schema, collection, connection, _mongoose);
      if (!skipInit) {
        model2.init(function $modelInitNoop() {
        });
      }
      connection.emit("model", model2);
      if (options.cache === false) {
        return model2;
      }
      _mongoose.models[name] = model2;
      return _mongoose.models[name];
    };
    Mongoose.prototype.deleteModel = function(name) {
      const _mongoose = this instanceof Mongoose ? this : mongoose;
      _mongoose.connection.deleteModel(name);
      return _mongoose;
    };
    Mongoose.prototype.modelNames = function() {
      const _mongoose = this instanceof Mongoose ? this : mongoose;
      const names = Object.keys(_mongoose.models);
      return names;
    };
    Mongoose.prototype._applyPlugins = function(schema, options) {
      const _mongoose = this instanceof Mongoose ? this : mongoose;
      options = options || {};
      options.applyPluginsToDiscriminators = get(_mongoose, "options.applyPluginsToDiscriminators", false);
      options.applyPluginsToChildSchemas = get(_mongoose, "options.applyPluginsToChildSchemas", true);
      applyPlugins(schema, _mongoose.plugins, options, "$globalPluginsApplied");
    };
    Mongoose.prototype.plugin = function(fn, opts) {
      const _mongoose = this instanceof Mongoose ? this : mongoose;
      _mongoose.plugins.push([fn, opts]);
      return _mongoose;
    };
    Mongoose.prototype.__defineGetter__("connection", function() {
      return this.connections[0];
    });
    Mongoose.prototype.__defineSetter__("connection", function(v) {
      if (v instanceof Connection) {
        this.connections[0] = v;
        this.models = v.models;
      }
    });
    Mongoose.prototype.connections;
    var Connection = driver.get().getConnection();
    var Collection = driver.get().Collection;
    Mongoose.prototype.Aggregate = Aggregate;
    Mongoose.prototype.Collection = Collection;
    Mongoose.prototype.Connection = Connection;
    Mongoose.prototype.version = pkg.version;
    Mongoose.prototype.Mongoose = Mongoose;
    Mongoose.prototype.Schema = Schema2;
    Mongoose.prototype.SchemaType = SchemaType;
    Mongoose.prototype.SchemaTypes = Schema2.Types;
    Mongoose.prototype.VirtualType = VirtualType;
    Mongoose.prototype.Types = Types;
    Mongoose.prototype.Query = Query;
    Object.defineProperty(Mongoose.prototype, "Promise", {
      get: function() {
        return PromiseProvider.get();
      },
      set: function(lib) {
        PromiseProvider.set(lib);
      }
    });
    Mongoose.prototype.PromiseProvider = PromiseProvider;
    Mongoose.prototype.Model = Model;
    Mongoose.prototype.Document = Document2;
    Mongoose.prototype.DocumentProvider = require_document_provider();
    Mongoose.prototype.ObjectId = SchemaTypes.ObjectId;
    Mongoose.prototype.isValidObjectId = function(v) {
      if (v == null) {
        return true;
      }
      const base = this || mongoose;
      const ObjectId2 = base.driver.get().ObjectId;
      if (v instanceof ObjectId2) {
        return true;
      }
      if (v._id != null) {
        if (v._id instanceof ObjectId2) {
          return true;
        }
        if (v._id.toString instanceof Function) {
          v = v._id.toString();
          if (typeof v === "string" && v.length === 12) {
            return true;
          }
          if (typeof v === "string" && v.length === 24 && /^[a-f0-9]*$/.test(v)) {
            return true;
          }
          return false;
        }
      }
      if (v.toString instanceof Function) {
        v = v.toString();
      }
      if (typeof v === "string" && v.length === 12) {
        return true;
      }
      if (typeof v === "string" && v.length === 24 && /^[a-f0-9]*$/.test(v)) {
        return true;
      }
      return false;
    };
    Mongoose.prototype.Decimal128 = SchemaTypes.Decimal128;
    Mongoose.prototype.Mixed = SchemaTypes.Mixed;
    Mongoose.prototype.Date = SchemaTypes.Date;
    Mongoose.prototype.Number = SchemaTypes.Number;
    Mongoose.prototype.Error = require_error3();
    Mongoose.prototype.now = function now() {
      return new Date();
    };
    Mongoose.prototype.CastError = require_cast();
    Mongoose.prototype.SchemaTypeOptions = require_SchemaTypeOptions();
    Mongoose.prototype.mongo = require_mongodb();
    Mongoose.prototype.mquery = require_mquery();
    Mongoose.prototype._promiseOrCallback = function(callback, fn, ee) {
      return promiseOrCallback(callback, fn, ee, this.Promise);
    };
    var mongoose = module2.exports = exports2 = new Mongoose({
      [defaultMongooseSymbol]: true
    });
  }
});

// node_modules/mongoose/index.js
var require_mongoose = __commonJS({
  "node_modules/mongoose/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_lib5();
  }
});

// node_modules/bcryptjs/dist/bcrypt.js
var require_bcrypt = __commonJS({
  "node_modules/bcryptjs/dist/bcrypt.js"(exports2, module2) {
    (function(global2, factory) {
      if (typeof define === "function" && define["amd"])
        define([], factory);
      else if (typeof require === "function" && typeof module2 === "object" && module2 && module2["exports"])
        module2["exports"] = factory();
      else
        (global2["dcodeIO"] = global2["dcodeIO"] || {})["bcrypt"] = factory();
    })(exports2, function() {
      "use strict";
      var bcrypt = {};
      var randomFallback = null;
      function random(len) {
        if (typeof module2 !== "undefined" && module2 && module2["exports"])
          try {
            return require("crypto")["randomBytes"](len);
          } catch (e) {
          }
        try {
          var a;
          (self["crypto"] || self["msCrypto"])["getRandomValues"](a = new Uint32Array(len));
          return Array.prototype.slice.call(a);
        } catch (e) {
        }
        if (!randomFallback)
          throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
        return randomFallback(len);
      }
      var randomAvailable = false;
      try {
        random(1);
        randomAvailable = true;
      } catch (e) {
      }
      randomFallback = null;
      bcrypt.setRandomFallback = function(random2) {
        randomFallback = random2;
      };
      bcrypt.genSaltSync = function(rounds, seed_length) {
        rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
        if (typeof rounds !== "number")
          throw Error("Illegal arguments: " + typeof rounds + ", " + typeof seed_length);
        if (rounds < 4)
          rounds = 4;
        else if (rounds > 31)
          rounds = 31;
        var salt = [];
        salt.push("$2a$");
        if (rounds < 10)
          salt.push("0");
        salt.push(rounds.toString());
        salt.push("$");
        salt.push(base64_encode(random(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
        return salt.join("");
      };
      bcrypt.genSalt = function(rounds, seed_length, callback) {
        if (typeof seed_length === "function")
          callback = seed_length, seed_length = void 0;
        if (typeof rounds === "function")
          callback = rounds, rounds = void 0;
        if (typeof rounds === "undefined")
          rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
        else if (typeof rounds !== "number")
          throw Error("illegal arguments: " + typeof rounds);
        function _async(callback2) {
          nextTick(function() {
            try {
              callback2(null, bcrypt.genSaltSync(rounds));
            } catch (err) {
              callback2(err);
            }
          });
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve(res);
            });
          });
      };
      bcrypt.hashSync = function(s, salt) {
        if (typeof salt === "undefined")
          salt = GENSALT_DEFAULT_LOG2_ROUNDS;
        if (typeof salt === "number")
          salt = bcrypt.genSaltSync(salt);
        if (typeof s !== "string" || typeof salt !== "string")
          throw Error("Illegal arguments: " + typeof s + ", " + typeof salt);
        return _hash(s, salt);
      };
      bcrypt.hash = function(s, salt, callback, progressCallback) {
        function _async(callback2) {
          if (typeof s === "string" && typeof salt === "number")
            bcrypt.genSalt(salt, function(err, salt2) {
              _hash(s, salt2, callback2, progressCallback);
            });
          else if (typeof s === "string" && typeof salt === "string")
            _hash(s, salt, callback2, progressCallback);
          else
            nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s + ", " + typeof salt)));
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve(res);
            });
          });
      };
      function safeStringCompare(known, unknown) {
        var right = 0, wrong = 0;
        for (var i = 0, k = known.length; i < k; ++i) {
          if (known.charCodeAt(i) === unknown.charCodeAt(i))
            ++right;
          else
            ++wrong;
        }
        if (right < 0)
          return false;
        return wrong === 0;
      }
      bcrypt.compareSync = function(s, hash) {
        if (typeof s !== "string" || typeof hash !== "string")
          throw Error("Illegal arguments: " + typeof s + ", " + typeof hash);
        if (hash.length !== 60)
          return false;
        return safeStringCompare(bcrypt.hashSync(s, hash.substr(0, hash.length - 31)), hash);
      };
      bcrypt.compare = function(s, hash, callback, progressCallback) {
        function _async(callback2) {
          if (typeof s !== "string" || typeof hash !== "string") {
            nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s + ", " + typeof hash)));
            return;
          }
          if (hash.length !== 60) {
            nextTick(callback2.bind(this, null, false));
            return;
          }
          bcrypt.hash(s, hash.substr(0, 29), function(err, comp) {
            if (err)
              callback2(err);
            else
              callback2(null, safeStringCompare(comp, hash));
          }, progressCallback);
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve(res);
            });
          });
      };
      bcrypt.getRounds = function(hash) {
        if (typeof hash !== "string")
          throw Error("Illegal arguments: " + typeof hash);
        return parseInt(hash.split("$")[2], 10);
      };
      bcrypt.getSalt = function(hash) {
        if (typeof hash !== "string")
          throw Error("Illegal arguments: " + typeof hash);
        if (hash.length !== 60)
          throw Error("Illegal hash length: " + hash.length + " != 60");
        return hash.substring(0, 29);
      };
      var nextTick = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? typeof setImmediate === "function" ? setImmediate : process.nextTick : setTimeout;
      function stringToBytes(str) {
        var out = [], i = 0;
        utfx.encodeUTF16toUTF8(function() {
          if (i >= str.length)
            return null;
          return str.charCodeAt(i++);
        }, function(b) {
          out.push(b);
        });
        return out;
      }
      var BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
      var BASE64_INDEX = [
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        1,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        -1,
        -1,
        -1,
        -1,
        -1
      ];
      var stringFromCharCode = String.fromCharCode;
      function base64_encode(b, len) {
        var off = 0, rs2 = [], c1, c2;
        if (len <= 0 || len > b.length)
          throw Error("Illegal len: " + len);
        while (off < len) {
          c1 = b[off++] & 255;
          rs2.push(BASE64_CODE[c1 >> 2 & 63]);
          c1 = (c1 & 3) << 4;
          if (off >= len) {
            rs2.push(BASE64_CODE[c1 & 63]);
            break;
          }
          c2 = b[off++] & 255;
          c1 |= c2 >> 4 & 15;
          rs2.push(BASE64_CODE[c1 & 63]);
          c1 = (c2 & 15) << 2;
          if (off >= len) {
            rs2.push(BASE64_CODE[c1 & 63]);
            break;
          }
          c2 = b[off++] & 255;
          c1 |= c2 >> 6 & 3;
          rs2.push(BASE64_CODE[c1 & 63]);
          rs2.push(BASE64_CODE[c2 & 63]);
        }
        return rs2.join("");
      }
      function base64_decode(s, len) {
        var off = 0, slen = s.length, olen = 0, rs2 = [], c1, c2, c3, c4, o, code;
        if (len <= 0)
          throw Error("Illegal len: " + len);
        while (off < slen - 1 && olen < len) {
          code = s.charCodeAt(off++);
          c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          code = s.charCodeAt(off++);
          c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          if (c1 == -1 || c2 == -1)
            break;
          o = c1 << 2 >>> 0;
          o |= (c2 & 48) >> 4;
          rs2.push(stringFromCharCode(o));
          if (++olen >= len || off >= slen)
            break;
          code = s.charCodeAt(off++);
          c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          if (c3 == -1)
            break;
          o = (c2 & 15) << 4 >>> 0;
          o |= (c3 & 60) >> 2;
          rs2.push(stringFromCharCode(o));
          if (++olen >= len || off >= slen)
            break;
          code = s.charCodeAt(off++);
          c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          o = (c3 & 3) << 6 >>> 0;
          o |= c4;
          rs2.push(stringFromCharCode(o));
          ++olen;
        }
        var res = [];
        for (off = 0; off < olen; off++)
          res.push(rs2[off].charCodeAt(0));
        return res;
      }
      var utfx = function() {
        "use strict";
        var utfx2 = {};
        utfx2.MAX_CODEPOINT = 1114111;
        utfx2.encodeUTF8 = function(src, dst) {
          var cp = null;
          if (typeof src === "number")
            cp = src, src = function() {
              return null;
            };
          while (cp !== null || (cp = src()) !== null) {
            if (cp < 128)
              dst(cp & 127);
            else if (cp < 2048)
              dst(cp >> 6 & 31 | 192), dst(cp & 63 | 128);
            else if (cp < 65536)
              dst(cp >> 12 & 15 | 224), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
            else
              dst(cp >> 18 & 7 | 240), dst(cp >> 12 & 63 | 128), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
            cp = null;
          }
        };
        utfx2.decodeUTF8 = function(src, dst) {
          var a, b, c, d, fail = function(b2) {
            b2 = b2.slice(0, b2.indexOf(null));
            var err = Error(b2.toString());
            err.name = "TruncatedError";
            err["bytes"] = b2;
            throw err;
          };
          while ((a = src()) !== null) {
            if ((a & 128) === 0)
              dst(a);
            else if ((a & 224) === 192)
              (b = src()) === null && fail([a, b]), dst((a & 31) << 6 | b & 63);
            else if ((a & 240) === 224)
              ((b = src()) === null || (c = src()) === null) && fail([a, b, c]), dst((a & 15) << 12 | (b & 63) << 6 | c & 63);
            else if ((a & 248) === 240)
              ((b = src()) === null || (c = src()) === null || (d = src()) === null) && fail([a, b, c, d]), dst((a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63);
            else
              throw RangeError("Illegal starting byte: " + a);
          }
        };
        utfx2.UTF16toUTF8 = function(src, dst) {
          var c1, c2 = null;
          while (true) {
            if ((c1 = c2 !== null ? c2 : src()) === null)
              break;
            if (c1 >= 55296 && c1 <= 57343) {
              if ((c2 = src()) !== null) {
                if (c2 >= 56320 && c2 <= 57343) {
                  dst((c1 - 55296) * 1024 + c2 - 56320 + 65536);
                  c2 = null;
                  continue;
                }
              }
            }
            dst(c1);
          }
          if (c2 !== null)
            dst(c2);
        };
        utfx2.UTF8toUTF16 = function(src, dst) {
          var cp = null;
          if (typeof src === "number")
            cp = src, src = function() {
              return null;
            };
          while (cp !== null || (cp = src()) !== null) {
            if (cp <= 65535)
              dst(cp);
            else
              cp -= 65536, dst((cp >> 10) + 55296), dst(cp % 1024 + 56320);
            cp = null;
          }
        };
        utfx2.encodeUTF16toUTF8 = function(src, dst) {
          utfx2.UTF16toUTF8(src, function(cp) {
            utfx2.encodeUTF8(cp, dst);
          });
        };
        utfx2.decodeUTF8toUTF16 = function(src, dst) {
          utfx2.decodeUTF8(src, function(cp) {
            utfx2.UTF8toUTF16(cp, dst);
          });
        };
        utfx2.calculateCodePoint = function(cp) {
          return cp < 128 ? 1 : cp < 2048 ? 2 : cp < 65536 ? 3 : 4;
        };
        utfx2.calculateUTF8 = function(src) {
          var cp, l = 0;
          while ((cp = src()) !== null)
            l += utfx2.calculateCodePoint(cp);
          return l;
        };
        utfx2.calculateUTF16asUTF8 = function(src) {
          var n = 0, l = 0;
          utfx2.UTF16toUTF8(src, function(cp) {
            ++n;
            l += utfx2.calculateCodePoint(cp);
          });
          return [n, l];
        };
        return utfx2;
      }();
      Date.now = Date.now || function() {
        return +new Date();
      };
      var BCRYPT_SALT_LEN = 16;
      var GENSALT_DEFAULT_LOG2_ROUNDS = 10;
      var BLOWFISH_NUM_ROUNDS = 16;
      var MAX_EXECUTION_TIME = 100;
      var P_ORIG = [
        608135816,
        2242054355,
        320440878,
        57701188,
        2752067618,
        698298832,
        137296536,
        3964562569,
        1160258022,
        953160567,
        3193202383,
        887688300,
        3232508343,
        3380367581,
        1065670069,
        3041331479,
        2450970073,
        2306472731
      ];
      var S_ORIG = [
        3509652390,
        2564797868,
        805139163,
        3491422135,
        3101798381,
        1780907670,
        3128725573,
        4046225305,
        614570311,
        3012652279,
        134345442,
        2240740374,
        1667834072,
        1901547113,
        2757295779,
        4103290238,
        227898511,
        1921955416,
        1904987480,
        2182433518,
        2069144605,
        3260701109,
        2620446009,
        720527379,
        3318853667,
        677414384,
        3393288472,
        3101374703,
        2390351024,
        1614419982,
        1822297739,
        2954791486,
        3608508353,
        3174124327,
        2024746970,
        1432378464,
        3864339955,
        2857741204,
        1464375394,
        1676153920,
        1439316330,
        715854006,
        3033291828,
        289532110,
        2706671279,
        2087905683,
        3018724369,
        1668267050,
        732546397,
        1947742710,
        3462151702,
        2609353502,
        2950085171,
        1814351708,
        2050118529,
        680887927,
        999245976,
        1800124847,
        3300911131,
        1713906067,
        1641548236,
        4213287313,
        1216130144,
        1575780402,
        4018429277,
        3917837745,
        3693486850,
        3949271944,
        596196993,
        3549867205,
        258830323,
        2213823033,
        772490370,
        2760122372,
        1774776394,
        2652871518,
        566650946,
        4142492826,
        1728879713,
        2882767088,
        1783734482,
        3629395816,
        2517608232,
        2874225571,
        1861159788,
        326777828,
        3124490320,
        2130389656,
        2716951837,
        967770486,
        1724537150,
        2185432712,
        2364442137,
        1164943284,
        2105845187,
        998989502,
        3765401048,
        2244026483,
        1075463327,
        1455516326,
        1322494562,
        910128902,
        469688178,
        1117454909,
        936433444,
        3490320968,
        3675253459,
        1240580251,
        122909385,
        2157517691,
        634681816,
        4142456567,
        3825094682,
        3061402683,
        2540495037,
        79693498,
        3249098678,
        1084186820,
        1583128258,
        426386531,
        1761308591,
        1047286709,
        322548459,
        995290223,
        1845252383,
        2603652396,
        3431023940,
        2942221577,
        3202600964,
        3727903485,
        1712269319,
        422464435,
        3234572375,
        1170764815,
        3523960633,
        3117677531,
        1434042557,
        442511882,
        3600875718,
        1076654713,
        1738483198,
        4213154764,
        2393238008,
        3677496056,
        1014306527,
        4251020053,
        793779912,
        2902807211,
        842905082,
        4246964064,
        1395751752,
        1040244610,
        2656851899,
        3396308128,
        445077038,
        3742853595,
        3577915638,
        679411651,
        2892444358,
        2354009459,
        1767581616,
        3150600392,
        3791627101,
        3102740896,
        284835224,
        4246832056,
        1258075500,
        768725851,
        2589189241,
        3069724005,
        3532540348,
        1274779536,
        3789419226,
        2764799539,
        1660621633,
        3471099624,
        4011903706,
        913787905,
        3497959166,
        737222580,
        2514213453,
        2928710040,
        3937242737,
        1804850592,
        3499020752,
        2949064160,
        2386320175,
        2390070455,
        2415321851,
        4061277028,
        2290661394,
        2416832540,
        1336762016,
        1754252060,
        3520065937,
        3014181293,
        791618072,
        3188594551,
        3933548030,
        2332172193,
        3852520463,
        3043980520,
        413987798,
        3465142937,
        3030929376,
        4245938359,
        2093235073,
        3534596313,
        375366246,
        2157278981,
        2479649556,
        555357303,
        3870105701,
        2008414854,
        3344188149,
        4221384143,
        3956125452,
        2067696032,
        3594591187,
        2921233993,
        2428461,
        544322398,
        577241275,
        1471733935,
        610547355,
        4027169054,
        1432588573,
        1507829418,
        2025931657,
        3646575487,
        545086370,
        48609733,
        2200306550,
        1653985193,
        298326376,
        1316178497,
        3007786442,
        2064951626,
        458293330,
        2589141269,
        3591329599,
        3164325604,
        727753846,
        2179363840,
        146436021,
        1461446943,
        4069977195,
        705550613,
        3059967265,
        3887724982,
        4281599278,
        3313849956,
        1404054877,
        2845806497,
        146425753,
        1854211946,
        1266315497,
        3048417604,
        3681880366,
        3289982499,
        290971e4,
        1235738493,
        2632868024,
        2414719590,
        3970600049,
        1771706367,
        1449415276,
        3266420449,
        422970021,
        1963543593,
        2690192192,
        3826793022,
        1062508698,
        1531092325,
        1804592342,
        2583117782,
        2714934279,
        4024971509,
        1294809318,
        4028980673,
        1289560198,
        2221992742,
        1669523910,
        35572830,
        157838143,
        1052438473,
        1016535060,
        1802137761,
        1753167236,
        1386275462,
        3080475397,
        2857371447,
        1040679964,
        2145300060,
        2390574316,
        1461121720,
        2956646967,
        4031777805,
        4028374788,
        33600511,
        2920084762,
        1018524850,
        629373528,
        3691585981,
        3515945977,
        2091462646,
        2486323059,
        586499841,
        988145025,
        935516892,
        3367335476,
        2599673255,
        2839830854,
        265290510,
        3972581182,
        2759138881,
        3795373465,
        1005194799,
        847297441,
        406762289,
        1314163512,
        1332590856,
        1866599683,
        4127851711,
        750260880,
        613907577,
        1450815602,
        3165620655,
        3734664991,
        3650291728,
        3012275730,
        3704569646,
        1427272223,
        778793252,
        1343938022,
        2676280711,
        2052605720,
        1946737175,
        3164576444,
        3914038668,
        3967478842,
        3682934266,
        1661551462,
        3294938066,
        4011595847,
        840292616,
        3712170807,
        616741398,
        312560963,
        711312465,
        1351876610,
        322626781,
        1910503582,
        271666773,
        2175563734,
        1594956187,
        70604529,
        3617834859,
        1007753275,
        1495573769,
        4069517037,
        2549218298,
        2663038764,
        504708206,
        2263041392,
        3941167025,
        2249088522,
        1514023603,
        1998579484,
        1312622330,
        694541497,
        2582060303,
        2151582166,
        1382467621,
        776784248,
        2618340202,
        3323268794,
        2497899128,
        2784771155,
        503983604,
        4076293799,
        907881277,
        423175695,
        432175456,
        1378068232,
        4145222326,
        3954048622,
        3938656102,
        3820766613,
        2793130115,
        2977904593,
        26017576,
        3274890735,
        3194772133,
        1700274565,
        1756076034,
        4006520079,
        3677328699,
        720338349,
        1533947780,
        354530856,
        688349552,
        3973924725,
        1637815568,
        332179504,
        3949051286,
        53804574,
        2852348879,
        3044236432,
        1282449977,
        3583942155,
        3416972820,
        4006381244,
        1617046695,
        2628476075,
        3002303598,
        1686838959,
        431878346,
        2686675385,
        1700445008,
        1080580658,
        1009431731,
        832498133,
        3223435511,
        2605976345,
        2271191193,
        2516031870,
        1648197032,
        4164389018,
        2548247927,
        300782431,
        375919233,
        238389289,
        3353747414,
        2531188641,
        2019080857,
        1475708069,
        455242339,
        2609103871,
        448939670,
        3451063019,
        1395535956,
        2413381860,
        1841049896,
        1491858159,
        885456874,
        4264095073,
        4001119347,
        1565136089,
        3898914787,
        1108368660,
        540939232,
        1173283510,
        2745871338,
        3681308437,
        4207628240,
        3343053890,
        4016749493,
        1699691293,
        1103962373,
        3625875870,
        2256883143,
        3830138730,
        1031889488,
        3479347698,
        1535977030,
        4236805024,
        3251091107,
        2132092099,
        1774941330,
        1199868427,
        1452454533,
        157007616,
        2904115357,
        342012276,
        595725824,
        1480756522,
        206960106,
        497939518,
        591360097,
        863170706,
        2375253569,
        3596610801,
        1814182875,
        2094937945,
        3421402208,
        1082520231,
        3463918190,
        2785509508,
        435703966,
        3908032597,
        1641649973,
        2842273706,
        3305899714,
        1510255612,
        2148256476,
        2655287854,
        3276092548,
        4258621189,
        236887753,
        3681803219,
        274041037,
        1734335097,
        3815195456,
        3317970021,
        1899903192,
        1026095262,
        4050517792,
        356393447,
        2410691914,
        3873677099,
        3682840055,
        3913112168,
        2491498743,
        4132185628,
        2489919796,
        1091903735,
        1979897079,
        3170134830,
        3567386728,
        3557303409,
        857797738,
        1136121015,
        1342202287,
        507115054,
        2535736646,
        337727348,
        3213592640,
        1301675037,
        2528481711,
        1895095763,
        1721773893,
        3216771564,
        62756741,
        2142006736,
        835421444,
        2531993523,
        1442658625,
        3659876326,
        2882144922,
        676362277,
        1392781812,
        170690266,
        3921047035,
        1759253602,
        3611846912,
        1745797284,
        664899054,
        1329594018,
        3901205900,
        3045908486,
        2062866102,
        2865634940,
        3543621612,
        3464012697,
        1080764994,
        553557557,
        3656615353,
        3996768171,
        991055499,
        499776247,
        1265440854,
        648242737,
        3940784050,
        980351604,
        3713745714,
        1749149687,
        3396870395,
        4211799374,
        3640570775,
        1161844396,
        3125318951,
        1431517754,
        545492359,
        4268468663,
        3499529547,
        1437099964,
        2702547544,
        3433638243,
        2581715763,
        2787789398,
        1060185593,
        1593081372,
        2418618748,
        4260947970,
        69676912,
        2159744348,
        86519011,
        2512459080,
        3838209314,
        1220612927,
        3339683548,
        133810670,
        1090789135,
        1078426020,
        1569222167,
        845107691,
        3583754449,
        4072456591,
        1091646820,
        628848692,
        1613405280,
        3757631651,
        526609435,
        236106946,
        48312990,
        2942717905,
        3402727701,
        1797494240,
        859738849,
        992217954,
        4005476642,
        2243076622,
        3870952857,
        3732016268,
        765654824,
        3490871365,
        2511836413,
        1685915746,
        3888969200,
        1414112111,
        2273134842,
        3281911079,
        4080962846,
        172450625,
        2569994100,
        980381355,
        4109958455,
        2819808352,
        2716589560,
        2568741196,
        3681446669,
        3329971472,
        1835478071,
        660984891,
        3704678404,
        4045999559,
        3422617507,
        3040415634,
        1762651403,
        1719377915,
        3470491036,
        2693910283,
        3642056355,
        3138596744,
        1364962596,
        2073328063,
        1983633131,
        926494387,
        3423689081,
        2150032023,
        4096667949,
        1749200295,
        3328846651,
        309677260,
        2016342300,
        1779581495,
        3079819751,
        111262694,
        1274766160,
        443224088,
        298511866,
        1025883608,
        3806446537,
        1145181785,
        168956806,
        3641502830,
        3584813610,
        1689216846,
        3666258015,
        3200248200,
        1692713982,
        2646376535,
        4042768518,
        1618508792,
        1610833997,
        3523052358,
        4130873264,
        2001055236,
        3610705100,
        2202168115,
        4028541809,
        2961195399,
        1006657119,
        2006996926,
        3186142756,
        1430667929,
        3210227297,
        1314452623,
        4074634658,
        4101304120,
        2273951170,
        1399257539,
        3367210612,
        3027628629,
        1190975929,
        2062231137,
        2333990788,
        2221543033,
        2438960610,
        1181637006,
        548689776,
        2362791313,
        3372408396,
        3104550113,
        3145860560,
        296247880,
        1970579870,
        3078560182,
        3769228297,
        1714227617,
        3291629107,
        3898220290,
        166772364,
        1251581989,
        493813264,
        448347421,
        195405023,
        2709975567,
        677966185,
        3703036547,
        1463355134,
        2715995803,
        1338867538,
        1343315457,
        2802222074,
        2684532164,
        233230375,
        2599980071,
        2000651841,
        3277868038,
        1638401717,
        4028070440,
        3237316320,
        6314154,
        819756386,
        300326615,
        590932579,
        1405279636,
        3267499572,
        3150704214,
        2428286686,
        3959192993,
        3461946742,
        1862657033,
        1266418056,
        963775037,
        2089974820,
        2263052895,
        1917689273,
        448879540,
        3550394620,
        3981727096,
        150775221,
        3627908307,
        1303187396,
        508620638,
        2975983352,
        2726630617,
        1817252668,
        1876281319,
        1457606340,
        908771278,
        3720792119,
        3617206836,
        2455994898,
        1729034894,
        1080033504,
        976866871,
        3556439503,
        2881648439,
        1522871579,
        1555064734,
        1336096578,
        3548522304,
        2579274686,
        3574697629,
        3205460757,
        3593280638,
        3338716283,
        3079412587,
        564236357,
        2993598910,
        1781952180,
        1464380207,
        3163844217,
        3332601554,
        1699332808,
        1393555694,
        1183702653,
        3581086237,
        1288719814,
        691649499,
        2847557200,
        2895455976,
        3193889540,
        2717570544,
        1781354906,
        1676643554,
        2592534050,
        3230253752,
        1126444790,
        2770207658,
        2633158820,
        2210423226,
        2615765581,
        2414155088,
        3127139286,
        673620729,
        2805611233,
        1269405062,
        4015350505,
        3341807571,
        4149409754,
        1057255273,
        2012875353,
        2162469141,
        2276492801,
        2601117357,
        993977747,
        3918593370,
        2654263191,
        753973209,
        36408145,
        2530585658,
        25011837,
        3520020182,
        2088578344,
        530523599,
        2918365339,
        1524020338,
        1518925132,
        3760827505,
        3759777254,
        1202760957,
        3985898139,
        3906192525,
        674977740,
        4174734889,
        2031300136,
        2019492241,
        3983892565,
        4153806404,
        3822280332,
        352677332,
        2297720250,
        60907813,
        90501309,
        3286998549,
        1016092578,
        2535922412,
        2839152426,
        457141659,
        509813237,
        4120667899,
        652014361,
        1966332200,
        2975202805,
        55981186,
        2327461051,
        676427537,
        3255491064,
        2882294119,
        3433927263,
        1307055953,
        942726286,
        933058658,
        2468411793,
        3933900994,
        4215176142,
        1361170020,
        2001714738,
        2830558078,
        3274259782,
        1222529897,
        1679025792,
        2729314320,
        3714953764,
        1770335741,
        151462246,
        3013232138,
        1682292957,
        1483529935,
        471910574,
        1539241949,
        458788160,
        3436315007,
        1807016891,
        3718408830,
        978976581,
        1043663428,
        3165965781,
        1927990952,
        4200891579,
        2372276910,
        3208408903,
        3533431907,
        1412390302,
        2931980059,
        4132332400,
        1947078029,
        3881505623,
        4168226417,
        2941484381,
        1077988104,
        1320477388,
        886195818,
        18198404,
        3786409e3,
        2509781533,
        112762804,
        3463356488,
        1866414978,
        891333506,
        18488651,
        661792760,
        1628790961,
        3885187036,
        3141171499,
        876946877,
        2693282273,
        1372485963,
        791857591,
        2686433993,
        3759982718,
        3167212022,
        3472953795,
        2716379847,
        445679433,
        3561995674,
        3504004811,
        3574258232,
        54117162,
        3331405415,
        2381918588,
        3769707343,
        4154350007,
        1140177722,
        4074052095,
        668550556,
        3214352940,
        367459370,
        261225585,
        2610173221,
        4209349473,
        3468074219,
        3265815641,
        314222801,
        3066103646,
        3808782860,
        282218597,
        3406013506,
        3773591054,
        379116347,
        1285071038,
        846784868,
        2669647154,
        3771962079,
        3550491691,
        2305946142,
        453669953,
        1268987020,
        3317592352,
        3279303384,
        3744833421,
        2610507566,
        3859509063,
        266596637,
        3847019092,
        517658769,
        3462560207,
        3443424879,
        370717030,
        4247526661,
        2224018117,
        4143653529,
        4112773975,
        2788324899,
        2477274417,
        1456262402,
        2901442914,
        1517677493,
        1846949527,
        2295493580,
        3734397586,
        2176403920,
        1280348187,
        1908823572,
        3871786941,
        846861322,
        1172426758,
        3287448474,
        3383383037,
        1655181056,
        3139813346,
        901632758,
        1897031941,
        2986607138,
        3066810236,
        3447102507,
        1393639104,
        373351379,
        950779232,
        625454576,
        3124240540,
        4148612726,
        2007998917,
        544563296,
        2244738638,
        2330496472,
        2058025392,
        1291430526,
        424198748,
        50039436,
        29584100,
        3605783033,
        2429876329,
        2791104160,
        1057563949,
        3255363231,
        3075367218,
        3463963227,
        1469046755,
        985887462
      ];
      var C_ORIG = [
        1332899944,
        1700884034,
        1701343084,
        1684370003,
        1668446532,
        1869963892
      ];
      function _encipher(lr, off, P, S) {
        var n, l = lr[off], r = lr[off + 1];
        l ^= P[0];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[1];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[2];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[3];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[4];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[5];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[6];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[7];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[8];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[9];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[10];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[11];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[12];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[13];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[14];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[15];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[16];
        lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
        lr[off + 1] = l;
        return lr;
      }
      function _streamtoword(data, offp) {
        for (var i = 0, word = 0; i < 4; ++i)
          word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
        return { key: word, offp };
      }
      function _key(key, P, S) {
        var offset = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
        for (var i = 0; i < plen; i++)
          sw = _streamtoword(key, offset), offset = sw.offp, P[i] = P[i] ^ sw.key;
        for (i = 0; i < plen; i += 2)
          lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
        for (i = 0; i < slen; i += 2)
          lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
      }
      function _ekskey(data, key, P, S) {
        var offp = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
        for (var i = 0; i < plen; i++)
          sw = _streamtoword(key, offp), offp = sw.offp, P[i] = P[i] ^ sw.key;
        offp = 0;
        for (i = 0; i < plen; i += 2)
          sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
        for (i = 0; i < slen; i += 2)
          sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
      }
      function _crypt(b, salt, rounds, callback, progressCallback) {
        var cdata = C_ORIG.slice(), clen = cdata.length, err;
        if (rounds < 4 || rounds > 31) {
          err = Error("Illegal number of rounds (4-31): " + rounds);
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        if (salt.length !== BCRYPT_SALT_LEN) {
          err = Error("Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN);
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        rounds = 1 << rounds >>> 0;
        var P, S, i = 0, j;
        if (Int32Array) {
          P = new Int32Array(P_ORIG);
          S = new Int32Array(S_ORIG);
        } else {
          P = P_ORIG.slice();
          S = S_ORIG.slice();
        }
        _ekskey(salt, b, P, S);
        function next() {
          if (progressCallback)
            progressCallback(i / rounds);
          if (i < rounds) {
            var start = Date.now();
            for (; i < rounds; ) {
              i = i + 1;
              _key(b, P, S);
              _key(salt, P, S);
              if (Date.now() - start > MAX_EXECUTION_TIME)
                break;
            }
          } else {
            for (i = 0; i < 64; i++)
              for (j = 0; j < clen >> 1; j++)
                _encipher(cdata, j << 1, P, S);
            var ret2 = [];
            for (i = 0; i < clen; i++)
              ret2.push((cdata[i] >> 24 & 255) >>> 0), ret2.push((cdata[i] >> 16 & 255) >>> 0), ret2.push((cdata[i] >> 8 & 255) >>> 0), ret2.push((cdata[i] & 255) >>> 0);
            if (callback) {
              callback(null, ret2);
              return;
            } else
              return ret2;
          }
          if (callback)
            nextTick(next);
        }
        if (typeof callback !== "undefined") {
          next();
        } else {
          var res;
          while (true)
            if (typeof (res = next()) !== "undefined")
              return res || [];
        }
      }
      function _hash(s, salt, callback, progressCallback) {
        var err;
        if (typeof s !== "string" || typeof salt !== "string") {
          err = Error("Invalid string / salt: Not a string");
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        var minor, offset;
        if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
          err = Error("Invalid salt version: " + salt.substring(0, 2));
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        if (salt.charAt(2) === "$")
          minor = String.fromCharCode(0), offset = 3;
        else {
          minor = salt.charAt(2);
          if (minor !== "a" && minor !== "b" && minor !== "y" || salt.charAt(3) !== "$") {
            err = Error("Invalid salt revision: " + salt.substring(2, 4));
            if (callback) {
              nextTick(callback.bind(this, err));
              return;
            } else
              throw err;
          }
          offset = 4;
        }
        if (salt.charAt(offset + 2) > "$") {
          err = Error("Missing salt rounds");
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r2, real_salt = salt.substring(offset + 3, offset + 25);
        s += minor >= "a" ? "\0" : "";
        var passwordb = stringToBytes(s), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
        function finish(bytes) {
          var res = [];
          res.push("$2");
          if (minor >= "a")
            res.push(minor);
          res.push("$");
          if (rounds < 10)
            res.push("0");
          res.push(rounds.toString());
          res.push("$");
          res.push(base64_encode(saltb, saltb.length));
          res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
          return res.join("");
        }
        if (typeof callback == "undefined")
          return finish(_crypt(passwordb, saltb, rounds));
        else {
          _crypt(passwordb, saltb, rounds, function(err2, bytes) {
            if (err2)
              callback(err2, null);
            else
              callback(null, finish(bytes));
          }, progressCallback);
        }
      }
      bcrypt.encodeBase64 = base64_encode;
      bcrypt.decodeBase64 = base64_decode;
      return bcrypt;
    });
  }
});

// node_modules/bcryptjs/index.js
var require_bcryptjs = __commonJS({
  "node_modules/bcryptjs/index.js"(exports2, module2) {
    module2.exports = require_bcrypt();
  }
});

// functions/auth.ts
__export(exports, {
  default: () => auth_default
});
var import_express = __toModule(require_express2());

// src/libs/verifyToken.ts
var import_jsonwebtoken = __toModule(require_jsonwebtoken());
var TokenValidation = (req, res, next) => {
  let token = req.header("auth-token") || "";
  if (!token)
    res.status(401).json("Access denied");
  const payload = import_jsonwebtoken.default.verify(token, process.env.TOKEN_SECRET || "holamundo");
  req.userId = payload._id;
  next();
};

// src/models/User.ts
var import_mongoose = __toModule(require_mongoose());
var import_bcryptjs = __toModule(require_bcryptjs());
var userSchema = new import_mongoose.Schema({
  username: {
    type: String,
    require: true,
    min: 4,
    lowercase: true,
    trim: true
  },
  email: {
    type: String,
    unique: true,
    require: true,
    lowercase: true,
    trim: true
  },
  password: {
    type: String,
    require: true
  }
});
userSchema.methods.encryptPassword = async (password) => {
  const salt = await import_bcryptjs.default.genSalt(10);
  return import_bcryptjs.default.hash(password, salt);
};
userSchema.methods.validatePassword = async function(password, userPassword) {
  return await import_bcryptjs.default.compare(password, userPassword);
};
var User_default = (0, import_mongoose.model)("User", userSchema);

// src/controllers/auth.controller.ts
var import_jsonwebtoken2 = __toModule(require_jsonwebtoken());
var signup = async (req, res) => {
  let { username, email, password } = req.body;
  const user = new User_default({
    username,
    email,
    password
  });
  user.password = await user.encryptPassword(password);
  const saveUser = await user.save();
  const token = import_jsonwebtoken2.default.sign({ _id: saveUser._id }, process.env.TOKEN_SECRET || "holamundo");
  res.header("auth-token", token).json(saveUser);
};
var signin = async (req, res) => {
  let { email, password } = req.body;
  let user = await User_default.findOne({ email });
  if (!user) {
    return res.status(400).json("Usuario no encontrado");
  }
  let correctPassword = await (user == null ? void 0 : user.validatePassword(password, user.password));
  if (!correctPassword) {
    return res.status(400).json("Invalid password");
  }
  const token = import_jsonwebtoken2.default.sign({ _id: user._id }, process.env.TOKEN_SECRET || "holamundo", {
    expiresIn: 60 * 60 * 24
  });
  return res.header("auth-token", token).json(user);
};
var profile = async (req, res) => {
  const user = await User_default.findById(req.userId, { password: 0 });
  if (!user)
    res.status(404).json("No user found");
  res.json(user);
};

// functions/auth.ts
var router = (0, import_express.Router)();
router.post("/signup", signup);
router.post("/signin", signin);
router.get("/profile", TokenValidation, profile);
var auth_default = router;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*!
 * 1) Apply backwards compatible find/findOne behavior to sub documents
 *
 *    find logic:
 *      a) filter out non-documents
 *      b) remove _id from sub docs when user specified
 *
 *    findOne
 *      a) if no doc found, set to null
 *      b) remove _id from sub docs when user specified
 *
 * 2) Remove _ids when specified by users query.
 *
 * background:
 * _ids are left in the query even when user excludes them so
 * that population mapping can occur.
 */
/*!
 * @ignore
 */
/*!
 * @param {Schema} schema
 * @param {Object} doc POJO
 * @param {string} path
 */
/*!
 * @see exports.options
 */
/*!
 * A faster Array.prototype.slice.call(arguments) alternative
 * @api private
 */
/*!
 * A list of authentication mechanisms that don't require a password for authentication.
 * This is used by the authMechanismDoesNotRequirePassword method.
 *
 * @api private
 */
/*!
 * A query thunk is the function responsible for sending the query to MongoDB,
 * like `Query#_findOne()` or `Query#_execUpdate()`. The `Query#exec()` function
 * calls a thunk. The term "thunk" here is the traditional Node.js definition:
 * a function that takes exactly 1 parameter, a callback.
 *
 * This function defines common behavior for all query thunks.
 */
/*!
 * Adds the appropriate `$match` pipeline step to the top of an aggregate's
 * pipeline, should it's model is a non-root discriminator type. This is
 * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.
 *
 * @param {Aggregate} aggregate Aggregate to prepare
 */
/*!
 * Applies schema type transforms to `json`.
 *
 * @param {Document} self
 * @param {Object} json
 * @return {Object} `json`
 */
/*!
 * Applies setters without casting
 *
 * @api private
 */
/*!
 * Applies toObject recursively.
 *
 * @param {Document|Array|Object} obj
 * @return {Object}
 * @api private
 */
/*!
 * Applies virtuals properties to `json`.
 *
 * @param {Document} self
 * @param {Object} json
 * @return {Object} `json`
 */
/*!
 * Applies virtuals properties to `json`.
 */
/*!
 * Apply query middleware
 *
 * @param {Query} query constructor
 * @param {Model} model
 */
/*!
 * Apply the operation to the delta (update) clause as
 * well as track versioning for our where clause.
 *
 * @param {Document} self
 * @param {Object} where
 * @param {Object} delta
 * @param {Object} data
 * @param {Mixed} val
 * @param {String} [operation]
 */
/*!
 * Assign `vals` returned by mongo query to the `rawIds`
 * structure returned from utils.getVals() honoring
 * query sort order if specified by user.
 *
 * This can be optimized.
 *
 * Rules:
 *
 *   if the value of the path is not an array, use findOne rules, else find.
 *   for findOne the results are assigned directly to doc path (including null results).
 *   for find, if user specified sort order, results are assigned directly
 *   else documents are put back in original order of array if found in results
 *
 * @param {Array} rawIds
 * @param {Array} vals
 * @param {Boolean} sort
 * @api private
 */
/*!
 * Behaves like `Schema#path()`, except for it also digs into arrays without
 * needing to put `.0.`, so `getPath(schema, 'docArr.elProp')` works.
 */
/*!
 * Browser doc exposes the event emitter API
 */
/*!
 * Casts `val` according to `schema` and atomic `op`.
 *
 * @param {SchemaType} schema
 * @param {Object} val
 * @param {String} op - the atomic operator ($pull, $set, etc)
 * @param {String} $conditional
 * @param {Query} context
 * @api private
 */
/*!
 * Casts an update op based on the given schema
 *
 * @param {Schema} schema
 * @param {Object} obj
 * @param {Object} options
 * @param {Boolean} [options.overwrite] defaults to false
 * @param {Boolean|String} [options.strict] defaults to true
 * @param {Query} context passed to setters
 * @return {Boolean} true iff the update is non-empty
 */
/*!
 * Casts obj for an update command.
 *
 * @param {Object} obj
 * @return {Object} obj after casting its values
 * @api private
 */
/*!
 * Casts val to an object suitable for `$text`. Throws an error if the object
 * can't be casted.
 *
 * @param {Any} val value to cast
 * @param {String} [path] path to associate with any errors that occured
 * @return {Object} casted object
 * @see https://docs.mongodb.com/manual/reference/operator/query/text/
 * @api private
 */
/*!
 * Centralize this so we can more easily work around issues with people
 * stubbing out `process.nextTick()` in tests using sinon:
 * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time
 * See gh-6074
 */
/*!
 * Checks for indexes added to subdocs using Schema.index().
 * These indexes need their paths prefixed properly.
 *
 * schema._indexes = [ [indexObj, options], [indexObj, options] ..]
 */
/*!
 * Checks to see if at least one path is in the states passed in via `arguments`
 * e.g., this.some('required', 'inited')
 *
 * @param {String} state that we want to check for.
 * @private
 */
/*!
 * Collection
 */
/*!
 * Collection the model uses.
 *
 * @property collection
 * @api public
 * @memberOf Model
 */
/*!
 * Common code for `updateOne()`, `updateMany()`, `replaceOne()`, and `update()`
 * because they need to do the same thing
 */
/*!
 * Compile other Buffer methods marking this buffer as modified.
 */
/*!
 * Compiled middleware for this model. Set in `applyHooks()`.
 *
 * @api private
 * @property _middleware
 * @memberOf Model
 * @static
 */
/*!
 * Compiler utility.
 *
 * @param {String|Function} name model name or class extending Model
 * @param {Schema} schema
 * @param {String} collectionName
 * @param {Connection} connection
 * @param {Mongoose} base mongoose instance
 */
/*!
 * Compiles an update and where clause for a `val` with _atomics.
 *
 * @param {Document} self
 * @param {Object} where
 * @param {Object} delta
 * @param {Object} data
 * @param {Array} value
 */
/*!
 * Compiles schemas.
 */
/*!
 * Connection
 */
/*!
 * Connection instance the model uses.
 *
 * @property db
 * @api public
 * @memberOf Model
 */
/*!
 * Connection states
 */
/*!
 * Convert a raw doc into a full mongoose doc.
 */
/*!
 * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.
 *
 * @param {Object} object
 * @api private
 */
/*!
 * Converts arguments to ReadPrefs the driver
 * can understand.
 *
 * @param {String|Array} pref
 * @param {Array} [tags]
 */
/*!
 * Converts to POJO when you use the document for querying
 */
/*!
 * Copy the collection methods and make them subject to queues
 */
/*!
 * Create virtual properties with alias field
 */
/*!
 * Date Query casting.
 *
 * @api private
 */
/*!
 * Debug print helper
 */
/*!
 * Decorate buffers
 */
/*!
 * Decorate the update with a version key, if necessary
 */
/*!
 * Defines the accessor named prop on the incoming prototype.
 */
/*!
 * Dependencies
 */
/*!
 * Determine if `obj` is something we can set a populated path to. Can be a
 * document, a lean document, or an array/map that contains docs.
 */
/*!
 * Determine if `val` is null or undefined
 *
 * @return {Boolean}
 */
/*!
 * Determine if array was populated with some form of filter and is now
 * being updated in a manner which could overwrite data unintentionally.
 *
 * @see https://github.com/Automattic/mongoose/issues/1334
 * @param {Document} doc
 * @param {String} path
 * @return {String|undefined}
 */
/*!
 * Determines if `a` and `b` are deep equal.
 *
 * Modified from node/lib/assert.js
 *
 * @param {any} a a value to compare to `b`
 * @param {any} b a value to compare to `a`
 * @return {Boolean}
 * @api private
 */
/*!
 * Determines if `arg` is a plain old JavaScript object (POJO). Specifically,
 * `arg` must be an object but not an instance of any special class, like String,
 * ObjectId, etc.
 *
 * `Object.getPrototypeOf()` is part of ES5: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf
 *
 * @param {Object|Array|String|Function|RegExp|any} arg
 * @api private
 * @return {Boolean}
 */
/*!
 * Determines if `arg` is an object.
 *
 * @param {Object|Array|String|Function|RegExp|any} arg
 * @api private
 * @return {Boolean}
 */
/*!
 * Determines if `obj` is a built-in object like an array, date, boolean,
 * etc.
 */
/*!
 * Determines if `path` is excluded by `projection`
 *
 * @param {Object} projection
 * @param {string} path
 * @return {Boolean}
 */
/*!
 * Determines if `val` is an object that has no own keys
 */
/*!
 * Determines if two buffers are equal.
 *
 * @param {Buffer} a
 * @param {Object} b
 */
/*!
 * Determines whether versioning should be skipped for the given path
 *
 * @param {Document} self
 * @param {String} path
 * @return {Boolean} true if versioning should be skipped for the given path
 */
/*!
 * Document exposes the NodeJS event emitter API, so you can use
 * `on`, `once`, etc.
 */
/*!
 * Export
 */
/*!
 * Exports
 */
/*!
 * Exports.
 */
/*!
 * Find the correct constructor, taking into account discriminators
 */
/*!
 * Flattens an array.
 *
 * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]
 *
 * @param {Array} arr
 * @param {Function} [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsy value, the item will not be included in the results.
 * @return {Array}
 * @private
 */
/*!
 * Format `mod.match` given that it may be an array that we need to $or if
 * the client has multiple docs with match functions
 */
/*!
 * Formats error messages
 */
/*!
 * Gather all indexes defined in the schema, including single nested,
 * document arrays, and embedded discriminators.
 */
/*!
 * Generates a random string
 *
 * @api private
 */
/*!
 * Get options from query opts, falling back to the base mongoose object.
 */
/*!
 * Get the bson type, if it exists
 */
/*!
 * Get the error to throw for `orFail()`
 */
/*!
 * Get the last element of an array
 */
/*!
 * Get the next doc from the underlying cursor and mongooseify it
 * (populate, etc.)
 */
/*!
 * Getter for convenience with populate, see gh-6115
 */
/*!
 * Give the constructor the ability to emit events.
 */
/*!
 * Given a model and a bulkWrite op, return a thunk that handles casting and
 * validating the individual op.
 */
/*!
 * Given a model and an array of docs, hydrates all the docs to be instances
 * of the model. Used to initialize docs returned from the db from `find()`
 *
 * @param {Model} model
 * @param {Array} docs
 * @param {Object} fields the projection used, including `select` from schemas
 * @param {Object} userProvidedFields the user-specified projection
 * @param {Object} opts
 * @param {Array} [opts.populated]
 * @param {ClientSession} [opts.session]
 * @param {Function} callback
 */
/*!
 * Given a value, cast it to a boolean, or throw a `CastError` if the value
 * cannot be casted. `null` and `undefined` are considered valid.
 *
 * @param {Any} value
 * @param {String} [path] optional the path to set on the CastError
 * @return {Boolean|null|undefined}
 * @throws {CastError} if `value` is not one of the allowed values
 * @api private
 */
/*!
 * Given a value, cast it to a number, or throw a `CastError` if the value
 * cannot be casted. `null` and `undefined` are considered valid.
 *
 * @param {Any} value
 * @param {String} [path] optional the path to set on the CastError
 * @return {Boolean|null|undefined}
 * @throws {Error} if `value` is not one of the allowed values
 * @api private
 */
/*!
 * Given a value, cast it to a string, or throw a `CastError` if the value
 * cannot be casted. `null` and `undefined` are considered valid.
 *
 * @param {Any} value
 * @param {String} [path] optional the path to set on the CastError
 * @return {string|null|undefined}
 * @throws {CastError}
 * @api private
 */
/*!
 * Handle async validators
 */
/*!
 * Handle the `WriteOpResult` from the server
 */
/*!
 * Helper for JSON.stringify
 * Ensure `name` and `message` show up in toJSON output re: gh-9847
 */
/*!
 * Helpers
 */
/*!
 * If `val` is an object, returns constructor name, if possible. Otherwise returns undefined.
 */
/*!
 * If populating a path within a document array, make sure each
 * subdoc within the array knows its subpaths are populated.
 *
 * ####Example:
 *     const doc = await Article.findOne().populate('comments.author');
 *     doc.comments[0].populated('author'); // Should be set
 */
/*!
 * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,
 * it returns an instance of the given model.
 *
 * @param {Model}  model
 * @param {Object} doc
 * @param {Object} fields
 *
 * @return {Document}
 */
/*!
 * If the model is a discriminator type and not root, then add the key & value to the criteria.
 */
/*!
 * If this is a document array, each element may contain single
 * populated paths, so we need to modify the top-level document's
 * populated cache. See gh-8247, gh-8265.
 */
/*!
 * Ignore
 */
/*!
 * Inherit from Buffer.
 */
/*!
 * Inherit from Document
 */
/*!
 * Inherit from EventEmitter
 */
/*!
 * Inherit from EventEmitter.
 */
/*!
 * Inherit from abstract Collection.
 */
/*!
 * Inherit from the NodeJS document
 */
/*!
 * Inherits from ArrayType.
 */
/*!
 * Inherits from Connection.
 */
/*!
 * Inherits from Document.
 *
 * All Model.prototype features are available on
 * top level (non-sub) documents.
 */
/*!
 * Inherits from SchemaType.
 */
/*!
 * Init helper.
 *
 * @param {Object} self document instance
 * @param {Object} obj raw mongodb doc
 * @param {Object} doc object we are initializing
 * @api private
 */
/*!
 * Internal helper for update, updateMany, updateOne
 */
/*!
 * Internal helper for update, updateMany, updateOne, replaceOne
 */
/*!
 * Internal switch for runSetters
 *
 * @api private
 */
/*!
 * Internal thunk around `deleteMany()`
 */
/*!
 * Internal thunk for .replaceOne()
 *
 * @param {Function} callback
 * @see Model.replaceOne #model_Model.replaceOne
 * @api private
 */
/*!
 * Internal thunk for .update()
 *
 * @param {Function} callback
 * @see Model.update #model_Model.update
 * @api private
 */
/*!
 * Internal thunk for .updateMany()
 *
 * @param {Function} callback
 * @see Model.update #model_Model.update
 * @api private
 */
/*!
 * Internal thunk for .updateOne()
 *
 * @param {Function} callback
 * @see Model.update #model_Model.update
 * @api private
 */
/*!
 * Internal thunk for `deleteOne()`
 */
/*!
 * Iterates over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @private
 */
/*!
 * Just like handleArray, except also allows `[]` because surprisingly
 * `$in: [1, []]` works fine
 */
/*!
 * Like `schema.path()`, except with a document, because impossible to
 * determine path type without knowing the embedded discriminator key.
 */
/*!
 * Make sure `this` is a model
 */
/*!
 * Maps over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @return {Array}
 * @private
 */
/*!
 * Marks this cursor as errored
 */
/*!
 * Merges `from` into `to` without overwriting existing properties.
 *
 * @param {Object} to
 * @param {Object} from
 * @api private
 */
/*!
 * Minimizes an object, removing undefined values and empty objects
 *
 * @param {Object} object to minimize
 * @return {Object}
 */
/*!
 * Module dependencies
 */
/*!
 * Module dependencies.
 */
/*!
 * Module exports
 */
/*!
 * Module exports.
 */
/*!
 * Module requirements
 */
/*!
 * Module requirements.
 */
/*!
 * Mongoose calls this function internally to validate the query if
 * `runValidators` is set
 *
 * @param {Object} castedDoc the update, after casting
 * @param {Object} options the options from `_optionsForExec()`
 * @param {Function} callback
 * @api private
 */
/*!
 * Necessary to satisfy the Readable API
 */
/*!
 * Object clone with Mongoose natives support.
 *
 * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.
 *
 * Functions are never cloned.
 *
 * @param {Object} obj the object to clone
 * @param {Object} options
 * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.
 * @return {Object} the cloned object
 * @api private
 */
/*!
 * Optionally filter out invalid ids that don't conform to foreign field's schema
 * to avoid cast errors (gh-7706)
 */
/*!
 * Override mquery.prototype._findAndModify to provide casting etc.
 *
 * @param {String} type - either "remove" or "update"
 * @param {Function} callback
 * @api private
 */
/*!
 * Override mquery.prototype._mergeUpdate to handle mongoose objects in
 * updates.
 *
 * @param {Object} doc
 * @api private
 */
/*!
 * Overwriting mquery is needed to support a couple different near() forms found in older
 * versions of mongoose
 * near([1,1])
 * near(1,1)
 * near(field, [1,2])
 * near(field, 1, 2)
 * In addition to all of the normal forms supported by mquery
 */
/*!
 * Permissions
 */
/*!
 * Pluralize function.
 *
 * @author TJ Holowaychuk (extracted from _ext.js_)
 * @param {String} string to pluralize
 * @api private
 */
/*!
 * Populate helper
 *
 * @param {Model} model the model to use
 * @param {Document|Array} docs Either a single document or array of documents to populate.
 * @param {Object} paths
 * @param {Function} [cb(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.
 * @return {Function}
 * @api private
 */
/*!
 * Populates `docs`
 */
/*!
 * Prepare a set of path options for query population.
 *
 * @param {Query} query
 * @param {Object} options
 * @return {Array}
 */
/*!
 * Prepare a set of path options for query population. This is the MongooseQuery
 * version
 *
 * @param {Query} query
 * @param {Object} options
 * @return {Array}
 */
/*!
 * Produces a collection name from model `name`. By default, just returns
 * the model name
 *
 * @param {String} name a model name
 * @param {Function} pluralize function that pluralizes the collection name
 * @return {String} a collection name
 * @api private
 */
/*!
 * Recursively set nested arrays
 */
/*!
 * Register custom query methods for this model
 *
 * @param {Model} model
 * @param {Schema} schema
 */
/*!
 * Register hooks for this model
 *
 * @param {Model} model
 * @param {Schema} schema
 */
/*!
 * Register listeners for important events and bubble appropriately.
 */
/*!
 * Register methods for this model
 *
 * @param {Model} model
 * @param {Schema} schema
 */
/*!
 * Register statics for this model
 * @param {Model} model
 * @param {Schema} schema
 */
/*!
 * Registers remove event listeners for triggering
 * on subdocuments.
 *
 * @param {EmbeddedDocument} sub
 * @api private
 */
/*!
 * Registers remove event listeners for triggering
 * on subdocuments.
 *
 * @param {Subdocument} sub
 * @api private
 */
/*!
 * Remove _id from `subdoc` if user specified "lean" query option
 */
/*!
 * Removes duplicate values from an array
 *
 * [1, 2, 3, 3, 5] => [1, 2, 3, 5]
 * [ ObjectId("550988ba0c19d57f697dc45e"), ObjectId("550988ba0c19d57f697dc45e") ]
 *    => [ObjectId("550988ba0c19d57f697dc45e")]
 *
 * @param {Array} arr
 * @return {Array}
 * @private
 */
/*!
 * Retrieve the _id of `val` if a Document or Array of Documents.
 *
 * @param {Array|Document|Any} val
 * @return {Array|Document|Any}
 */
/*!
 * Return the value of `obj` at the given `path`.
 *
 * @param {String} path
 * @param {Object} obj
 */
/*!
 * Returns an array of values from object `o`.
 *
 * @param {Object} o
 * @return {Array}
 * @private
 */
/*!
 * Returns if `v` is a mongoose object that has a `toObject()` method we can use.
 *
 * This is for compatibility with libs like Date.js which do foolish things to Natives.
 *
 * @param {any} v
 * @api private
 */
/*!
 * Returns the value passed to it.
 */
/*!
 * Returns this documents _id cast to a string.
 */
/*!
 * Returns true if `v` is an object that can be serialized as a primitive in
 * MongoDB
 */
/*!
 * Runs queued functions
 */
/*!
 * Safer helper for hasOwnProperty checks
 *
 * @param {Object} obj
 * @param {String} prop
 */
/*!
 * Scopes paths selected in a query to this array.
 * Necessary for proper default application of subdocument values.
 *
 * @param {DocumentArrayPath} array - the array to scope `fields` paths
 * @param {Object|undefined} fields - the root fields selected in the query
 * @param {Boolean|undefined} init - if we are being created part of a query result
 */
/*!
 * Search if `obj` or any POJOs nested underneath `obj` has a property named
 * `key`
 */
/*!
 * Set each path query option to lean
 *
 * @param {Object} option
 */
/*!
 * Sets the value of `obj` at the given `path`.
 *
 * @param {String} path
 * @param {Anything} val
 * @param {Object} obj
 */
/*!
 * Shallow copies defaults into options.
 *
 * @param {Object} defaults
 * @param {Object} options
 * @return {Object} the merged object
 * @api private
 */
/*!
 * Simplified lodash.get to work around the annoying null quirk. See:
 * https://github.com/lodash/lodash/issues/3659
 */
/*!
 * Since maps are stored as objects under the hood, keys must be strings
 * and can't contain any invalid characters
 */
/*!
 * Special case for when users use a common location schema to represent
 * locations for use with $geoWithin.
 * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/
 *
 * @param {Object} val
 * @api private
 */
/*!
 * StateMachine represents a minimal `interface` for the
 * constructors it builds via StateMachine.ctor(...).
 *
 * @api private
 */
/*!
 * StateMachine.ctor('state1', 'state2', ...)
 * A factory method for subclassing StateMachine.
 * The arguments are a list of states. For each state,
 * the constructor's prototype gets state transition
 * methods named after each state. These transition methods
 * place their path argument into the given state.
 *
 * @param {String} state
 * @param {String} [state]
 * @return {Function} subclass constructor
 * @private
 */
/*!
 * Subclass this model with `conn`, `schema`, and `collection` settings.
 *
 * @param {Connection} conn
 * @param {Schema} [schema]
 * @param {String} [collection]
 * @return {Model}
 */
/*!
 * Support the `new` option as an alternative to `returnOriginal` for backwards
 * compat.
 */
/*!
 * The class that Mongoose uses internally to instantiate this SchemaType's `options` property.
 */
/*!
 * The exports object is an instance of Mongoose.
 *
 * @api public
 */
/*!
 * The mongodb driver 1.3.23 only supports the nested array sort
 * syntax. We must convert it or sorting findAndModify will not work.
 */
/*!
 * The object used to define this validator. Not enumerable to hide
 * it from `require('util').inspect()` output re: gh-3925
 */
/*!
 * These operators require casting docs
 * to real Documents for Update operations.
 */
/*!
 * These operators should be cast to numbers instead
 * of their path schema type.
 */
/*!
 * These ops require no casting because the RHS doesn't do anything.
 */
/*!
 * This function builds the functions that get assigned to `forEach` and `map`,
 * since both of those methods share a lot of the same logic.
 *
 * @param {String} iterMethod is either 'forEach' or 'map'
 * @return {Function}
 * @api private
 */
/*!
 * This function is wrapped by the state change functions:
 *
 * - `require(path)`
 * - `modify(path)`
 * - `init(path)`
 *
 * @api private
 */
/*!
 * Thunk around findOneAndDelete()
 *
 * @param {Function} [callback]
 * @return {Query} this
 * @api private
 */
/*!
 * Thunk around findOneAndRemove()
 *
 * @param {Function} [callback]
 * @return {Query} this
 * @api private
 */
/*!
 * Thunk around findOneAndReplace()
 *
 * @param {Function} [callback]
 * @return {Query} this
 * @api private
 */
/*!
 * Thunk around findOneAndUpdate()
 *
 * @param {Function} [callback]
 * @api private
 */
/*!
 * Use native promises by default
 */
/*!
 * Valid mongoose options
 */
/*!
 * Walk each path of obj and cast its values
 * according to its schema.
 *
 * @param {Schema} schema
 * @param {Object} obj - part of a query
 * @param {String} op - the atomic operator ($pull, $set, etc)
 * @param {Object} options
 * @param {Boolean|String} [options.strict]
 * @param {Boolean} [options.omitUndefined]
 * @param {Query} context
 * @param {String} pref - path prefix (internal only)
 * @return {Bool} true if this path has keys to update
 * @api private
 */
/*!
 * Wraps `castForQuery` to handle context
 */
/*!
 * [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) ObjectId
 * @constructor NodeMongoDbObjectId
 * @see ObjectId
 */
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
/*!
 * castDoc
 * @api private
 */
/*!
 * castQuery
 * @api private
 */
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * define methods
 */
/*!
 * depd
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * depd
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * depd
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * exports
 */
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * finalhandler
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * gets discriminator model if discriminator key is present in object
 */
/*!
 * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance
 *
 *     Thing.where('type').nin(array)
 */
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * hydrates a document
 *
 * @param {Model} model
 * @param {Document} doc
 * @param {Object} res 3rd parameter to callback
 * @param {Object} fields
 * @param {Query} self
 * @param {Array} [pop] array of paths used in population
 * @param {Function} callback
 */
/*!
 * ignore
 */
/*!
 * ignore. Deprecated re: #6405
 */
/*!
 * inherit mquery
 */
/*!
 * limit, skip, maxScan, batchSize, comment
 *
 * Sets these associated options.
 *
 *     query.comment('feed query');
 */
/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * no-op for hooks
 */
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * populate helper
 */
/*!
 * process.nextTick helper.
 *
 * Wraps `callback` in a try/catch + nextTick.
 *
 * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.
 *
 * @param {Function} callback
 * @api private
 */
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * this is needed to support the mongoose syntax of:
 * box(field, { ll : [x,y], ur : [x2,y2] })
 * box({ ll : [x,y], ur : [x2,y2] })
 */
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
* Avoid Node deprecation warning DEP0079
*/
/*!
* returns discriminator by discriminatorMapping.value
*
* @param {Model} model
* @param {string} value
*/
/*!
* returns discriminator by discriminatorMapping.value
*
* @param {Schema} schema
* @param {string} value
*/
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * @license bcrypt.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/bcrypt.js for details
 */
//# sourceMappingURL=auth.js.map
